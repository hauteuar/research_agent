<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Component-Specific Mainframe Analysis</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            min-height: 100vh;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 25px;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .header h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #FFD700, #FFA500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .main-grid {
            display: grid;
            grid-template-columns: 520px 1fr;
            gap: 25px;
            min-height: 80vh;
        }

        .control-panel, .analysis-workspace {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .control-panel {
            height: fit-content;
            max-height: 85vh;
            overflow-y: auto;
        }

        .analysis-workspace {
            min-height: 80vh;
            overflow-y: auto;
        }

        /* Component-specific styles */
        .component-search-section {
            margin-bottom: 25px;
            padding: 20px;
            background: rgba(76, 175, 80, 0.2);
            border-radius: 15px;
            border-left: 4px solid #4CAF50;
        }

        .component-input {
            width: 100%;
            padding: 12px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 14px;
            margin-bottom: 10px;
            transition: all 0.3s ease;
        }

        .component-input:focus {
            outline: none;
            border-color: #FFD700;
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.3);
        }

        .component-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .component-suggestions {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            max-height: 150px;
            overflow-y: auto;
            display: none;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .suggestion-item {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
            font-size: 13px;
        }

        .suggestion-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(3px);
        }

        .suggestion-item:last-child {
            border-bottom: none;
        }
        
        .lifecycle-flow {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 15px;
            border-left: 4px solid #2196F3;
            transition: all 0.3s ease;
        }

        .lifecycle-flow:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        .flow-stage {
            display: flex;
            align-items: flex-start;
            margin-bottom: 15px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .flow-stage:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .stage-icon {
            font-size: 20px;
            margin-right: 15px;
            min-width: 30px;
            text-align: center;
        }

        .stage-content {
            flex: 1;
        }

        .stage-title {
            font-weight: bold;
            color: #FFD700;
            margin-bottom: 5px;
            font-size: 16px;
        }

        .stage-details {
            font-size: 13px;
            opacity: 0.9;
            line-height: 1.5;
        }
        
        .field-matrix {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .field-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            border-top: 3px solid #FFD700;
            transition: all 0.3s ease;
        }

        .field-card:hover {
            transform: translateY(-2px);
            background: rgba(255, 255, 255, 0.15);
        }

        .field-name {
            font-weight: bold;
            color: #FFD700;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .field-usage {
            font-size: 12px;
            line-height: 1.4;
        }
        
        .usage-tag {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            margin: 2px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .tag-create {
            background: #4CAF50;
            color: white;
        }

        .tag-update {
            background: #FF9800;
            color: white;
        }

        .tag-read {
            background: #2196F3;
            color: white;
        }

        .tag-unused {
            background: #f44336;
            color: white;
        }

        .tag-reference {
            background: #9C27B0;
            color: white;
        }

        .tag-working {
            background: #607D8B;
            color: white;
        }

        .tag-control {
            background: #795548;
            color: white;
        }

        .tag-key {
            background: #E91E63;
            color: white;
        }
        
        /* Form styles */
        .section-title {
            color: #FFD700;
            font-size: 1.2rem;
            margin-bottom: 15px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: 500;
            color: #E8E8E8;
            font-size: 14px;
        }

        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .form-group input:focus, .form-group select:focus, .form-group textarea:focus {
            outline: none;
            border-color: #FFD700;
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.3);
        }

        .form-group input::placeholder, .form-group textarea::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .action-btn {
            width: 100%;
            background: linear-gradient(45deg, #FF6B6B, #FF5252);
            color: white;
            border: none;
            padding: 14px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 15px;
            font-weight: 600;
            margin-bottom: 12px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }

        .action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .validate-btn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
        }

        .validate-btn:hover {
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }

        .secondary-btn {
            background: linear-gradient(45deg, #2196F3, #1976D2);
        }

        .secondary-btn:hover {
            box-shadow: 0 6px 20px rgba(33, 150, 243, 0.4);
        }

        .component-btn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
        }

        .component-btn:hover {
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }
        
        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
            overflow-x: auto;
            flex-wrap: wrap;
        }

        .tab {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
            white-space: nowrap;
            font-weight: 500;
            min-width: 100px;
            font-size: 14px;
        }

        .tab.active {
            color: #FFD700;
            border-bottom-color: #FFD700;
            background: rgba(255, 215, 0, 0.1);
        }

        .tab:hover:not(.active) {
            color: rgba(255, 255, 255, 0.9);
            background: rgba(255, 255, 255, 0.05);
        }

        .tab-content {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .api-status {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
            padding: 8px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
        }

        .api-status.connected {
            background: rgba(76, 175, 80, 0.2);
            color: #ccffcc;
            border: 1px solid rgba(76, 175, 80, 0.5);
        }

        .api-status.disconnected {
            background: rgba(244, 67, 54, 0.2);
            color: #ffcccc;
            border: 1px solid rgba(244, 67, 54, 0.5);
        }

        .api-status.connecting {
            background: rgba(255, 152, 0, 0.2);
            border: 1px solid rgba(255, 152, 0, 0.5);
            color: #ffe0b3;
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 40px;
        }

        .loading.show {
            display: block;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #FFD700;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .error, .success, .warning {
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-weight: 500;
        }

        .error {
            background: rgba(255, 0, 0, 0.2);
            color: #ffcccc;
            border: 1px solid rgba(255, 0, 0, 0.5);
        }

        .success {
            background: rgba(0, 255, 0, 0.2);
            color: #ccffcc;
            border: 1px solid rgba(0, 255, 0, 0.5);
        }

        .warning {
            background: rgba(255, 193, 7, 0.2);
            color: #fff3cd;
            border: 1px solid rgba(255, 193, 7, 0.5);
        }

        .upload-area {
            border: 2px dashed rgba(255, 255, 255, 0.5);
            border-radius: 10px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.05);
        }

        .upload-area:hover {
            border-color: rgba(255, 255, 255, 0.8);
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
        }

        .upload-area.dragover {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.2);
            transform: scale(1.02);
        }

        .file-list {
            margin-top: 15px;
        }

        .file-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
        }

        .file-item:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateX(3px);
        }

        .file-info {
            flex: 1;
        }

        .file-name {
            font-weight: bold;
            color: #FFD700;
            font-size: 14px;
        }

        .file-details {
            font-size: 11px;
            opacity: 0.8;
            margin-top: 2px;
        }

        .remove-btn {
            background: #ff4444;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.3s ease;
        }

        .remove-btn:hover {
            background: #cc0000;
            transform: scale(1.1);
        }

        @media (max-width: 1400px) {
            .main-grid {
                grid-template-columns: 450px 1fr;
            }
        }
        
        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üî¨ Component-Specific Mainframe Analysis</h1>
            <p>Targeted analysis of individual components with complete data lifecycle tracking</p>
        </div>

        <div class="main-grid">
            <!-- Control Panel -->
            <div class="control-panel">
                <!-- Component Search Section -->
                <div class="component-search-section">
                    <h2 class="section-title">üéØ Component Analysis</h2>
                    <div class="form-group">
                        <label for="componentName">Enter Component Name:</label>
                        <input type="text" id="componentName" class="component-input" 
                               placeholder="e.g., CUSTOMER-RECORD, ACCOUNT-COPY, PAYROLL-PROC">
                        <div id="componentSuggestions" class="component-suggestions"></div>
                    </div>
                    <button class="action-btn component-btn" id="analyzeComponentBtn" disabled>
                        üîç Analyze Component Lifecycle
                    </button>
                    <div style="font-size: 12px; margin-top: 10px; opacity: 0.8; line-height: 1.4;">
                        <strong>üí° Analyze:</strong><br>
                        ‚Ä¢ Copybook fields and their complete lifecycle<br>
                        ‚Ä¢ Program call chains and data flow<br>
                        ‚Ä¢ JCL job execution and file dependencies<br>
                        ‚Ä¢ Field usage patterns across all programs
                    </div>
                </div>

                <!-- vLLM API Setup -->
                <div style="margin-bottom: 25px; padding: 20px; background: rgba(0, 0, 0, 0.2); border-radius: 15px; border-left: 4px solid #4CAF50;">
                    <h2 class="section-title">üöÄ vLLM Server Setup</h2>
                    <div class="form-group">
                        <label for="vllmEndpoint">Server Endpoint:</label>
                        <input type="text" id="vllmEndpoint" placeholder="http://localhost:8000" value="http://localhost:8000">
                    </div>
                    <div class="form-group">
                        <label for="maxTokens">Max Tokens:</label>
                        <input type="number" id="maxTokens" value="4000" min="1000" max="8000">
                    </div>
                    <button class="action-btn validate-btn" id="validateApiBtn">
                        üîê Test Connection
                    </button>
                    <div class="api-status disconnected" id="apiStatus">
                        <span>üî¥</span> Enter server details and test connection
                    </div>
                </div>

                <!-- File Upload Section -->
                <div style="margin-bottom: 25px;">
                    <h2 class="section-title">üìÅ Upload Mainframe Files</h2>
                    <div class="upload-area" id="uploadArea">
                        <div>
                            <h3 style="margin-bottom: 8px;">üì§ Drop files here</h3>
                            <p style="font-size: 14px;">COBOL (.cbl), Copybooks (.cpy), JCL (.jcl)</p>
                            <p style="font-size: 11px; margin-top: 8px; opacity: 0.7;">
                                Upload all related files for complete analysis
                            </p>
                        </div>
                        <input type="file" id="fileInput" multiple accept=".cbl,.cob,.cpy,.copybook,.jcl,.txt,.proc" style="display: none;">
                    </div>
                    <div id="uploadedFiles" class="file-list"></div>
                </div>

                <!-- Quick Actions -->
                <div>
                    <h3 class="section-title">‚ö° Quick Actions</h3>
                    <button class="action-btn secondary-btn" id="bulkAnalyzeBtn" disabled>
                        üìä Analyze Top Components
                    </button>
                    <button class="action-btn secondary-btn" id="exportBtn" disabled>
                        üì§ Export Analysis Results
                    </button>
                    <button class="action-btn secondary-btn" id="clearBtn">
                        üóëÔ∏è Clear All Data
                    </button>
                </div>
            </div>

            <!-- Analysis Workspace -->
            <div class="analysis-workspace">
                <div class="tabs">
                    <button class="tab active" data-tab="lifecycle">üîÑ Component Lifecycle</button>
                    <button class="tab" data-tab="fieldmatrix">üìã Field Matrix</button>
                    <button class="tab" data-tab="usage">üìà Usage Analysis</button>
                    <button class="tab" data-tab="dependencies">üîó Dependencies</button>
                </div>

                <!-- Tab Contents -->
                <div id="lifecycle" class="tab-content active">
                    <div id="lifecycleContent">
                        <h3>üéØ Component Lifecycle Analysis</h3>
                        <p style="margin-bottom: 20px; line-height: 1.6;">
                            Enter a component name to see its complete data flow and lifecycle across all uploaded programs, copybooks, and JCL files.
                        </p>
                        
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px; border-left: 4px solid #FFD700;">
                            <h4 style="color: #FFD700; margin-bottom: 15px;">üéØ What you can analyze:</h4>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                                <div>
                                    <strong style="color: #4CAF50;">üìö Copybooks:</strong>
                                    <ul style="list-style: none; margin-left: 10px; line-height: 1.8;">
                                        <li>‚Ä¢ Complete field usage across programs</li>
                                        <li>‚Ä¢ Field creation and modification tracking</li>
                                        <li>‚Ä¢ Unused/stale field detection</li>
                                        <li>‚Ä¢ Data transformation analysis</li>
                                    </ul>
                                </div>
                                <div>
                                    <strong style="color: #2196F3;">üíæ Programs:</strong>
                                    <ul style="list-style: none; margin-left: 10px; line-height: 1.8;">
                                        <li>‚Ä¢ Call chains and execution flow</li>
                                        <li>‚Ä¢ Parameter passing analysis</li>
                                        <li>‚Ä¢ Data input/output mapping</li>
                                        <li>‚Ä¢ Business logic extraction</li>
                                    </ul>
                                </div>
                                <div>
                                    <strong style="color: #FF9800;">üè∑Ô∏è Fields:</strong>
                                    <ul style="list-style: none; margin-left: 10px; line-height: 1.8;">
                                        <li>‚Ä¢ Creation to deletion lifecycle</li>
                                        <li>‚Ä¢ Cross-program usage patterns</li>
                                        <li>‚Ä¢ Validation and business rules</li>
                                        <li>‚Ä¢ Reference vs update operations</li>
                                    </ul>
                                </div>
                                <div>
                                    <strong style="color: #9C27B0;">‚öôÔ∏è JCL Jobs:</strong>
                                    <ul style="list-style: none; margin-left: 10px; line-height: 1.8;">
                                        <li>‚Ä¢ Execution flow and dependencies</li>
                                        <li>‚Ä¢ File processing patterns</li>
                                        <li>‚Ä¢ Program invocation sequences</li>
                                        <li>‚Ä¢ Data file lifecycles</li>
                                    </ul>
                                </div>
                            </div>
                        </div>

                        <div style="margin-top: 25px; background: rgba(33, 150, 243, 0.1); padding: 15px; border-radius: 8px; border-left: 4px solid #2196F3;">
                            <h4 style="color: #2196F3; margin-bottom: 10px;">üöÄ Getting Started:</h4>
                            <ol style="line-height: 1.8; padding-left: 20px;">
                                <li>Upload your COBOL programs, copybooks, and JCL files</li>
                                <li>Test your vLLM server connection</li>
                                <li>Enter a component name (suggestions will appear as you type)</li>
                                <li>Click "Analyze Component Lifecycle" for detailed analysis</li>
                                <li>Explore different tabs to see field matrices, usage patterns, and dependencies</li>
                            </ol>
                        </div>
                    </div>
                </div>

                <div id="fieldmatrix" class="tab-content">
                    <div id="fieldMatrixContent">
                        <h3>üìã Field Usage Matrix</h3>
                        <p style="margin-bottom: 20px;">
                            Field-level analysis showing how each field is used across different programs.
                        </p>
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px;">
                            <p style="text-align: center; opacity: 0.8;">
                                Select a component from the control panel to see detailed field usage patterns here.
                            </p>
                        </div>
                    </div>
                </div>

                <div id="usage" class="tab-content">
                    <div id="usageContent">
                        <h3>üìà Cross-Program Usage Analysis</h3>
                        <p style="margin-bottom: 20px;">
                            Detailed statistics and usage patterns across all uploaded programs.
                        </p>
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px;">
                            <p style="text-align: center; opacity: 0.8;">
                                Usage patterns and statistics will appear here after component analysis.
                            </p>
                        </div>
                    </div>
                </div>

                <div id="dependencies" class="tab-content">
                    <div id="dependenciesContent">
                        <h3>üîó Component Dependencies</h3>
                        <p style="margin-bottom: 20px;">
                            Component relationships, dependencies, and integration points.
                        </p>
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px;">
                            <p style="text-align: center; opacity: 0.8;">
                                Dependency analysis will appear here after selecting a component.
                            </p>
                        </div>
                    </div>
                </div>

                <!-- Loading Indicator -->
                <div class="loading" id="loadingIndicator">
                    <div class="spinner"></div>
                    <h3>ü§ñ Analyzing Component...</h3>
                    <p id="loadingStatus">Initializing analysis...</p>
                </div>
            </div>
        </div>
    </div>
    <script>
        class ComponentSpecificAnalyzer {
            constructor() {
                this.uploadedFiles = [];
                this.analysisResults = {};
                this.componentAnalysis = {};
                this.componentSuggestions = [];
                this.serverValidated = false;
                this.vllmEndpoint = 'http://localhost:8000';
                this.maxTokens = 4000;
                this.storageKey = 'component_specific_analysis';
                
                this.initializeEventListeners();
                this.loadStoredData();
            }

            initializeEventListeners() {
                // API validation
                document.getElementById('validateApiBtn').addEventListener('click', this.validateConnection.bind(this));
                document.getElementById('vllmEndpoint').addEventListener('input', this.onEndpointChange.bind(this));
                document.getElementById('maxTokens').addEventListener('input', this.onSettingsChange.bind(this));
                
                // File upload handlers
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');
                
                uploadArea.addEventListener('click', () => {
                    if (this.serverValidated) fileInput.click();
                });
                uploadArea.addEventListener('drop', this.handleFileDrop.bind(this));
                uploadArea.addEventListener('dragover', this.handleDragOver.bind(this));
                uploadArea.addEventListener('dragleave', this.handleDragLeave.bind(this));
                fileInput.addEventListener('change', this.handleFileSelect.bind(this));

                // Component analysis
                document.getElementById('componentName').addEventListener('input', this.onComponentInput.bind(this));
                document.getElementById('analyzeComponentBtn').addEventListener('click', this.analyzeComponent.bind(this));
                
                // Quick actions
                document.getElementById('bulkAnalyzeBtn').addEventListener('click', this.bulkAnalyze.bind(this));
                document.getElementById('exportBtn').addEventListener('click', this.exportResults.bind(this));
                document.getElementById('clearBtn').addEventListener('click', this.clearAllData.bind(this));

                // Tab navigation
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', this.switchTab.bind(this));
                });

                // Hide suggestions when clicking outside
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.component-search-section')) {
                        document.getElementById('componentSuggestions').style.display = 'none';
                    }
                });
            }

            onEndpointChange() {
                this.serverValidated = false;
                this.updateConnectionStatus('disconnected', 'Endpoint changed - Test connection');
                this.validateForm();
            }

            onSettingsChange() {
                this.maxTokens = parseInt(document.getElementById('maxTokens').value) || 4000;
            }

            async validateConnection() {
                const endpoint = document.getElementById('vllmEndpoint').value.trim();
                if (!endpoint) {
                    this.showError('Please enter vLLM endpoint');
                    return;
                }

                this.updateConnectionStatus('connecting', 'Testing connection...');

                try {
                    new URL(endpoint); // Validate URL format
                    
                    const response = await fetch(`${endpoint}/generate`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            prompt: "Test connection. Respond with 'Connected successfully'",
                            max_tokens: 10,
                            temperature: 0.1
                        }),
                        signal: AbortSignal.timeout(10000)
                    });

                    if (response.ok) {
                        const data = await response.json();
                        const responseText = data.text || data.choices?.[0]?.text || JSON.stringify(data);
                        
                        if (responseText.toLowerCase().includes('connect')) {
                            this.serverValidated = true;
                            this.vllmEndpoint = endpoint;
                            this.updateConnectionStatus('connected', `Connected to ${endpoint}`);
                            this.showSuccess('vLLM connection validated!');
                        } else {
                            throw new Error('Unexpected response format');
                        }
                    } else {
                        throw new Error(`HTTP ${response.status}`);
                    }
                } catch (error) {
                    this.serverValidated = false;
                    this.updateConnectionStatus('disconnected', `Connection failed: ${error.message}`);
                    this.showError(`Connection failed: ${error.message}`);
                }
                
                this.validateForm();
            }

            updateConnectionStatus(status, message) {
                const statusElement = document.getElementById('apiStatus');
                const statusClasses = ['disconnected', 'connecting', 'connected'];
                
                statusClasses.forEach(cls => statusElement.classList.remove(cls));
                statusElement.classList.add(status);
                
                const indicators = {
                    'disconnected': 'üî¥',
                    'connecting': 'üü°',
                    'connected': 'üü¢'
                };
                
                statusElement.innerHTML = `<span>${indicators[status]}</span> ${message}`;
            }

            handleDragOver(e) {
                e.preventDefault();
                document.getElementById('uploadArea').classList.add('dragover');
            }

            handleDragLeave(e) {
                e.preventDefault();
                document.getElementById('uploadArea').classList.remove('dragover');
            }

            handleFileDrop(e) {
                e.preventDefault();
                document.getElementById('uploadArea').classList.remove('dragover');
                const files = Array.from(e.dataTransfer.files);
                this.processFiles(files);
            }

            handleFileSelect(e) {
                const files = Array.from(e.target.files);
                this.processFiles(files);
            }

            async processFiles(files) {
                this.showLoading();
                this.updateLoadingStatus('Processing uploaded files...');

                try {
                    for (const file of files) {
                        if (this.isValidFile(file)) {
                            const content = await this.readFileContent(file);
                            this.uploadedFiles.push({
                                name: file.name,
                                type: this.getFileType(file.name),
                                content: content,
                                size: file.size
                            });
                        }
                    }
                    
                    this.updateFileList();
                    this.updateComponentSuggestions();
                    this.validateForm();
                    
                    this.hideLoading();
                    this.showSuccess(`Processed ${files.length} file(s) successfully`);
                } catch (error) {
                    this.hideLoading();
                    this.showError(`File processing failed: ${error.message}`);
                }
            }

            isValidFile(file) {
                const validExtensions = ['.cbl', '.cob', '.cpy', '.copybook', '.jcl', '.txt', '.proc'];
                const ext = file.name.toLowerCase().substring(file.name.lastIndexOf('.'));
                return validExtensions.includes(ext) || file.type.includes('text');
            }

            getFileType(filename) {
                const ext = filename.toLowerCase().substring(filename.lastIndexOf('.'));
                const typeMap = {
                    '.cbl': 'COBOL Program',
                    '.cob': 'COBOL Program', 
                    '.cpy': 'Copybook',
                    '.copybook': 'Copybook',
                    '.jcl': 'JCL Job',
                    '.proc': 'JCL Procedure',
                    '.txt': 'Text File'
                };
                return typeMap[ext] || 'Unknown';
            }

            readFileContent(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = (e) => reject(new Error('Failed to read file'));
                    reader.readAsText(file);
                });
            }

            updateFileList() {
                const container = document.getElementById('uploadedFiles');
                if (this.uploadedFiles.length === 0) {
                    container.innerHTML = '';
                    return;
                }

                let html = '<h4 style="margin: 15px 0 10px 0; color: #FFD700;">üìÑ Uploaded Files:</h4>';
                this.uploadedFiles.forEach((file, index) => {
                    html += `
                        <div class="file-item">
                            <div class="file-info">
                                <div class="file-name">${file.name}</div>
                                <div class="file-details">${file.type} ‚Ä¢ ${this.formatFileSize(file.size)}</div>
                            </div>
                            <button class="remove-btn" onclick="analyzer.removeFile(${index})">√ó</button>
                        </div>
                    `;
                });
                container.innerHTML = html;
            }

            removeFile(index) {
                this.uploadedFiles.splice(index, 1);
                this.updateFileList();
                this.updateComponentSuggestions();
                this.validateForm();
            }

            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }

            updateComponentSuggestions() {
                const suggestions = new Set();
                
                this.uploadedFiles.forEach(file => {
                    // Add file names (without extensions)
                    const baseName = file.name.replace(/\.(cbl|cob|cpy|copybook|jcl|txt|proc)$/i, '');
                    suggestions.add(baseName);
                    
                    // Extract copybook names from COPY statements
                    const copyMatches = file.content.match(/COPY\s+([A-Z0-9\-_]+)/gi);
                    if (copyMatches) {
                        copyMatches.forEach(match => {
                            const copybook = match.replace(/COPY\s+/i, '').trim();
                            if (copybook.length > 2) suggestions.add(copybook);
                        });
                    }
                    
                    // Extract program names from CALL statements
                    const callMatches = file.content.match(/CALL\s+['"]([A-Z0-9\-_]+)['"]|CALL\s+([A-Z0-9\-_]+)/gi);
                    if (callMatches) {
                        callMatches.forEach(match => {
                            const program = match.replace(/CALL\s+['"]?/i, '').replace(/['"].*/, '').trim();
                            if (program.length > 2) suggestions.add(program);
                        });
                    }
                    
                    // Extract field names from copybooks (simplified)
                    if (file.type === 'Copybook') {
                        const fieldMatches = file.content.match(/^\s*\d{2}\s+([A-Z0-9\-_]+)/gm);
                        if (fieldMatches) {
                            fieldMatches.forEach(match => {
                                const field = match.replace(/^\s*\d{2}\s+/, '').trim();
                                if (field.length > 3 && !field.includes('PIC') && !field.includes('OCCURS')) {
                                    suggestions.add(field);
                                }
                            });
                        }
                    }
                });
                
                this.componentSuggestions = Array.from(suggestions).sort();
                console.log(`Found ${this.componentSuggestions.length} component suggestions`);
            }

            onComponentInput() {
                const input = document.getElementById('componentName').value.trim().toUpperCase();
                const suggestions = document.getElementById('componentSuggestions');
                
                if (input.length < 2) {
                    suggestions.style.display = 'none';
                    this.validateForm();
                    return;
                }
                
                const matches = this.componentSuggestions
                    .filter(s => s.toUpperCase().includes(input))
                    .slice(0, 10);
                
                if (matches.length > 0) {
                    suggestions.innerHTML = matches.map(match => 
                        `<div class="suggestion-item" onclick="analyzer.selectSuggestion('${match}')">${match}</div>`
                    ).join('');
                    suggestions.style.display = 'block';
                } else {
                    suggestions.style.display = 'none';
                }
                
                this.validateForm();
            }

            selectSuggestion(suggestion) {
                document.getElementById('componentName').value = suggestion;
                document.getElementById('componentSuggestions').style.display = 'none';
                this.validateForm();
            }

            validateForm() {
                const hasFiles = this.uploadedFiles.length > 0;
                const hasComponent = document.getElementById('componentName').value.trim().length > 0;
                const hasConnection = this.serverValidated;
                
                document.getElementById('analyzeComponentBtn').disabled = !(hasFiles && hasComponent && hasConnection);
                document.getElementById('bulkAnalyzeBtn').disabled = !(hasFiles && hasConnection);
                document.getElementById('exportBtn').disabled = Object.keys(this.componentAnalysis).length === 0;
            }
            async analyzeComponent() {
                const componentName = document.getElementById('componentName').value.trim();
                if (!componentName) return;

                this.showLoading();
                this.updateLoadingStatus(`Analyzing component: ${componentName}`);

                try {
                    // Step 1: Identify what type of component this is
                    this.updateLoadingStatus('Identifying component type and locations...');
                    const componentInfo = await this.identifyComponent(componentName);
                    
                    if (componentInfo.type === 'NOT_FOUND') {
                        throw new Error(`Component "${componentName}" not found in uploaded files`);
                    }
                    
                    // Step 2: Perform targeted analysis based on component type
                    this.updateLoadingStatus(`Performing ${componentInfo.type} analysis...`);
                    const analysis = await this.performComponentAnalysis(componentName, componentInfo);
                    
                    // Step 3: Store results
                    this.componentAnalysis[componentName] = {
                        timestamp: new Date().toISOString(),
                        componentInfo: componentInfo,
                        analysis: analysis
                    };
                    
                    // Step 4: Display results
                    this.displayComponentAnalysis(componentName);
                    this.saveToStorage();
                    
                    this.hideLoading();
                    this.showSuccess(`Analysis complete for component: ${componentName}`);
                    this.validateForm();
                    
                } catch (error) {
                    this.hideLoading();
                    this.showError(`Analysis failed: ${error.message}`);
                    console.error('Component analysis error:', error);
                }
            }

            async identifyComponent(componentName) {
                const prompt = `
COMPONENT IDENTIFICATION AND MAPPING

Component Name: ${componentName}

Analyze these files to identify where and how this component appears:

FILES:
${this.uploadedFiles.map(f => `
=== ${f.name} (${f.type}) ===
${f.content.substring(0, 3000)}${f.content.length > 3000 ? '\n... (truncated)' : ''}
`).join('\n')}

IDENTIFICATION TASKS:
1. **Component Type**: Is this a copybook name, program name, field name, or JCL job?
2. **File Locations**: Which files contain references to this component?
3. **Usage Context**: How is it used in each file (COPY statement, CALL, field reference, etc.)?
4. **Related Components**: What other components does it interact with?

Format response EXACTLY as:
COMPONENT_TYPE: [COPYBOOK|PROGRAM|FIELD|JCL_JOB|NOT_FOUND]
FOUND_IN: file1.ext, file2.ext
USAGE_CONTEXT: Brief description of how it's used
RELATED_COMPONENTS: component1, component2
                `;

                const response = await this.callvLLMAPI(prompt);
                return this.parseComponentInfo(response);
            }

            parseComponentInfo(response) {
                const info = {
                    type: 'NOT_FOUND',
                    foundIn: [],
                    usageContext: '',
                    relatedComponents: []
                };

                const lines = response.split('\n');
                lines.forEach(line => {
                    line = line.trim();
                    if (line.includes('COMPONENT_TYPE:')) {
                        info.type = line.split(':')[1]?.trim() || 'NOT_FOUND';
                    } else if (line.includes('FOUND_IN:')) {
                        const filesStr = line.split(':')[1]?.trim() || '';
                        info.foundIn = filesStr.split(',').map(s => s.trim()).filter(s => s);
                    } else if (line.includes('USAGE_CONTEXT:')) {
                        info.usageContext = line.split(':')[1]?.trim() || '';
                    } else if (line.includes('RELATED_COMPONENTS:')) {
                        const componentsStr = line.split(':')[1]?.trim() || '';
                        info.relatedComponents = componentsStr.split(',').map(s => s.trim()).filter(s => s);
                    }
                });

                console.log('Parsed component info:', info);
                return info;
            }

            async performComponentAnalysis(componentName, componentInfo) {
                let analysisPrompt = '';
                
                switch (componentInfo.type) {
                    case 'COPYBOOK':
                        analysisPrompt = this.buildCopybookAnalysisPrompt(componentName, componentInfo);
                        break;
                    case 'FIELD':
                        analysisPrompt = this.buildFieldAnalysisPrompt(componentName, componentInfo);
                        break;
                    case 'PROGRAM':
                        analysisPrompt = this.buildProgramAnalysisPrompt(componentName, componentInfo);
                        break;
                    case 'JCL_JOB':
                        analysisPrompt = this.buildJCLAnalysisPrompt(componentName, componentInfo);
                        break;
                    default:
                        throw new Error(`Unsupported component type: ${componentInfo.type}`);
                }

                return await this.callvLLMAPI(analysisPrompt);
            }

            buildCopybookAnalysisPrompt(componentName, componentInfo) {
                const relevantFiles = this.uploadedFiles.filter(f => 
                    componentInfo.foundIn.some(fileName => f.name.includes(fileName)) ||
                    f.content.includes(componentName) ||
                    f.type === 'COBOL Program'
                );

                return `
COPYBOOK LIFECYCLE ANALYSIS: ${componentName}

Analyze the complete lifecycle of copybook "${componentName}" across all programs:

RELEVANT FILES:
${relevantFiles.map(f => `
=== ${f.name} (${f.type}) ===
${f.content}
`).join('\n')}

COMPREHENSIVE COPYBOOK ANALYSIS:

**1. FIELD INVENTORY**
- List ALL fields defined in this copybook with their PIC clauses and descriptions
- Identify group fields vs elementary fields  
- Note REDEFINES and OCCURS clauses
- Field hierarchy and data structure organization

**2. CROSS-PROGRAM USAGE**
For each program that uses this copybook, identify:
- Which fields are READ (used as input/reference)
- Which fields are UPDATED/WRITTEN (modified by MOVE statements)
- Which fields are NEVER USED (stale/unused fields)
- Field usage frequency and patterns

**3. DATA LIFECYCLE FLOW**
For each field in the copybook, trace the complete lifecycle:
- **CREATION**: Where/how is the field first populated? (INPUT files, user entry, calculations)
- **UPDATES**: Which programs modify this field and how?
- **REFERENCES**: Which programs read this field for processing?
- **TRANSFORMATIONS**: How is data converted, calculated, or formatted?
- **OUTPUT**: Where does the field data go? (files, DB2, reports, other programs)
- **PURGING**: Where/when is the data deleted, archived, or cleared?

**4. FIELD CLASSIFICATION**
Classify each field as:
- INPUT_ONLY: Only populated from external sources, never modified internally
- OUTPUT_ONLY: Only written to external targets, never read internally  
- WORKING: Used for calculations, transformations, temporary storage
- CONTROL: Status flags, counters, indicators, processing controls
- UNUSED: Defined but never referenced in any uploaded program
- KEY_FIELD: Used for lookups, joins, indexing, or identification

**5. STALE FIELD DETECTION**
- List fields that are defined but NEVER used in any program
- Fields that are only populated but never referenced
- Fields with outdated or obsolete business purposes
- Recommended fields for removal or consolidation

**6. BUSINESS IMPACT ANALYSIS**
- Programs that would break if this copybook changed
- Critical fields vs optional fields
- Data quality issues and validation gaps
- Performance impact of field usage patterns

Provide specific examples with program names and line references where possible.
                `;
            }

            buildFieldAnalysisPrompt(componentName, componentInfo) {
                const relevantFiles = this.uploadedFiles.filter(f => 
                    f.content.includes(componentName)
                );

                return `
FIELD LIFECYCLE ANALYSIS: ${componentName}

Analyze the complete lifecycle of field "${componentName}" across all uploaded files:

RELEVANT FILES:
${relevantFiles.map(f => `
=== ${f.name} (${f.type}) ===
${f.content}
`).join('\n')}

COMPREHENSIVE FIELD ANALYSIS:

**1. FIELD DEFINITION**
- Where is this field defined? (copybook name, program name)
- Data type, length, and format (PIC clause)
- Parent group structure and level number
- Any REDEFINES or alternate definitions

**2. COMPLETE DATA FLOW LIFECYCLE**
Trace the field through its entire lifecycle:

**CREATION/INPUT STAGE:**
- How is this field initially populated?
- External data sources (input files, DB2, user entry)
- Default values or initialization logic
- Input validation rules and constraints

**PROCESSING/TRANSFORMATION STAGE:**
- Which programs READ this field for processing?
- Which programs WRITE/UPDATE this field?
- Calculations, computations, or transformations applied
- Business logic and validation rules that use this field
- Conditional processing based on field values

**OUTPUT/STORAGE STAGE:**
- Where is the field data written or stored?
- File outputs, database updates, report generation
- Data formatting or conversion on output
- Integration with external systems

**ARCHIVAL/CLEANUP STAGE:**
- Archival processes that affect this field
- Data retention policies and cleanup procedures
- When and how is the field data purged?

**3. USAGE PATTERN ANALYSIS**
- READ operations: List all programs that reference this field
- WRITE operations: List all programs that modify this field  
- CALCULATION operations: Programs that use field in computations
- VALIDATION operations: Programs that check or validate field values
- CONDITIONAL operations: Programs that make decisions based on field values
- UNUSED patterns: Programs that include but don't actually use the field

**4. CROSS-PROGRAM DEPENDENCIES**
- Programs that depend on this field being populated
- Programs that must execute BEFORE this field is populated
- Programs that must execute AFTER this field is updated
- JCL job execution order dependencies related to this field

**5. DATA QUALITY AND VALIDATION**
- Validation rules and business constraints
- Error handling procedures for this field
- Data consistency checks across programs
- Potential data quality issues or risks

**6. BUSINESS IMPACT ASSESSMENT**
- Business processes that critically depend on this field
- Impact analysis if field was removed or changed
- Compliance, regulatory, or audit requirements
- Integration points with external systems

**7. MODERNIZATION OPPORTUNITIES**
- Is this field suitable for database normalization?
- Can this field be consolidated with similar fields?
- API or service interface potential
- Opportunities for automation or optimization

Provide specific program names, line numbers, and code examples where the field is used.
                `;
            }

            buildProgramAnalysisPrompt(componentName, componentInfo) {
                const relevantFiles = this.uploadedFiles.filter(f => 
                    componentInfo.foundIn.some(fileName => f.name.includes(fileName)) ||
                    f.content.includes(componentName)
                );

                return `
PROGRAM LIFECYCLE ANALYSIS: ${componentName}

Analyze how program "${componentName}" is used and integrated across the system:

RELEVANT FILES:
${relevantFiles.map(f => `
=== ${f.name} (${f.type}) ===
${f.content}
`).join('\n')}

COMPREHENSIVE PROGRAM ANALYSIS:

**1. PROGRAM IDENTIFICATION AND PURPOSE**
- Program type and main business function
- Input parameters and linkage section analysis
- Main processing logic and business purpose
- Program classification (batch, online, utility, etc.)

**2. EXECUTION FLOW AND DEPENDENCIES**
- Which programs or JCL jobs CALL this program?
- What programs does this program CALL?
- Parameter passing and data sharing mechanisms
- Execution sequence and timing dependencies

**3. DATA DEPENDENCIES AND I/O**
- Copybooks included and used by this program
- Input files and datasets read by this program
- Output files and datasets written by this program
- Database tables accessed (EXEC SQL statements)
- Temporary files or work areas used

**4. BUSINESS PROCESSING ANALYSIS**
- Core business logic and processing rules
- Data transformations and calculations performed
- Validation and error handling procedures
- Business workflows and process integration

**5. INTEGRATION POINTS**
- Programs that depend on this program's execution
- Data passed TO this program (inputs)
- Data passed FROM this program (outputs)
- Shared data areas, files, or database records
- External system interfaces

**6. ERROR HANDLING AND RECOVERY**
- Error conditions and exception handling
- Recovery procedures and restart capabilities
- Notification and alerting mechanisms
- Data integrity and consistency measures

**7. PERFORMANCE AND RESOURCE USAGE**
- Processing time and resource requirements
- File I/O patterns and efficiency
- Database access patterns
- Memory and storage utilization

**8. MAINTENANCE AND SUPPORT**
- Code quality and maintainability assessment
- Documentation and commenting adequacy
- Testing and validation procedures
- Change impact analysis

**9. MODERNIZATION OPPORTUNITIES**
- Areas suitable for refactoring or optimization
- Database modernization opportunities
- API or service interface potential
- Automation and process improvement opportunities

Provide specific examples with file names, line numbers, and code snippets where relevant.
                `;
            }

            buildJCLAnalysisPrompt(componentName, componentInfo) {
                const relevantFiles = this.uploadedFiles.filter(f => 
                    componentInfo.foundIn.some(fileName => f.name.includes(fileName)) ||
                    f.content.includes(componentName) ||
                    f.type === 'JCL Job'
                );

                return `
JCL JOB LIFECYCLE ANALYSIS: ${componentName}

Analyze the execution flow and dependencies of JCL job "${componentName}":

RELEVANT FILES:
${relevantFiles.map(f => `
=== ${f.name} (${f.type}) ===
${f.content}
`).join('\n')}

COMPREHENSIVE JCL ANALYSIS:

**1. JOB STRUCTURE AND ORGANIZATION**
- Job steps and execution sequence
- Programs executed in each step  
- DD statements and file allocations
- Conditional execution logic (IF/THEN/ELSE)
- PROC calls and parameter substitution

**2. DATA FLOW AND FILE MANAGEMENT**
- Input files and datasets required before job execution
- Output files and datasets created during execution
- Temporary work files and intermediate datasets
- Data passed between job steps
- File cleanup and housekeeping procedures

**3. PROGRAM EXECUTION SEQUENCE**
- Which COBOL programs are executed and in what order?
- Parameter passing between job steps (PARM values)
- Return code handling and conditional execution
- Dependencies between program executions
- Error recovery and restart procedures

**4. FILE AND DATA DEPENDENCIES**
- Files that must exist before this job can run
- Files created by this job that other jobs depend on
- Database connections and table access
- Backup and recovery file handling
- Archive and retention procedures

**5. SYSTEM INTEGRATION AND SCHEDULING**
- Jobs that must run BEFORE this job (predecessors)
- Jobs that depend on this job's completion (successors)  
- Scheduling requirements and timing constraints
- Resource requirements and system dependencies
- Integration with job scheduling systems

**6. ERROR HANDLING AND RECOVERY**
- Error detection and notification procedures
- Restart and recovery capabilities
- Cleanup procedures on job failure
- Rollback and data integrity measures
- Alerting and monitoring integration

**7. RESOURCE MANAGEMENT**
- Memory and storage requirements
- Processing time estimates and SLA requirements
- System resource allocation and limits
- Performance monitoring and optimization
- Cost and resource efficiency analysis

**8. BUSINESS PROCESS INTEGRATION**
- Business processes supported by this job
- Critical vs non-critical job classification
- Impact analysis if job fails or is delayed
- Integration with business workflows
- Compliance and audit requirements



Provide specific step names, file references, program names, and execution dependencies.
                `;
            }
async callvLLMAPI(prompt) {
                try {
                    const response = await fetch(`${this.vllmEndpoint}/generate`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            prompt: prompt,
                            max_tokens: this.maxTokens,
                            temperature: 0.1,
                            stop: ["###", "---END---", "</analysis>"]
                        }),
                        signal: AbortSignal.timeout(120000) // 2 minute timeout
                    });

                    if (!response.ok) {
                        const errorText = await response.text().catch(() => 'Unknown error');
                        throw new Error(`HTTP ${response.status}: ${errorText}`);
                    }

                    const data = await response.json();
                    const responseText = data.text || data.choices?.[0]?.text || JSON.stringify(data);
                    
                    if (!responseText) {
                        throw new Error('No response text generated');
                    }

                    return responseText.trim();
                } catch (error) {
                    if (error.name === 'AbortError') {
                        throw new Error('Request timed out - try reducing file size or max tokens');
                    }
                    throw new Error(`vLLM API error: ${error.message}`);
                }
            }

            displayComponentAnalysis(componentName) {
                const analysis = this.componentAnalysis[componentName];
                
                // Update all tabs with the analysis
                this.displayLifecycleAnalysis(componentName, analysis);
                this.displayFieldMatrix(componentName, analysis);
                this.displayUsageAnalysis(componentName, analysis);
                this.displayDependencyAnalysis(componentName, analysis);
                
                // Switch to lifecycle tab to show results
                this.switchTab({ target: { dataset: { tab: 'lifecycle' } } });
            }

            displayLifecycleAnalysis(componentName, analysis) {
                const container = document.getElementById('lifecycleContent');
                const componentInfo = analysis.componentInfo;
                
                let html = `
                    <div class="lifecycle-flow"><h3 style="color: #FFD700; margin-bottom: 15px;">üéØ Component Analysis: ${componentName}</h3>
                        <div style="margin-bottom: 20px; padding: 15px; background: rgba(255, 255, 255, 0.05); border-radius: 8px;">
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                                <div>
                                    <strong style="color: #4CAF50;">Type:</strong><br>
                                    <span style="font-size: 18px;">${this.getTypeIcon(componentInfo.type)} ${componentInfo.type}</span>
                                </div>
                                <div>
                                    <strong style="color: #2196F3;">Found in:</strong><br>
                                    ${componentInfo.foundIn.join(', ') || 'Multiple files'}
                                </div>
                                <div>
                                    <strong style="color: #FF9800;">Context:</strong><br>
                                    ${componentInfo.usageContext || 'Cross-program usage'}
                                </div>
                                <div>
                                    <strong style="color: #9C27B0;">Related:</strong><br>
                                    ${componentInfo.relatedComponents.slice(0, 3).join(', ') || 'Various components'}
                                </div>
                            </div>
                        </div>
                `;

                // Parse and display analysis sections
                const sections = this.extractAnalysisSections(analysis.analysis);
                
                sections.forEach((section, index) => {
                    const icon = this.getSectionIcon(section.title);
                    const isEvenSection = index % 2 === 0;
                    const sectionColor = isEvenSection ? 'rgba(76, 175, 80, 0.1)' : 'rgba(33, 150, 243, 0.1)';
                    
                    html += `
                        <div class="flow-stage" style="background: ${sectionColor};">
                            <div class="stage-icon">${icon}</div>
                            <div class="stage-content">
                                <div class="stage-title">${section.title}</div>
                                <div class="stage-details">${section.content}</div>
                            </div>
                        </div>
                    `;
                });

                // Add summary footer
                html += `
                    <div style="margin-top: 20px; padding: 15px; background: rgba(255, 215, 0, 0.1); border-radius: 8px; border-left: 4px solid #FFD700;">
                        <h4 style="color: #FFD700; margin-bottom: 10px;">üìä Analysis Summary</h4>
                        <div style="font-size: 13px; line-height: 1.6;">
                            <strong>Analysis completed for:</strong> ${componentName}<br>
                            <strong>Component type:</strong> ${componentInfo.type}<br>
                            <strong>Files analyzed:</strong> ${this.uploadedFiles.length}<br>
                            <strong>Generated:</strong> ${new Date().toLocaleString()}
                        </div>
                    </div>
                </div>`;
                
                container.innerHTML = html;
            }

            displayFieldMatrix(componentName, analysis) {
                const container = document.getElementById('fieldMatrixContent');
                
                // Extract field information from the analysis
                const fields = this.extractFieldInfo(analysis.analysis, componentName);
                
                let html = `
                    <h3>üìã Field Usage Matrix: ${componentName}</h3>
                    <p style="margin-bottom: 20px;">
                        Detailed field-level analysis showing usage patterns across programs.
                    </p>
                `;
                
                if (fields.length > 0) {
                    html += '<div class="field-matrix">';
                    fields.forEach(field => {
                        html += `
                            <div class="field-card">
                                <div class="field-name">${field.name}</div>
                                <div class="field-usage">
                                    <div style="margin-bottom: 8px;">${field.description}</div>
                                    <div style="margin-bottom: 10px;">
                                        ${field.usageTypes.map(type => 
                                            `<span class="usage-tag tag-${type.toLowerCase().replace('_', '')}">${type}</span>`
                                        ).join(' ')}
                                    </div>
                                    <div style="font-size: 11px;">
                                        <strong>Programs:</strong> ${field.programs.join(', ')}<br>
                                        <strong>Data Type:</strong> ${field.dataType || 'Unknown'}<br>
                                        <strong>Usage Count:</strong> ${field.usageCount || 'Multiple'}
                                    </div>
                                </div>
                            </div>
                        `;
                    });
                    html += '</div>';
                } else {
                    html += `
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px; text-align: center;">
                            <p>No detailed field information available for this component.</p>
                            <p style="font-size: 12px; opacity: 0.8; margin-top: 10px;">
                                This may be a program or JCL job rather than a data structure component.
                            </p>
                        </div>
                    `;
                }
                
                container.innerHTML = html;
            }

            displayUsageAnalysis(componentName, analysis) {
                const container = document.getElementById('usageContent');
                
                // Extract usage statistics
                const stats = this.extractUsageStats(analysis.analysis);
                
                let html = `
                    <h3>üìà Usage Analysis: ${componentName}</h3>
                    <p style="margin-bottom: 20px;">
                        Cross-program usage patterns and statistics.
                    </p>
                `;

                // Usage statistics summary
                if (stats.length > 0) {
                    html += `
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin-bottom: 25px;">
                    `;
                    
                    stats.forEach(stat => {
                        html += `
                            <div style="background: rgba(255, 255, 255, 0.1); padding: 15px; border-radius: 8px; text-align: center; border-top: 3px solid #FFD700;">
                                <div style="font-size: 1.5rem; font-weight: bold; color: #FFD700;">${stat.value}</div>
                                <div style="font-size: 11px; opacity: 0.8; margin-top: 4px;">${stat.label}</div>
                            </div>
                        `;
                    });
                    
                    html += '</div>';
                }

                // Detailed analysis
                html += `
                    <div style="background: rgba(0,0,0,0.2); padding: 20px; border-radius: 10px; line-height: 1.6;">
                        <h4 style="color: #FFD700; margin-bottom: 15px;">Detailed Usage Analysis</h4>
                        <div style="font-size: 14px;">
                            ${this.formatAnalysisText(analysis.analysis)}
                        </div>
                    </div>
                `;
                
                container.innerHTML = html;
            }

            displayDependencyAnalysis(componentName, analysis) {
                const container = document.getElementById('dependenciesContent');
                const componentInfo = analysis.componentInfo;
                
                let html = `
                    <h3>üîó Dependencies: ${componentName}</h3>
                    <p style="margin-bottom: 20px;">
                        Component relationships, dependencies, and integration points.
                    </p>
                `;

                // Dependency flow
                html += `
                    <div class="lifecycle-flow">
                        <div class="flow-stage">
                            <div class="stage-icon">üì§</div>
                            <div class="stage-content">
                                <div class="stage-title">Component Dependencies</div>
                                <div class="stage-details">
                                    <strong>Related Components:</strong> ${componentInfo.relatedComponents.join(', ') || 'None identified'}<br>
                                    <strong>Found in Files:</strong> ${componentInfo.foundIn.join(', ') || 'Multiple locations'}<br>
                                    <strong>Usage Context:</strong> ${componentInfo.usageContext || 'Various contexts'}
                                </div>
                            </div>
                        </div>

                        <div class="flow-stage">
                            <div class="stage-icon">üîÑ</div>
                            <div class="stage-content">
                                <div class="stage-title">Integration Points</div>
                                <div class="stage-details">
                                    <strong>Programs Analyzed:</strong> ${this.uploadedFiles.filter(f => f.type === 'COBOL Program').length}<br>
                                    <strong>Copybooks Analyzed:</strong> ${this.uploadedFiles.filter(f => f.type === 'Copybook').length}<br>
                                    <strong>JCL Jobs Analyzed:</strong> ${this.uploadedFiles.filter(f => f.type === 'JCL Job').length}<br>
                                    <strong>Total Files:</strong> ${this.uploadedFiles.length}
                                </div>
                            </div>
                        </div>

                        <div class="flow-stage">
                            <div class="stage-icon">‚ö°</div>
                            <div class="stage-content">
                                <div class="stage-title">Impact Assessment</div>
                                <div class="stage-details">
                                    <strong>Component Type:</strong> ${componentInfo.type}<br>
                                    <strong>Analysis Scope:</strong> Complete lifecycle analysis<br>
                                    <strong>Risk Level:</strong> ${this.calculateRiskLevel(componentInfo)}<br>
                                    <strong>Modification Impact:</strong> ${this.assessModificationImpact(componentInfo)}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                
                container.innerHTML = html;
            }

            // Helper methods for display
            getTypeIcon(type) {
                const icons = {
                    'COPYBOOK': 'üìö',
                    'PROGRAM': 'üíæ', 
                    'FIELD': 'üè∑Ô∏è',
                    'JCL_JOB': '‚öôÔ∏è',
                    'NOT_FOUND': '‚ùì'
                };
                return icons[type] || 'üìå';
            }

            getSectionIcon(title) {
                const iconMap = {
                    'FIELD INVENTORY': 'üìã',
                    'CROSS-PROGRAM USAGE': 'üîÑ', 
                    'DATA LIFECYCLE FLOW': 'üåä',
                    'FIELD CLASSIFICATION': 'üè∑Ô∏è',
                    'STALE FIELD DETECTION': 'üö®',
                    'BUSINESS IMPACT ANALYSIS': 'üíº',
                    'FIELD DEFINITION': 'üìù',
                    'COMPLETE DATA FLOW LIFECYCLE': 'üîÑ',
                    'USAGE PATTERN ANALYSIS': 'üìà',
                    'CROSS-PROGRAM DEPENDENCIES': 'üîó',
                    'DATA QUALITY AND VALIDATION': '‚úÖ',
                    'BUSINESS IMPACT ASSESSMENT': 'üíº',
                    'MODERNIZATION OPPORTUNITIES': 'üöÄ',
                    'PROGRAM IDENTIFICATION AND PURPOSE': 'üéØ',
                    'EXECUTION FLOW AND DEPENDENCIES': 'üîÑ',
                    'DATA DEPENDENCIES AND I/O': 'üíæ',
                    'BUSINESS PROCESSING ANALYSIS': '‚öôÔ∏è',
                    'INTEGRATION POINTS': 'üîó',
                    'ERROR HANDLING AND RECOVERY': 'üõ°Ô∏è',
                    'JOB STRUCTURE AND ORGANIZATION': 'üìä',
                    'DATA FLOW AND FILE MANAGEMENT': 'üìÅ',
                    'PROGRAM EXECUTION SEQUENCE': 'üî¢',
                    'SYSTEM INTEGRATION AND SCHEDULING': '‚è∞'
                };
                
                return iconMap[title.toUpperCase()] || 'üìå';
            }

            extractAnalysisSections(analysisText) {
                const sections = [];
                const lines = analysisText.split('\n');
                let currentSection = null;
                
                lines.forEach(line => {
                    line = line.trim();
                    
                    // Look for section headers (marked with **)
                    if (line.match(/^\*\*\d+\.\s/) || line.match(/^\*\*[A-Z]/)) {
                        // Save previous section
                        if (currentSection) {
                            sections.push(currentSection);
                        }
                        
                        // Start new section
                        currentSection = {
                            title: line.replace(/^\*\*\d+\.\s*/, '').replace(/\*\*$/, '').trim(),
                            content: ''
                        };
                    } else if (currentSection && line.length > 0 && !line.startsWith('**')) {
                        // Add content to current section
                        if (currentSection.content) {
                            currentSection.content += '<br>';
                        }
                        currentSection.content += line;
                    }
                });
                
                // Add final section
                if (currentSection) {
                    sections.push(currentSection);
                }
                
                return sections;
            }

            extractFieldInfo(analysisText, componentName) {
                const fields = [];
                const lines = analysisText.split('\n');
                
                // Look for field definitions and usage patterns
                lines.forEach((line, index) => {
                    // Simple pattern matching for field information
                    const fieldMatch = line.match(/([A-Z][A-Z0-9\-_]{2,})\s*[:\-]\s*(.+)/);
                    if (fieldMatch && fieldMatch[1].length > 3) {
                        const fieldName = fieldMatch[1];
                        const description = fieldMatch[2] || 'Field analysis';
                        
                        // Determine usage types based on context
                        const usageTypes = [];
                        const context = lines.slice(Math.max(0, index-2), index+3).join(' ').toLowerCase();
                        
                        if (context.includes('read') || context.includes('input') || context.includes('reference')) {
                            usageTypes.push('read');
                        }
                        if (context.includes('update') || context.includes('write') || context.includes('move')) {
                            usageTypes.push('update');
                        }
                        if (context.includes('unused') || context.includes('stale')) {
                            usageTypes.push('unused');
                        }
                        if (context.includes('key') || context.includes('identifier')) {
                            usageTypes.push('key');
                        }
                        if (context.includes('working') || context.includes('calculation')) {
                            usageTypes.push('working');
                        }
                        if (context.includes('control') || context.includes('flag')) {
                            usageTypes.push('control');
                        }
                        
                        if (usageTypes.length === 0) {
                            usageTypes.push('reference');
                        }
                        
                        fields.push({
                            name: fieldName,
                            description: description.substring(0, 100) + (description.length > 100 ? '...' : ''),
                            usageTypes: [...new Set(usageTypes)],
                            programs: this.extractProgramNames(context),
                            dataType: this.extractDataType(context),
                            usageCount: usageTypes.length
                        });
                    }
                });
                
                // Limit and deduplicate
                const uniqueFields = fields.filter((field, index, self) => 
                    index === self.findIndex(f => f.name === field.name)
                ).slice(0, 12);
                
                return uniqueFields;
            }

            extractProgramNames(context) {
                const programs = [];
                const matches = context.match(/([A-Z][A-Z0-9\-_]{3,})\.(cbl|cob)/gi);
                if (matches) {
                    matches.forEach(match => {
                        programs.push(match.replace(/\.(cbl|cob)/i, ''));
                    });
                }
                return programs.length > 0 ? programs : ['Various'];
            }

            extractDataType(context) {
                if (context.includes('pic') || context.includes('picture')) {
                    if (context.includes('9')) return 'Numeric';
                    if (context.includes('x')) return 'Alphanumeric';
                    if (context.includes('s9')) return 'Signed Numeric';
                }
                if (context.includes('comp') || context.includes('binary')) return 'Binary';
                return 'Text';
            }

            extractUsageStats(analysisText) {
                const stats = [];
                
                // Count different types of mentions
                const readCount = (analysisText.match(/read|input|reference/gi) || []).length;
                const writeCount = (analysisText.match(/write|update|move|modify/gi) || []).length;
                const unusedCount = (analysisText.match(/unused|stale|never/gi) || []).length;
                const programCount = (analysisText.match(/program[s]?/gi) || []).length;
                
                if (readCount > 0) stats.push({ label: 'Read Operations', value: readCount });
                if (writeCount > 0) stats.push({ label: 'Write Operations', value: writeCount });
                if (unusedCount > 0) stats.push({ label: 'Unused References', value: unusedCount });
                if (programCount > 0) stats.push({ label: 'Program References', value: programCount });
                
                return stats;
            }

            formatAnalysisText(text) {
                return text
                    .replace(/\n/g, '<br>')
                    .replace(/\*\*([^*]+)\*\*/g, '<strong style="color: #FFD700;">$1</strong>')
                    .replace(/- ([^<\n]+)/g, '‚Ä¢ $1')
                    .replace(/^\s*\d+\.\s*/gm, '<br><strong>$&</strong>');
            }

            calculateRiskLevel(componentInfo) {
                const fileCount = componentInfo.foundIn.length;
                const relatedCount = componentInfo.relatedComponents.length;
                
                if (fileCount > 5 || relatedCount > 10) return 'High';
                if (fileCount > 2 || relatedCount > 5) return 'Medium';
                return 'Low';
            }

            assessModificationImpact(componentInfo) {
                const type = componentInfo.type;
                const fileCount = componentInfo.foundIn.length;
                
                if (type === 'COPYBOOK' && fileCount > 3) return 'High - Multiple programs affected';
                if (type === 'FIELD' && fileCount > 2) return 'Medium - Cross-program impact';
                if (type === 'PROGRAM') return 'Medium - Call chain impact';
                if (type === 'JCL_JOB') return 'Low - Job-specific impact';
                
                return 'Low - Limited impact';
            }
            async bulkAnalyze() {
                if (this.componentSuggestions.length === 0) {
                    this.showError('No components found to analyze. Upload files first.');
                    return;
                }

                this.showLoading();
                this.updateLoadingStatus('Starting bulk analysis...');
                
                try {
                    // Select top components based on frequency and importance
                    const topComponents = this.componentSuggestions
                        .filter(comp => comp.length > 3) // Filter out short names
                        .slice(0, 5); // Analyze top 5 components
                    
                    let analysisCount = 0;
                    
                    for (const component of topComponents) {
                        try {
                            this.updateLoadingStatus(`Analyzing component ${analysisCount + 1}/${topComponents.length}: ${component}`);
                            
                            const componentInfo = await this.identifyComponent(component);
                            
                            if (componentInfo.type !== 'NOT_FOUND') {
                                const analysis = await this.performComponentAnalysis(component, componentInfo);
                                
                                this.componentAnalysis[component] = {
                                    timestamp: new Date().toISOString(),
                                    componentInfo: componentInfo,
                                    analysis: analysis
                                };
                                
                                analysisCount++;
                                
                                // Rate limiting between analyses
                                if (analysisCount < topComponents.length) {
                                    await this.sleep(2000);
                                }
                            }
                        } catch (error) {
                            console.warn(`Failed to analyze component ${component}:`, error);
                            // Continue with next component
                        }
                    }
                    
                    this.saveToStorage();
                    this.hideLoading();
                    
                    if (analysisCount > 0) {
                        this.showSuccess(`Bulk analysis complete! Analyzed ${analysisCount} components.`);
                        // Display the first analyzed component
                        const firstComponent = Object.keys(this.componentAnalysis)[0];
                        if (firstComponent) {
                            document.getElementById('componentName').value = firstComponent;
                            this.displayComponentAnalysis(firstComponent);
                        }
                    } else {
                        this.showWarning('No components could be analyzed. Check your files and try individual analysis.');
                    }
                    
                    this.validateForm();
                    
                } catch (error) {
                    this.hideLoading();
                    this.showError(`Bulk analysis failed: ${error.message}`);
                }
            }

            exportResults() {
                if (Object.keys(this.componentAnalysis).length === 0) {
                    this.showError('No analysis results to export');
                    return;
                }

                const exportData = {
                    metadata: {
                        exportDate: new Date().toISOString(),
                        version: '1.0',
                        totalComponents: Object.keys(this.componentAnalysis).length,
                        totalFiles: this.uploadedFiles.length,
                        fileTypes: [...new Set(this.uploadedFiles.map(f => f.type))]
                    },
                    uploadedFiles: this.uploadedFiles.map(f => ({
                        name: f.name,
                        type: f.type,
                        size: f.size
                    })),
                    componentAnalyses: this.componentAnalysis
                };

                try {
                    const blob = new Blob([JSON.stringify(exportData, null, 2)], {
                        type: 'application/json'
                    });
                    
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `component_analysis_${new Date().toISOString().split('T')[0]}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    this.showSuccess('Analysis results exported successfully');
                } catch (error) {
                    this.showError(`Export failed: ${error.message}`);
                }
            }

            clearAllData() {
                if (confirm('Are you sure you want to clear all uploaded files and analysis results? This cannot be undone.')) {
                    // Clear uploaded files
                    this.uploadedFiles = [];
                    this.componentAnalysis = {};
                    this.componentSuggestions = [];
                    
                    // Clear UI
                    document.getElementById('uploadedFiles').innerHTML = '';
                    document.getElementById('componentName').value = '';
                    document.getElementById('componentSuggestions').style.display = 'none';
                    
                    // Reset analysis content
                    document.getElementById('lifecycleContent').innerHTML = `
                        <h3>üéØ Component Lifecycle Analysis</h3>
                        <p style="margin-bottom: 20px;">Upload files and enter a component name to begin analysis.</p>
                    `;
                    
                    document.getElementById('fieldMatrixContent').innerHTML = `
                        <h3>üìã Field Usage Matrix</h3>
                        <p>Field-level analysis will appear here after component analysis.</p>
                    `;
                    
                    document.getElementById('usageContent').innerHTML = `
                        <h3>üìà Cross-Program Usage Analysis</h3>
                        <p>Usage patterns and statistics will appear here.</p>
                    `;
                    
                    document.getElementById('dependenciesContent').innerHTML = `
                        <h3>üîó Component Dependencies</h3>
                        <p>Dependency analysis will appear here.</p>
                    `;
                    
                    // Clear storage
                    localStorage.removeItem(this.storageKey);
                    
                    this.validateForm();
                    this.showSuccess('All data cleared successfully');
                }
            }

            loadStoredData() {
                try {
                    const stored = localStorage.getItem(this.storageKey);
                    if (stored) {
                        const data = JSON.parse(stored);
                        this.componentAnalysis = data.componentAnalyses || {};
                        console.log(`Loaded ${Object.keys(this.componentAnalysis).length} stored analyses`);
                    }
                } catch (error) {
                    console.error('Error loading stored data:', error);
                    this.componentAnalysis = {};
                }
            }

            saveToStorage() {
                try {
                    const dataToStore = {
                        componentAnalyses: this.componentAnalysis,
                        lastUpdated: new Date().toISOString()
                    };
                    localStorage.setItem(this.storageKey, JSON.stringify(dataToStore));
                    console.log(`Saved ${Object.keys(this.componentAnalysis).length} analyses to storage`);
                } catch (error) {
                    console.error('Error saving to storage:', error);
                }
            }

            switchTab(e) {
                const targetTab = e.target.dataset.tab;
                
                // Remove active class from all tabs and contents
                document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                
                // Add active class to clicked tab and corresponding content
                e.target.classList.add('active');
                document.getElementById(targetTab).classList.add('active');
            }

            // Utility methods
            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            showLoading() {
                document.getElementById('loadingIndicator').classList.add('show');
            }

            hideLoading() {
                document.getElementById('loadingIndicator').classList.remove('show');
            }

            updateLoadingStatus(status) {
                document.getElementById('loadingStatus').textContent = status;
            }

            showError(message) {
                this.showMessage('error', message, 5000);
            }

            showSuccess(message) {
                this.showMessage('success', message, 3000);
            }

            showWarning(message) {
                this.showMessage('warning', message, 4000);
            }

            showMessage(type, message, duration = 3000) {
                // Remove existing messages of the same type
                document.querySelectorAll(`.${type}`).forEach(el => el.remove());
                
                const div = document.createElement('div');
                div.className = type;
                div.innerHTML = `<strong>${type.charAt(0).toUpperCase() + type.slice(1)}:</strong> ${message}`;
                
                const container = document.querySelector('.analysis-workspace');
                container.insertBefore(div, container.firstChild);
                
                // Auto-remove after duration
                setTimeout(() => {
                    if (div.parentNode) {
                        div.remove();
                    }
                }, duration);
            }
        }

        // Initialize the component analyzer when the page loads
        const analyzer = new ComponentSpecificAnalyzer();
        
        // Add some helpful console information
        console.log('üî¨ Component-Specific Mainframe Analyzer initialized');
        console.log('üí° Upload COBOL, copybook, and JCL files to begin analysis');
    </script>
</body>
</html>