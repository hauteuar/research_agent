<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Mainframe Code Analyzer with vLLM</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        /* Header with Live Metrics */
        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 2px solid #e0e0e0;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }

        .header h1 {
            color: #2c3e50;
            font-size: 24px;
            font-weight: 600;
        }

        .metrics-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .metric-card {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            min-width: 100px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        .token-usage {
            background: linear-gradient(135deg, #f093fb, #f5576c);
            padding: 8px 15px;
            border-radius: 8px;
            color: white;
            font-weight: 600;
        }

        .processing-status {
            display: flex;
            align-items: center;
            gap: 10px;
            background: #27ae60;
            color: white;
            padding: 8px 15px;
            border-radius: 8px;
            font-weight: 500;
        }

        .processing-status.analyzing {
            background: #f39c12;
        }

        .processing-status.error {
            background: #e74c3c;
        }

        /* Main Layout Container */
        .container {
            display: flex;
            height: calc(100vh - 80px);
            gap: 10px;
            padding: 10px;
        }

        /* Left Panel */
        .left-panel {
            width: 420px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            padding: 20px;
            overflow-y: auto;
            transition: all 0.3s ease;
            position: relative;
        }

        .left-panel.collapsed {
            width: 50px;
            padding: 10px;
        }

        .panel-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-size: 16px;
        }

        /* Upload Section */
        .upload-section {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
        }

        .upload-area {
            border: 2px dashed rgba(255,255,255,0.5);
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upload-area:hover {
            border-color: white;
            background: rgba(255,255,255,0.1);
        }

        .upload-button {
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            margin-top: 10px;
        }

        /* Component Dashboard */
        .component-dashboard {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .component-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .component-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin: 5px 0;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .component-type {
            background: #667eea;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
        }

        /* Main Content Area */
        .main-content {
            flex: 1;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Tab Navigation */
        .tab-nav {
            display: flex;
            background: linear-gradient(90deg, #667eea, #764ba2);
            border-radius: 15px 15px 0 0;
        }

        .tab-button {
            flex: 1;
            background: none;
            border: none;
            color: rgba(255,255,255,0.7);
            padding: 15px 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .tab-button.active {
            color: white;
            background: rgba(255,255,255,0.1);
        }

        .tab-button:hover {
            color: white;
            background: rgba(255,255,255,0.05);
        }

        /* Tab Content */
        .tab-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Field Mapping Analysis Tab */
        .field-mapping-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .file-input-section {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 20px;
        }

        .file-input {
            flex: 1;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s ease;
        }

        .file-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .analyze-button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.3s ease;
        }

        .analyze-button:hover {
            transform: translateY(-2px);
        }

        /* Advanced Mapping Table */
        .mapping-table-container {
            overflow-x: auto;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .advanced-mapping-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 10px;
            overflow: hidden;
        }

        .advanced-mapping-table th {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px 10px;
            font-weight: 600;
            text-align: left;
            border-bottom: 2px solid #5a6fd8;
        }

        .advanced-mapping-table td {
            padding: 12px 10px;
            border-bottom: 1px solid #e0e0e0;
            vertical-align: top;
        }

        .advanced-mapping-table tr:hover {
            background: rgba(102, 126, 234, 0.05);
        }

        .business-logic-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            margin: 2px;
        }

        .logic-move { background: #e3f2fd; color: #1976d2; }
        .logic-derived { background: #e8f5e8; color: #388e3c; }
        .logic-conditional { background: #fff3e0; color: #f57c00; }
        .logic-calculated { background: #fce4ec; color: #c2185b; }
        .logic-string_manipulation { background: #f3e5f5; color: #7b1fa2; }
        .logic-unused { background: #f5f5f5; color: #757575; }
        .logic-multi_source { background: #ffebee; color: #d32f2f; }

        .programs-list {
            font-size: 12px;
            color: #666;
            max-width: 150px;
            word-break: break-word;
        }

        /* Right Panel - Chat */
        .right-panel {
            width: 500px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease;
            position: relative;
        }

        .right-panel.collapsed {
            width: 50px;
        }

        .chat-header {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px 20px;
            border-radius: 15px 15px 0 0;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-token-display {
            font-size: 12px;
            background: rgba(255,255,255,0.2);
            padding: 4px 8px;
            border-radius: 4px;
        }

        .chat-messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .message {
            padding: 12px 15px;
            border-radius: 12px;
            max-width: 85%;
            word-wrap: break-word;
        }

        .message.user {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            align-self: flex-end;
        }

        .message.assistant {
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            align-self: flex-start;
        }

        .message-tokens {
            font-size: 10px;
            opacity: 0.7;
            margin-top: 5px;
        }

        .context-indicator {
            font-size: 11px;
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
            padding: 4px 8px;
            border-radius: 4px;
            margin-bottom: 5px;
        }

        .chat-input-container {
            padding: 20px;
            border-top: 1px solid #e0e0e0;
        }

        .chat-input {
            width: 100%;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 25px;
            resize: none;
            font-family: inherit;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        .chat-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .input-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 8px;
            font-size: 12px;
            color: #666;
        }

        .char-counter {
            color: #667eea;
        }

        .send-button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
        }

        /* Loading and Progress Indicators */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: #e0e0e0;
            border-radius: 2px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s ease;
        }

        /* Dashboard Charts */
        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .chart-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #2c3e50;
        }

        /* Dependencies Flow */
        .dependencies-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .dependency-node {
            background: white;
            border: 2px solid #667eea;
            border-radius: 10px;
            padding: 15px;
            position: relative;
        }

        .dependency-arrow {
            position: absolute;
            right: -20px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 20px;
            color: #667eea;
        }

        /* Field Matrix */
        .field-matrix {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .field-group {
            background: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .field-group h3 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .field-item {
            padding: 8px;
            margin: 5px 0;
            background: #f8f9fa;
            border-radius: 6px;
            font-size: 14px;
        }

        /* vLLM Configuration Modal */
        .vllm-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            z-index: 1000;
            max-width: 600px;
            width: 90%;
        }

        .vllm-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 999;
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .left-panel { width: 350px; }
            .right-panel { width: 400px; }
        }

        @media (max-width: 768px) {
            .container { flex-direction: column; height: auto; }
            .left-panel, .right-panel { width: 100%; }
            .metrics-container { justify-content: center; }
            .header { text-align: center; }
        }
    </style>
</head>
<body>
    <!-- Header with Live Metrics and Token Usage -->
    <header class="header">
        <h1>üè¢ Enhanced Mainframe Code Analyzer with vLLM</h1>
        <div class="metrics-container">
            <div class="metric-card">
                <div>Components</div>
                <div id="componentCount">0</div>
            </div>
            <div class="metric-card">
                <div>Programs</div>
                <div id="programCount">0</div>
            </div>
            <div class="metric-card">
                <div>Copybooks</div>
                <div id="copybookCount">0</div>
            </div>
            <div class="metric-card">
                <div>Fields</div>
                <div id="fieldCount">0</div>
            </div>
            <div class="metric-card">
                <div>Lines of Code</div>
                <div id="linesOfCode">0</div>
            </div>
            <div class="token-usage">
                <div>Tokens Used</div>
                <div id="tokenUsage">0 / 100K</div>
            </div>
            <div class="processing-status" id="processingStatus">
                <span>Ready</span>
            </div>
        </div>
    </header>

    <!-- Main Container with Three-Panel Layout -->
    <div class="container">
        <!-- Left Panel: Component Dashboard & Upload -->
        <div class="left-panel" id="leftPanel">
            <button class="panel-toggle" onclick="togglePanel('left')" title="Toggle Left Panel">‚Üê</button>
            
            <!-- Upload Section -->
            <div class="upload-section">
                <h3>üìÅ Upload Mainframe Code</h3>
                <div class="upload-area" onclick="document.getElementById('fileInput').click()">
                    <div>üîÑ Drop files here or click to browse</div>
                    <div style="font-size: 12px; opacity: 0.8; margin-top: 5px;">
                        Supports: .cbl, .cob, .jcl, .proc, .copy
                    </div>
                    <input type="file" id="fileInput" multiple accept=".cbl,.cob,.jcl,.proc,.copy" style="display: none;" onchange="handleFileUpload(event)">
                </div>
                <button class="upload-button" onclick="processAllFiles()">üöÄ Start Analysis</button>
            </div>

            <!-- Token Usage Display -->
            <div class="component-dashboard">
                <h3>üéØ Token Usage Breakdown</h3>
                <div class="component-item">
                    <span>Analysis Tokens</span>
                    <span id="analysisTokens">0</span>
                </div>
                <div class="component-item">
                    <span>Chat Tokens</span>
                    <span id="chatTokens">0</span>
                </div>
                <div class="component-item">
                    <span>Total Budget</span>
                    <span id="tokenBudget">100,000</span>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="tokenProgress" style="width: 0%"></div>
                </div>
            </div>

            <!-- Component Dashboard -->
            <div class="component-dashboard">
                <h3>üìä Component Dashboard</h3>
                <div class="component-list" id="componentList">
                    <div class="component-item">
                        <span>üìÑ No components loaded</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Content: Five-Tab Interface -->
        <div class="main-content">
            <nav class="tab-nav">
                <button class="tab-button active" onclick="showTab('dashboard')">üìä Dashboard</button>
                <button class="tab-button" onclick="showTab('components')">üîß Components</button>
                <button class="tab-button" onclick="showTab('dependencies')">üîó Dependencies</button>
                <button class="tab-button" onclick="showTab('matrix')">üéØ Field Matrix</button>
                <button class="tab-button" onclick="showTab('mapping')">‚≠ê Field Mapping</button>
            </nav>

            <!-- Dashboard Tab -->
            <div class="tab-content active" id="dashboard">
                <div class="chart-container">
                    <div class="chart-title">üìà Analysis Overview</div>
                    <div id="dashboardCharts">
                        <p>Upload mainframe files to see comprehensive analysis dashboard with component breakdown, field distribution, and modernization metrics.</p>
                    </div>
                </div>
            </div>

            <!-- Components Library Tab -->
            <div class="tab-content" id="components">
                <div class="chart-container">
                    <div class="chart-title">üîß Components Library</div>
                    <div id="componentsLibrary">
                        <p>Detailed view of all analyzed components will appear here after file processing.</p>
                    </div>
                </div>
            </div>

            <!-- Dependencies Flow Tab -->
            <div class="tab-content" id="dependencies">
                <div class="chart-container">
                    <div class="chart-title">üîó Dependencies Flow</div>
                    <div class="dependencies-container" id="dependenciesFlow">
                        <p>Interactive dependency visualization will be generated after component analysis.</p>
                    </div>
                </div>
            </div>

            <!-- Field Matrix Tab -->
            <div class="tab-content" id="matrix">
                <div class="chart-container">
                    <div class="chart-title">üéØ Field Matrix Analysis</div>
                    <div class="field-matrix" id="fieldMatrix">
                        <p>Field relationships and data flow matrix will be populated after processing.</p>
                    </div>
                </div>
            </div>

            <!-- Enhanced Field Mapping Analysis Tab -->
            <div class="tab-content" id="mapping">
                <div class="field-mapping-section">
                    <div class="chart-title">‚≠ê Advanced Field Mapping Analysis</div>
                    <p style="margin-bottom: 20px; color: #666;">
                        Enter a target file name to analyze all programs that write to it, including business logic patterns, data type conversions, and Oracle mapping recommendations.
                    </p>
                    
                    <div class="file-input-section">
                        <input 
                            type="text" 
                            class="file-input" 
                            id="targetFileName" 
                            placeholder="Enter file name (e.g., CUSTOMER-FILE, TRANSACTION-RECORD)"
                            onkeypress="if(event.key==='Enter') analyzeFieldMapping()"
                        >
                        <button class="analyze-button" onclick="analyzeFieldMapping()">
                            üîç Analyze Field Mapping
                        </button>
                    </div>

                    <div class="progress-bar" id="mappingProgress" style="display: none;">
                        <div class="progress-fill" id="mappingProgressFill" style="width: 0%"></div>
                    </div>

                    <div class="mapping-table-container">
                        <table class="advanced-mapping-table" id="fieldMappingTable">
                            <thead>
                                <tr>
                                    <th>Field Name</th>
                                    <th>Mainframe Data Type</th>
                                    <th>Oracle Data Type</th>
                                    <th>MF Length</th>
                                    <th>Oracle Length</th>
                                    <th>Population Source</th>
                                    <th>Source Record Layout</th>
                                    <th>Business Logic</th>
                                    <th>Programs Involved</th>
                                    <th>Confidence</th>
                                </tr>
                            </thead>
                            <tbody id="fieldMappingTableBody">
                                <tr>
                                    <td colspan="10" style="text-align: center; padding: 40px; color: #666;">
                                        Enter a file name above and click "Analyze Field Mapping" to see detailed field analysis with business logic patterns.
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Panel: Token-Aware Business Intelligence Chat -->
        <div class="right-panel" id="rightPanel">
            <button class="panel-toggle" onclick="togglePanel('right')" title="Toggle Right Panel" style="left: 10px;">‚Üí</button>
            
            <div class="chat-header">
                <span>ü§ñ vLLM Business Intelligence Chat</span>
                <div class="chat-token-display" id="chatTokenDisplay">
                    Tokens: 0
                </div>
            </div>

            <div class="chat-messages" id="chatMessages">
                <div class="message assistant">
                    <div class="context-indicator">üéØ Context: System Ready</div>
                    Welcome! I'm your mainframe modernization assistant powered by local vLLM (Llama 3.1). I can help you analyze field mappings, dependencies, business logic patterns, and provide Oracle migration recommendations. Upload some code and start asking questions!
                    <div class="message-tokens">Tokens: 0</div>
                </div>
            </div>

            <div class="chat-input-container">
                <textarea 
                    class="chat-input" 
                    id="chatInput" 
                    placeholder="Ask about field mappings, dependencies, business logic, Oracle migration strategies..."
                    rows="3"
                    onkeypress="if(event.key==='Enter' && !event.shiftKey) { event.preventDefault(); sendChatMessage(); }"
                    oninput="updateCharCounter()"
                ></textarea>
                <div class="input-info">
                    <span class="char-counter" id="charCounter">0 characters (~0 tokens)</span>
                    <button class="send-button" onclick="sendChatMessage()">Send üì§</button>
                </div>
            </div>
        </div>
    </div>

    <!-- vLLM Configuration Button -->
    <div style="position: fixed; bottom: 20px; right: 20px; z-index: 100;">
        <button onclick="showVLLMConfiguration()" 
                style="background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; 
                       padding: 15px 20px; border-radius: 25px; cursor: pointer; font-weight: 600; 
                       box-shadow: 0 4px 20px rgba(0,0,0,0.2);">
            ü¶ô Configure vLLM
        </button>
    </div>

    <script>
       // Part 2: Core JavaScript Classes for Enhanced Mainframe Code Analyzer with vLLM

// Global Application State
const AppState = {
    sessionId: generateSessionId(),
    components: [],
    fieldMappings: [],
    dependencies: [],
    conversations: [],
    tokenUsage: {
        analysis: 0,
        chat: 0,
        total: 0,
        budget: 100000
    },
    processingStatus: 'ready',
    uploadedFiles: [],
    analysisResults: {}
};

// Generate Session ID
function generateSessionId() {
    return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
}

// Enhanced Token Management System with 6000 Token Limit
class TokenManager {
    static TOKENS_PER_CHAR = 0.25;
    static MAX_TOKENS_PER_CALL = 6000;
    static EFFECTIVE_LIMIT = 5500; // 500 reserved for system prompts
    static CHUNK_OVERLAP = 200;
    static RETRY_ATTEMPTS = 3;
    static RETRY_DELAY = 1000;

    static estimateTokens(text) {
        // Rough estimation: ~4 characters per token for English text
        return Math.ceil(text.length / 4);
    }

    static needsChunking(text) {
        return this.estimateTokens(text) > this.EFFECTIVE_LIMIT;
    }

    static chunkText(text, preserveStructure = true) {
        const tokens = this.estimateTokens(text);
        if (tokens <= this.EFFECTIVE_LIMIT) {
            return [text];
        }

        const chunks = [];
        const charsPerChunk = Math.floor(this.EFFECTIVE_LIMIT / this.TOKENS_PER_CHAR);
        const overlapChars = Math.floor(this.CHUNK_OVERLAP / this.TOKENS_PER_CHAR);

        if (preserveStructure) {
            // Try to split at natural COBOL boundaries
            const lines = text.split('\n');
            let currentChunk = '';
            let currentSize = 0;

            for (let line of lines) {
                const lineSize = this.estimateTokens(line);
                
                if (currentSize + lineSize > this.EFFECTIVE_LIMIT && currentChunk) {
                    chunks.push(currentChunk);
                    // Start new chunk with overlap
                    const overlapLines = currentChunk.split('\n').slice(-5).join('\n');
                    currentChunk = overlapLines + '\n' + line;
                    currentSize = this.estimateTokens(currentChunk);
                } else {
                    currentChunk += (currentChunk ? '\n' : '') + line;
                    currentSize += lineSize;
                }
            }
            
            if (currentChunk) chunks.push(currentChunk);
        } else {
            // Simple character-based chunking
            for (let i = 0; i < text.length; i += charsPerChunk - overlapChars) {
                const end = Math.min(i + charsPerChunk, text.length);
                chunks.push(text.substring(i, end));
            }
        }

        return chunks;
    }

    static updateTokenUsage(analysisTokens = 0, chatTokens = 0) {
        AppState.tokenUsage.analysis += analysisTokens;
        AppState.tokenUsage.chat += chatTokens;
        AppState.tokenUsage.total = AppState.tokenUsage.analysis + AppState.tokenUsage.chat;
        
        this.updateUI();
    }

    static updateUI() {
        const usage = AppState.tokenUsage;
        const tokenUsageElement = document.getElementById('tokenUsage');
        if (tokenUsageElement) {
            tokenUsageElement.textContent = 
                `${usage.total.toLocaleString()} / ${usage.budget.toLocaleString()}`;
        }
        
        const analysisTokensElement = document.getElementById('analysisTokens');
        if (analysisTokensElement) {
            analysisTokensElement.textContent = usage.analysis.toLocaleString();
        }
        
        const chatTokensElement = document.getElementById('chatTokens');
        if (chatTokensElement) {
            chatTokensElement.textContent = usage.chat.toLocaleString();
        }
        
        const tokenBudgetElement = document.getElementById('tokenBudget');
        if (tokenBudgetElement) {
            tokenBudgetElement.textContent = usage.budget.toLocaleString();
        }
        
        const progressElement = document.getElementById('tokenProgress');
        if (progressElement) {
            const progressPercent = (usage.total / usage.budget) * 100;
            progressElement.style.width = `${Math.min(progressPercent, 100)}%`;
        }
        
        // Update chat display
        const chatTokenDisplayElement = document.getElementById('chatTokenDisplay');
        if (chatTokenDisplayElement) {
            chatTokenDisplayElement.textContent = `Tokens: ${usage.chat.toLocaleString()}`;
        }
    }
}

// vLLM API Manager for Local Llama 3.1 Integration
class VLLMAPIManager {
    static API_ENDPOINT = 'http://localhost:8100/generate';  // Changed endpoint
    static MODEL = 'codellama/CodeLlama-7b-Python-hf';       // Your model name
    static MAX_RETRIES = 3;
    static RETRY_DELAY = 1000;
    static MAX_TOKENS = 2048;
    static TEMPERATURE = 0.1;
    static serverConfigured = false;

    static estimateTokens(text) {
        // Rough estimation: ~4 characters per token for English text
        return Math.ceil(text.length / 4);
    }

    static configureServer(endpoint, model = null) {
        this.API_ENDPOINT = endpoint.endsWith('/generate') ? endpoint : `${endpoint}/generate`;
        if (model) this.MODEL = model;
        this.serverConfigured = true;
        console.log(`‚úÖ vLLM Server configured: ${this.API_ENDPOINT}`);
        console.log(`üìù Model: ${this.MODEL}`);
    }

    static async makeAPICall(prompt, systemPrompt = '', maxTokens = 2048) {
        if (!this.serverConfigured) {
            throw new Error('vLLM server not configured. Use VLLMAPIManager.configureServer() first.');
        }

        // Your server expects this format (compatible with /generate endpoint)
        const requestBody = {
            prompt: systemPrompt ? `${systemPrompt}\n\n${prompt}` : prompt,
            max_tokens: Math.min(maxTokens, this.MAX_TOKENS),
            temperature: this.TEMPERATURE,
            top_p: 0.95,
            stop: null,
            stream: false
        };

        for (let attempt = 1; attempt <= this.MAX_RETRIES; attempt++) {
            try {
                updateProcessingStatus('analyzing', `vLLM API Call - Attempt ${attempt}/${this.MAX_RETRIES}`);
                
                const response = await fetch(this.API_ENDPOINT, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`vLLM API Error ${response.status}: ${errorText}`);
                }

                const data = await response.json();
                
                // Your server returns: { text: "...", choices: [{"text": "..."}], id: "...", model: "..." }
                const content = data.text || data.choices?.[0]?.text || '';
                
                // Estimate tokens since your server doesn't return usage stats
                const inputTokens = this.estimateTokens(requestBody.prompt);
                const outputTokens = this.estimateTokens(content);

                console.log('‚úÖ vLLM API Call successful:', {
                    model: this.MODEL,
                    inputTokens: inputTokens,
                    outputTokens: outputTokens,
                    responseLength: content.length
                });

                return {
                    content: content.trim(),
                    inputTokens: inputTokens,
                    outputTokens: outputTokens,
                    totalTokens: inputTokens + outputTokens
                };

            } catch (error) {
                console.warn(`vLLM API Call attempt ${attempt} failed:`, error.message);
                
                if (attempt === this.MAX_RETRIES) {
                    throw new Error(`vLLM API failed after ${this.MAX_RETRIES} attempts: ${error.message}`);
                }
                
                await new Promise(resolve => setTimeout(resolve, this.RETRY_DELAY * attempt));
            }
        }
    }

    static formatLlamaPrompt(systemPrompt, userPrompt) {
        return `<|begin_of_text|><|start_header_id|>system<|end_header_id|>

${systemPrompt || 'You are a helpful assistant specialized in COBOL mainframe analysis and modernization.'}<|eot_id|><|start_header_id|>user<|end_header_id|>

${userPrompt}<|eot_id|><|start_header_id|>assistant<|end_header_id|>

`;
    }

    static async testConnection() {
        try {
            const testResponse = await this.makeAPICall(
                'Hello! Please respond with "vLLM connection successful" to confirm the API is working.',
                'You are a helpful assistant. Respond concisely.',
                50
            );
            
            console.log('‚úÖ vLLM Connection Test Result:', testResponse);
            return { success: true, response: testResponse };
            
        } catch (error) {
            console.error('‚ùå vLLM Connection Test Failed:', error.message);
            return { success: false, error: error.message };
        }
    }

}

// SQL Database Simulation (In production, this would connect to actual SQL database)
class DatabaseManager {
    constructor() {
        this.tables = {
            analysis_sessions: [],
            llm_analysis_calls: [],
            component_analysis: [],
            field_mappings: [],
            dependency_relationships: [],
            chat_conversations: [],
            field_analysis_details: []
        };
    }

    async createSession() {
        const session = {
            id: this.tables.analysis_sessions.length + 1,
            session_id: AppState.sessionId,
            project_name: 'Mainframe Analysis',
            created_at: new Date().toISOString(),
            status: 'active',
            total_components: 0,
            total_fields: 0
        };
        this.tables.analysis_sessions.push(session);
        return session;
    }

    async logLLMCall(analysisType, chunkNumber, totalChunks, promptTokens, responseTokens, success, errorMessage = null) {
        const call = {
            id: this.tables.llm_analysis_calls.length + 1,
            session_id: AppState.sessionId,
            analysis_type: analysisType,
            chunk_number: chunkNumber,
            total_chunks: totalChunks,
            prompt_tokens: promptTokens,
            response_tokens: responseTokens,
            processing_time_ms: Date.now(),
            success: success,
            error_message: errorMessage,
            created_at: new Date().toISOString()
        };
        this.tables.llm_analysis_calls.push(call);
        return call;
    }

    async saveComponentAnalysis(componentName, componentType, filePath, analysisResult) {
        const component = {
            id: this.tables.component_analysis.length + 1,
            session_id: AppState.sessionId,
            component_name: componentName,
            component_type: componentType,
            file_path: filePath,
            analysis_status: 'completed',
            total_lines: analysisResult.totalLines || 0,
            total_fields: analysisResult.fields?.length || 0,
            dependencies_count: analysisResult.dependencies?.length || 0,
            analysis_result_json: JSON.stringify(analysisResult),
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString()
        };
        this.tables.component_analysis.push(component);
        return component;
    }

    async saveFieldMapping(targetFileName, fieldData) {
        const mapping = {
            id: this.tables.field_mappings.length + 1,
            session_id: AppState.sessionId,
            target_file_name: targetFileName,
            field_name: fieldData.fieldName,
            mainframe_data_type: fieldData.mainframeDataType,
            oracle_data_type: fieldData.oracleDataType,
            mainframe_length: fieldData.mainframeLength,
            oracle_length: fieldData.oracleLength,
            population_source: fieldData.populationSource,
            source_record_layout: fieldData.sourceRecordLayout,
            business_logic_type: fieldData.businessLogicType,
            business_logic_description: fieldData.businessLogicDescription,
            derivation_logic: fieldData.derivationLogic,
            programs_involved_json: JSON.stringify(fieldData.programsInvolved),
            confidence_score: fieldData.confidenceScore,
            analysis_timestamp: new Date().toISOString()
        };
        this.tables.field_mappings.push(mapping);
        return mapping;
    }

    async saveChatMessage(conversationId, messageType, messageContent, contextUsed, tokensUsed) {
        const message = {
            id: this.tables.chat_conversations.length + 1,
            session_id: AppState.sessionId,
            conversation_id: conversationId,
            message_type: messageType,
            message_content: messageContent,
            context_used_json: JSON.stringify(contextUsed),
            tokens_used: tokensUsed,
            processing_time_ms: Date.now(),
            created_at: new Date().toISOString()
        };
        this.tables.chat_conversations.push(message);
        return message;
    }

    // Query methods for retrieving analysis data
    async getComponentsByType(componentType) {
        return this.tables.component_analysis.filter(c => 
            c.session_id === AppState.sessionId && c.component_type === componentType
        );
    }

    async getFieldMappingsByFile(fileName) {
        return this.tables.field_mappings.filter(f => 
            f.session_id === AppState.sessionId && f.target_file_name === fileName
        );
    }

    async getConversationHistory(limit = 10) {
        return this.tables.chat_conversations
            .filter(c => c.session_id === AppState.sessionId)
            .slice(-limit);
    }
}

// Initialize Database Manager
const db = new DatabaseManager();
// Part 3: Enhanced Field Mapping Analysis Engine with Complete vLLM Integration
// Enhanced COBOL parsing that respects column structure
class COBOLParser {
    static isCommentLine(line) {
        // Check if column 7 (index 6) has * or / or C or D
        if (line.length >= 7) {
            const col7 = line.charAt(6);
            return col7 === '*' || col7 === '/' || col7.toUpperCase() === 'C' || col7.toUpperCase() === 'D';
        }
        return false;
    }
    
    static isContinuationLine(line) {
        // Check if column 7 (index 6) has - for continuation
        if (line.length >= 7) {
            const col7 = line.charAt(6);
            return col7 === '-';
        }
        return false;
    }
    
    static getCodeContent(line) {
        // Extract content starting from column 8 (index 7)
        if (line.length >= 8) {
            return line.substring(7).trimRight(); // Keep leading spaces from col 8+
        }
        return '';
    }
    
    static getSequenceArea(line) {
        // Columns 1-6 (indices 0-5)
        return line.length >= 6 ? line.substring(0, 6) : '';
    }
    
    static getIdentificationArea(line) {
        // Column 73-80 (indices 72-79) 
        return line.length >= 73 ? line.substring(72, 80) : '';
    }
    
    static cleanCOBOLLines(content) {
        const lines = content.split('\n');
        const cleanLines = [];
        let continuedLine = '';
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            
            // Skip comment lines
            if (this.isCommentLine(line)) {
                continue;
            }
            
            // Handle continuation lines
            if (this.isContinuationLine(line)) {
                continuedLine += this.getCodeContent(line);
                continue;
            }
            
            // If we have a continued line, add it
            if (continuedLine) {
                cleanLines.push(continuedLine.trim());
                continuedLine = '';
            }
            
            // Get the actual COBOL code content (col 8+)
            const codeContent = this.getCodeContent(line);
            if (codeContent.trim()) {
                cleanLines.push(codeContent);
            }
        }
        
        // Don't forget last continued line
        if (continuedLine) {
            cleanLines.push(continuedLine.trim());
        }
        
        return cleanLines;
    }
}
// Enhanced Chat System with SQL Integration
class EnhancedChatSystem extends ChatSystem {
    static async sendMessage(userMessage) {
        const messageTokens = TokenManager.estimateTokens(userMessage);
        
        try {
            // Build comprehensive context including SQL data
            const context = await this.buildComprehensiveContext(userMessage);
            const contextTokens = TokenManager.estimateTokens(JSON.stringify(context));
            
            // Check token limits and adjust context if needed
            let finalContext = context;
            const totalInputTokens = messageTokens + contextTokens;
            
            if (totalInputTokens > TokenManager.EFFECTIVE_LIMIT * 0.6) {
                finalContext = await this.truncateContext(context, userMessage);
            }

            // Generate intelligent response with SQL data
            const response = await this.generateIntelligentResponseWithSQL(userMessage, finalContext);
            const responseTokens = TokenManager.estimateTokens(response);

            // Log conversation with full context
            await db.saveChatMessage(this.conversationId, 'user', userMessage, finalContext, messageTokens);
            await db.saveChatMessage(this.conversationId, 'assistant', response, finalContext, responseTokens);

            // Update token usage
            TokenManager.updateTokenUsage(0, messageTokens + responseTokens);

            return {
                response: response,
                context: finalContext,
                tokensUsed: messageTokens + responseTokens,
                contextTypes: Object.keys(finalContext).filter(key => finalContext[key]?.length > 0)
            };
            
        } catch (error) {
            console.error('Enhanced chat system error:', error);
            const errorResponse = `I apologize, but I encountered an error processing your request: ${error.message}. Please try rephrasing your question or contact support if the issue persists.`;
            
            await db.saveChatMessage(this.conversationId, 'user', userMessage, {}, messageTokens);
            await db.saveChatMessage(this.conversationId, 'assistant', errorResponse, {}, TokenManager.estimateTokens(errorResponse));
            
            return {
                response: errorResponse,
                context: {},
                tokensUsed: messageTokens + TokenManager.estimateTokens(errorResponse),
                contextTypes: []
            };
        }
    }
    
    static async buildComprehensiveContext(message) {
        const context = await super.buildRelevantContext(message);
        const lowerMessage = message.toLowerCase();
        
        // Add SQL table data based on query intent
        if (this.isAskingAboutProgram(lowerMessage)) {
            const programName = this.extractProgramName(message);
            if (programName) {
                context.programCode = await this.getStoredProgramCode(programName);
                context.programAnalysis = await this.getStoredProgramAnalysis(programName);
                context.programBusinessLogic = await this.getStoredBusinessLogic(programName);
            }
        }
        
        if (this.isAskingAboutField(lowerMessage)) {
            const fieldName = this.extractFieldName(message);
            if (fieldName) {
                context.fieldMappingDetails = await this.getStoredFieldMappings(fieldName);
                context.fieldUsageAnalysis = await this.getFieldUsageFromCode(fieldName);
            }
        }
        
        if (this.isAskingAboutLayout(lowerMessage)) {
            const layoutName = this.extractLayoutName(message);
            if (layoutName) {
                context.layoutStructure = await this.getStoredLayoutStructure(layoutName);
                context.layoutFields = await this.getLayoutFields(layoutName);
            }
        }
        
        return context;
    }
    
    static isAskingAboutProgram(message) {
        return message.includes('program') || message.includes('cobol') || 
               message.match(/\w+\.(cbl|cob)/i) || message.includes('component');
    }
    
    static isAskingAboutField(message) {
        return message.includes('field') || message.includes('data') || 
               message.includes('variable') || message.match(/pic\s+/i);
    }
    
    static isAskingAboutLayout(message) {
        return message.includes('layout') || message.includes('record') || 
               message.includes('structure') || message.includes('01 ');
    }
    
    static extractProgramName(message) {
        // Try to extract program name from various patterns
        const patterns = [
            /program\s+([A-Z0-9\-_]+)/i,
            /([A-Z0-9\-_]+)\.(cbl|cob)/i,
            /component\s+([A-Z0-9\-_]+)/i,
            /([A-Z0-9\-_]{3,})/i // Generic pattern for program names
        ];
        
        for (const pattern of patterns) {
            const match = message.match(pattern);
            if (match) {
                const programName = match[1];
                // Check if this program exists in our components
                const component = AppState.components.find(c => 
                    c.name.toLowerCase().includes(programName.toLowerCase()) ||
                    (c.displayName && c.displayName.toLowerCase().includes(programName.toLowerCase()))
                );
                if (component) {
                    return component.name;
                }
            }
        }
        return null;
    }
    
    static extractFieldName(message) {
        const patterns = [
            /field\s+([A-Z0-9\-_]+)/i,
            /([A-Z0-9\-_]+)\s+field/i,
            /pic\s+[x9]+\s+([A-Z0-9\-_]+)/i,
           /([A-Z0-9\-_]{3,})/i // Generic field name pattern
       ];
       
       for (const pattern of patterns) {
           const match = message.match(pattern);
           if (match) {
               const fieldName = match[1];
               // Check if this field exists in our field mappings or components
               const fieldExists = AppState.fieldMappings.find(f => 
                   f.fieldName.toLowerCase().includes(fieldName.toLowerCase())
               ) || AppState.components.some(c => 
                   c.fields?.some(f => f.name.toLowerCase().includes(fieldName.toLowerCase()))
               );
               if (fieldExists) {
                   return fieldName;
               }
           }
       }
       return null;
   }
   
   static extractLayoutName(message) {
       const patterns = [
           /layout\s+([A-Z0-9\-_]+)/i,
           /record\s+([A-Z0-9\-_]+)/i,
           /01\s+([A-Z0-9\-_]+)/i,
           /structure\s+([A-Z0-9\-_]+)/i
       ];
       
       for (const pattern of patterns) {
           const match = message.match(pattern);
           if (match) {
               const layoutName = match[1];
               // Check if this layout exists in our components
               const layout = AppState.components.find(c => 
                   c.type === 'RECORD_LAYOUT' && 
                   c.name.toLowerCase().includes(layoutName.toLowerCase())
               );
               if (layout) {
                   return layout.name;
               }
           }
       }
       return null;
   }
   
   static async getStoredProgramCode(programName) {
       const component = AppState.components.find(c => c.name === programName);
       if (component) {
           return {
               name: component.name,
               displayName: component.displayName || component.friendlyName,
               type: component.type,
               content: component.content || '',
               totalLines: component.totalLines || 0,
               fieldsCount: component.fields?.length || 0
           };
       }
       return null;
   }
   
   static async getStoredProgramAnalysis(programName) {
       const dbComponent = db.tables.component_analysis.find(c => c.component_name === programName);
       if (dbComponent && dbComponent.analysis_result_json) {
           try {
               const analysis = JSON.parse(dbComponent.analysis_result_json);
               return {
                   analysisStatus: dbComponent.analysis_status,
                   totalLines: dbComponent.total_lines,
                   totalFields: dbComponent.total_fields,
                   dependenciesCount: dbComponent.dependencies_count,
                   createdAt: dbComponent.created_at,
                   summary: analysis.summary || 'No summary available'
               };
           } catch (e) {
               console.warn('Failed to parse stored analysis:', e);
           }
       }
       return null;
   }
   
   static async getStoredBusinessLogic(programName) {
       const component = AppState.components.find(c => c.name === programName);
       if (component && component.businessLogic) {
           return component.businessLogic.map(logic => ({
               type: logic.type,
               pattern: logic.pattern,
               source: logic.source,
               target: logic.target,
               confidence: logic.confidence,
               lineNumber: logic.lineNumber
           }));
       }
       return [];
   }
   
   static async getStoredFieldMappings(fieldName) {
       return db.tables.field_mappings.filter(f => 
           f.session_id === AppState.sessionId && 
           f.field_name.toLowerCase().includes(fieldName.toLowerCase())
       ).map(mapping => ({
           fieldName: mapping.field_name,
           targetFile: mapping.target_file_name,
           mainframeDataType: mapping.mainframe_data_type,
           oracleDataType: mapping.oracle_data_type,
           populationSource: mapping.population_source,
           businessLogicType: mapping.business_logic_type,
           businessLogicDescription: mapping.business_logic_description,
           confidenceScore: mapping.confidence_score,
           programsInvolved: JSON.parse(mapping.programs_involved_json || '[]')
       }));
   }
   
   static async getFieldUsageFromCode(fieldName) {
       const usageInfo = {
           occurrences: 0,
           programs: [],
           operations: []
       };
       
       AppState.components.forEach(component => {
           if (component.content) {
               const regex = new RegExp(`\\b${fieldName}\\b`, 'gi');
               const matches = component.content.match(regex);
               if (matches) {
                   usageInfo.occurrences += matches.length;
                   usageInfo.programs.push(component.displayName || component.name);
                   
                   // Extract operations involving this field
                   const lines = component.content.split('\n');
                   lines.forEach((line, index) => {
                       if (regex.test(line)) {
                           const trimmed = line.trim();
                           if (trimmed.includes('MOVE')) {
                               usageInfo.operations.push({ type: 'MOVE', line: index + 1, program: component.name });
                           } else if (trimmed.includes('COMPUTE')) {
                               usageInfo.operations.push({ type: 'COMPUTE', line: index + 1, program: component.name });
                           } else if (trimmed.includes('IF')) {
                               usageInfo.operations.push({ type: 'CONDITION', line: index + 1, program: component.name });
                           }
                       }
                   });
               }
           }
       });
       
       return usageInfo;
   }
   
   static async getStoredLayoutStructure(layoutName) {
       const layout = AppState.components.find(c => 
           c.type === 'RECORD_LAYOUT' && c.name === layoutName
       );
       
       if (layout) {
           return {
               name: layout.name,
               displayName: layout.displayName || layout.friendlyName,
               parentComponent: layout.parentComponent,
               totalFields: layout.fields?.length || 0,
               content: layout.content || '',
               recordLayout: layout.recordLayout || {}
           };
       }
       return null;
   }
   
   static async getLayoutFields(layoutName) {
       const layout = AppState.components.find(c => 
           c.type === 'RECORD_LAYOUT' && c.name === layoutName
       );
       
       if (layout && layout.fields) {
           return layout.fields.map(field => ({
               name: field.name,
               dataType: field.dataType,
               level: field.level,
               isGroup: field.isGroup,
               parentRecord: field.parentRecord,
               lineNumber: field.lineNumber
           }));
       }
       return [];
   }
   
   static async generateIntelligentResponseWithSQL(message, context) {
       const systemPrompt = `You are an expert mainframe modernization consultant with access to comprehensive code analysis data stored in SQL tables. You can analyze COBOL programs, field mappings, business logic, and provide Oracle migration recommendations.

Available context data:
- Program code and analysis from SQL component_analysis table
- Field mappings from field_mappings table  
- Business logic patterns from stored analysis
- Dependency relationships from dependency_relationships table
- Chat conversation history from chat_conversations table

When discussing specific programs, fields, or layouts, reference the actual stored code and analysis data. Provide specific, actionable insights based on the available data.`;

       try {
           // Make REAL vLLM API call with enhanced context
           const llmResponse = await VLLMAPIManager.makeAPICall(message, systemPrompt, 1500);
           
           // Enhance response with specific data references
           const enhancedResponse = this.enhanceResponseWithDataReferences(llmResponse.content, context);
           
           return enhancedResponse;

       } catch (error) {
           console.error('Enhanced chat vLLM API call failed, using fallback:', error);
           
           // Enhanced fallback responses with SQL data
           const lowerMessage = message.toLowerCase();
           
           if (this.isAskingAboutProgram(lowerMessage)) {
               return this.generateProgramResponseWithSQL(message, context);
           } else if (this.isAskingAboutField(lowerMessage)) {
               return this.generateFieldResponseWithSQL(message, context);
           } else if (this.isAskingAboutLayout(lowerMessage)) {
               return this.generateLayoutResponseWithSQL(message, context);
           } else {
               return `I can help you analyze your mainframe components! Here's what I have access to:

**üìä Available Data from SQL Tables:**
- **${AppState.components.length} Components** analyzed and stored
- **${AppState.fieldMappings.length} Field Mappings** with Oracle conversions
- **${AppState.dependencies.length} Dependencies** between components
- **${db.tables.chat_conversations.length} Chat Messages** in conversation history

**üí¨ Try asking me about:**
- *"Tell me about program CUSTOMER-UPDATE"* - I'll show you the stored code and analysis
- *"What does field ACCOUNT-BALANCE do?"* - I'll search through all stored field mappings
- *"Show me the CUSTOMER-RECORD layout"* - I'll display the record structure from the database
- *"What business logic is in component X?"* - I'll pull the stored business rules

**üîç I can also help with:**
- Oracle migration strategies based on stored field mappings
- Dependency impact analysis using relationship data
- Code modernization recommendations from stored analysis
- Business logic explanations from stored patterns

What would you like to explore?`;
           }
       }
   }
   
   static enhanceResponseWithDataReferences(response, context) {
       let enhanced = response;
       
       // Add data source references if context contains SQL data
       if (context.programCode) {
           enhanced += `\n\n**üìÑ Program Data Source:** ${context.programCode.name} (${context.programCode.totalLines} lines, ${context.programCode.fieldsCount} fields)`;
       }
       
       if (context.fieldMappingDetails && context.fieldMappingDetails.length > 0) {
           enhanced += `\n\n**üéØ Field Mapping Data:** ${context.fieldMappingDetails.length} mappings found in database`;
       }
       
       if (context.programBusinessLogic && context.programBusinessLogic.length > 0) {
           enhanced += `\n\n**üß† Business Logic Rules:** ${context.programBusinessLogic.length} patterns stored in analysis`;
       }
       
       return enhanced;
   }
   
   static generateProgramResponseWithSQL(message, context) {
       const programName = this.extractProgramName(message);
       const programData = context.programCode;
       const analysisData = context.programAnalysis;
       const businessLogic = context.programBusinessLogic || [];
       
       if (!programData) {
           return `I couldn't find a program matching "${programName}" in the analyzed components. 

**Available Programs:**
${AppState.components.filter(c => c.type === 'CBL' || c.type === 'COB').slice(0, 5).map(c => 
   `‚Ä¢ **${c.displayName || c.name}** (${c.type}) - ${c.totalLines || 0} lines`
).join('\n')}

Try asking about one of these specific programs!`;
       }
       
       return `**üìä Program Analysis: ${programData.displayName || programData.name}**

**üîç Stored Analysis Data:**
- **Program Type:** ${programData.type}
- **Lines of Code:** ${programData.totalLines.toLocaleString()}
- **Fields Defined:** ${programData.fieldsCount}
- **Analysis Status:** ${analysisData?.analysisStatus || 'Completed'}

**üß† Business Logic Patterns:** ${businessLogic.length} rules identified
${businessLogic.slice(0, 3).map(logic => 
   `‚Ä¢ **${logic.type}**: ${logic.pattern.substring(0, 60)}...`
).join('\n')}

**üíæ Storage Details:**
- Code content stored in component_analysis table
- Business logic patterns indexed for search
- ${analysisData ? `Analysis created: ${new Date(analysisData.createdAt).toLocaleDateString()}` : ''}

**üéØ Oracle Migration Readiness:**
- Field mappings: Available for analysis
- Business logic: ${businessLogic.filter(l => l.confidence > 0.8).length} high-confidence patterns
- Dependencies: Tracked in relationship table

Would you like me to dive deeper into any specific aspect of this program?`;
   }
   
   static generateFieldResponseWithSQL(message, context) {
       const fieldName = this.extractFieldName(message);
       const fieldMappings = context.fieldMappingDetails || [];
       const usageData = context.fieldUsageAnalysis || {};
       
       if (fieldMappings.length === 0) {
           return `I couldn't find specific mappings for field "${fieldName}" in the database.

**üìã Available Field Data:**
- **Total Mapped Fields:** ${AppState.fieldMappings.length}
- **Field Categories:** Input, Derived, Static, Conditional
- **Programs with Fields:** ${AppState.components.filter(c => c.fields?.length > 0).length}

**üîç Try searching for:**
${AppState.fieldMappings.slice(0, 5).map(f => `‚Ä¢ ${f.fieldName}`).join('\n')}`;
       }
       
       const primaryMapping = fieldMappings[0];
       
       return `**üéØ Field Analysis: ${primaryMapping.fieldName}**

**üìä Database Records Found:** ${fieldMappings.length} mapping(s)

**üîç Field Details:**
- **Mainframe Type:** \`${primaryMapping.mainframeDataType}\`
- **Oracle Type:** \`${primaryMapping.oracleDataType}\`
- **Population Source:** ${primaryMapping.populationSource}
- **Business Logic:** ${primaryMapping.businessLogicType}
- **Target File:** ${primaryMapping.targetFile}

**üíº Business Purpose:**
${primaryMapping.businessLogicDescription}

**üìà Usage Analysis:**
- **Programs Using Field:** ${primaryMapping.programsInvolved.join(', ')}
- **Confidence Score:** ${(primaryMapping.confidenceScore * 100).toFixed(0)}%
- **Code Occurrences:** ${usageData.occurrences || 0} times across ${usageData.programs?.length || 0} programs

**üîÑ Operations Found:**
${usageData.operations?.slice(0, 3).map(op => 
   `‚Ä¢ **${op.type}** in ${op.program} (line ${op.line})`
).join('\n') || 'No operations tracked'}

**üèóÔ∏è Oracle Migration:**
- Data type conversion: Automated
- Business logic: ${primaryMapping.businessLogicType === 'CONDITIONAL' ? 'Requires review' : 'Standard migration'}
- Testing priority: ${primaryMapping.confidenceScore > 0.8 ? 'Medium' : 'High'}

Need more details about this field or its usage patterns?`;
   }
   
   static generateLayoutResponseWithSQL(message, context) {
       const layoutName = this.extractLayoutName(message);
       const layoutData = context.layoutStructure;
       const fieldsData = context.layoutFields || [];
       
       if (!layoutData) {
           return `I couldn't find a record layout matching "${layoutName}" in the analyzed components.

**üìã Available Record Layouts:**
${AppState.components.filter(c => c.type === 'RECORD_LAYOUT').slice(0, 5).map(c => 
   `‚Ä¢ **${c.displayName || c.name}** - ${c.fields?.length || 0} fields`
).join('\n')}

Try asking about one of these specific layouts!`;
       }
       
       return `**üìã Record Layout Analysis: ${layoutData.displayName || layoutData.name}**

**üèóÔ∏è Structure Overview:**
- **Total Fields:** ${layoutData.totalFields}
- **Parent Component:** ${layoutData.parentComponent || 'Standalone'}
- **Definition Status:** Complete in database

**üéØ Field Breakdown:**
${fieldsData.slice(0, 8).map(field => {
   const groupIcon = field.isGroup ? 'üìÅ' : 'üìÑ';
   return `${groupIcon} **${field.name}** (Level ${field.level}) - ${field.dataType}`;
}).join('\n')}
${fieldsData.length > 8 ? `\n... and ${fieldsData.length - 8} more fields` : ''}

**üìä Field Categories:**
- **Group Items:** ${fieldsData.filter(f => f.isGroup).length} structure organizers
- **Data Items:** ${fieldsData.filter(f => !f.isGroup).length} actual data fields
- **Levels Used:** ${[...new Set(fieldsData.map(f => f.level))].sort().join(', ')}

**üíæ Storage Details:**
- Layout definition stored in component tables
- Field relationships indexed for queries
- Parent-child structure maintained

**üîÑ Oracle Mapping Strategy:**
- Group items ‚Üí Table structure planning
- Data items ‚Üí Column definitions
- Hierarchical levels ‚Üí Nested table considerations

**üéØ Modernization Notes:**
- This layout can be converted to Oracle table structure
- Field relationships preserved in relational design
- Business logic patterns available for each field

Would you like to see the complete field definitions or explore specific field mappings?`;
   }
}

// Replace the existing ChatSystem.sendMessage calls
ChatSystem.sendMessage = EnhancedChatSystem.sendMessage.bind(EnhancedChatSystem);
ChatSystem.buildRelevantContext = EnhancedChatSystem.buildComprehensiveContext.bind(EnhancedChatSystem);

// Global synchronization system for friendly names
class ComponentSyncManager {
    static syncAllTabs() {
        // Update all tabs with latest friendly names and data
        updateDashboard();
        updateComponentsLibrary();
        updateDependenciesFlow();
        updateFieldMatrix();
        this.updateFieldMappingTable();
    }
    
    static updateFieldMappingTable() {
        const tbody = document.getElementById('fieldMappingTableBody');
        if (!tbody || AppState.fieldMappings.length === 0) return;
        
        // Refresh the field mapping table with friendly names
        updateFieldMappingTable(AppState.fieldMappings);
    }
    
    static async refreshComponentNames() {
        if (VLLMAPIManager.serverConfigured) {
            try {
                updateProcessingStatus('analyzing', 'Refreshing component names...');
                const friendlyNames = await FieldMappingAnalyzer.generateFriendlyBusinessNames(AppState.components);
                console.log('‚úÖ Component names refreshed:', friendlyNames);
                this.syncAllTabs();
                updateProcessingStatus('ready', 'All tabs synchronized with latest names');
            } catch (error) {
                console.warn('Name refresh failed:', error);
                updateProcessingStatus('ready', 'Name refresh completed with fallbacks');
            }
        }
    }
}

// Auto-sync when components change
const originalPush = AppState.components.push;
AppState.components.push = function(...items) {
    const result = originalPush.apply(this, items);
    ComponentSyncManager.syncAllTabs();
    return result;
};

// Auto-refresh names every 5 minutes if vLLM is configured
if (VLLMAPIManager.serverConfigured) {
    setInterval(() => {
        ComponentSyncManager.refreshComponentNames();
    }, 300000); // 5 minutes
}

// Add button to manually refresh names
function addNameRefreshButton() {
    const button = `
        <button onclick="ComponentSyncManager.refreshComponentNames()" 
                style="position: fixed; bottom: 80px; right: 20px; z-index: 100;
                       background: linear-gradient(135deg, #27ae60, #2ecc71); color: white; border: none; 
                       padding: 12px 16px; border-radius: 25px; cursor: pointer; font-weight: 600; 
                       box-shadow: 0 4px 20px rgba(0,0,0,0.2);"
                title="Refresh all component names with AI">
            üîÑ Refresh Names
        </button>
    `;
    document.body.insertAdjacentHTML('beforeend', button);
}

// Initialize the refresh button
setTimeout(addNameRefreshButton, 2000);
// Enhanced Field Mapping Analysis Engine with Complete vLLM Integration
class FieldMappingAnalyzer {
    static businessLogicPatterns = {
        MOVE: /MOVE\s+([A-Z0-9\-_\(\)]+)\s+TO\s+([A-Z0-9\-_\(\)]+)/gi,
        DERIVED: /COMPUTE\s+([A-Z0-9\-_]+)\s*=\s*(.+?)(?:\.|$)/gi,
        CONDITIONAL: /IF\s+(.+?)\s+(MOVE|COMPUTE|ADD|SUBTRACT)\s+(.+?)(?:END-IF|\.|$)/gi,
        CALCULATED: /(ADD|SUBTRACT|MULTIPLY|DIVIDE)\s+(.+?)\s+(TO|FROM|BY|GIVING)\s+([A-Z0-9\-_]+)/gi,
        STRING_MANIPULATION: /(STRING|UNSTRING)\s+(.+?)(?:END-STRING|\.)/gi,
        CICS_READ: /EXEC\s+CICS\s+(READ|RECEIVE|READNEXT|READPREV|STARTBR)\s+(.+?)\s+END-EXEC/gi,
        CICS_WRITE: /EXEC\s+CICS\s+(WRITE|SEND|REWRITE|DELETE)\s+(.+?)\s+END-EXEC/gi,
        FILE_READ: /(read|open\s+input)\s+([A-Z0-9\-_]+)/gi,
        FILE_WRITE: /(write|open\s+output)\s+([A-Z0-9\-_]+)/gi,
        PERFORM: /PERFORM\s+([A-Z0-9\-_]+)/gi
    };

    static cicsOperationCategories = {
        read_operations: ['read', 'receive', 'readnext', 'readprev', 'startbr', 'endbr'],
        write_operations: ['write', 'send', 'rewrite', 'delete'],
        transaction_operations: ['link', 'xctl', 'return', 'syncpoint'],
        file_operations: ['read', 'write', 'rewrite', 'delete', 'startbr', 'endbr'],
        terminal_operations: ['send', 'receive', 'converse'],
        queue_operations: ['writeq', 'readq', 'deleteq']
    };

    static dataTypeConversions = {
        'PIC 9': (length) => `NUMBER(${length})`,
        'PIC 9V9': (intLength, decLength) => `NUMBER(${intLength + decLength}, ${decLength})`,
        'PIC X': (length) => length <= 4000 ? `VARCHAR2(${length})` : `CLOB`,
        'COMP': (length) => `NUMBER(${Math.ceil(length * 2.4)})`, // Binary estimation
        'COMP-3': (length) => `NUMBER(${Math.ceil((length * 2) - 1)})`, // Packed decimal
        'COMP-1': () => 'FLOAT',
        'COMP-2': () => 'DOUBLE PRECISION'
    };

    static async analyzeTargetFile(fileName) {
        updateProcessingStatus('analyzing', `Starting field mapping analysis for ${fileName}`);
        
        try {
            // Find all programs that reference the target file
            const relatedPrograms = await this.findRelatedPrograms(fileName);
            updateProcessingStatus('analyzing', `Found ${relatedPrograms.length} related programs`);
            
            const allFieldMappings = [];
            const allDependencies = [];

            for (let i = 0; i < relatedPrograms.length; i++) {
                const program = relatedPrograms[i];
                updateProgress('mappingProgress', ((i + 1) / relatedPrograms.length) * 50);
                
                updateProcessingStatus('analyzing', `Analyzing program ${program.name} (${i + 1}/${relatedPrograms.length})`);
                
                // Perform token-aware analysis with chunking
                const programAnalysis = await this.analyzeProgram(program, fileName);
                allFieldMappings.push(...programAnalysis.fieldMappings);
                allDependencies.push(...programAnalysis.dependencies);
                
                // Add processing delay to simulate real vLLM calls
                await new Promise(resolve => setTimeout(resolve, 800));
            }

            updateProgress('mappingProgress', 75);
            updateProcessingStatus('analyzing', 'Consolidating field mappings from all programs');

            // Consolidate and resolve conflicts
            const consolidatedMappings = this.consolidateFieldMappings(allFieldMappings);
            const consolidatedDependencies = this.consolidateDependencies(allDependencies);
            
            updateProgress('mappingProgress', 90);
            updateProcessingStatus('analyzing', 'Storing analysis results in database');
            
            // Store in database with detailed logging
            for (const mapping of consolidatedMappings) {
                await db.saveFieldMapping(fileName, mapping);
            }

            // Store dependencies
            AppState.dependencies.push(...consolidatedDependencies);
            
            updateProgress('mappingProgress', 100);
            updateProcessingStatus('ready', `Analysis completed: ${consolidatedMappings.length} fields mapped`);
            
            return consolidatedMappings;

        } catch (error) {
            updateProcessingStatus('error', `Analysis failed: ${error.message}`);
            console.error('Field mapping analysis error:', error);
            throw error;
        }
    }

    // Add to FieldMappingAnalyzer class
static async generateFriendlyBusinessNames(components) {
    const friendlyNames = new Map();
    
    for (let i = 0; i < components.length; i++) {
        const component = components[i];
        
        // Check if we need chunking for the component content
        const content = component.content || '';
        const contentTokens = TokenManager.estimateTokens(content);
        
        try {
            let businessName = '';
            
            if (contentTokens > TokenManager.EFFECTIVE_LIMIT) {
                // Chunk the content and analyze key sections only
                const keyLines = this.extractKeyBusinessLines(content);
                const keyContent = keyLines.join('\n');
                businessName = await this.callLLMForBusinessName(component.name, keyContent, component.type);
            } else {
                businessName = await this.callLLMForBusinessName(component.name, content, component.type);
            }
            
            friendlyNames.set(component.name, businessName);
            
            // Update the component with friendly name
            component.friendlyName = businessName;
            component.displayName = businessName;
            
            // Small delay between calls to avoid overwhelming vLLM
            await new Promise(resolve => setTimeout(resolve, 500));
            
        } catch (error) {
            console.warn(`Failed to generate business name for ${component.name}:`, error);
            // Fallback to pattern-based naming
            friendlyNames.set(component.name, this.generateFallbackBusinessName(component.name, component.type));
            component.friendlyName = this.generateFallbackBusinessName(component.name, component.type);
            component.displayName = component.friendlyName;
        }
    }
    
    return friendlyNames;
}

static extractKeyBusinessLines(content) {
    const lines = content.split('\n');
    const keyLines = [];
    
    // Extract key business-relevant lines
    lines.forEach(line => {
        const trimmed = line.trim().toUpperCase();
        
        // Include program identification
        if (trimmed.includes('PROGRAM-ID') || 
            trimmed.includes('AUTHOR') ||
            trimmed.includes('REMARKS') ||
            // Include file definitions
            trimmed.includes('SELECT') ||
            trimmed.includes('FD ') ||
            // Include key data structures (01 level)
            trimmed.match(/^01\s+/) ||
            // Include key procedure names
            trimmed.includes('PERFORM') ||
            // Include comments that might have business context
            (trimmed.startsWith('*') && trimmed.length > 10)) {
            keyLines.push(line);
        }
    });
    
    return keyLines.slice(0, 50); // Limit to 50 key lines
}

static async callLLMForBusinessName(componentName, content, componentType) {
    const systemPrompt = `You are a business analyst expert in mainframe systems. Generate a friendly, business-meaningful name for this ${componentType} component. The name should be:
- Clear and business-friendly (no technical jargon)
- Under 4 words
- Descriptive of the business function
- Professional and readable

Examples:
- "CUST-ACCT-UPD" ‚Üí "Customer Account Updates"  
- "INV-PROC-RPT" ‚Üí "Inventory Processing Report"
- "PAYMENT-FILE" ‚Üí "Payment Transaction File"

Return ONLY the friendly business name, nothing else.`;

    const analysisPrompt = `Component Name: ${componentName}
Component Type: ${componentType}

Code Context:
${content.substring(0, 2000)}

Generate a friendly business name for this component:`;

    try {
        const llmResponse = await VLLMAPIManager.makeAPICall(analysisPrompt, systemPrompt, 100);
        const businessName = llmResponse.content.trim().replace(/['"]/g, '');
        
        // Validate the response
        if (businessName && businessName.length > 0 && businessName.length < 50) {
            return businessName;
        } else {
            throw new Error('Invalid business name generated');
        }
        
    } catch (error) {
        console.warn('LLM business name generation failed:', error);
        return this.generateFallbackBusinessName(componentName, componentType);
    }
}

static generateFallbackBusinessName(componentName, componentType) {
    // Pattern-based business name generation as fallback
    const name = componentName.replace(/[-_]/g, ' ').toLowerCase();
    const words = name.split(' ');
    
    const businessTerms = {
        'cust': 'Customer',
        'acct': 'Account', 
        'inv': 'Inventory',
        'ord': 'Order',
        'pay': 'Payment',
        'upd': 'Update',
        'inq': 'Inquiry', 
        'rpt': 'Report',
        'proc': 'Processing',
        'maint': 'Maintenance',
        'file': 'File',
        'rec': 'Record',
        'tran': 'Transaction'
    };
    
    const friendlyWords = words.map(word => {
        const lower = word.toLowerCase();
        return businessTerms[lower] || businessTerms[lower.substring(0, 4)] || 
               word.charAt(0).toUpperCase() + word.slice(1);
    });
    
    return friendlyWords.join(' ') + (componentType === 'RECORD_LAYOUT' ? ' Layout' : '');
}

    static async findRelatedPrograms(fileName) {
    // Use REAL uploaded components instead of simulated ones
    const realPrograms = AppState.components.filter(component => {
        const content = component.content || component.analysisResult || '';
        const lowerContent = content.toLowerCase();
        const lowerFileName = fileName.toLowerCase();
        
        // Check if component references the target file
        const hasFileReference = 
            lowerContent.includes(lowerFileName) ||
            lowerContent.includes(`file('${fileName.toLowerCase()}')`) ||
            lowerContent.includes(`file("${fileName.toLowerCase()}")`) ||
            lowerContent.includes(fileName.replace('-', '_').toLowerCase()) ||
            content.includes(fileName);
            
        return hasFileReference;
    });

    if (realPrograms.length === 0) {
        // If no real programs found, create analysis from uploaded components
        return AppState.components.map(component => ({
            name: component.name,
            type: component.type,
            content: component.content || this.generateAdvancedCOBOLProgram(fileName, 'ANALYSIS'),
            confidence: 0.75,
            cicsOperations: component.cicsOperations || [],
            fileOperations: component.dependencies?.filter(d => d.type === 'FILE_OPERATION') || []
        }));
    }

    return realPrograms.map(component => ({
        name: component.name,
        type: component.type,
        content: component.content || '',
        confidence: 0.95,
        cicsOperations: component.cicsOperations || [],
        fileOperations: component.dependencies?.filter(d => d.type === 'FILE_OPERATION') || []
    }));
}

    static async analyzeProgram(program, targetFile) {
        updateProcessingStatus('analyzing', `Processing ${program.name} with token-aware chunking`);
        
        // Check if content needs chunking
        const needsChunking = TokenManager.needsChunking(program.content);
        let chunks = [program.content];
        
        if (needsChunking) {
            chunks = TokenManager.chunkText(program.content, true);
            updateProcessingStatus('analyzing', `Chunking ${program.name} into ${chunks.length} parts`);
        }

        const allFieldMappings = [];
        const allDependencies = [];
        const allCicsOperations = [];

        for (let i = 0; i < chunks.length; i++) {
            const chunk = chunks[i];
            const chunkNumber = i + 1;
            const totalChunks = chunks.length;
            
            updateProcessingStatus('analyzing', 
                `Analyzing ${program.name} chunk ${chunkNumber}/${totalChunks}`);
            
            try {
                // Perform vLLM analysis call
                const chunkAnalysis = await this.performVLLMAnalysis(chunk, targetFile, program.name, chunkNumber, totalChunks);
                
                // Log successful vLLM call
                await db.logLLMCall('field_mapping', chunkNumber, totalChunks, 
                    chunkAnalysis.inputTokens, chunkAnalysis.outputTokens, true);
                
                allFieldMappings.push(...chunkAnalysis.fieldMappings);
                allDependencies.push(...chunkAnalysis.dependencies);
                allCicsOperations.push(...chunkAnalysis.cicsOperations);

                // Update token usage
                TokenManager.updateTokenUsage(chunkAnalysis.inputTokens + chunkAnalysis.outputTokens, 0);
                
            } catch (error) {
                // Log failed vLLM call
                await db.logLLMCall('field_mapping', chunkNumber, totalChunks, 
                    TokenManager.estimateTokens(chunk), 0, false, error.message);
                
                console.warn(`Chunk ${chunkNumber} analysis failed:`, error);
                // Continue with other chunks
            }
            
            // Rate limiting between chunks
            if (i < chunks.length - 1) {
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
        }

        return {
            programName: program.name,
            fieldMappings: allFieldMappings,
            dependencies: allDependencies,
            cicsOperations: allCicsOperations,
            confidence: program.confidence,
            chunksProcessed: chunks.length
        };
    }

    static buildAnalysisPrompt(codeChunk, targetFile, programName) {
        return `
Analyze this COBOL code chunk from program ${programName} that processes file ${targetFile}.

Extract and categorize:
1. Field mappings and data movements
2. Business logic patterns (MOVE, COMPUTE, conditional, calculations)
3. CICS operations (READ, WRITE, SEND, RECEIVE, etc.)
4. File operations and dependencies
5. Data type definitions and field structures

Code to analyze:
${codeChunk}

Provide structured analysis focusing on field mappings to ${targetFile}.
                `.trim();
    }

    static async performVLLMAnalysis(codeChunk, targetFile, programName, chunkNumber, totalChunks) {
    const systemPrompt = `You are an expert COBOL mainframe analyst. Analyze the provided COBOL code chunk and extract field mapping information.

CRITICAL: Your response must be valid JSON only. No explanations, no markdown, just JSON.

Extract and return in this JSON format:
{
  "fieldMappings": [
    {
      "fieldName": "string",
      "mainframeDataType": "string", 
      "populationSource": "string",
      "businessLogicType": "MOVE|DERIVED|CONDITIONAL|CALCULATED|STRING_MANIPULATION",
      "businessLogicDescription": "string",
      "derivationLogic": "string",
      "confidenceScore": 0.0-1.0
    }
  ],
  "dependencies": [
    {
      "targetComponent": "string",
      "relationshipType": "COPYBOOK_INCLUDE|PROGRAM_CALL|CICS_FILE_ACCESS|FILE_OPERATION",
      "interfaceType": "string",
      "confidenceScore": 0.0-1.0
    }
  ],
  "cicsOperations": [
    {
      "operation": "string",
      "category": "READ_OPERATION|WRITE_OPERATION|TRANSACTION_OPERATION|TERMINAL_OPERATION",
      "fileName": "string",
      "confidenceScore": 0.0-1.0
    }
  ]
}`;

    // CHUNKING FIX: Check prompt size and chunk if needed
    const basePrompt = `Program: ${programName} (Chunk ${chunkNumber}/${totalChunks})
Target File: ${targetFile}

Focus on field mappings to ${targetFile} and provide detailed analysis.

COBOL Code to Analyze:`;
    
    const maxContentLength = TokenManager.EFFECTIVE_LIMIT * 4 - TokenManager.estimateTokens(systemPrompt + basePrompt) - 500; // Reserve 500 tokens for response
    
    let finalCodeChunk = codeChunk;
    if (TokenManager.estimateTokens(codeChunk) > maxContentLength) {
        console.warn(`Code chunk too large (${TokenManager.estimateTokens(codeChunk)} tokens), further chunking...`);
        
        // Further chunk the code - prioritize business logic sections
        const priorityLines = this.extractPriorityLines(codeChunk);
        finalCodeChunk = priorityLines.join('\n');
        
        // If still too large, truncate
        if (TokenManager.estimateTokens(finalCodeChunk) > maxContentLength) {
            const lines = finalCodeChunk.split('\n');
            const maxLines = Math.floor(lines.length * (maxContentLength / TokenManager.estimateTokens(finalCodeChunk)));
            finalCodeChunk = lines.slice(0, maxLines).join('\n');
            console.warn(`Further truncated to ${maxLines} lines to fit token limit`);
        }
    }
    
    const analysisPrompt = basePrompt + '\n' + finalCodeChunk;
    
    try {
        // Make REAL vLLM API call with chunked content
        const llmResponse = await VLLMAPIManager.makeAPICall(analysisPrompt, systemPrompt, 1500);

        // Parse JSON response with enhanced error handling
        let analysisResult;
        try {
            // Clean the response - remove any markdown formatting
            let cleanResponse = llmResponse.content.trim();
            if (cleanResponse.startsWith('```json')) {
                cleanResponse = cleanResponse.replace(/```json\s*/, '').replace(/\s*```$/, '');
            }
            if (cleanResponse.startsWith('```')) {
                cleanResponse = cleanResponse.replace(/```\s*/, '').replace(/\s*```$/, '');
            }
            
            analysisResult = JSON.parse(cleanResponse);
        } catch (parseError) {
            console.warn('vLLM response not valid JSON, using enhanced fallback parsing');
            analysisResult = this.enhancedFallbackParse(llmResponse.content, finalCodeChunk, targetFile, programName);
        }

        // Enhance field mappings with Oracle conversions
        if (analysisResult.fieldMappings) {
            analysisResult.fieldMappings.forEach(mapping => {
                mapping.oracleDataType = this.convertToOracleType(mapping.mainframeDataType);
                mapping.mainframeLength = this.inferAdvancedLength(mapping.fieldName, finalCodeChunk);
                mapping.oracleLength = this.inferOracleLength(mapping.fieldName, finalCodeChunk);
                mapping.sourceRecordLayout = targetFile;
                mapping.programsInvolved = [programName];
            });
        }

        return {
            fieldMappings: analysisResult.fieldMappings || [],
            dependencies: analysisResult.dependencies || [],
            cicsOperations: analysisResult.cicsOperations || [],
            inputTokens: llmResponse.inputTokens,
            outputTokens: llmResponse.outputTokens,
            processingTime: Date.now(),
            chunkNumber,
            totalChunks,
            vllmCall: true,
            actualContentLength: TokenManager.estimateTokens(finalCodeChunk)
        };

    } catch (error) {
        console.error('vLLM API call failed, using fallback analysis:', error);
        
        // Enhanced fallback to pattern-based analysis if vLLM fails
        return {
            fieldMappings: this.extractAdvancedFieldMappings(finalCodeChunk, targetFile, programName),
            dependencies: this.extractAdvancedDependencies(finalCodeChunk, programName), 
            cicsOperations: this.extractCICSOperations(finalCodeChunk, programName),
            inputTokens: 0,
            outputTokens: 0,
            processingTime: Date.now(),
            chunkNumber,
            totalChunks,
            vllmCall: false,
            fallback: true,
            error: error.message,
            actualContentLength: TokenManager.estimateTokens(finalCodeChunk)
        };
    }
}

// Add helper function to extract priority lines for chunking
static extractPriorityLines(codeChunk) {
    const cleanLines = COBOLParser.cleanCOBOLLines(codeChunk);
    const priorityLines = [];
    
    // Priority 1: Program identification and file definitions
    cleanLines.forEach(line => {
        const trimmed = line.trim().toUpperCase();
        if (trimmed.includes('PROGRAM-ID') || 
            trimmed.includes('SELECT') ||
            trimmed.match(/^FD\s+/) ||
            trimmed.match(/^01\s+/)) {
            priorityLines.push(line);
        }
    });
    
    // Priority 2: Business logic (MOVE, COMPUTE, etc.)
    cleanLines.forEach(line => {
        const trimmed = line.trim().toUpperCase();
        if (trimmed.match(/^\s*MOVE\s+/) || 
            trimmed.match(/^\s*COMPUTE\s+/) ||
            trimmed.match(/^\s*IF\s+/) ||
            trimmed.match(/^\s*ADD\s+/) ||
            trimmed.match(/^\s*SUBTRACT\s+/) ||
            trimmed.match(/^\s*MULTIPLY\s+/) ||
            trimmed.match(/^\s*DIVIDE\s+/)) {
            if (!priorityLines.includes(line)) {
                priorityLines.push(line);
            }
        }
    });
    
    // Priority 3: CICS operations
    cleanLines.forEach(line => {
        const trimmed = line.trim().toUpperCase();
        if (trimmed.includes('EXEC CICS')) {
            if (!priorityLines.includes(line)) {
                priorityLines.push(line);
            }
        }
    });
    
    return priorityLines.length > 0 ? priorityLines : cleanLines.slice(0, 100);
}

// Enhanced fallback parsing
static enhancedFallbackParse(responseText, codeChunk, targetFile, programName) {
    // Try to extract JSON from mixed response
    const jsonMatch = responseText.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
        try {
            return JSON.parse(jsonMatch[0]);
        } catch (e) {
            // Continue to pattern-based fallback
        }
    }
    
    // Pattern-based fallback analysis
    const fieldMappings = this.extractAdvancedFieldMappings(codeChunk, targetFile, programName);
    const dependencies = this.extractAdvancedDependencies(codeChunk, programName);
    const cicsOperations = this.extractCICSOperations(codeChunk, programName);
    
    return { fieldMappings, dependencies, cicsOperations };
}

    // Fallback parsing for non-JSON vLLM responses
  
    static fallbackParseResponse(responseText, codeChunk, targetFile, programName) {
        // Extract information from natural language response
        const fieldMappings = [];
        const dependencies = [];
        const cicsOperations = [];

        // Use pattern matching as fallback
        const moveMatches = [...codeChunk.matchAll(this.businessLogicPatterns.MOVE)];
        moveMatches.forEach(match => {
            fieldMappings.push({
                fieldName: match[2],
                mainframeDataType: this.inferAdvancedDataType(match[2], codeChunk),
                populationSource: match[1],
                businessLogicType: 'MOVE',
                businessLogicDescription: `Direct assignment: ${match[1]} ‚Üí ${match[2]}`,
                derivationLogic: match[0],
                confidenceScore: 0.7
            });
        });

        return { fieldMappings, dependencies, cicsOperations };
    }

    static extractAdvancedFieldMappings(codeChunk, targetFile, programName) {
        const fieldMappings = [];
        const lines = codeChunk.split('\n');
        
        lines.forEach((line, index) => {
            const trimmedLine = line.trim();
            
            // Enhanced MOVE operation detection
            const moveMatches = [...trimmedLine.matchAll(this.businessLogicPatterns.MOVE)];
            moveMatches.forEach(match => {
                const sourceField = match[1];
                const targetField = match[2];
                
                fieldMappings.push({
                    fieldName: targetField,
                    mainframeDataType: this.inferAdvancedDataType(targetField, codeChunk),
                    oracleDataType: this.convertToOracleType(this.inferAdvancedDataType(targetField, codeChunk)),
                    mainframeLength: this.inferAdvancedLength(targetField, codeChunk),
                    oracleLength: this.inferOracleLength(targetField, codeChunk),
                    populationSource: sourceField,
                    sourceRecordLayout: targetFile,
                    businessLogicType: 'MOVE',
                    businessLogicDescription: `Direct assignment: ${sourceField} ‚Üí ${targetField}`,
                    derivationLogic: trimmedLine,
                    programsInvolved: [programName],
                    confidenceScore: 0.92,
                    lineNumber: index + 1,
                    cicsContext: this.detectCICSContext(lines, index)
                });
            });

            // Enhanced COMPUTE operation detection
            const computeMatches = [...trimmedLine.matchAll(this.businessLogicPatterns.DERIVED)];
            computeMatches.forEach(match => {
                const targetField = match[1];
                const expression = match[2];
                
                fieldMappings.push({
                    fieldName: targetField,
                    mainframeDataType: this.inferAdvancedDataType(targetField, codeChunk),
                    oracleDataType: this.convertToOracleType(this.inferAdvancedDataType(targetField, codeChunk)),
                    mainframeLength: this.inferAdvancedLength(targetField, codeChunk),
                    oracleLength: this.inferOracleLength(targetField, codeChunk),
                    populationSource: 'COMPUTED',
                    sourceRecordLayout: targetFile,
                    businessLogicType: 'DERIVED',
                    businessLogicDescription: `Calculated field using: ${expression}`,
                    derivationLogic: trimmedLine,
                    programsInvolved: [programName],
                    confidenceScore: 0.87,
                    lineNumber: index + 1,
                    cicsContext: this.detectCICSContext(lines, index)
                });
            });

            // Enhanced conditional logic detection
            const conditionalMatches = [...trimmedLine.matchAll(this.businessLogicPatterns.CONDITIONAL)];
            conditionalMatches.forEach(match => {
                const condition = match[1];
                const operation = match[2];
                const target = match[3];
                
                // Extract target field from operation
                const targetField = this.extractTargetField(target);
                if (targetField) {
                    fieldMappings.push({
                        fieldName: targetField,
                        mainframeDataType: this.inferAdvancedDataType(targetField, codeChunk),
                        oracleDataType: this.convertToOracleType(this.inferAdvancedDataType(targetField, codeChunk)),
                        mainframeLength: this.inferAdvancedLength(targetField, codeChunk),
                        oracleLength: this.inferOracleLength(targetField, codeChunk),
                        populationSource: 'CONDITIONAL',
                        sourceRecordLayout: targetFile,
                        businessLogicType: 'CONDITIONAL',
                        businessLogicDescription: `Conditional assignment based on: ${condition}`,
                        derivationLogic: trimmedLine,
                        programsInvolved: [programName],
                        confidenceScore: 0.84,
                        lineNumber: index + 1,
                        cicsContext: this.detectCICSContext(lines, index)
                    });
                }
            });

            // Enhanced arithmetic operations
            const calcMatches = [...trimmedLine.matchAll(this.businessLogicPatterns.CALCULATED)];
            calcMatches.forEach(match => {
                const operation = match[1];
                const operands = match[2];
                const targetField = match[4];
                
                fieldMappings.push({
                    fieldName: targetField,
                    mainframeDataType: this.inferAdvancedDataType(targetField, codeChunk),
                    oracleDataType: this.convertToOracleType(this.inferAdvancedDataType(targetField, codeChunk)),
                    mainframeLength: this.inferAdvancedLength(targetField, codeChunk),
                    oracleLength: this.inferOracleLength(targetField, codeChunk),
                    populationSource: 'CALCULATED',
                    sourceRecordLayout: targetFile,
                    businessLogicType: 'CALCULATED',
                    businessLogicDescription: `Arithmetic operation: ${operation} ${operands}`,
                    derivationLogic: trimmedLine,
                    programsInvolved: [programName],
                    confidenceScore: 0.89,
                    lineNumber: index + 1,
                    cicsContext: this.detectCICSContext(lines, index)
                });
            });

            // String manipulation operations
            const stringMatches = [...trimmedLine.matchAll(this.businessLogicPatterns.STRING_MANIPULATION)];
            stringMatches.forEach(match => {
                const operation = match[1];
                const operands = match[2];
                
                // Extract target field from STRING/UNSTRING operation
                const targetField = this.extractStringTarget(operands);
                if (targetField) {
                    fieldMappings.push({
                        fieldName: targetField,
                        mainframeDataType: this.inferAdvancedDataType(targetField, codeChunk),
                        oracleDataType: this.convertToOracleType(this.inferAdvancedDataType(targetField, codeChunk)),
                        mainframeLength: this.inferAdvancedLength(targetField, codeChunk),
                        oracleLength: this.inferOracleLength(targetField, codeChunk),
                        populationSource: 'STRING_MANIPULATION',
                        sourceRecordLayout: targetFile,
                        businessLogicType: 'STRING_MANIPULATION',
                        businessLogicDescription: `String operation: ${operation} ${operands}`,
                        derivationLogic: trimmedLine,
                        programsInvolved: [programName],
                        confidenceScore: 0.81,
                        lineNumber: index + 1,
                        cicsContext: this.detectCICSContext(lines, index)
                    });
                }
            });
        });

        return fieldMappings;
    }

    static extractAdvancedDependencies(codeChunk, programName) {
        const dependencies = [];
        const lines = codeChunk.split('\n');
        
        lines.forEach((line, index) => {
            const trimmedLine = line.trim();
            
            // COPY/INCLUDE statements
            const copyMatch = trimmedLine.match(/COPY\s+([A-Z0-9\-_]+)/i);
            if (copyMatch) {
                dependencies.push({
                    sourceComponent: programName,
                    targetComponent: copyMatch[1],
                    relationshipType: 'COPYBOOK_INCLUDE',
                    interfaceType: 'INCLUDE',
                    confidenceScore: 0.95,
                    lineNumber: index + 1,
                    analysisDetails: {
                        operation: 'COPY',
                        context: 'DATA_DIVISION'
                    }
                });
            }
            
            // CALL statements with detailed analysis
            const callMatch = trimmedLine.match(/CALL\s+['"]([A-Z0-9\-_]+)['"](?:\s+USING\s+(.+))?/i);
            if (callMatch) {
                dependencies.push({
                    sourceComponent: programName,
                    targetComponent: callMatch[1],
                    relationshipType: 'PROGRAM_CALL',
                    interfaceType: 'DYNAMIC_CALL',
                    confidenceScore: 0.92,
                    lineNumber: index + 1,
                    analysisDetails: {
                        operation: 'CALL',
                        parameters: callMatch[2] || 'NONE',
                        context: 'PROCEDURE_DIVISION'
                    }
                });
            }
            
            // CICS file operations
            const cicsFileMatch = trimmedLine.match(/EXEC\s+CICS\s+(READ|WRITE|REWRITE|DELETE)\s+.*FILE\s*\(\s*['"]?([A-Z0-9\-_]+)['"]?\s*\)/i);
            if (cicsFileMatch) {
                dependencies.push({
                    sourceComponent: programName,
                    targetComponent: cicsFileMatch[2],
                    relationshipType: 'CICS_FILE_ACCESS',
                    interfaceType: `CICS_${cicsFileMatch[1].toUpperCase()}`,
                    confidenceScore: 0.90,
                    lineNumber: index + 1,
                    analysisDetails: {
                        operation: cicsFileMatch[1].toUpperCase(),
                        fileType: 'VSAM',
                        context: 'CICS_TRANSACTION'
                    }
                });
            }
            
            // Regular file operations
            const fileMatch = trimmedLine.match(/(OPEN|READ|WRITE|CLOSE)\s+([A-Z0-9\-_]+)/i);
            if (fileMatch) {
                dependencies.push({
                    sourceComponent: programName,
                    targetComponent: fileMatch[2],
                    relationshipType: 'FILE_OPERATION',
                    interfaceType: `FILE_${fileMatch[1].toUpperCase()}`,
                    confidenceScore: 0.85,
                    lineNumber: index + 1,
                    analysisDetails: {
                        operation: fileMatch[1].toUpperCase(),
                        fileType: 'SEQUENTIAL',
                        context: 'BATCH_PROCESSING'
                    }
                });
            }
            
            // PERFORM statements
            const performMatch = trimmedLine.match(/PERFORM\s+([A-Z0-9\-_]+)/i);
            if (performMatch) {
                dependencies.push({
                    sourceComponent: programName,
                    targetComponent: performMatch[1],
                    relationshipType: 'INTERNAL_CALL',
                    interfaceType: 'PERFORM',
                    confidenceScore: 0.88,
                    lineNumber: index + 1,
                    analysisDetails: {
                        operation: 'PERFORM',
                        context: 'INTERNAL_PROCEDURE'
                    }
                });
            }
        });

        return dependencies;
    }

    static extractCICSOperations(codeChunk, programName) {
        const cicsOps = [];
        const lines = codeChunk.split('\n');
        
        lines.forEach((line, index) => {
            const trimmedLine = line.trim();
            
            // Comprehensive CICS operation detection
            const cicsMatch = trimmedLine.match(/EXEC\s+CICS\s+([A-Z]+)\s+(.+?)\s+END-EXEC/i);
            if (cicsMatch) {
                const operation = cicsMatch[1].toUpperCase();
                const parameters = cicsMatch[2];
                
                // Categorize CICS operation
                let category = 'OTHER';
                if (this.cicsOperationCategories.read_operations.includes(operation.toLowerCase())) {
                    category = 'READ_OPERATION';
                } else if (this.cicsOperationCategories.write_operations.includes(operation.toLowerCase())) {
                    category = 'WRITE_OPERATION';
                } else if (this.cicsOperationCategories.transaction_operations.includes(operation.toLowerCase())) {
                    category = 'TRANSACTION_OPERATION';
                } else if (this.cicsOperationCategories.terminal_operations.includes(operation.toLowerCase())) {
                    category = 'TERMINAL_OPERATION';
                } else if (this.cicsOperationCategories.queue_operations.includes(operation.toLowerCase())) {
                    category = 'QUEUE_OPERATION';
                }
                
                // Extract file name if present
                const fileMatch = parameters.match(/FILE\s*\(\s*['"]?([A-Z0-9\-_]+)['"]?\s*\)/i);
                const fileName = fileMatch ? fileMatch[1] : null;
                
                cicsOps.push({
                    operation: operation,
                    category: category,
                    parameters: parameters,
                    fileName: fileName,
                    programName: programName,
                    lineNumber: index + 1,
                    fullStatement: trimmedLine,
                    confidenceScore: 0.93
                });
            }
        });
        
        return cicsOps;
    }

    static detectCICSContext(lines, currentIndex) {
        // Look for CICS context around the current line
        const contextRange = 3;
        const startIndex = Math.max(0, currentIndex - contextRange);
        const endIndex = Math.min(lines.length - 1, currentIndex + contextRange);
        
        for (let i = startIndex; i <= endIndex; i++) {
            if (lines[i].includes('EXEC CICS')) {
                return {
                    hasCICS: true,
                    cicsLine: i + 1,
                    operation: lines[i].match(/EXEC\s+CICS\s+([A-Z]+)/i)?.[1] || 'UNKNOWN'
                };
            }
        }
        
        return { hasCICS: false };
    }

    static extractTargetField(operationText) {
        // Extract target field from various operation formats
        const moveMatch = operationText.match(/TO\s+([A-Z0-9\-_]+)/i);
        if (moveMatch) return moveMatch[1];
        
        const computeMatch = operationText.match(/^([A-Z0-9\-_]+)\s*=/i);
        if (computeMatch) return computeMatch[1];
        
        return null;
    }

    static extractStringTarget(operands) {
        // Extract target field from STRING/UNSTRING operations
        const intoMatch = operands.match(/INTO\s+([A-Z0-9\-_]+)/i);
        if (intoMatch) return intoMatch[1];
        
        const givingMatch = operands.match(/GIVING\s+([A-Z0-9\-_]+)/i);
        if (givingMatch) return givingMatch[1];
        
        return null;
    }

    static inferAdvancedDataType(fieldName, codeChunk) {
        // Enhanced data type inference using context analysis
        
        // First, try to find explicit definition in the code
        const picMatch = codeChunk.match(new RegExp(`\\s+${fieldName}\\s+PIC\\s+([X9VS\\(\\)\\+\\-COMP\\-]+)`, 'i'));
        if (picMatch) {
            return picMatch[1];
        }
        
        // Use enhanced heuristics based on field name patterns
        const lowerField = fieldName.toLowerCase();
        
        if (lowerField.includes('amt') || lowerField.includes('amount') || lowerField.includes('balance')) {
            return 'PIC S9(9)V99 COMP-3';
        }
        if (lowerField.includes('rate') || lowerField.includes('percent')) {
            return 'PIC S9(3)V999 COMP-3';
        }
        if (lowerField.includes('date')) {
            return 'PIC X(8)';
        }
        if (lowerField.includes('time') || lowerField.includes('timestamp')) {
            return 'PIC X(14)';
        }
        if (lowerField.includes('num') || lowerField.includes('count') || lowerField.includes('seq')) {
            return 'PIC S9(7) COMP-3';
        }
        if (lowerField.includes('code') || lowerField.includes('type') || lowerField.includes('status')) {
            return 'PIC X(3)';
        }
        if (lowerField.includes('name') || lowerField.includes('desc')) {
            return 'PIC X(30)';
        }
        if (lowerField.includes('addr') || lowerField.includes('address')) {
            return 'PIC X(50)';
        }
        if (lowerField.includes('id') || lowerField.includes('key')) {
            return 'PIC S9(10) COMP-3';
        }
        if (lowerField.includes('flag') || lowerField.includes('ind')) {
            return 'PIC X(1)';
        }
        
        return 'PIC X(20)'; // Default
    }

    static inferAdvancedLength(fieldName, codeChunk) {
        const dataType = this.inferAdvancedDataType(fieldName, codeChunk);
        
        // Parse COMP-3 length
        if (dataType.includes('COMP-3')) {
            const match = dataType.match(/9\((\d+)\)/);
            if (match) {
                const digits = parseInt(match[1]);
                return Math.ceil((digits + 1) / 2); // Packed decimal calculation
            }
        }
        
        // Parse regular PIC lengths
        const match = dataType.match(/[X9]\((\d+)\)/);
        return match ? parseInt(match[1]) : 20;
    }

    static convertToOracleType(cobolType) {
        // Enhanced COBOL to Oracle type conversion with COMP support
        if (cobolType.includes('COMP-3')) {
            // Packed decimal conversion
            const match = cobolType.match(/S?9\((\d+)\)(?:V9\((\d+)\))?/);
            if (match) {
                const intDigits = parseInt(match[1]);
                const decDigits = match[2] ? parseInt(match[2]) : 0;
                return `NUMBER(${intDigits + decDigits}, ${decDigits})`;
            }
            return 'NUMBER(10,2)';
        }
        
        if (cobolType.includes('COMP-1')) return 'FLOAT';
        if (cobolType.includes('COMP-2')) return 'DOUBLE PRECISION';
        if (cobolType.includes('COMP')) {
            // Binary fields
            const match = cobolType.match(/S?9\((\d+)\)/);
            if (match) {
                const digits = parseInt(match[1]);
                return `NUMBER(${digits})`;
            }
            return 'NUMBER(10)';
        }
        
        // Standard PIC clause conversions
        if (cobolType.includes('V')) {
            const parts = cobolType.match(/S?9\((\d+)\)V9\((\d+)\)/);
            if (parts) {
                const intDigits = parseInt(parts[1]);
                const decDigits = parseInt(parts[2]);
                return `NUMBER(${intDigits + decDigits}, ${decDigits})`;
            }
        }
        
        if (cobolType.includes('9')) {
            const match = cobolType.match(/S?9\((\d+)\)/);
            if (match) {
                return `NUMBER(${match[1]})`;
            }
            return 'NUMBER(10)';
        }
        
        if (cobolType.includes('X')) {
            const match = cobolType.match(/X\((\d+)\)/);
            if (match) {
                const len = parseInt(match[1]);
                return len <= 4000 ? `VARCHAR2(${len})` : 'CLOB';
            }
            return 'VARCHAR2(100)';
        }
        
        return 'VARCHAR2(100)'; // Default
    }

    static inferOracleLength(fieldName, codeChunk) {
        const oracleType = this.convertToOracleType(this.inferAdvancedDataType(fieldName, codeChunk));
        
        // Extract length from Oracle type
        if (oracleType.includes('VARCHAR2') || oracleType.includes('NUMBER')) {
            const match = oracleType.match(/\((\d+)(?:,\s*\d+)?\)/);
            return match ? parseInt(match[1]) : null;
        }
        
        return null;
    }

    static consolidateFieldMappings(allMappings) {
        const fieldMap = new Map();

        allMappings.forEach(mapping => {
            const key = mapping.fieldName;
            
            if (fieldMap.has(key)) {
                const existing = fieldMap.get(key);
                
                // Merge programs involved
                existing.programsInvolved = [...new Set([...existing.programsInvolved, ...mapping.programsInvolved])];
                
                // Handle conflicting business logic types
                if (existing.businessLogicType !== mapping.businessLogicType) {
                    existing.businessLogicType = 'MULTI_SOURCE';
                    existing.businessLogicDescription = `Multiple patterns: ${existing.businessLogicDescription} | ${mapping.businessLogicDescription}`;
                }
                
                // Update confidence (weighted average based on program count)
                existing.confidenceScore = (existing.confidenceScore + mapping.confidenceScore) / 2;
                
                // Merge derivation logic
                if (existing.derivationLogic !== mapping.derivationLogic) {
                    existing.derivationLogic = `${existing.derivationLogic} | ${mapping.derivationLogic}`;
                }
                
                // Keep highest confidence CICS context
                if (mapping.cicsContext?.hasCICS && !existing.cicsContext?.hasCICS) {
                    existing.cicsContext = mapping.cicsContext;
                }
                
            } else {
                fieldMap.set(key, { ...mapping });
            }
        });

        return Array.from(fieldMap.values()).sort((a, b) => b.confidenceScore - a.confidenceScore);
    }

    static consolidateDependencies(allDependencies) {
        const depMap = new Map();

        allDependencies.forEach(dep => {
            const key = `${dep.sourceComponent}-${dep.targetComponent}-${dep.relationshipType}`;
            
            if (!depMap.has(key)) {
                depMap.set(key, { ...dep });
            }
        });

        return Array.from(depMap.values());
    }
    // Part 4: Advanced COBOL Generator & Enhanced Chat System with vLLM Integration

// Continue FieldMappingAnalyzer class with advanced COBOL program generation
generateAdvancedCOBOLProgram = function(fileName, programType) {
    const fileNameClean = fileName.replace(/[-_]/g, '');
    const programId = `${fileNameClean.substring(0, 6)}${programType.substring(0, 3)}`;
    
    const baseProgram = `
       IDENTIFICATION DIVISION.
       PROGRAM-ID. ${programId}.
       AUTHOR. SYSTEM GENERATED.
       
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       SPECIAL-NAMES.
           DECIMAL-POINT IS COMMA.
           
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT ${fileName} ASSIGN TO DD${fileName}
           ORGANIZATION IS INDEXED
           ACCESS MODE IS RANDOM
           RECORD KEY IS ${fileNameClean}-KEY
           FILE STATUS IS WS-FILE-STATUS.
           
       DATA DIVISION.
       FILE SECTION.
       FD  ${fileName}.
       01  ${fileNameClean}-RECORD.
           05  ${fileNameClean}-KEY.
               10  CUSTOMER-ID          PIC S9(10) COMP-3.
               10  ACCOUNT-TYPE         PIC X(3).
           05  ${fileNameClean}-DATA.
               10  CUSTOMER-NAME        PIC X(30).
               10  CUSTOMER-ADDRESS     PIC X(50).
               10  PHONE-NUMBER         PIC X(15).
               10  EMAIL-ADDRESS        PIC X(50).
               10  ACCOUNT-BALANCE      PIC S9(9)V99 COMP-3.
               10  CREDIT-LIMIT         PIC S9(7)V99 COMP-3.
               10  LAST-ACTIVITY-DATE   PIC X(8).
               10  STATUS-CODE          PIC X(1).
               10  INTEREST-RATE        PIC S9(3)V999 COMP-3.
               10  BRANCH-CODE          PIC X(5).
               10  ACCOUNT-OPEN-DATE    PIC X(8).
               10  LAST-STATEMENT-DATE  PIC X(8).
               10  TRANSACTION-COUNT    PIC S9(5) COMP-3.
               10  YTD-INTEREST         PIC S9(7)V99 COMP-3.
               10  OVERDRAFT-LIMIT      PIC S9(7)V99 COMP-3.
               10  RISK-RATING          PIC X(2).
               10  PREFERRED-CUSTOMER   PIC X(1).
               10  MARKETING-CODE       PIC X(3).
               10  LAST-MAINT-DATE      PIC X(8).
               10  LAST-MAINT-TIME      PIC X(6).
               10  FILLER               PIC X(20).
       
       WORKING-STORAGE SECTION.
       01  WS-WORK-AREAS.
           05  WS-FILE-STATUS          PIC X(2).
           05  WS-CUSTOMER-ID          PIC S9(10) COMP-3.
           05  WS-TRANSACTION-AMOUNT   PIC S9(9)V99 COMP-3.
           05  WS-NEW-BALANCE          PIC S9(9)V99 COMP-3.
           05  WS-INTEREST-CALC        PIC S9(7)V99 COMP-3.
           05  WS-CURRENT-DATE         PIC X(8).
           05  WS-CURRENT-TIME         PIC X(6).
           05  WS-ERROR-MESSAGE        PIC X(80).
           05  WS-RETURN-CODE          PIC S9(4) COMP.
           05  WS-RECORD-FOUND         PIC X(1) VALUE 'N'.
           05  WS-UPDATE-FLAG          PIC X(1) VALUE 'N'.
           
       01  WS-CALCULATED-FIELDS.
           05  WS-AVAILABLE-CREDIT     PIC S9(9)V99 COMP-3.
           05  WS-TOTAL-EXPOSURE       PIC S9(11)V99 COMP-3.
           05  WS-UTILIZATION-PCT      PIC S9(3)V99 COMP-3.
           05  WS-MONTHLY-INTEREST     PIC S9(7)V99 COMP-3.
           
       01  WS-STRING-WORK-AREAS.
           05  WS-FULL-NAME            PIC X(60).
           05  WS-FORMATTED-ADDRESS    PIC X(100).
           05  WS-DISPLAY-BALANCE      PIC $,$$,$9.99.
           
       COPY ERRHAND.
       COPY DATEUTIL.
       COPY CALCUTIL.
       
       LINKAGE SECTION.
       01  LS-CUSTOMER-INPUT.
           05  LS-CUSTOMER-ID          PIC S9(10) COMP-3.
           05  LS-TRANSACTION-TYPE     PIC X(1).
           05  LS-TRANSACTION-AMOUNT   PIC S9(9)V99 COMP-3.
           05  LS-REFERENCE-NUMBER     PIC X(15).
       
       01  LS-CUSTOMER-OUTPUT.
           05  LS-RETURN-CODE          PIC S9(4) COMP.
           05  LS-ERROR-MESSAGE        PIC X(80).
           05  LS-CUSTOMER-DATA        PIC X(200).
       
       PROCEDURE DIVISION USING LS-CUSTOMER-INPUT LS-CUSTOMER-OUTPUT.
       
       MAIN-PROCESS.
           PERFORM INITIALIZE-PROGRAM
           PERFORM VALIDATE-INPUT
           IF WS-RETURN-CODE = ZERO
              PERFORM PROCESS-${programType}
           END-IF
           PERFORM CLEANUP-PROGRAM
           GOBACK.
           
       INITIALIZE-PROGRAM.
           MOVE ZERO TO WS-RETURN-CODE
           MOVE SPACES TO WS-ERROR-MESSAGE
           MOVE FUNCTION CURRENT-DATE(1:8) TO WS-CURRENT-DATE
           MOVE FUNCTION CURRENT-DATE(9:6) TO WS-CURRENT-TIME
           MOVE 'N' TO WS-RECORD-FOUND
           MOVE 'N' TO WS-UPDATE-FLAG.
           
       VALIDATE-INPUT.
           IF LS-CUSTOMER-ID = ZERO
              MOVE 'Invalid customer ID' TO WS-ERROR-MESSAGE
              MOVE 100 TO WS-RETURN-CODE
           END-IF
           
           IF LS-TRANSACTION-TYPE NOT = 'C' AND NOT = 'D' AND NOT = 'I'
              MOVE 'Invalid transaction type' TO WS-ERROR-MESSAGE  
              MOVE 101 TO WS-RETURN-CODE
           END-IF.
           
       PROCESS-${programType}.`;

    // Add specific processing logic based on program type
    if (programType === 'UPDATE') {
        return baseProgram + `
           MOVE LS-CUSTOMER-ID TO WS-CUSTOMER-ID
           MOVE LS-TRANSACTION-AMOUNT TO WS-TRANSACTION-AMOUNT
           
           PERFORM READ-CUSTOMER-RECORD
           IF WS-RECORD-FOUND = 'Y'
              PERFORM CALCULATE-NEW-BALANCE
              PERFORM VALIDATE-TRANSACTION
              IF WS-RETURN-CODE = ZERO
                 PERFORM UPDATE-CUSTOMER-RECORD
              END-IF
           ELSE
              MOVE 'Customer not found' TO WS-ERROR-MESSAGE
              MOVE 404 TO WS-RETURN-CODE
           END-IF.
           
       READ-CUSTOMER-RECORD.
           MOVE WS-CUSTOMER-ID TO CUSTOMER-ID
           MOVE 'SAV' TO ACCOUNT-TYPE
           
           EXEC CICS READ
                FILE('${fileName}')
                INTO(${fileNameClean}-RECORD)
                RIDFLD(${fileNameClean}-KEY)
                RESP(WS-RETURN-CODE)
           END-EXEC
           
           IF WS-RETURN-CODE = DFHRESP(NORMAL)
              MOVE 'Y' TO WS-RECORD-FOUND
           ELSE
              MOVE 'N' TO WS-RECORD-FOUND
           END-IF.
           
       CALCULATE-NEW-BALANCE.
           IF LS-TRANSACTION-TYPE = 'C'
              COMPUTE WS-NEW-BALANCE = ACCOUNT-BALANCE + WS-TRANSACTION-AMOUNT
           ELSE
              COMPUTE WS-NEW-BALANCE = ACCOUNT-BALANCE - WS-TRANSACTION-AMOUNT
           END-IF
           
           COMPUTE WS-AVAILABLE-CREDIT = CREDIT-LIMIT - WS-NEW-BALANCE
           COMPUTE WS-UTILIZATION-PCT = 
               (WS-NEW-BALANCE / CREDIT-LIMIT) * 100.
               
       VALIDATE-TRANSACTION.
           IF LS-TRANSACTION-TYPE = 'D' AND WS-NEW-BALANCE < ZERO
              IF WS-NEW-BALANCE < (OVERDRAFT-LIMIT * -1)
                 MOVE 'Insufficient funds' TO WS-ERROR-MESSAGE
                 MOVE 200 TO WS-RETURN-CODE
              END-IF
           END-IF
           
           IF WS-UTILIZATION-PCT > 95
              MOVE 'Credit limit exceeded' TO WS-ERROR-MESSAGE
              MOVE 201 TO WS-RETURN-CODE
           END-IF.
           
       UPDATE-CUSTOMER-RECORD.
           MOVE WS-NEW-BALANCE TO ACCOUNT-BALANCE
           MOVE WS-CURRENT-DATE TO LAST-ACTIVITY-DATE
           MOVE WS-CURRENT-TIME TO LAST-MAINT-TIME
           ADD 1 TO TRANSACTION-COUNT
           
           IF WS-NEW-BALANCE > CREDIT-LIMIT
              MOVE 'H' TO STATUS-CODE
           ELSE
              IF WS-NEW-BALANCE < ZERO
                 MOVE 'O' TO STATUS-CODE
              ELSE
                 MOVE 'A' TO STATUS-CODE
              END-IF
           END-IF
           
           EXEC CICS REWRITE
                FILE('${fileName}')
                FROM(${fileNameClean}-RECORD)
                RESP(WS-RETURN-CODE)
           END-EXEC
           
           IF WS-RETURN-CODE NOT = DFHRESP(NORMAL)
              MOVE 'Update failed' TO WS-ERROR-MESSAGE
              MOVE 500 TO WS-RETURN-CODE
           ELSE
              MOVE 'Y' TO WS-UPDATE-FLAG
           END-IF.

       CLEANUP-PROGRAM.
           MOVE WS-RETURN-CODE TO LS-RETURN-CODE
           MOVE WS-ERROR-MESSAGE TO LS-ERROR-MESSAGE
           IF WS-UPDATE-FLAG = 'Y'
              EXEC CICS SYNCPOINT END-EXEC
           END-IF.`;
        
    } else if (programType === 'INQUIRY') {
        return baseProgram + `
           MOVE LS-CUSTOMER-ID TO WS-CUSTOMER-ID
           
           PERFORM READ-CUSTOMER-RECORD
           IF WS-RECORD-FOUND = 'Y'
              PERFORM FORMAT-CUSTOMER-DATA
              PERFORM CALCULATE-DISPLAY-VALUES
           ELSE
              MOVE 'Customer not found' TO WS-ERROR-MESSAGE
              MOVE 404 TO WS-RETURN-CODE
           END-IF.
           
       READ-CUSTOMER-RECORD.
           MOVE WS-CUSTOMER-ID TO CUSTOMER-ID
           MOVE 'SAV' TO ACCOUNT-TYPE
           
           EXEC CICS READ
                FILE('${fileName}')
                INTO(${fileNameClean}-RECORD)
                RIDFLD(${fileNameClean}-KEY)
                RESP(WS-RETURN-CODE)
           END-EXEC
           
           IF WS-RETURN-CODE = DFHRESP(NORMAL)
              MOVE 'Y' TO WS-RECORD-FOUND
           ELSE
              MOVE 'N' TO WS-RECORD-FOUND
           END-IF.
           
       FORMAT-CUSTOMER-DATA.
           STRING CUSTOMER-NAME DELIMITED BY SPACE
                  ' - Account: ' DELIMITED BY SIZE
                  CUSTOMER-ID DELIMITED BY SIZE
                  INTO WS-FULL-NAME
           END-STRING
           
           STRING CUSTOMER-ADDRESS DELIMITED BY SPACE
                  ', Phone: ' DELIMITED BY SIZE
                  PHONE-NUMBER DELIMITED BY SIZE
                  INTO WS-FORMATTED-ADDRESS
           END-STRING
           
           MOVE ACCOUNT-BALANCE TO WS-DISPLAY-BALANCE.
           
       CALCULATE-DISPLAY-VALUES.
           COMPUTE WS-AVAILABLE-CREDIT = CREDIT-LIMIT - ACCOUNT-BALANCE
           COMPUTE WS-UTILIZATION-PCT = 
               (ACCOUNT-BALANCE / CREDIT-LIMIT) * 100
           COMPUTE WS-MONTHLY-INTEREST = 
               ACCOUNT-BALANCE * (INTEREST-RATE / 12).

       CLEANUP-PROGRAM.
           MOVE WS-RETURN-CODE TO LS-RETURN-CODE
           MOVE WS-ERROR-MESSAGE TO LS-ERROR-MESSAGE.`;
       
    } else if (programType === 'REPORT') {
        return baseProgram + `
           PERFORM OPEN-BROWSE-OPERATION
           PERFORM PROCESS-ALL-RECORDS
           PERFORM CLOSE-BROWSE-OPERATION.
           
       OPEN-BROWSE-OPERATION.
           MOVE LOW-VALUES TO ${fileNameClean}-KEY
           
           EXEC CICS STARTBR
                FILE('${fileName}')
                RIDFLD(${fileNameClean}-KEY)
                RESP(WS-RETURN-CODE)
           END-EXEC
           
           IF WS-RETURN-CODE NOT = DFHRESP(NORMAL)
              MOVE 'Browse start failed' TO WS-ERROR-MESSAGE
              MOVE 300 TO WS-RETURN-CODE
           END-IF.
           
       PROCESS-ALL-RECORDS.
           PERFORM UNTIL WS-RETURN-CODE NOT = DFHRESP(NORMAL)
              PERFORM READ-NEXT-RECORD
              IF WS-RETURN-CODE = DFHRESP(NORMAL)
                 PERFORM PROCESS-RECORD-FOR-REPORT
              END-IF
           END-PERFORM.
           
       READ-NEXT-RECORD.
           EXEC CICS READNEXT
                FILE('${fileName}')
                INTO(${fileNameClean}-RECORD)
                RIDFLD(${fileNameClean}-KEY)
                RESP(WS-RETURN-CODE)
           END-EXEC.
           
       PROCESS-RECORD-FOR-REPORT.
           STRING CUSTOMER-NAME DELIMITED BY SPACE
                  ' | Balance: ' DELIMITED BY SIZE
                  ACCOUNT-BALANCE DELIMITED BY SIZE
                  ' | Status: ' DELIMITED BY SIZE
                  STATUS-CODE DELIMITED BY SIZE
                  INTO LS-CUSTOMER-DATA
           END-STRING
           
           COMPUTE WS-TOTAL-EXPOSURE = 
               WS-TOTAL-EXPOSURE + ACCOUNT-BALANCE.
               
       CLOSE-BROWSE-OPERATION.
           EXEC CICS ENDBR
                FILE('${fileName}')
                RESP(WS-RETURN-CODE)
           END-EXEC.

       CLEANUP-PROGRAM.
           MOVE WS-RETURN-CODE TO LS-RETURN-CODE
           MOVE WS-ERROR-MESSAGE TO LS-ERROR-MESSAGE.`;
   
    } else if (programType === 'DELETE') {
        return baseProgram + `
           MOVE LS-CUSTOMER-ID TO WS-CUSTOMER-ID
           
           PERFORM READ-CUSTOMER-RECORD
           IF WS-RECORD-FOUND = 'Y'
              PERFORM VALIDATE-DELETE-REQUEST
              IF WS-RETURN-CODE = ZERO
                 PERFORM DELETE-CUSTOMER-RECORD
              END-IF
           ELSE
              MOVE 'Customer not found' TO WS-ERROR-MESSAGE
              MOVE 404 TO WS-RETURN-CODE
           END-IF.
           
       READ-CUSTOMER-RECORD.
           MOVE WS-CUSTOMER-ID TO CUSTOMER-ID
           MOVE 'SAV' TO ACCOUNT-TYPE
           
           EXEC CICS READ
                FILE('${fileName}')
                INTO(${fileNameClean}-RECORD)
                RIDFLD(${fileNameClean}-KEY)
                UPDATE
                RESP(WS-RETURN-CODE)
           END-EXEC
           
           IF WS-RETURN-CODE = DFHRESP(NORMAL)
              MOVE 'Y' TO WS-RECORD-FOUND
           ELSE
              MOVE 'N' TO WS-RECORD-FOUND
           END-IF.
           
       VALIDATE-DELETE-REQUEST.
           IF ACCOUNT-BALANCE NOT = ZERO
              MOVE 'Cannot delete account with balance' TO WS-ERROR-MESSAGE
              MOVE 400 TO WS-RETURN-CODE
           END-IF
           
           IF STATUS-CODE = 'H'
              MOVE 'Cannot delete account on hold' TO WS-ERROR-MESSAGE
              MOVE 401 TO WS-RETURN-CODE
           END-IF.
           
       DELETE-CUSTOMER-RECORD.
           EXEC CICS DELETE
                FILE('${fileName}')
                RESP(WS-RETURN-CODE)
           END-EXEC
           
           IF WS-RETURN-CODE NOT = DFHRESP(NORMAL)
              MOVE 'Delete operation failed' TO WS-ERROR-MESSAGE
              MOVE 500 TO WS-RETURN-CODE
           END-IF.

       CLEANUP-PROGRAM.
           MOVE WS-RETURN-CODE TO LS-RETURN-CODE
           MOVE WS-ERROR-MESSAGE TO LS-ERROR-MESSAGE.`;
    }
    
    return baseProgram;
}
}            

// Enhanced Chat System with Complete vLLM Response Generation
class ChatSystem {
    static conversationId = 1; // Example conversation ID
    static responseTemplates = {
        fieldMapping: {
            analysis: "Based on the field mapping analysis for **{fileName}**, I found {fieldCount} fields across {programCount} programs.",
            oracleRecommendations: "For Oracle migration, here are the key data type conversions:\n\n{conversions}",
            businessLogic: "The business logic patterns detected include:\n\n{patterns}",
            cicsOperations: "CICS operations found:\n\n{cicsOps}"
        },
        modernization: {
            strategy: "For mainframe modernization, I recommend a phased approach focusing on {components}.",
            riskAssessment: "Risk analysis shows {lowRisk} low-risk items, {mediumRisk} medium-risk, and {highRisk} high-risk components.",
            technology: "Technology stack recommendations:\n‚Ä¢ **Database**: Oracle 19c+ with PL/SQL\n‚Ä¢ **Application**: {appStack}\n‚Ä¢ **Integration**: REST APIs for service interfaces"
        },
        dependencies: {
            relationships: "Dependency analysis shows {depCount} relationships across {componentCount} components.",
            impact: "Impact analysis indicates that changes to {criticalComponents} would affect multiple downstream systems.",
            modernization: "For dependency modernization:\n{recommendations}"
        }
    }

    static async sendMessage(userMessage) {
        const messageTokens = TokenManager.estimateTokens(userMessage);
        
        try {
            // Build relevant context
            const context = await this.buildRelevantContext(userMessage);
            const contextTokens = TokenManager.estimateTokens(JSON.stringify(context));
            
            // Check token limits and adjust context if needed
            let finalContext = context;
            const totalInputTokens = messageTokens + contextTokens;
            
            if (totalInputTokens > TokenManager.EFFECTIVE_LIMIT * 0.6) {
                finalContext = await this.truncateContext(context, userMessage);
            }

            // Generate intelligent response
            const response = await this.generateIntelligentResponse(userMessage, finalContext);
            const responseTokens = TokenManager.estimateTokens(response);

            // Log conversation with full context
            await db.saveChatMessage(this.conversationId, 'user', userMessage, finalContext, messageTokens);
            await db.saveChatMessage(this.conversationId, 'assistant', response, finalContext, responseTokens);

            // Update token usage
            TokenManager.updateTokenUsage(0, messageTokens + responseTokens);

            return {
                response: response,
                context: finalContext,
                tokensUsed: messageTokens + responseTokens,
                contextTypes: Object.keys(finalContext).filter(key => finalContext[key]?.length > 0)
            };
            
        } catch (error) {
            console.error('Chat system error:', error);
            const errorResponse = `I apologize, but I encountered an error processing your request: ${error.message}. Please try rephrasing your question or contact support if the issue persists.`;
            
            await db.saveChatMessage(this.conversationId, 'user', userMessage, {}, messageTokens);
            await db.saveChatMessage(this.conversationId, 'assistant', errorResponse, {}, TokenManager.estimateTokens(errorResponse));
            
            return {
                response: errorResponse,
                context: {},
                tokensUsed: messageTokens + TokenManager.estimateTokens(errorResponse),
                contextTypes: []
            };
        }
    }

    static async buildRelevantContext(message) {
        const context = {};
        const lowerMessage = message.toLowerCase();

        // Field mapping context
        if (lowerMessage.includes('field') || lowerMessage.includes('mapping') || lowerMessage.includes('oracle')) {
            context.fieldMappings = AppState.fieldMappings.slice(-10);
            context.fieldMappingsSummary = {
                totalFields: AppState.fieldMappings.length,
                businessLogicTypes: [...new Set(AppState.fieldMappings.map(f => f.businessLogicType))],
                programsInvolved: [...new Set(AppState.fieldMappings.flatMap(f => f.programsInvolved))],
                averageConfidence: AppState.fieldMappings.reduce((sum, f) => sum + f.confidenceScore, 0) / AppState.fieldMappings.length
            };
        }

        // Component context
        if (lowerMessage.includes('component') || lowerMessage.includes('program') || lowerMessage.includes('cobol')) {
            context.components = AppState.components.slice(-5);
            context.componentsSummary = {
                totalComponents: AppState.components.length,
                programCount: AppState.components.filter(c => c.type === 'CBL' || c.type === 'COB').length,
                copybookCount: AppState.components.filter(c => c.type === 'COPY').length,
                totalFields: AppState.components.reduce((sum, c) => sum + (c.fields?.length || 0), 0),
                totalLines: AppState.components.reduce((sum, c) => sum + (c.totalLines || 0), 0)
            };
        }

        // Dependency context
        if (lowerMessage.includes('dependency') || lowerMessage.includes('relationship') || lowerMessage.includes('call')) {
            context.dependencies = AppState.dependencies.slice(-10);
            context.dependenciesSummary = {
                totalDependencies: AppState.dependencies.length,
                relationshipTypes: [...new Set(AppState.dependencies.map(d => d.relationshipType))],
                mostReferencedComponents: this.getMostReferencedComponents(AppState.dependencies)
            };
        }

        // CICS context
        if (lowerMessage.includes('cics') || lowerMessage.includes('transaction') || lowerMessage.includes('read') || lowerMessage.includes('write')) {
            const cicsOperations = this.extractCICSFromComponents();
            context.cicsOperations = cicsOperations.slice(-10);
            context.cicsSummary = {
                totalOperations: cicsOperations.length,
                operationTypes: [...new Set(cicsOperations.map(op => op.operation))],
                categories: [...new Set(cicsOperations.map(op => op.category))]
            };
        }

        // Modernization context
        if (lowerMessage.includes('moderniz') || lowerMessage.includes('migrat') || lowerMessage.includes('transform')) {
            context.modernizationMetrics = {
                complexity: this.calculateModernizationComplexity(),
                riskAssessment: this.calculateRiskAssessment(),
                recommendations: this.generateModernizationRecommendations()
            };
        }

        // Conversation history
        const recentMessages = await db.getConversationHistory(3);
        context.conversationHistory = recentMessages;

        return context;
    }

    static async truncateContext(context, message) {
        // Smart context truncation to fit token limits
        const priorityOrder = ['fieldMappings', 'components', 'dependencies', 'cicsOperations', 'modernizationMetrics'];
        const truncatedContext = {};
        let currentTokens = TokenManager.estimateTokens(message);
        
        for (const key of priorityOrder) {
            if (context[key]) {
                const keyTokens = TokenManager.estimateTokens(JSON.stringify(context[key]));
                if (currentTokens + keyTokens < TokenManager.EFFECTIVE_LIMIT * 0.6) {
                    truncatedContext[key] = context[key];
                    currentTokens += keyTokens;
                }
            }
        }
        
        return truncatedContext;
    }

    static async generateIntelligentResponse(message, context) {
        const systemPrompt = `You are an expert mainframe modernization consultant specializing in COBOL to Oracle migrations. 
You help analyze mainframe code, provide Oracle conversion recommendations, and suggest modernization strategies.

Context available:
- Field mappings: ${context.fieldMappings?.length || 0} analyzed
- Components: ${context.components?.length || 0} programs/copybooks  
- Dependencies: ${context.dependencies?.length || 0} relationships
- CICS operations: ${context.cicsOperations?.length || 0} transactions

Provide helpful, specific advice based on the available context data.`;

        try {
            // Make REAL vLLM API call for chat
            const llmResponse = await VLLMAPIManager.makeAPICall(message, systemPrompt, 1500);
            return llmResponse.content;

        } catch (error) {
            console.error('Chat vLLM API call failed, using fallback:', error);
            
            // Fallback to rule-based responses
            const lowerMessage = message.toLowerCase();
            
            if (lowerMessage.includes('field mapping')) {
                return this.generateFieldMappingResponse(message, context);
            } else if (lowerMessage.includes('oracle')) {
                return this.generateOracleConversionResponse(message, context);
            } else if (lowerMessage.includes('cics')) {
                return this.generateCICSResponse(message, context);
            } else {
                return `I apologize, but I'm currently having trouble connecting to the vLLM API. However, I can still help you with:

‚Ä¢ **Field Mapping Analysis**: Understanding data structures and Oracle conversions
‚Ä¢ **Business Logic Patterns**: MOVE, COMPUTE, conditional operations
‚Ä¢ **CICS Operations**: Transaction processing modernization
‚Ä¢ **Dependency Analysis**: Component relationships and impact

Please try your question again, or upload some COBOL files to analyze first.`;
            }
        }
    }

    static getMostReferencedComponents(dependencies) {
        const componentCounts = {};
        dependencies.forEach(dep => {
            componentCounts[dep.targetComponent] = (componentCounts[dep.targetComponent] || 0) + 1;
        });
        
        return Object.entries(componentCounts)
            .sort(([,a], [,b]) => b - a)
            .slice(0, 5)
            .map(([component, count]) => ({ component, count }));
    }

    static extractCICSFromComponents() {
        const allCicsOps = [];
        AppState.components.forEach(component => {
            if (component.cicsOperations) {
                allCicsOps.push(...component.cicsOperations);
            }
        });
        return allCicsOps;
    }

    static calculateModernizationComplexity() {
        const totalComponents = AppState.components.length;
        const totalDependencies = AppState.dependencies.length;
        const cicsOperations = this.extractCICSFromComponents().length;
        const businessLogicComplexity = AppState.fieldMappings.filter(f => 
            f.businessLogicType === 'CONDITIONAL' || f.businessLogicType === 'DERIVED'
        ).length;

        const complexityScore = (
            (totalComponents * 0.3) +
            (totalDependencies * 0.2) +
            (cicsOperations * 0.3) +
            (businessLogicComplexity * 0.2)
        ) / 10;

        return {
            score: Math.min(complexityScore, 10),
            level: complexityScore < 3 ? 'Low' : complexityScore < 7 ? 'Medium' : 'High',
            factors: {
                componentCount: totalComponents,
                dependencyCount: totalDependencies,
                cicsComplexity: cicsOperations,
                businessLogicComplexity: businessLogicComplexity
            }
        };
    }

    static calculateRiskAssessment() {
        const components = AppState.components;
        const dependencies = AppState.dependencies;
        const fieldMappings = AppState.fieldMappings;

        const lowRisk = components.filter(c => 
            (c.dependencies?.length || 0) < 3 && 
            (c.businessLogic?.length || 0) < 5
        ).length;

        const highRisk = components.filter(c => 
            (c.dependencies?.length || 0) > 10 || 
            (c.businessLogic?.filter(bl => bl.type === 'CONDITIONAL')?.length || 0) > 3
        ).length;

        const mediumRisk = components.length - lowRisk - highRisk;

        return {
            lowRisk,
            mediumRisk,
            highRisk,
            totalComponents: components.length,
            riskFactors: {
                complexDependencies: dependencies.filter(d => d.relationshipType === 'CICS_FILE_ACCESS').length,
                conditionalLogic: fieldMappings.filter(f => f.businessLogicType === 'CONDITIONAL').length,
                multiSourceFields: fieldMappings.filter(f => f.businessLogicType === 'MULTI_SOURCE').length
            }
        };
    }

    static generateModernizationRecommendations() {
        const recommendations = [];
        const complexity = this.calculateModernizationComplexity();
        const riskAssessment = this.calculateRiskAssessment();

        if (complexity.level === 'Low') {
            recommendations.push({
                phase: 'Phase 1 - Quick Wins',
                approach: 'Direct lift-and-shift with minimal refactoring',
                timeline: '3-6 months',
                priority: 'High'
            });
        }

        if (riskAssessment.riskFactors.complexDependencies > 5) {
            recommendations.push({
                phase: 'Phase 2 - Dependency Modernization',
                approach: 'Replace CICS file operations with database transactions',
                timeline: '6-12 months',
                priority: 'Medium'
            });
        }

        if (riskAssessment.riskFactors.conditionalLogic > 10) {
            recommendations.push({
                phase: 'Phase 3 - Business Logic Refactoring',
                approach: 'Migrate complex conditional logic to modern business rules engine',
                timeline: '9-18 months',
                priority: 'Medium'
            });
        }

        return recommendations;
    }

    // Fallback response generators for when vLLM is unavailable
    static generateFieldMappingResponse(message, context) {
        const fieldMappings = context.fieldMappings || [];
        const summary = context.fieldMappingsSummary || {};

        if (fieldMappings.length === 0) {
            return `**Field Mapping Analysis**

I can help analyze field mappings in your mainframe code. After analyzing your COBOL programs, I'll show you:

üéØ **Field Mapping Features**:
‚Ä¢ **Business Logic Detection**: MOVE, COMPUTE, conditional, calculated operations
‚Ä¢ **Data Type Conversion**: Automatic COBOL PIC to Oracle type mapping
‚Ä¢ **Multi-Program Analysis**: Consolidate logic across all programs that use a field
‚Ä¢ **Confidence Scoring**: Rate the accuracy of each field mapping
‚Ä¢ **Oracle DDL Generation**: Complete table creation scripts

Upload your COBOL programs and use the ‚≠ê Field Mapping tab to analyze specific files.`;
        }

        const logicPatterns = {};
        fieldMappings.forEach(field => {
            const type = field.businessLogicType;
            logicPatterns[type] = (logicPatterns[type] || 0) + 1;
        });

        return `**Field Mapping Analysis Results**

üìä **Summary**: ${summary.totalFields} fields analyzed across ${summary.programsInvolved?.length || 0} programs

üîç **Business Logic Patterns**:
${Object.entries(logicPatterns).map(([type, count]) => {
    const icon = {
        'MOVE': '‚û°Ô∏è',
        'DERIVED': 'üßÆ',
        'CONDITIONAL': 'üîÄ',
        'CALCULATED': 'üî¢',
        'STRING_MANIPULATION': 'üî§',
        'MULTI_SOURCE': 'üîÑ'
    }[type] || 'üìã';
    
    return `${icon} **${type}**: ${count} fields`;
}).join('\n')}

üìà **Oracle Migration Readiness**: ${(summary.averageConfidence * 100).toFixed(0)}% average confidence

üéØ **Next Steps**:
‚Ä¢ Review fields with MULTI_SOURCE logic for conflicts
‚Ä¢ Generate Oracle DDL for validated field mappings
‚Ä¢ Plan data migration scripts for complex business logic

Would you like me to generate Oracle DDL for any specific file or analyze business logic patterns in more detail?`;
    }

    static generateOracleConversionResponse(message, context) {
        const fieldMappings = context.fieldMappings || [];

        if (fieldMappings.length === 0) {
            return `**Oracle Conversion Guide**

I can help convert your COBOL data structures to Oracle. Here are the key conversion patterns:

üîÑ **Data Type Conversions**:
‚Ä¢ **PIC 9(n)** ‚Üí **NUMBER(n)**
‚Ä¢ **PIC 9(n)V9(m)** ‚Üí **NUMBER(n+m, m)**  
‚Ä¢ **PIC X(n)** ‚Üí **VARCHAR2(n)** (max 4000, else CLOB)
‚Ä¢ **COMP-3** ‚Üí **NUMBER** with packed decimal calculation
‚Ä¢ **COMP** ‚Üí **NUMBER** with binary estimation

üìä **Business Logic Migration**:
‚Ä¢ **MOVE operations** ‚Üí Direct SQL INSERT/UPDATE
‚Ä¢ **COMPUTE statements** ‚Üí PL/SQL functions or triggers
‚Ä¢ **Conditional logic** ‚Üí CASE statements or stored procedures
‚Ä¢ **String operations** ‚Üí Oracle string functions

Upload COBOL programs to see specific conversion recommendations for your fields.`;
        }

        const conversionExamples = fieldMappings.slice(0, 5).map(field => {
            return `‚Ä¢ **${field.fieldName}**: ${field.mainframeDataType} ‚Üí ${field.oracleDataType}`;
        }).join('\n');

        return `**Oracle Conversion Analysis**

üîÑ **Data Type Conversions**:
${conversionExamples}

üìã **Migration Strategy**:
‚Ä¢ **${fieldMappings.filter(f => f.businessLogicType === 'MOVE').length} MOVE operations**: Direct field assignments ‚Üí SQL DML
‚Ä¢ **${fieldMappings.filter(f => f.businessLogicType === 'CALCULATED').length} Calculated fields**: Arithmetic operations ‚Üí PL/SQL functions
‚Ä¢ **${fieldMappings.filter(f => f.businessLogicType === 'CONDITIONAL').length} Conditional logic**: IF-THEN patterns ‚Üí CASE statements

üéØ **Generated Oracle DDL Example**:
\`\`\`sql
CREATE TABLE customer_data (
  customer_id NUMBER(10),
  account_balance NUMBER(11,2),
  status_code VARCHAR2(3),
  last_activity_date DATE
);
\`\`\`

Would you like me to generate complete Oracle DDL for a specific file or provide detailed migration scripts?`;
    }

    static generateCICSResponse(message, context) {
        const cicsOps = context.cicsOperations || [];
        const cicsSummary = context.cicsSummary || {};

        if (cicsOps.length === 0) {
            return `**CICS Operations Modernization**

I can help analyze CICS operations in your mainframe code. Here's what I look for:

üîç **CICS Operation Categories**:
‚Ä¢ **üìñ Read Operations**: READ, RECEIVE, READNEXT, READPREV, STARTBR
‚Ä¢ **‚úèÔ∏è Write Operations**: WRITE, SEND, REWRITE, DELETE
‚Ä¢ **üîÑ Transaction Operations**: LINK, XCTL, RETURN, SYNCPOINT
‚Ä¢ **üíª Terminal Operations**: SEND, RECEIVE, CONVERSE
‚Ä¢ **üìã Queue Operations**: WRITEQ, READQ, DELETEQ

Upload COBOL programs with CICS commands to see detailed modernization strategies.`;
        }

        const opsByCategory = {};
        cicsOps.forEach(op => {
            if (!opsByCategory[op.category]) {
                opsByCategory[op.category] = [];
            }
            opsByCategory[op.category].push(op);
        });

        return `**CICS Operations Analysis**

üìä **Summary**: ${cicsSummary.totalOperations} CICS operations found

üéØ **Operation Categories**:
${Object.entries(opsByCategory).map(([category, ops]) => {
    const icon = {
        'READ_operation': 'üìñ',
        'write_operation': '‚úèÔ∏è',
        'transaction_operation': 'üîÑ',
        'terminal_operation': 'üíª',
        'queue_operation': 'üìã'
    }[category.toLowerCase()] || 'üîß';
    
    return `${icon} **${category.replace('_', ' ').toUpperCase()}**: ${ops.length} operations`;
}).join('\n')}

üèóÔ∏è **Modernization Strategy**:

**üìñ File Operations** ‚Üí **Database Transactions**:
‚Ä¢ Replace EXEC CICS READ with SELECT statements
‚Ä¢ Convert EXEC CICS WRITE to INSERT/UPDATE operations
‚Ä¢ Implement connection pooling and transaction management

**üíª Terminal Operations** ‚Üí **Web Services**:
‚Ä¢ Replace 3270 terminal interaction with REST APIs
‚Ä¢ Convert SEND/RECEIVE to JSON request/response patterns
‚Ä¢ Implement modern authentication and session management

**Example Conversion**:
\`\`\`sql
-- CICS: EXEC CICS READ FILE('CUSTOMER') INTO(CUST-REC) END-EXEC
-- Oracle: SELECT * FROM customers WHERE customer_id = :cust_id;
\`\`\`

Would you like specific modernization recommendations for any CICS operation patterns?`;
    }
}

// Enhanced Dependency Visualization with Interactive Network
class DependencyVisualizer {
    static createInteractiveDependencyMap(dependencies) {
        const nodes = new Set();
        const edges = [];

        // Build nodes and edges from dependencies
        dependencies.forEach(dep => {
            nodes.add(dep.sourceComponent);
            nodes.add(dep.targetComponent);
            
            edges.push({
                source: dep.sourceComponent,
                target: dep.targetComponent,
                type: dep.relationshipType,
                confidence: dep.confidenceScore,
                interface: dep.interfaceType
            });
        });

        // Create interactive visualization
        const nodeArray = Array.from(nodes).map(node => ({
            id: node,
            type: this.getNodeType(node),
            size: this.getNodeSize(node, edges),
            color: this.getNodeColor(node)
        }));

        return {
            nodes: nodeArray,
            edges: edges,
            layout: 'force-directed',
            interactivity: {
                zoomable: true,
                draggable: true,
                selectable: true
            }
        };
    }

    static getNodeType(nodeName) {
        const extension = nodeName.split('.').pop()?.toUpperCase();
        if (['CBL', 'COB'].includes(extension)) return 'program';
        if (extension === 'COPY') return 'copybook';
        if (extension === 'JCL') return 'job';
        if (nodeName.includes('-FILE') || nodeName.includes('FILE')) return 'file';
        return 'unknown';
    }

    static getNodeSize(nodeName, edges) {
        const connections = edges.filter(e => 
            e.source === nodeName || e.target === nodeName
        ).length;
        return Math.max(10, Math.min(50, connections * 3));
    }

    static getNodeColor(nodeName) {
        const type = this.getNodeType(nodeName);
        const colors = {
            program: '#667eea',
            copybook: '#27ae60',
            job: '#f39c12',
            file: '#e74c3c',
            unknown: '#95a5a6'
        };
        return colors[type] || colors.unknown;
    }

    static generateVisualizationHTML(dependencyMap) {
        return `
        <div class="dependency-visualization" style="width: 100%; height: 400px; border: 1px solid #ddd; border-radius: 8px; position: relative; background: #f8f9fa;">
            <div class="viz-header" style="padding: 15px; border-bottom: 1px solid #ddd; background: white; border-radius: 8px 8px 0 0;">
                <h4 style="margin: 0; color: #667eea;">üìä Interactive Dependency Map</h4>
                <div style="font-size: 12px; color: #666; margin-top: 5px;">
                    ${dependencyMap.nodes.length} components, ${dependencyMap.edges.length} relationships
                </div>
            </div>
            <div class="viz-content" style="padding: 20px; height: calc(100% - 70px); overflow: auto;">
                <div class="viz-network" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; align-items: start;">
                    ${dependencyMap.nodes.map(node => `
                        <div class="network-node" style="
                            background: ${node.color}; 
                            color: white; 
                            padding: 10px; 
                            border-radius: 8px; 
                            text-align: center; 
                            font-size: 12px;
                            cursor: pointer;
                            transition: transform 0.2s ease;
                        " 
                        onmouseover="this.style.transform='scale(1.05)'"
                        onmouseout="this.style.transform='scale(1)'"
                        onclick="showNodeDetails('${node.id}')">
                            <div style="font-weight: 600;">${node.id}</div>
                            <div style="font-size: 10px; opacity: 0.8;">${node.type}</div>
                            <div style="font-size: 10px; opacity: 0.8;">${this.getConnectionCount(node.id, dependencyMap.edges)} connections</div>
                        </div>
                    `).join('')}
                </div>
                
                <div class="dependency-legend" style="margin-top: 20px; padding: 15px; background: white; border-radius: 8px; border: 1px solid #e0e0e0;">
                    <h5 style="margin: 0 0 10px 0; color: #667eea;">üîó Relationship Types</h5>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; font-size: 12px;">
                        ${[...new Set(dependencyMap.edges.map(e => e.type))].map(type => `
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <div style="width: 12px; height: 12px; background: #667eea; border-radius: 50%;"></div>
                                <span>${type.replace('_', ' ')}</span>
                                <span style="color: #666;">(${dependencyMap.edges.filter(e => e.type === type).length})</span>
                            </div>
                        `).join('')}
                    </div>
                </div>
            </div>
        </div>
        `;
    }

    static getConnectionCount(nodeId, edges) {
        return edges.filter(e => e.source === nodeId || e.target === nodeId).length;
    }
}

function updateDependenciesFlow() {
    const container = document.getElementById('dependenciesFlow');
    if (!container) return;
    
    if (AppState.dependencies.length === 0 && AppState.components.length === 0) {
        container.innerHTML = `
            <div style="text-align: center; padding: 40px; color: #666;">
                <div style="font-size: 48px; margin-bottom: 20px;">üîó</div>
                <h3>No Dependencies Found</h3>
                <p>Upload and analyze COBOL programs to see component relationships, program calls, copybook includes, and file operations.</p>
            </div>
        `;
        return;
    }
    
    // Create city-view dependency map
    const cityViewHTML = createCityViewDependencyMap();
    container.innerHTML = cityViewHTML;
}

function createCityViewDependencyMap() {
    const components = AppState.components;
    const dependencies = AppState.dependencies;
    
    // Categorize components by data flow position
    const flowCategories = categorizeComponentsByFlow(components, dependencies);
    
    return `
        <div class="city-dependency-map" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 15px; padding: 30px; color: white; position: relative; min-height: 600px;">
            <div class="city-header" style="text-align: center; margin-bottom: 30px;">
                <h2 style="margin: 0; font-size: 24px;">üèôÔ∏è Business System City View</h2>
                <p style="margin: 10px 0 0 0; opacity: 0.9;">Data flow visualization with ${components.length} business components</p>
            </div>
            
            <!-- Input Sources District -->
            <div class="flow-section" style="margin-bottom: 25px;">
                <h3 style="color: #4CAF50; margin-bottom: 15px;">üì• INPUT SOURCES</h3>
                <div class="input-district" style="display: flex; flex-wrap: wrap; gap: 15px; justify-content: center; min-height: 120px; background: rgba(76, 175, 80, 0.1); border-radius: 12px; padding: 20px; border: 2px dashed rgba(76, 175, 80, 0.5);">
                    ${flowCategories.inputs.map(component => createBusinessBuilding(component, 'input')).join('')}
                    ${flowCategories.inputs.length === 0 ? '<div style="color: rgba(255,255,255,0.7); align-self: center;">No input sources identified</div>' : ''}
                </div>
            </div>
            
            <!-- Flow Arrows -->
            <div style="text-align: center; margin: 20px 0;">
                <div style="font-size: 30px; animation: pulse 2s infinite;">‚¨áÔ∏è</div>
            </div>
            
            <!-- Interface/Processing District -->
            <div class="flow-section" style="margin-bottom: 25px;">
                <h3 style="color: #FF9800; margin-bottom: 15px;">‚öôÔ∏è PROCESSING INTERFACES</h3>
                <div class="interface-district" style="display: flex; flex-wrap: wrap; gap: 15px; justify-content: center; min-height: 120px; background: rgba(255, 152, 0, 0.1); border-radius: 12px; padding: 20px; border: 2px dashed rgba(255, 152, 0, 0.5);">
                    ${flowCategories.processors.map(component => createBusinessBuilding(component, 'processor')).join('')}
                    ${flowCategories.processors.length === 0 ? '<div style="color: rgba(255,255,255,0.7); align-self: center;">No processing interfaces identified</div>' : ''}
                </div>
            </div>
            
            <!-- Flow Arrows -->
            <div style="text-align: center; margin: 20px 0;">
                <div style="font-size: 30px; animation: pulse 2s infinite;">‚¨áÔ∏è</div>
            </div>
            
            <!-- Output Destinations District -->
            <div class="flow-section" style="margin-bottom: 25px;">
                <h3 style="color: #F44336; margin-bottom: 15px;">üì§ OUTPUT DESTINATIONS</h3>
                <div class="output-district" style="display: flex; flex-wrap: wrap; gap: 15px; justify-content: center; min-height: 120px; background: rgba(244, 67, 54, 0.1); border-radius: 12px; padding: 20px; border: 2px dashed rgba(244, 67, 54, 0.5);">
                    ${flowCategories.outputs.map(component => createBusinessBuilding(component, 'output')).join('')}
                    ${flowCategories.outputs.length === 0 ? '<div style="color: rgba(255,255,255,0.7); align-self: center;">No output destinations identified</div>' : ''}
                </div>
            </div>
            
            <!-- Missing Dependencies Alert -->
            ${flowCategories.orphaned.length > 0 ? `
                <div class="missing-deps" style="background: rgba(156, 39, 176, 0.2); border: 2px dashed rgba(156, 39, 176, 0.6); border-radius: 12px; padding: 20px; margin-top: 25px;">
                    <h3 style="color: #E91E63; margin-bottom: 15px;">‚ö†Ô∏è ISOLATED COMPONENTS (Missing Dependencies)</h3>
                    <div style="display: flex; flex-wrap: wrap; gap: 15px; justify-content: center;">
                        ${flowCategories.orphaned.map(component => createBusinessBuilding(component, 'orphaned')).join('')}
                    </div>
                    <p style="margin-top: 15px; font-size: 12px; opacity: 0.8; text-align: center;">
                        These components have no clear input/output relationships. Consider reviewing their integration points.
                    </p>
                </div>
            ` : ''}
            
            <!-- Data Flow Rivers -->
            <div class="dependency-rivers" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; opacity: 0.3;">
                ${generateDataFlowRivers(dependencies)}
            </div>
            
            <style>
                @keyframes pulse { 0%, 100% { opacity: 0.5; } 50% { opacity: 1; } }
                @keyframes flow { 0%, 100% { opacity: 0.3; transform: translateY(0); } 50% { opacity: 0.8; transform: translateY(10px); } }
            </style>
        </div>
        
        <div class="city-analytics" style="margin-top: 20px; display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
            ${generateFlowAnalytics(flowCategories)}
        </div>
    `;
}

function categorizeComponentsByFlow(components, dependencies) {
    const inputs = [];
    const processors = [];
    const outputs = [];
    const orphaned = [];
    
    components.forEach(component => {
        const incomingDeps = dependencies.filter(d => d.targetComponent === component.name).length;
        const outgoingDeps = dependencies.filter(d => d.sourceComponent === component.name).length;
        const componentName = component.name.toLowerCase();
        
        // Determine component category based on dependencies and naming patterns
        if (incomingDeps === 0 && outgoingDeps > 0) {
            // Pure input source
            inputs.push(component);
        } else if (incomingDeps > 0 && outgoingDeps === 0) {
            // Pure output destination  
            outputs.push(component);
        } else if (incomingDeps > 0 && outgoingDeps > 0) {
            // Processing interface
            processors.push(component);
        } else if (incomingDeps === 0 && outgoingDeps === 0) {
            // Orphaned component
            orphaned.push(component);
        } else {
            // Default to processor if unclear
            processors.push(component);
        }
    });
    
    return { inputs, processors, outputs, orphaned };
}

function createBusinessBuilding(component, flowType) {
    const flowColors = {
        'input': '#4CAF50',
        'processor': '#FF9800', 
        'output': '#F44336',
        'orphaned': '#9C27B0'
    };
    
    const flowIcons = {
        'input': 'üì•',
        'processor': '‚öôÔ∏è',
        'output': 'üì§', 
        'orphaned': '‚ùì'
    };
    
    const color = flowColors[flowType];
    const icon = flowIcons[flowType];
    const displayName = component.displayName || component.friendlyName || component.name;
    
    return `
        <div class="business-building" 
             style="background: linear-gradient(145deg, ${color}, ${color}cc); 
                    min-width: 140px; 
                    height: 80px; 
                    border-radius: 8px; 
                    position: relative; 
                    cursor: pointer;
                    transition: all 0.3s ease;
                    border: 2px solid rgba(255,255,255,0.3);
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    text-align: center;
                    padding: 10px;"
             onclick="showBuildingDetails('${component.name}')"
             onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 8px 25px rgba(0,0,0,0.3)'"
             onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'">
            
            <div style="font-size: 20px; margin-bottom: 5px;">${icon}</div>
            
            <div style="font-size: 11px; font-weight: 600; line-height: 1.2; overflow: hidden; text-overflow: ellipsis;">
                ${displayName.length > 25 ? displayName.substring(0, 25) + '...' : displayName}
            </div>
            
            <div style="font-size: 9px; opacity: 0.8; margin-top: 2px;">
                ${component.type} ${component.fields?.length ? `(${component.fields.length} fields)` : ''}
            </div>
            
            ${component.type === 'RECORD_LAYOUT' ? `
                <div style="position: absolute; bottom: 3px; left: 3px; right: 3px; height: 2px; background: rgba(255,255,255,0.4); border-radius: 1px;"></div>
            ` : ''}
        </div>
    `;
}

function generateDataFlowRivers(dependencies) {
    return dependencies.slice(0, 15).map((dep, index) => `
        <div style="position: absolute; 
                    left: ${10 + (index % 5) * 18}%; 
                    top: ${20 + Math.floor(index / 5) * 30}%; 
                    width: 3px; 
                    height: ${40 + (index % 3) * 20}px; 
                    background: linear-gradient(180deg, transparent, rgba(255,255,255,0.6), transparent);
                    border-radius: 2px;
                    animation: flow ${2 + (index % 3)}s infinite ease-in-out;
                    animation-delay: ${index * 0.2}s;"></div>
    `).join('');
}

function generateFlowAnalytics(flowCategories) {
    return `
        <div style="background: white; padding: 20px; border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.1);">
            <h4 style="color: #4CAF50; margin: 0 0 10px 0;">üì• Input Sources</h4>
            <div style="font-size: 24px; font-weight: 600; color: #4CAF50;">${flowCategories.inputs.length}</div>
            <div style="font-size: 12px; color: #666;">Data entry points</div>
        </div>
        
        <div style="background: white; padding: 20px; border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.1);">
            <h4 style="color: #FF9800; margin: 0 0 10px 0;">‚öôÔ∏è Processors</h4>
            <div style="font-size: 24px; font-weight: 600; color: #FF9800;">${flowCategories.processors.length}</div>
            <div style="font-size: 12px; color: #666;">Business logic</div>
        </div>
        
        <div style="background: white; padding: 20px; border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.1);">
            <h4 style="color: #F44336; margin: 0 0 10px 0;">üì§ Outputs</h4>
            <div style="font-size: 24px; font-weight: 600; color: #F44336;">${flowCategories.outputs.length}</div>
            <div style="font-size: 12px; color: #666;">Reports & files</div>
        </div>
        
        <div style="background: white; padding: 20px; border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.1);">
            <h4 style="color: ${flowCategories.orphaned.length > 0 ? '#E91E63' : '#27ae60'}; margin: 0 0 10px 0;">
                ${flowCategories.orphaned.length > 0 ? '‚ö†Ô∏è' : '‚úÖ'} Integration
            </h4>
            <div style="font-size: 24px; font-weight: 600; color: ${flowCategories.orphaned.length > 0 ? '#E91E63' : '#27ae60'};">
                ${flowCategories.orphaned.length > 0 ? flowCategories.orphaned.length + ' Missing' : 'Complete'}
            </div>
            <div style="font-size: 12px; color: #666;">Dependency health</div>
        </div>
    `;
}

function createCityDistrict(districtName, components, dependencies) {
    const districtColors = {
        'PROGRAMS': '#27ae60',
        'COPYBOOKS': '#f39c12', 
        'RECORD_LAYOUTS': '#e74c3c',
        'JCL_JOBS': '#9b59b6'
    };
    
    const districtIcons = {
        'PROGRAMS': 'üè¢',
        'COPYBOOKS': 'üìö',
        'RECORD_LAYOUTS': 'üèóÔ∏è',
        'JCL_JOBS': '‚öôÔ∏è'
    };
    
    if (components.length === 0) return '';
    
    return `
        <div class="city-district" style="background: rgba(255,255,255,0.1); border-radius: 12px; padding: 20px; backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.2);">
            <div class="district-header" style="display: flex; align-items: center; margin-bottom: 15px;">
                <span style="font-size: 24px; margin-right: 10px;">${districtIcons[districtName]}</span>
                <h3 style="margin: 0; color: ${districtColors[districtName]};">${districtName.replace('_', ' ')}</h3>
                <span style="margin-left: auto; background: ${districtColors[districtName]}; padding: 4px 8px; border-radius: 12px; font-size: 12px;">${components.length}</span>
            </div>
            
            <div class="district-buildings" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px;">
                ${components.map(component => createCityBuilding(component, dependencies, districtColors[districtName])).join('')}
            </div>
        </div>
    `;
}

function createCityBuilding(component, dependencies, color) {
    const connectionCount = dependencies.filter(d => 
        d.sourceComponent === component.name || d.targetComponent === component.name
    ).length;
    
    const buildingHeight = Math.max(40, Math.min(120, connectionCount * 15 + 40));
    
    return `
        <div class="city-building" 
             style="background: linear-gradient(180deg, ${color}, ${color}dd); 
                    height: ${buildingHeight}px; 
                    border-radius: 4px 4px 0 0; 
                    position: relative; 
                    cursor: pointer;
                    transition: all 0.3s ease;
                    border: 1px solid rgba(255,255,255,0.3);"
             onclick="showBuildingDetails('${component.name}')"
             onmouseover="this.style.transform='scale(1.05)'"
             onmouseout="this.style.transform='scale(1)'">
            <div style="position: absolute; bottom: -25px; left: 50%; transform: translateX(-50%); 
                        font-size: 10px; text-align: center; white-space: nowrap; 
                        background: rgba(0,0,0,0.7); padding: 2px 6px; border-radius: 4px;">
                ${component.name.length > 12 ? component.name.substring(0, 12) + '...' : component.name}
            </div>
            <div style="position: absolute; top: 5px; right: 5px; 
                        background: rgba(255,255,255,0.9); color: ${color}; 
                        font-size: 10px; font-weight: bold; 
                        width: 16px; height: 16px; border-radius: 50%; 
                        display: flex; align-items: center; justify-content: center;">
                ${connectionCount}
            </div>
            ${component.type === 'RECORD_LAYOUT' ? `
                <div style="position: absolute; top: 25px; left: 5px; right: 5px; height: 2px; background: rgba(255,255,255,0.5);"></div>
                <div style="position: absolute; top: 35px; left: 5px; right: 5px; height: 2px; background: rgba(255,255,255,0.5);"></div>
            ` : ''}
        </div>
    `;
}

function generateConnectionStats(dependencies) {
    const connectionTypes = {};
    dependencies.forEach(dep => {
        connectionTypes[dep.relationshipType] = (connectionTypes[dep.relationshipType] || 0) + 1;
    });
    
    return Object.entries(connectionTypes).map(([type, count]) => {
        const typeIcons = {
            'COPYBOOK_INCLUDE': 'üìã',
            'PROGRAM_CALL': 'üîÑ',
            'CICS_FILE_ACCESS': 'üíæ',
            'FILE_OPERATION': 'üìÅ',
            'INTERNAL_CALL': 'üéØ'
        };
        
        return `
            <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; text-align: center;">
                <div style="font-size: 20px; margin-bottom: 5px;">${typeIcons[type] || 'üîó'}</div>
                <div style="font-weight: bold; font-size: 18px;">${count}</div>
                <div style="font-size: 11px; opacity: 0.8;">${type.replace('_', ' ')}</div>
            </div>
        `;
    }).join('');
}

function generateDependencyRivers(dependencies) {
    // Create flowing connection lines between districts
    return dependencies.slice(0, 10).map((dep, index) => `
        <div style="position: absolute; 
                    left: ${20 + index * 8}%; 
                    top: ${30 + index * 5}%; 
                    width: 2px; 
                    height: ${30 + index * 10}px; 
                    background: linear-gradient(180deg, transparent, #ffffff88, transparent);
                    animation: flow ${2 + index * 0.5}s infinite ease-in-out;"></div>
    `).join('') + `
        <style>
            @keyframes flow {
                0%, 100% { opacity: 0.3; transform: scaleY(1); }
                50% { opacity: 0.8; transform: scaleY(1.2); }
            }
        </style>
    `;
}

// Add these supporting functions
function showBuildingDetails(componentName) {
    const component = AppState.components.find(c => c.name === componentName);
    if (component) {
        viewComponentDetails(componentName);
    }
}

function toggleCityView(viewType) {
    console.log(`Switching to ${viewType} view`);
    // Implement view switching logic
    updateDependenciesFlow();
}

function exportDependencyMap() {
    const mapData = {
        components: AppState.components.map(c => ({
            name: c.name,
            type: c.type,
            fields: c.fields?.length || 0,
            dependencies: AppState.dependencies.filter(d => 
                d.sourceComponent === c.name || d.targetComponent === c.name
            ).length
        })),
        dependencies: AppState.dependencies,
        timestamp: new Date().toISOString()
    };
    
    const blob = new Blob([JSON.stringify(mapData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `dependency_map_${AppState.sessionId}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

function updateFieldMatrix() {
    const container = document.getElementById('fieldMatrix');
    if (!container) return;
    
    if (AppState.components.length === 0) {
        container.innerHTML = `
            <div style="text-align: center; padding: 40px; color: #666;">
                <div style="font-size: 48px; margin-bottom: 20px;">üéØ</div>
                <h3>No Field Analysis Available</h3>
                <p>Upload and analyze COBOL programs to see field relationships, data types, and business logic patterns.</p>
            </div>
        `;
        return;
    }
    
    // Analyze all fields with usage patterns
    const fieldAnalysis = analyzeFieldUsagePatterns();
    
    container.innerHTML = generateComprehensiveFieldMatrix(fieldAnalysis);
}

async function analyzeFieldUsagePatterns() {
    const allFields = [];
    
    // Process each component to analyze field usage
    for (const component of AppState.components) {
        if (component.fields && component.fields.length > 0) {
            for (const field of component.fields) {
                const usage = await analyzeFieldUsage(field, component);
                allFields.push({
                    ...field,
                    component: component.name,
                    componentType: component.type,
                    friendlyName: component.displayName || component.friendlyName || component.name,
                    usage: usage
                });
            }
        }
    }
    
    return categorizeFieldsByUsage(allFields);
}

async function analyzeFieldUsage(field, component) {
    const fieldName = field.name;
    const content = component.content || '';
    const businessLogic = component.businessLogic || [];
    const dependencies = component.dependencies || [];
    
    // Analyze field usage patterns
    const usage = {
        category: 'UNUSED',
        source: 'UNKNOWN',
        operations: [],
        businessPurpose: '',
        confidence: 0.5
    };
    
    // Check if field appears in business logic
    const fieldLogic = businessLogic.filter(logic => 
        logic.pattern && (
            logic.pattern.includes(fieldName) ||
            logic.source === fieldName ||
            logic.target === fieldName
        )
    );
    
    if (fieldLogic.length > 0) {
        // Determine usage category based on logic patterns
        const hasMove = fieldLogic.some(l => l.type === 'MOVE');
        const hasCompute = fieldLogic.some(l => l.type === 'DERIVED' || l.type === 'CALCULATED');
        const hasCondition = fieldLogic.some(l => l.type === 'CONDITIONAL');
        
        if (hasCompute) {
            usage.category = 'DERIVED';
            usage.source = 'CALCULATED';
            usage.businessPurpose = 'Calculated field based on business rules';
        } else if (hasMove && content.toLowerCase().includes('input')) {
            usage.category = 'INPUT';
            usage.source = 'EXTERNAL_SOURCE';
            usage.businessPurpose = 'Input data from external source';
        } else if (hasMove) {
            usage.category = 'TRANSFORMED';
            usage.source = 'DATA_MOVEMENT';
            usage.businessPurpose = 'Data transformation or movement';
        } else if (hasCondition) {
            usage.category = 'CONDITIONAL';
            usage.source = 'BUSINESS_LOGIC';
            usage.businessPurpose = 'Used in conditional business logic';
        }
        
        usage.operations = fieldLogic.map(l => l.type);
        usage.confidence = 0.8;
    } else {
        // Check if field is just defined but not used
        const fieldUsageCount = (content.match(new RegExp(fieldName, 'gi')) || []).length;
        if (fieldUsageCount <= 1) {
            usage.category = 'UNUSED';
            usage.businessPurpose = 'Defined but not actively used';
        } else {
            usage.category = 'STATIC';
            usage.source = 'REFERENCE_DATA';
            usage.businessPurpose = 'Static reference or configuration data';
            usage.confidence = 0.6;
        }
    }
    
    // Use LLM to enhance business purpose if available
    if (VLLMAPIManager.serverConfigured && fieldLogic.length > 0) {
        try {
            const businessPurpose = await generateFieldBusinessPurpose(field, fieldLogic, component);
            usage.businessPurpose = businessPurpose;
            usage.confidence = Math.min(usage.confidence + 0.2, 1.0);
        } catch (error) {
            console.warn(`Failed to generate business purpose for ${fieldName}:`, error);
        }
    }
    
    return usage;
}

async function generateFieldBusinessPurpose(field, fieldLogic, component) {
    const systemPrompt = `You are a business analyst expert. Analyze this COBOL field and its usage to determine its business purpose. Provide a concise, business-friendly explanation (max 2 sentences) of what this field represents and why it's used.`;
    
    const analysisPrompt = `Field: ${field.name}
Data Type: ${field.dataType}
Component: ${component.name}
Usage Patterns:
${fieldLogic.map(logic => `- ${logic.type}: ${logic.pattern}`).join('\n')}

What is the business purpose of this field?`;
    
    try {
        const response = await VLLMAPIManager.makeAPICall(analysisPrompt, systemPrompt, 150);
        return response.content.trim() || 'Business purpose analysis pending';
    } catch (error) {
        return 'Business purpose analysis unavailable';
    }
}

function categorizeFieldsByUsage(allFields) {
    const categories = {
        INPUT: { fields: [], icon: 'üì•', color: '#4CAF50', description: 'Fields populated from external sources' },
        DERIVED: { fields: [], icon: 'üßÆ', color: '#2196F3', description: 'Calculated or computed fields' },
        TRANSFORMED: { fields: [], icon: 'üîÑ', color: '#FF9800', description: 'Fields modified through data movement' },
        CONDITIONAL: { fields: [], icon: 'üîÄ', color: '#9C27B0', description: 'Fields used in business conditions' },
        STATIC: { fields: [], icon: 'üìã', color: '#607D8B', description: 'Static or reference data fields' },
        UNUSED: { fields: [], icon: '‚ùå', color: '#F44336', description: 'Defined but unused fields' }
    };
    
    allFields.forEach(field => {
        const category = field.usage.category;
        if (categories[category]) {
            categories[category].fields.push(field);
        }
    });
    
    return categories;
}

function generateComprehensiveFieldMatrix(fieldCategories) {
    const totalFields = Object.values(fieldCategories).reduce((sum, cat) => sum + cat.fields.length, 0);
    
    return `
        <div class="field-matrix-header" style="background: white; padding: 25px; border-radius: 12px; margin-bottom: 25px; box-shadow: 0 4px 15px rgba(0,0,0,0.1);">
            <h2 style="color: #667eea; margin: 0 0 20px 0; display: flex; align-items: center;">
                <span style="margin-right: 10px;">üéØ</span>
                Comprehensive Field Usage Matrix
            </h2>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; text-align: center; margin-bottom: 20px;">
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
                    <div style="font-size: 28px; font-weight: 700; color: #667eea;">${totalFields}</div>
                    <div style="font-size: 12px; color: #666;">Total Fields</div>
                </div>
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
                    <div style="font-size: 28px; font-weight: 700; color: #4CAF50;">${fieldCategories.INPUT.fields.length}</div>
                    <div style="font-size: 12px; color: #666;">Input Fields</div>
                </div>
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
                    <div style="font-size: 28px; font-weight: 700; color: #2196F3;">${fieldCategories.DERIVED.fields.length}</div>
                    <div style="font-size: 12px; color: #666;">Derived Fields</div>
                </div>
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
                    <div style="font-size: 28px; font-weight: 700; color: #F44336;">${fieldCategories.UNUSED.fields.length}</div>
                    <div style="font-size: 12px; color: #666;">Unused Fields</div>
                </div>
            </div>
        </div>

        <div class="field-usage-categories" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 20px;">
            ${Object.entries(fieldCategories).map(([categoryName, categoryData]) => 
                generateFieldCategorySection(categoryName, categoryData)
            ).join('')}
        </div>
    `;
}

function generateFieldCategorySection(categoryName, categoryData) {
    if (categoryData.fields.length === 0) return '';
    
    return `
        <div class="field-category" style="background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); border-left: 5px solid ${categoryData.color};">
            <div class="category-header" style="display: flex; align-items: center; margin-bottom: 15px;">
                <span style="font-size: 24px; margin-right: 10px;">${categoryData.icon}</span>
                <div>
                    <h3 style="color: ${categoryData.color}; margin: 0; font-size: 18px;">${categoryName} FIELDS (${categoryData.fields.length})</h3>
                    <p style="margin: 5px 0 0 0; font-size: 12px; color: #666;">${categoryData.description}</p>
                </div>
            </div>
            
            <div class="field-list" style="max-height: 300px; overflow-y: auto;">
                ${categoryData.fields.map(field => `
                    <div class="field-item" style="background: #f8f9fa; padding: 12px; margin: 8px 0; border-radius: 8px; border-left: 3px solid ${categoryData.color};">
                        <div style="display: flex; justify-content: between; align-items: start; margin-bottom: 8px;">
                            <div>
                                <strong style="color: #2c3e50; font-size: 14px;">${field.name}</strong>
                                <span style="background: #e9ecef; color: #495057; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-left: 8px;">${field.dataType}</span>
                            </div>
                            <div style="text-align: right; font-size: 11px; color: #666;">
                                <div>${field.friendlyName}</div>
                                <div>Level ${field.level}</div>
                            </div>
                        </div>
                        
                        <div style="font-size: 12px; color: #666; margin-bottom: 6px;">
                            <strong>Business Purpose:</strong> ${field.usage.businessPurpose}
                        </div>
                        
                        ${field.usage.operations.length > 0 ? `
                            <div style="font-size: 11px;">
                                <strong>Operations:</strong> 
                                ${field.usage.operations.map(op => `<span style="background: ${categoryData.color}; color: white; padding: 1px 4px; border-radius: 2px; margin: 1px;">${op}</span>`).join(' ')}
                            </div>
                        ` : ''}
                        
                        <div style="display: flex; justify-content: between; align-items: center; margin-top: 8px;">
                            <span style="font-size: 10px; color: #666;">Source: ${field.usage.source}</span>
                            <span style="font-size: 10px; color: ${field.usage.confidence >= 0.8 ? '#4CAF50' : field.usage.confidence >= 0.6 ? '#FF9800' : '#F44336'};">
                                ${(field.usage.confidence * 100).toFixed(0)}% confidence
                            </span>
                        </div>
                    </div>
                `).join('')}
            </div>
        </div>
    `;
}

function generateFieldMatrixHTML(allFields) {
    const fieldCategories = categorizeFields(allFields);
    
    return `
        <div class="field-matrix-header" style="background: white; padding: 20px; border-radius: 10px; margin-bottom: 20px; box-shadow: 0 4px 15px rgba(0,0,0,0.1);">
            <h3 style="color: #667eea; margin: 0 0 15px 0;">üéØ Field Analysis Matrix</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; text-align: center;">
                <div>
                    <div style="font-size: 24px; font-weight: 600; color: #27ae60;">${allFields.length}</div>
                    <div style="font-size: 12px; color: #666;">Total Fields</div>
                </div>
                <div>
                    <div style="font-size: 24px; font-weight: 600; color: #f39c12;">${Object.keys(fieldCategories.dataTypes).length}</div>
                    <div style="font-size: 12px; color: #666;">Data Types</div>
                </div>
                <div>
                    <div style="font-size: 24px; font-weight: 600; color: #e74c3c;">${Object.keys(fieldCategories.businessLogic).length}</div>
                    <div style="font-size: 12px; color: #666;">Logic Patterns</div>
                </div>
                <div>
                    <div style="font-size: 24px; font-weight: 600; color: #9b59b6;">${fieldCategories.complexity.simple.length + fieldCategories.complexity.moderate.length + fieldCategories.complexity.complex.length}</div>
                    <div style="font-size: 12px; color: #666;">Analyzed Fields</div>
                </div>
            </div>
        </div>
        
        <!-- Migration Complexity Assessment -->
        <div class="field-group" style="background: white; padding: 20px; border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.1);">
            <h4 style="color: #667eea; margin-bottom: 15px;">‚ö° Migration Complexity Assessment</h4>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                <div style="border: 1px solid #27ae60; border-radius: 8px; padding: 15px; background: rgba(39, 174, 96, 0.05);">
                    <h5 style="color: #27ae60; margin: 0 0 10px 0;">üü¢ Simple (${fieldCategories.complexity.simple.length})</h5>
                    <div style="font-size: 12px; color: #666; margin-bottom: 10px;">Direct migration, minimal risk</div>
                    ${fieldCategories.complexity.simple.slice(0, 3).map(field => `
                        <div style="background: white; padding: 6px; margin: 3px 0; border-radius: 4px; font-size: 11px;">
                            <strong>${field.name}</strong> - ${field.dataType || 'Basic type'}
                        </div>
                    `).join('')}
                </div>
                
                <div style="border: 1px solid #f39c12; border-radius: 8px; padding: 15px; background: rgba(243, 156, 18, 0.05);">
                    <h5 style="color: #f39c12; margin: 0 0 10px 0;">üü° Moderate (${fieldCategories.complexity.moderate.length})</h5>
                    <div style="font-size: 12px; color: #666; margin-bottom: 10px;">Requires analysis, medium risk</div>
                    ${fieldCategories.complexity.moderate.slice(0, 3).map(field => `
                        <div style="background: white; padding: 6px; margin: 3px 0; border-radius: 4px; font-size: 11px;">
                            <strong>${field.name}</strong> - ${field.businessLogicType || field.dataType}
                        </div>
                    `).join('')}
                </div>
                
                <div style="border: 1px solid #e74c3c; border-radius: 8px; padding: 15px; background: rgba(231, 76, 60, 0.05);">
                    <h5 style="color: #e74c3c; margin: 0 0 10px 0;">üî¥ Complex (${fieldCategories.complexity.complex.length})</h5>
                    <div style="font-size: 12px; color: #666; margin-bottom: 10px;">Manual review required, high risk</div>
                    ${fieldCategories.complexity.complex.slice(0, 3).map(field => `
                        <div style="background: white; padding: 6px; margin: 3px 0; border-radius: 4px; font-size: 11px;">
                            <strong>${field.name}</strong> - ${field.businessLogicType || 'Complex logic'}
                        </div>
                    `).join('')}
                </div>
            </div>
        </div>
    `;
}

function categorizeFields(allFields) {
    const fieldCategories = {
        dataTypes: {},
        businessLogic: {},
        complexity: { simple: [], moderate: [], complex: [] }
    };
    
    allFields.forEach(field => {
        // Data type categorization
        const dataTypeCategory = categorizeDataType(field.dataType);
        if (!fieldCategories.dataTypes[dataTypeCategory]) {
            fieldCategories.dataTypes[dataTypeCategory] = [];
        }
        fieldCategories.dataTypes[dataTypeCategory].push(field);
        
        // Business logic categorization
        if (field.businessLogicType) {
            if (!fieldCategories.businessLogic[field.businessLogicType]) {
                fieldCategories.businessLogic[field.businessLogicType] = [];
            }
            fieldCategories.businessLogic[field.businessLogicType].push(field);
        }
        
        // Complexity categorization
        const complexityLevel = assessFieldComplexity(field);
        fieldCategories.complexity[complexityLevel].push(field);
    });
    
    return fieldCategories;
}

function categorizeDataType(dataType) {
    if (!dataType) return 'Unknown';
    
    const type = dataType.toUpperCase();
    if (type.includes('9') && type.includes('V')) return 'Decimal Numbers';
    if (type.includes('9') && type.includes('COMP-3')) return 'Packed Decimal';
    if (type.includes('9') && type.includes('COMP')) return 'Binary Numbers';
    if (type.includes('9')) return 'Integer Numbers';
    if (type.includes('X')) return 'Character/Text';
    if (type.includes('COMP-1')) return 'Single Precision';
    if (type.includes('COMP-2')) return 'Double Precision';
    return 'Other';
}

function assessFieldComplexity(field) {
    if (!field.businessLogicType) {
        return field.dataType?.includes('COMP') ? 'moderate' : 'simple';
    }
    
    const complexTypes = ['CONDITIONAL', 'DERIVED', 'MULTI_SOURCE'];
    const moderateTypes = ['CALCULATED', 'STRING_MANIPULATION'];
    
    if (complexTypes.includes(field.businessLogicType)) return 'complex';
    if (moderateTypes.includes(field.businessLogicType)) return 'moderate';
    return 'simple';
}

async function updateDashboard() {
    const container = document.getElementById('dashboardCharts');
    if (!container) return;
    
    if (AppState.components.length === 0) {
        container.innerHTML = generateWelcomeScreen();
        return;
    }

    // Calculate analytics and generate LLM summaries
    const analytics = calculateDashboardAnalytics();
    const componentSummaries = await generateComponentSummaries();
    
    container.innerHTML = generateEnhancedDashboardHTML(analytics, componentSummaries);
}

async function generateComponentSummaries() {
    const summaries = {};
    
    if (!VLLMAPIManager.serverConfigured) {
        // Fallback summaries
        AppState.components.forEach(component => {
            summaries[component.name] = {
                purpose: generateFallbackSummary(component),
                inputFiles: extractInputFiles(component),
                outputFiles: extractOutputFiles(component),
                businessValue: 'Analysis requires vLLM configuration'
            };
        });
        return summaries;
    }
    
    updateProcessingStatus('analyzing', 'Generating component summaries with AI...');
    
    for (let i = 0; i < AppState.components.length; i++) {
        const component = AppState.components[i];
        
        try {
            updateProcessingStatus('analyzing', `Analyzing ${component.displayName || component.name} (${i + 1}/${AppState.components.length})`);
            
            const summary = await generateLLMComponentSummary(component);
            summaries[component.name] = summary;
            
            // Store summary in database
            await db.tables.component_analysis.forEach(comp => {
                if (comp.component_name === component.name) {
                    comp.llm_summary = JSON.stringify(summary);
                    comp.updated_at = new Date().toISOString();
                }
            });
            
            // Small delay between calls
            await new Promise(resolve => setTimeout(resolve, 800));
            
        } catch (error) {
            console.warn(`Failed to generate summary for ${component.name}:`, error);
            summaries[component.name] = {
                purpose: generateFallbackSummary(component),
                inputFiles: extractInputFiles(component),
                outputFiles: extractOutputFiles(component),
                businessValue: 'AI analysis failed - using pattern-based analysis'
            };
        }
    }
    
    updateProcessingStatus('ready', 'Component summaries completed');
    return summaries;
}

async function generateLLMComponentSummary(component) {
    const systemPrompt = `You are a business analyst expert in mainframe systems. Analyze this COBOL component and provide a business summary.

Respond in JSON format:
{
  "purpose": "Clear business purpose in 2-3 sentences",
  "inputFiles": ["list", "of", "input", "files"],
  "outputFiles": ["list", "of", "output", "files"],
  "businessValue": "Business value and importance in 1-2 sentences"
}`;

    const content = component.content || '';
    const keyContent = content.length > 3000 ? COBOLParser.cleanCOBOLLines(content).slice(0, 50).join('\n') : content;
    
    const analysisPrompt = `Component Name: ${component.name}
Type: ${component.type}
Lines of Code: ${component.totalLines || 0}
Fields: ${component.fields?.length || 0}

Key COBOL Code:
${keyContent}

Dependencies:
${(component.dependencies || []).map(d => `- ${d.type}: ${d.name}`).join('\n')}

Business Logic:
${(component.businessLogic || []).map(l => `- ${l.type}: ${l.pattern}`).slice(0, 5).join('\n')}

Analyze this component and provide business summary:`;

    try {
        const response = await VLLMAPIManager.makeAPICall(analysisPrompt, systemPrompt, 400);
        
        // Parse JSON response
        let summary;
        try {
            let cleanResponse = response.content.trim();
            if (cleanResponse.startsWith('```json')) {
                cleanResponse = cleanResponse.replace(/```json\s*/, '').replace(/\s*```$/, '');
            }
            summary = JSON.parse(cleanResponse);
        } catch (parseError) {
            // Fallback parsing
            summary = {
                purpose: response.content.substring(0, 200) + '...',
                inputFiles: extractInputFiles(component),
                outputFiles: extractOutputFiles(component),
                businessValue: 'Requires manual review for complete analysis'
            };
        }
        
        return summary;
        
    } catch (error) {
        throw error;
    }
}

function generateFallbackSummary(component) {
    const type = component.type;
    const name = component.displayName || component.name;
    
    if (type === 'RECORD_LAYOUT') {
        return `${name} defines the data structure for ${component.fields?.length || 0} fields, organizing information for business processing.`;
    } else if (type === 'CBL' || type === 'COB') {
        const hasLogic = (component.businessLogic?.length || 0) > 0;
        const hasCics = (component.cicsOperations?.length || 0) > 0;
        
        if (hasCics) {
            return `${name} is an online transaction program that processes business data through CICS operations.`;
        } else if (hasLogic) {
            return `${name} is a batch processing program that performs business logic operations on mainframe data.`;
        } else {
            return `${name} is a COBOL program that manages business data and operations.`;
        }
    } else if (type === 'COPY') {
        return `${name} is a copybook that provides shared data definitions and structures used across multiple programs.`;
    } else if (type === 'JCL' || type === 'PROC') {
        return `${name} is a job control script that manages the execution and resource allocation for mainframe batch processes.`;
    }
    
    return `${name} is a ${type} component that supports business operations.`;
}

function extractInputFiles(component) {
    const inputFiles = [];
    const dependencies = component.dependencies || [];
    
    // Look for input file operations
    dependencies.forEach(dep => {
        if (dep.type === 'FILE_OPERATION' && dep.operation && 
            (dep.operation.includes('READ') || dep.operation.includes('INPUT'))) {
            inputFiles.push(dep.name);
        } else if (dep.type === 'CICS_FILE_ACCESS' && dep.operation && 
                   dep.operation.includes('READ')) {
            inputFiles.push(dep.name);
        }
    });
    
    return [...new Set(inputFiles)];
}

function extractOutputFiles(component) {
    const outputFiles = [];
    const dependencies = component.dependencies || [];
    
    // Look for output file operations
    dependencies.forEach(dep => {
        if (dep.type === 'FILE_OPERATION' && dep.operation && 
            (dep.operation.includes('WRITE') || dep.operation.includes('OUTPUT'))) {
            outputFiles.push(dep.name);
        } else if (dep.type === 'CICS_FILE_ACCESS' && dep.operation && 
                   dep.operation.includes('WRITE')) {
            outputFiles.push(dep.name);
        }
    });
    
    return [...new Set(outputFiles)];
}

function generateEnhancedDashboardHTML(analytics, componentSummaries) {
    return `
        <div class="enhanced-dashboard">
            <!-- Executive Summary Section -->
            <div class="dashboard-section" style="background: linear-gradient(135deg, #667eea, #764ba2); color: white; padding: 25px; border-radius: 15px; margin-bottom: 25px;">
                <h2 style="margin: 0 0 20px 0;">üìä Business System Overview</h2>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 20px;">
                    <div style="text-align: center;">
                        <div style="font-size: 32px; font-weight: 700;">${analytics.components.total}</div>
                        <div style="opacity: 0.9;">Total Components</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 32px; font-weight: 700;">${analytics.components.programs}</div>
                        <div style="opacity: 0.9;">Business Programs</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 32px; font-weight: 700;">${(analytics.components.totalLines / 1000).toFixed(1)}K</div>
                        <div style="opacity: 0.9;">Lines of Code</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 32px; font-weight: 700;">${analytics.modernization.readinessScore}%</div>
                        <div style="opacity: 0.9;">Modernization Ready</div>
                    </div>
                </div>
            </div>

            <!-- Component Business Summaries -->
            <div class="dashboard-section" style="margin-bottom: 25px;">
                <h3 style="color: #667eea; margin-bottom: 20px;">üè¢ Business Component Analysis</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 20px;">
                    ${Object.entries(componentSummaries).map(([componentName, summary]) => {
                        const component = AppState.components.find(c => c.name === componentName);
                        return generateComponentSummaryCard(component, summary);
                    }).join('')}
                </div>
            </div>

            <!-- System Integration Flow -->
            <div class="dashboard-section" style="background: white; padding: 25px; border-radius: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.1);">
                <h3 style="color: #667eea; margin-bottom: 20px;">üîÑ System Integration Overview</h3>
                ${generateSystemFlowSummary(componentSummaries)}
            </div>
        </div>
    `;
}

function generateComponentSummaryCard(component, summary) {
    const typeColors = {
        'CBL': '#4CAF50', 'COB': '#4CAF50',
        'COPY': '#FF9800',
        'RECORD_LAYOUT': '#2196F3',
        'JCL': '#9C27B0', 'PROC': '#9C27B0'
    };
    
    const typeIcons = {
        'CBL': 'üíº', 'COB': 'üíº',
        'COPY': 'üìö',
        'RECORD_LAYOUT': 'üìã',
        'JCL': '‚öôÔ∏è', 'PROC': '‚öôÔ∏è'
    };
    
    const color = typeColors[component.type] || '#607D8B';
    const icon = typeIcons[component.type] || 'üìÑ';
    const displayName = component.displayName || component.friendlyName || component.name;
    
    return `
        <div class="component-summary-card" style="background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); border-left: 5px solid ${color};">
            <div style="display: flex; align-items: center; margin-bottom: 15px;">
                <span style="font-size: 24px; margin-right: 12px;">${icon}</span>
                <div>
                    <h4 style="margin: 0; color: ${color}; font-size: 16px;">${displayName}</h4>
                    <span style="font-size: 12px; color: #666; background: #f0f0f0; padding: 2px 6px; border-radius: 3px;">${component.type}</span>
                </div>
            </div>
            
            <div style="margin-bottom: 15px;">
                <h5 style="color: #2c3e50; margin: 0 0 8px 0; font-size: 14px;">Business Purpose</h5>
                <p style="margin: 0; font-size: 13px; line-height: 1.4; color: #555;">${summary.purpose}</p>
            </div>
            
            ${summary.inputFiles.length > 0 ? `
                <div style="margin-bottom: 12px;">
                    <h5 style="color: #4CAF50; margin: 0 0 6px 0; font-size: 12px;">üì• Input Files</h5>
                    <div style="display: flex; flex-wrap: wrap; gap: 4px;">
                        ${summary.inputFiles.map(file => `
                            <span style="background: rgba(76, 175, 80, 0.1); color: #4CAF50; padding: 2px 6px; border-radius: 3px; font-size: 10px;">${file}</span>
                        `).join('')}
                    </div>
                </div>
            ` : ''}
            
            ${summary.outputFiles.length > 0 ? `
                <div style="margin-bottom: 12px;">
                    <h5 style="color: #F44336; margin: 0 0 6px 0; font-size: 12px;">üì§ Output Files</h5>
                    <div style="display: flex; flex-wrap: wrap; gap: 4px;">
                        ${summary.outputFiles.map(file => `
                            <span style="background: rgba(244, 67, 54, 0.1); color: #F44336; padding: 2px 6px; border-radius: 3px; font-size: 10px;">${file}</span>
                        `).join('')}
                    </div>
                </div>
            ` : ''}
            
            <div style="border-top: 1px solid #eee; padding-top: 12px; margin-top: 12px;">
                <h5 style="color: #667eea; margin: 0 0 6px 0; font-size: 12px;">üíé Business Value</h5>
                <p style="margin: 0; font-size: 12px; color: #666; font-style: italic;">${summary.businessValue}</p>
            </div>
            
            <div style="display: flex; justify-content: between; align-items: center; margin-top: 12px; padding-top: 8px; border-top: 1px solid #f0f0f0;">
                <span style="font-size: 11px; color: #999;">${component.totalLines || 0} lines, ${component.fields?.length || 0} fields</span>
                <button onclick="viewComponentDetails('${component.name}')" 
                        style="background: ${color}; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 10px;">
                    View Details
                </button>
            </div>
        </div>
    `;
}

function generateSystemFlowSummary(componentSummaries) {
    const allInputFiles = new Set();
    const allOutputFiles = new Set();
    
    Object.values(componentSummaries).forEach(summary => {
        summary.inputFiles.forEach(file => allInputFiles.add(file));
        summary.outputFiles.forEach(file => allOutputFiles.add(file));
    });
    
    return `
        <div style="display: grid; grid-template-columns: 1fr 2fr 1fr; gap: 20px; align-items: start;">
            <div style="text-align: center;">
                <h4 style="color: #4CAF50; margin-bottom: 15px;">üì• System Inputs</h4>
                <div style="background: rgba(76, 175, 80, 0.1); padding: 15px; border-radius: 8px; min-height: 100px;">
                    ${Array.from(allInputFiles).length > 0 ? 
                        Array.from(allInputFiles).map(file => `
                            <div style="background: white; margin: 4px 0; padding: 6px; border-radius: 4px; font-size: 12px;">${file}</div>
                        `).join('') :
                        '<div style="color: #666; font-style: italic;">No input files identified</div>'
                    }
                </div>
            </div>
            
            <div style="text-align: center;">
                <h4 style="color: #667eea; margin-bottom: 15px;">‚öôÔ∏è Processing Flow</h4>
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
                    <div style="font-size: 24px; margin-bottom: 10px;">üìä</div>
                    <div style="font-size: 14px; color: #555;">
                        ${AppState.components.filter(c => c.type === 'CBL' || c.type === 'COB').length} Business Programs<br>
                        ${AppState.components.filter(c => c.type === 'RECORD_LAYOUT').length} Data Structures<br>
                        ${AppState.components.filter(c => c.type === 'COPY').length} Shared Components
                    </div>
                </div>
            </div>
            
            <div style="text-align: center;">
                <h4 style="color: #F44336; margin-bottom: 15px;">üì§ System Outputs</h4>
                <div style="background: rgba(244, 67, 54, 0.1); padding: 15px; border-radius: 8px; min-height: 100px;">
                    ${Array.from(allOutputFiles).length > 0 ? 
                       Array.from(allOutputFiles).map(file => `
                           <div style="background: white; margin: 4px 0; padding: 6px; border-radius: 4px; font-size: 12px;">${file}</div>
                       `).join('') :
                       '<div style="color: #666; font-style: italic;">No output files identified</div>'
                   }
               </div>
           </div>
       </div>
   `;
}

function calculateDashboardAnalytics() {
    const components = AppState.components;
    const fieldMappings = AppState.fieldMappings;
    const dependencies = AppState.dependencies;

    // Component analytics
    const componentAnalytics = {
        total: components.length,
        programs: components.filter(c => c.type === 'CBL' || c.type === 'COB').length,
        copybooks: components.filter(c => c.type === 'COPY').length,
        totalLines: components.reduce((sum, c) => sum + (c.totalLines || 0), 0),
        totalFields: components.reduce((sum, c) => sum + (c.fields?.length || 0), 0)
    };

    // Field mapping analytics
    const fieldMappingAnalytics = {
        total: fieldMappings.length,
        completionPercentage: componentAnalytics.totalFields > 0 ? 
            Math.round((fieldMappings.length / componentAnalytics.totalFields) * 100) : 0,
        highConfidence: fieldMappings.filter(f => f.confidenceScore >= 0.8).length,
        needsReview: fieldMappings.filter(f => f.confidenceScore < 0.7).length
    };

    // Business logic analytics
    const businessLogicPatterns = {};
    fieldMappings.forEach(mapping => {
        const pattern = mapping.businessLogicType;
        businessLogicPatterns[pattern] = (businessLogicPatterns[pattern] || 0) + 1;
    });

    // Modernization readiness
    const totalComplexity = components.reduce((sum, comp) => {
        let complexity = 0;
        complexity += (comp.dependencies?.length || 0) * 0.3;
        complexity += (comp.businessLogic?.length || 0) * 0.4;
        complexity += (comp.cicsOperations?.length || 0) * 0.3;
        return sum + complexity;
    }, 0);

    const avgComplexity = components.length > 0 ? totalComplexity / components.length : 0;
    const readinessScore = Math.max(0, Math.min(100, 100 - (avgComplexity * 10)));

    return {
        components: componentAnalytics,
        fieldMappings: fieldMappingAnalytics,
        businessLogic: { patterns: businessLogicPatterns },
        dependencies: { total: dependencies.length },
        modernization: { readinessScore: Math.round(readinessScore) }
    };
}

function generateDashboardHTML(analytics) {
    return `
        <div class="dashboard-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-bottom: 30px;">
            
            <!-- Component Analysis Summary -->
            <div class="analytics-card" style="background: linear-gradient(135deg, #667eea, #764ba2); color: white; padding: 25px; border-radius: 15px; box-shadow: 0 8px 25px rgba(0,0,0,0.15);">
                <h3 style="margin: 0 0 20px 0; font-size: 18px;">üìä Component Analysis</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <div>
                        <div style="font-size: 28px; font-weight: 700;">${analytics.components.total}</div>
                        <div style="opacity: 0.9; font-size: 14px;">Total Components</div>
                    </div>
                    <div>
                        <div style="font-size: 28px; font-weight: 700;">${analytics.components.programs}</div>
                        <div style="opacity: 0.9; font-size: 14px;">COBOL Programs</div>
                    </div>
                    <div>
                        <div style="font-size: 28px; font-weight: 700;">${analytics.components.copybooks}</div>
                        <div style="opacity: 0.9; font-size: 14px;">Copybooks</div>
                    </div>
                    <div>
                        <div style="font-size: 28px; font-weight: 700;">${(analytics.components.totalLines / 1000).toFixed(1)}K</div>
                        <div style="opacity: 0.9; font-size: 14px;">Lines of Code</div>
                    </div>
                </div>
            </div>

            <!-- Field Mapping Analytics -->
            <div class="analytics-card" style="background: white; padding: 25px; border-radius: 15px; box-shadow: 0 8px 25px rgba(0,0,0,0.1); border-left: 5px solid #27ae60;">
                <h3 style="margin: 0 0 20px 0; font-size: 18px; color: #27ae60;">üéØ Field Mapping Status</h3>
                <div style="margin-bottom: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <span style="font-size: 14px; color: #666;">Mapped Fields</span>
                        <span style="font-weight: 600; color: #27ae60;">${analytics.fieldMappings.total}</span>
                    </div>
                    <div style="background: #f0f0f0; border-radius: 10px; height: 8px;">
                        <div style="background: linear-gradient(90deg, #27ae60, #2ecc71); height: 100%; border-radius: 10px; width: ${analytics.fieldMappings.completionPercentage}%;"></div>
                    </div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 13px;">
                    <div style="background: #f8f9fa; padding: 10px; border-radius: 8px; text-align: center;">
                        <div style="font-weight: 600; color: #27ae60;">${analytics.fieldMappings.highConfidence}</div>
                        <div style="color: #666;">High Confidence</div>
                    </div>
                    <div style="background: #f8f9fa; padding: 10px; border-radius: 8px; text-align: center;">
                        <div style="font-weight: 600; color: #f39c12;">${analytics.fieldMappings.needsReview}</div>
                        <div style="color: #666;">Needs Review</div>
                    </div>
                </div>
            </div>

            <!-- Business Logic Breakdown -->
            <div class="analytics-card" style="background: white; padding: 25px; border-radius: 15px; box-shadow: 0 8px 25px rgba(0,0,0,0.1); border-left: 5px solid #f39c12;">
                <h3 style="margin: 0 0 20px 0; font-size: 18px; color: #f39c12;">üß† Business Logic Patterns</h3>
                ${Object.entries(analytics.businessLogic.patterns).map(([pattern, count]) => {
                    const percentage = Object.values(analytics.businessLogic.patterns).reduce((sum, c) => sum + c, 0) > 0 ? 
                        (count / Object.values(analytics.businessLogic.patterns).reduce((sum, c) => sum + c, 0) * 100).toFixed(0) : 0;
                    const colors = {
                        'MOVE': '#27ae60',
                        'DERIVED': '#f39c12',
                        'CONDITIONAL': '#e74c3c', 
                        'CALCULATED': '#9b59b6',
                        'STRING_MANIPULATION': '#16a085',
                        'MULTI_SOURCE': '#e67e22'
                    };
                    return `
                        <div style="margin-bottom: 12px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                                <span style="font-size: 13px; color: #666;">${pattern}</span>
                                <span style="font-weight: 600; color: ${colors[pattern] || '#666'};">${count}</span>
                            </div>
                            <div style="background: #f0f0f0; border-radius: 4px; height: 6px;">
                                <div style="background: ${colors[pattern] || '#666'}; height: 100%; border-radius: 4px; width: ${percentage}%;"></div>
                            </div>
                        </div>
                    `;
                }).join('')}
            </div>

            <!-- Modernization Readiness -->
            <div class="analytics-card" style="background: white; padding: 25px; border-radius: 15px; box-shadow: 0 8px 25px rgba(0,0,0,0.1); border-left: 5px solid #16a085;">
                <h3 style="margin: 0 0 20px 0; font-size: 18px; color: #16a085;">üöÄ Modernization Readiness</h3>
                <div style="margin-bottom: 20px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <span style="font-size: 14px; color: #666;">Overall Readiness</span>
                        <span style="font-weight: 600; color: #16a085;">${analytics.modernization.readinessScore}%</span>
                    </div>
                    <div style="background: #f0f0f0; border-radius: 10px; height: 10px;">
                        <div style="background: linear-gradient(90deg, #16a085, #1abc9c); height: 100%; border-radius: 10px; width: ${analytics.modernization.readinessScore}%;"></div>
                    </div>
                </div>
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
                    <div style="font-size: 14px; font-weight: 600; color: #2c3e50; margin-bottom: 5px;">AI-Powered Analysis</div>
                    <div style="font-size: 12px; color: #666; line-height: 1.4;">
                        ${VLLMAPIManager.serverConfigured ? '‚úÖ vLLM Server configured - Real-time AI analysis active' : '‚ö†Ô∏è Configure vLLM server for enhanced AI analysis'}
                    </div>
                </div>
            </div>
        </div>
    `;
}

// vLLM Configuration Functions
function showVLLMConfiguration() {
    const configHTML = `
        <div id="vllmConfigModal" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
             background: white; padding: 30px; border-radius: 15px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); 
             z-index: 1000; max-width: 600px; width: 90%;">
            <h3 style="color: #667eea; margin: 0 0 20px 0;">ü¶ô vLLM Server Configuration</h3>
            
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 5px; font-weight: 600;">vLLM Server Endpoint:</label>
                <input type="text" id="vllmEndpoint" value="http://localhost:8100" 
                       style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px;"
                       placeholder="http://localhost:8100">
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 5px; font-weight: 600;">Model Name:</label>
                <input type="text" id="vllmModel" value="codellama/CodeLlama-7b-Python-hf" 
                       style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px;"
                       placeholder="codellama/CodeLlama-7b-Python-hf">
            </div>
            
            <div style="margin-bottom: 20px; padding: 15px; background: #e3f2fd; border-radius: 8px;">
                <h4 style="margin: 0 0 10px 0; color: #1976d2;">üìã Your Server Endpoints:</h4>
                <ul style="margin: 0; padding-left: 20px; color: #666;">
                    <li><strong>Generate:</strong> http://localhost:8100/generate</li>
                    <li><strong>Health:</strong> http://localhost:8100/health</li>
                    <li><strong>Status:</strong> http://localhost:8100/status</li>
                    <li><strong>Metrics:</strong> http://localhost:8100/metrics</li>
                </ul>
            </div>
            
            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button onclick="closeVLLMModal()" 
                        style="background: #95a5a6; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer;">
                    Cancel
                </button>
                <button onclick="configureVLLMServer()" 
                        style="background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer;">
                    Configure & Test
                </button>
            </div>
        </div>
        
        <div id="vllmConfigBackdrop" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999;"
             onclick="closeVLLMModal()"></div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', configHTML);
}

// Add this new function to handle modal closure
function closeVLLMModal() {
    const modal = document.getElementById('vllmConfigModal');
    const backdrop = document.getElementById('vllmConfigBackdrop');
    
    if (modal) modal.remove();
    if (backdrop) backdrop.remove();
}

async function configureVLLMServer() {
    const endpointElement = document.getElementById('vllmEndpoint');
    const modelElement = document.getElementById('vllmModel');
    
    if (!endpointElement || !modelElement) return;
    
    const endpoint = endpointElement.value.trim();
    const model = modelElement.value.trim();
    
    if (!endpoint) {
        alert('Please enter a vLLM server endpoint');
        return;
    }
    
    VLLMAPIManager.configureServer(endpoint, model);
    
    localStorage.setItem('vllm_endpoint', endpoint);
    localStorage.setItem('vllm_model', model);
    
    // FIX: Close modal properly
    const modal = endpointElement.closest('div[style*="position: fixed"]');
    const backdrop = document.querySelector('div[style*="position: fixed"][style*="background: rgba(0,0,0,0.5)"]');
    
    if (modal) modal.remove();
    if (backdrop) backdrop.remove();
    
    try {
        const testResult = await VLLMAPIManager.testConnection();
        if (testResult.success) {
            updateProcessingStatus('ready', `‚úÖ vLLM Server connected successfully`);
            addChatMessage('assistant', 
                `üéâ **vLLM Server Connected!**\n\n**Endpoint**: ${endpoint}/generate\n**Model**: ${model}\n\nYour local CodeLlama model is ready for AI analysis!`, 
                { vllmConfigured: true }, 0);
        } else {
            throw new Error(testResult.error);
        }
    } catch (error) {
        updateProcessingStatus('error', `‚ùå vLLM connection failed`);
        addChatMessage('assistant', 
            `‚ö†Ô∏è vLLM configured but connection test failed: ${error.message}\n\nMake sure your server is running on the configured port.`, 
            {}, 0);
    }
}
// Node details function for dependency visualization
function showNodeDetails(nodeId) {
    const relatedDependencies = AppState.dependencies.filter(d => 
        d.sourceComponent === nodeId || d.targetComponent === nodeId
    );
    
    const incomingDeps = relatedDependencies.filter(d => d.targetComponent === nodeId);
    const outgoingDeps = relatedDependencies.filter(d => d.sourceComponent === nodeId);
    
    const detailsHTML = `
        <div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
             background: white; padding: 30px; border-radius: 15px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); 
             z-index: 1000; max-width: 600px; max-height: 80vh; overflow-y: auto;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h3 style="color: #667eea; margin: 0;">üìä ${nodeId} Details</h3>
                <button onclick="this.parentElement.parentElement.remove(); document.querySelector('.modal-backdrop').remove();" 
                        style="background: #e74c3c; color: white; border: none; border-radius: 50%; 
                               width: 30px; height: 30px; cursor: pointer; font-size: 16px;">√ó</button>
            </div>
            
            <div style="margin-bottom: 20px;">
                <h4 style="color: #27ae60; margin-bottom: 10px;">üì• Incoming Dependencies (${incomingDeps.length})</h4>
                ${incomingDeps.length > 0 ? 
                    incomingDeps.map(dep => `
                        <div style="background: #f8f9fa; padding: 10px; margin: 5px 0; border-radius: 6px; border-left: 4px solid #27ae60;">
                            <strong>${dep.sourceComponent}</strong> ‚Üí ${dep.relationshipType}
                            <div style="font-size: 12px; color: #666;">${dep.interfaceType} (${(dep.confidenceScore * 100).toFixed(0)}% confidence)</div>
                        </div>
                    `).join('') : 
                    '<div style="color: #666; font-style: italic;">No incoming dependencies</div>'
                }
            </div>
            
            <div>
                <h4 style="color: #f39c12; margin-bottom: 10px;">üì§ Outgoing Dependencies (${outgoingDeps.length})</h4>
                ${outgoingDeps.length > 0 ? 
                    outgoingDeps.map(dep => `
                        <div style="background: #f8f9fa; padding: 10px; margin: 5px 0; border-radius: 6px; border-left: 4px solid #f39c12;">
                            ${dep.relationshipType} ‚Üí <strong>${dep.targetComponent}</strong>
                            <div style="font-size: 12px; color: #666;">${dep.interfaceType} (${(dep.confidenceScore * 100).toFixed(0)}% confidence)</div>
                        </div>
                    `).join('') : 
                    '<div style="color: #666; font-style: italic;">No outgoing dependencies</div>'
                }
            </div>
        </div>
        
        <div class="modal-backdrop" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999;"
             onclick="this.previousElementSibling.remove(); this.remove();"></div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', detailsHTML);
}

// Export functionality
function exportAnalysisResults(format = 'json') {
    const data = {
        sessionId: AppState.sessionId,
        timestamp: new Date().toISOString(),
        components: AppState.components,
        fieldMappings: AppState.fieldMappings,
        dependencies: AppState.dependencies,
        tokenUsage: AppState.tokenUsage,
        vllmConfigured: VLLMAPIManager.serverConfigured,
        summary: {
            totalComponents: AppState.components.length,
            totalFields: AppState.components.reduce((sum, c) => sum + (c.fields?.length || 0), 0),
            totalDependencies: AppState.components.reduce((sum, c) => sum + (c.dependencies?.length || 0), 0)
        }
    };
    
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `mainframe_analysis_${AppState.sessionId}.${format}`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

// Initialize the application with complete vLLM functionality
function initializeAppWithVLLM() {
    console.log('üöÄ Initializing Enhanced Mainframe Code Analyzer with vLLM...');
    
    // Check for stored vLLM configuration
    const storedEndpoint = localStorage.getItem('vllm_endpoint') || 'http://localhost:8100';
    const storedModel = localStorage.getItem('vllm_model') || 'codellama/CodeLlama-7b-Python-hf';
    
    // Always configure with stored or default values
    VLLMAPIManager.configureServer(storedEndpoint, storedModel);
    console.log(`‚úÖ vLLM configuration loaded: ${storedEndpoint}`);
    
    // Create initial database session
    db.createSession().then(session => {
        console.log('‚úÖ Database session created:', session.session_id);
    });
    
    // Initialize token usage display
    TokenManager.updateUI();
    
    // Set up initial dashboard
    updateDashboard();
    
    // Set up initial chat message with enhanced context
    addChatMessage('assistant', 
        `Welcome to the **Enhanced Mainframe Code Analyzer with vLLM**! üè¢ü¶ô

I'm your AI-powered modernization assistant with advanced capabilities:

ü§ñ **vLLM Integration**: ${VLLMAPIManager.serverConfigured ? '‚úÖ Server Configured - AI analysis ready!' : '‚öôÔ∏è Configure vLLM for full AI power'}
üéØ **Field Mapping Analysis**: Upload COBOL files and analyze target files for complete Oracle migration planning
üß† **Business Logic Detection**: AI identifies MOVE, COMPUTE, conditional, calculated, and string manipulation patterns  
üîó **Dependency Mapping**: Visualize program relationships, copybook includes, and CICS operations
üíæ **CICS Modernization**: Categorize transaction operations for REST API conversion
üìä **Token-Aware Processing**: Intelligent chunking for large codebases with 6000-token limit management

**Quick Start Guide:**
1. **Configure vLLM**: ${VLLMAPIManager.serverConfigured ? 'Already configured! ‚úÖ' : 'Click "ü¶ô Configure vLLM" to enable AI analysis'}
2. **Upload Files**: Drop .CBL, .COB, .JCL, .PROC, or .COPY files in the left panel
3. **Analyze Components**: Click "Start Analysis" for comprehensive AI processing
4. **Field Mapping**: Use the ‚≠ê Field Mapping tab for target file analysis
5. **Ask Questions**: I can help with Oracle conversions, dependency impact, and modernization strategies

${VLLMAPIManager.serverConfigured ? 
    'Try asking: "*How do I convert CICS operations to REST APIs?*" or "*What\'s the Oracle DDL for CUSTOMER-FILE?*"' : 
    'üí° **Configure your vLLM server first** to unlock real-time AI analysis and intelligent chat responses!'
}`, 
        { systemReady: true, vllmConfigured: VLLMAPIManager.serverConfigured, features: ['field_mapping', 'cics_analysis', 'oracle_conversion', 'dependency_analysis'] }, 
        42
    );
    
    updateProcessingStatus('ready', VLLMAPIManager.serverConfigured ? 
        'System ready with vLLM - upload files to begin analysis' : 
        'System ready - configure vLLM server for full AI capabilities');
    
    console.log('‚úÖ Enhanced Mainframe Code Analyzer ready!');
    console.log('üìä Available features: Field Mapping, CICS Analysis, Oracle Conversion, Dependency Visualization');
    console.log('üéØ Token budget: 100,000 tokens available');
    console.log('üîß Database: 7 tables ready for analysis storage');
    console.log('ü§ñ vLLM API:', VLLMAPIManager.serverConfigured ? 'Configured ‚úÖ' : 'Not configured ‚öôÔ∏è');
}

// Export enhanced functionality for console access
window.MainframeAnalyzer = {
    AppState,
    TokenManager,
    FieldMappingAnalyzer,
    ChatSystem,
    DatabaseManager: db,
    DependencyVisualizer,
    VLLMAPIManager,
    exportResults: exportAnalysisResults,
    configureVLLM: showVLLMConfiguration,
    getPerformanceStats: () => ({
        tokenUsage: AppState.tokenUsage,
        componentsAnalyzed: AppState.components.length,
        fieldsMapped: AppState.fieldMappings.length,
        dependenciesFound: AppState.dependencies.length,
        databaseRecords: Object.values(db.tables).reduce((sum, table) => sum + table.length, 0),
        sessionDuration: Math.round((Date.now() - performance.timing.navigationStart) / 60000),
        vllmConfigured: VLLMAPIManager.serverConfigured,
        vllmModel: VLLMAPIManager.MODEL
    }),
    // Advanced debugging and analysis functions
    analyzeDependencyImpact: (componentName) => {
        const impacts = AppState.dependencies.filter(d => 
            d.sourceComponent === componentName || d.targetComponent === componentName
        );
        console.log(`Dependency Impact Analysis for ${componentName}:`, impacts);
        return impacts;
    },
    generateOracleDDL: (fileName) => {
        const fields = AppState.fieldMappings.filter(f => f.sourceRecordLayout === fileName);
        const ddl = `CREATE TABLE ${fileName.toLowerCase().replace('-', '_')} (\n${
            fields.map(f => `    ${f.fieldName.toLowerCase()} ${f.oracleDataType}`).join(',\n')
        }\n);`;
        console.log(`Oracle DDL for ${fileName}:`, ddl);
        return ddl;
    }
};

// Add keyboard shortcuts and enhanced UX
document.addEventListener('keydown', function(event) {
    // Ctrl/Cmd + Enter to send chat message
    if ((event.ctrlKey || event.metaKey) && event.key === 'Enter') {
        const chatInput = document.getElementById('chatInput');
        if (chatInput && document.activeElement === chatInput && chatInput.value.trim()) {
            sendChatMessage();
        }
    }
    
    // Ctrl/Cmd + K to show vLLM configuration
    if ((event.ctrlKey || event.metaKey) && event.key === 'k') {
        event.preventDefault();
        showVLLMConfiguration();
    }
    
    // Escape to clear chat input
    if (event.key === 'Escape') {
        const chatInput = document.getElementById('chatInput');
        if (chatInput && document.activeElement === chatInput) {
            chatInput.value = '';
            updateCharCounter();
        }
    }
});

// Add utility function for vLLM API testing
window.testVLLMAPI = async function() {
    if (!VLLMAPIManager.serverConfigured) {
        console.error('‚ùå vLLM server not configured. Use showVLLMConfiguration() first.');
        return;
    }
    
    try {
        console.log('üß™ Testing vLLM API connection...');
        const response = await VLLMAPIManager.makeAPICall(
            'Hello! Please respond with "vLLM API test successful" if you can read this message.',
            'You are a helpful assistant. Respond concisely.',
            100
        );
        
        console.log('‚úÖ vLLM API Test Result:', {
            success: true,
            model: VLLMAPIManager.MODEL,
            response: response.content,
            tokens: response.totalTokens
        });
        
        return response;
        
    } catch (error) {
        console.error('‚ùå vLLM API Test Failed:', error.message);
        return { success: false, error: error.message };
    }
};

// Start the enhanced application when page loads
document.addEventListener('DOMContentLoaded', initializeAppWithVLLM);

console.log('üéâ Enhanced Mainframe Code Analyzer with Real vLLM Integration loaded successfully!');
console.log('üîß Access advanced features via window.MainframeAnalyzer object');
console.log('ü§ñ vLLM Integration: Local Llama 3.1 support with advanced prompting');
console.log('‚ö° Real-time AI analysis with intelligent chunking (6000 token limit)');
console.log('üìä Complete SQL storage with 7 comprehensive tables');
console.log('üéØ Token budget: 100K tokens with smart management');
console.log('ü¶ô Use window.testVLLMAPI() to test your vLLM server connection');
console.log('‚å®Ô∏è Keyboard shortcuts: Ctrl+K (configure vLLM), Ctrl+Enter (send chat), Esc (clear input)');// Part 5: UI Functions, Integration, and Application Initialization

// UI Management Functions
function showTab(tabName) {
    // Hide all tabs
    document.querySelectorAll('.tab-content').forEach(tab => {
        tab.classList.remove('active');
    });
    
    // Remove active class from all tab buttons
    document.querySelectorAll('.tab-button').forEach(button => {
        button.classList.remove('active');
    });
    
    // Show selected tab
    const selectedTab = document.getElementById(tabName);
    if (selectedTab) {
        selectedTab.classList.add('active');
    }
    
    // Activate corresponding button
    if (event && event.target) {
        event.target.classList.add('active');
    }
}

function togglePanel(side) {
    const panel = document.getElementById(side + 'Panel');
    if (panel) {
        panel.classList.toggle('collapsed');
    }
}

function updateProcessingStatus(status, message) {
    AppState.processingStatus = status;
    const statusElement = document.getElementById('processingStatus');
    
    if (statusElement) {
        statusElement.className = `processing-status ${status}`;
        statusElement.innerHTML = status === 'analyzing' ? 
            `<div class="loading"></div> ${message}` : 
            `<span>${message}</span>`;
    }
}

function updateProgress(progressId, percent) {
    const progressElement = document.getElementById(progressId);
    const fillElement = document.getElementById(progressId + 'Fill');
    
    if (progressElement && fillElement) {
        progressElement.style.display = percent > 0 ? 'block' : 'none';
        fillElement.style.width = `${percent}%`;
    }
}

function updateCharCounter() {
    const input = document.getElementById('chatInput');
    const counter = document.getElementById('charCounter');
    
    if (input && counter) {
        const charCount = input.value.length;
        const tokenEstimate = TokenManager.estimateTokens(input.value);
        
        counter.textContent = `${charCount} characters (~${tokenEstimate} tokens)`;
        
        // Color coding based on token limit
        if (tokenEstimate > TokenManager.EFFECTIVE_LIMIT * 0.8) {
            counter.style.color = '#e74c3c';
        } else if (tokenEstimate > TokenManager.EFFECTIVE_LIMIT * 0.6) {
            counter.style.color = '#f39c12';
        } else {
            counter.style.color = '#667eea';
        }
    }
}

// File Upload and Processing
function handleFileUpload(event) {
    const files = Array.from(event.target.files);
    AppState.uploadedFiles = files;
    
    // Update component list
    const componentList = document.getElementById('componentList');
    if (componentList) {
        componentList.innerHTML = '';
        
        files.forEach(file => {
            const item = document.createElement('div');
            item.className = 'component-item';
            
            const fileType = file.name.split('.').pop().toUpperCase();
            const typeColors = {
                'CBL': '#667eea', 'COB': '#667eea',
                'JCL': '#f39c12', 'PROC': '#f39c12',
                'COPY': '#27ae60'
            };
            
            item.innerHTML = `
                <span>üìÑ ${file.name}</span>
                <span class="component-type" style="background: ${typeColors[fileType] || '#666'}">${fileType}</span>
            `;
            componentList.appendChild(item);
        });
    }
    
    // Update metrics
    updateMetrics();
}

async function processAllFiles() {
    if (AppState.uploadedFiles.length === 0) {
        alert('Please upload some files first!');
        return;
    }

    updateProcessingStatus('analyzing', 'Processing uploaded files...');
    
    try {
        // Create analysis session
        await db.createSession();
        
        for (let i = 0; i < AppState.uploadedFiles.length; i++) {
            const file = AppState.uploadedFiles[i];
            
            updateProcessingStatus('analyzing', `Processing ${file.name}...`);
            
            // Read file content
            const content = await readFileContent(file);
            
            // Analyze component
            const analysis = await analyzeComponent(file.name, content);
            
            // Store in app state and database
            AppState.components.push(analysis);
            await db.saveComponentAnalysis(file.name, analysis.type, file.name, analysis);
            
            // Update UI progressively
            updateMetrics();
            updateComponentsLibrary();
            updateDependenciesFlow();
            updateFieldMatrix();
            updateDashboard();
            
            // Simulate processing time
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
        
        // ENHANCEMENT: Generate business names for all components
        updateProcessingStatus('analyzing', 'Generating business-friendly names...');
        if (VLLMAPIManager.serverConfigured) {
            try {
                const friendlyNames = await FieldMappingAnalyzer.generateFriendlyBusinessNames(AppState.components);
                console.log('‚úÖ Business names generated:', friendlyNames);
                
                // Update all UI components with new names
                updateComponentsLibrary();
                updateDependenciesFlow();
                updateFieldMatrix();
                updateDashboard();
                
            } catch (error) {
                console.warn('Business name generation failed:', error);
            }
        } else {
            console.log('üìù vLLM not configured, using fallback business names');
            // Generate fallback names
            AppState.components.forEach(component => {
                component.friendlyName = FieldMappingAnalyzer.generateFallbackBusinessName(component.name, component.type);
                component.displayName = component.friendlyName;
            });
        }
        
        updateProcessingStatus('ready', 'Analysis completed successfully with business names');
        
    } catch (error) {
        updateProcessingStatus('error', `Processing failed: ${error.message}`);
    }
}

function readFileContent(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = e => resolve(e.target.result);
        reader.onerror = e => reject(new Error('Failed to read file'));
        reader.readAsText(file);
    });
}

async function analyzeComponent(fileName, content) {
    const fileType = fileName.split('.').pop().toUpperCase();
    const lines = content.split('\n');
    const tokens = TokenManager.estimateTokens(content);
    
    // Store original content for vLLM analysis
    const analysis = {
        name: fileName,
        type: fileType,
        totalLines: lines.length,
        tokens: tokens,
        content: content, // Store actual content for vLLM
        fields: extractFields(content, fileType),
        dependencies: extractDependencies(content, fileType),
        businessLogic: extractBusinessLogic(content),
        cicsOperations: extractCICSOperations(content),
        recordLayouts: extractRecordLayouts(content, fileName), // NEW: Extract record layouts
        confidence: 0.85
    };
    
    // Create separate components for each record layout
    if (analysis.recordLayouts && analysis.recordLayouts.length > 0) {
        for (const layout of analysis.recordLayouts) {
            const layoutComponent = {
                name: `${fileName}-${layout.name}`,
                type: 'RECORD_LAYOUT',
                parentComponent: fileName,
                totalLines: layout.lines.length,
                tokens: TokenManager.estimateTokens(layout.content),
                content: layout.content,
                fields: layout.fields,
                dependencies: [], // Will be populated by dependency analysis
                businessLogic: [],
                cicsOperations: [],
                recordLayout: layout,
                confidence: 0.90
            };
            
            AppState.components.push(layoutComponent);
            await db.saveComponentAnalysis(layoutComponent.name, layoutComponent.type, fileName, layoutComponent);
        }
    }
    
    TokenManager.updateTokenUsage(tokens, 0);
    return analysis;
}
function extractRecordLayouts(content, fileName) {
    const layouts = [];
    const cleanLines = COBOLParser.cleanCOBOLLines(content);
    
    let currentLayout = null;
    let inDataDivision = false;
    let inFileSection = false;
    
    cleanLines.forEach((line, index) => {
        const trimmed = line.trim().toUpperCase();
        
        // Track sections
        if (trimmed.includes('DATA DIVISION')) {
            inDataDivision = true;
            return;
        }
        if (trimmed.includes('PROCEDURE DIVISION')) {
            inDataDivision = false;
            if (currentLayout) {
                layouts.push(currentLayout);
                currentLayout = null;
            }
            return;
        }
        if (trimmed.includes('FILE SECTION')) {
            inFileSection = true;
            return;
        }
        if (trimmed.includes('WORKING-STORAGE SECTION')) {
            inFileSection = false;
            if (currentLayout && inFileSection) {
                layouts.push(currentLayout);
                currentLayout = null;
            }
            return;
        }
        
        // Only process record layouts in FILE SECTION
        if (!inDataDivision || !inFileSection) return;
        
        // Look for 01 level record definitions
        const recordMatch = line.match(/^\s*01\s+([A-Z0-9\-_]+)(\s+.*)?/i);
        if (recordMatch) {
            // Save previous layout
            if (currentLayout) {
                layouts.push(currentLayout);
            }
            
            const recordName = recordMatch[1];
            
            // Skip FILLER records
            if (recordName === 'FILLER') {
                currentLayout = null;
                return;
            }
            
            currentLayout = {
                name: recordName,
                startLine: index + 1,
                lines: [line],
                content: line + '\n',
                fields: [],
                level: '01'
            };
        }
        
        // Add fields to current record layout
        if (currentLayout) {
            const fieldMatch = line.match(/^\s*(\d+)\s+([A-Z0-9\-_]+)(\s+PIC\s+([X9VS\(\)\+\-COMP]+))?/i);
            if (fieldMatch) {
                const level = fieldMatch[1];
                const fieldName = fieldMatch[2];
                const picClause = fieldMatch[4];
                
                // Skip FILLER fields
                if (fieldName !== 'FILLER') {
                    currentLayout.lines.push(line);
                    currentLayout.content += line + '\n';
                    
                    currentLayout.fields.push({
                        name: fieldName,
                        dataType: picClause || 'GROUP',
                        level: level,
                        lineNumber: index + 1,
                        parentRecord: currentLayout.name,
                        isGroup: !picClause
                    });
                }
            } else if (line.trim() && !trimmed.startsWith('*')) {
                // Add other non-field lines that belong to the record
                currentLayout.lines.push(line);
                currentLayout.content += line + '\n';
            }
        }
    });
    
    // Don't forget the last layout
    if (currentLayout) {
        layouts.push(currentLayout);
    }
    
    return layouts;
}

function extractFields(content, fileType) {
    const fields = [];
    const cleanLines = COBOLParser.cleanCOBOLLines(content);
    
    let inDataDivision = false;
    let inFileSection = false;
    let inWorkingStorage = false;
    let currentLevel = 0;
    
    cleanLines.forEach((line, index) => {
        const trimmed = line.trim().toUpperCase();
        
        // Track divisions and sections
        if (trimmed.includes('DATA DIVISION')) {
            inDataDivision = true;
            return;
        }
        if (trimmed.includes('PROCEDURE DIVISION')) {
            inDataDivision = false;
            return;
        }
        if (trimmed.includes('FILE SECTION')) {
            inFileSection = true;
            inWorkingStorage = false;
            return;
        }
        if (trimmed.includes('WORKING-STORAGE SECTION')) {
            inWorkingStorage = true;
            inFileSection = false;
            return;
        }
        
        // Only process fields in data division
        if (!inDataDivision) return;
        
        // Look for field definitions (level number + field name + optional PIC)
        const fieldMatch = line.match(/^\s*(\d+)\s+([A-Z0-9\-_]+)(\s+PIC\s+([X9VS\(\)\+\-COMP]+))?/i);
        if (fieldMatch) {
            const level = fieldMatch[1];
            const fieldName = fieldMatch[2];
            const picClause = fieldMatch[4] || 'GROUP';
            
            // Skip FILLER fields and system fields
            if (fieldName === 'FILLER' || fieldName.startsWith('WS-')) {
                return;
            }
            
            fields.push({
                name: fieldName,
                dataType: picClause,
                level: level,
                lineNumber: index + 1,
                section: inFileSection ? 'FILE' : inWorkingStorage ? 'WORKING-STORAGE' : 'DATA',
                isGroup: !fieldMatch[3] // No PIC clause = group item
            });
        }
    });
    
    return fields;
}

function extractDependencies(content, fileType) {
    const dependencies = [];
    const cleanLines = COBOLParser.cleanCOBOLLines(content);
    
    cleanLines.forEach((line, index) => {
        const trimmed = line.trim().toUpperCase();
        
        // COPY/INCLUDE statements (only in actual code, not comments)
        const copyMatch = trimmed.match(/^COPY\s+([A-Z0-9\-_]+)/i);
        if (copyMatch) {
            dependencies.push({
                type: 'COPYBOOK',
                name: copyMatch[1],
                lineNumber: index + 1,
                statement: line.trim()
            });
        }
        
        // CALL statements
        const callMatch = trimmed.match(/^CALL\s+['"]([A-Z0-9\-_]+)['"](\s+USING\s+(.+))?/i);
        if (callMatch) {
            dependencies.push({
                type: 'PROGRAM_CALL',
                name: callMatch[1],
                parameters: callMatch[3] || null,
                lineNumber: index + 1,
                statement: line.trim()
            });
        }
        
        // CICS file operations (multi-line aware)
        if (trimmed.includes('EXEC CICS')) {
            // Handle multi-line CICS commands
            let cicsStatement = line;
            let nextIndex = index + 1;
            
            // Collect continuation lines until END-EXEC
            while (nextIndex < cleanLines.length && !cicsStatement.includes('END-EXEC')) {
                cicsStatement += ' ' + cleanLines[nextIndex].trim();
                nextIndex++;
            }
            
            const cicsFileMatch = cicsStatement.match(/EXEC\s+CICS\s+(READ|WRITE|REWRITE|DELETE|STARTBR|READNEXT|READPREV)\s+.*?FILE\s*\(\s*['"]?([A-Z0-9\-_]+)['"]?\s*\)/i);
            if (cicsFileMatch) {
                dependencies.push({
                    type: 'CICS_FILE_ACCESS',
                    operation: cicsFileMatch[1].toUpperCase(),
                    name: cicsFileMatch[2],
                    lineNumber: index + 1,
                    statement: cicsStatement.trim()
                });
            }
        }
        
        // Regular file operations
        const fileMatch = trimmed.match(/^(OPEN|READ|WRITE|CLOSE)\s+(INPUT|OUTPUT|I-O\s+)?([A-Z0-9\-_]+)/i);
        if (fileMatch) {
            dependencies.push({
                type: 'FILE_OPERATION',
                operation: fileMatch[1].toUpperCase(),
                mode: fileMatch[2] || '',
                name: fileMatch[3],
                lineNumber: index + 1,
                statement: line.trim()
            });
        }
        
        // PERFORM statements (internal calls)
        const performMatch = trimmed.match(/^PERFORM\s+([A-Z0-9\-_]+)/i);
        if (performMatch) {
            dependencies.push({
                type: 'INTERNAL_CALL',
                name: performMatch[1],
                lineNumber: index + 1,
                statement: line.trim()
            });
        }
    });
    
    return dependencies;
}

function extractBusinessLogic(content) {
    const logic = [];
    const cleanLines = COBOLParser.cleanCOBOLLines(content);
    
    let inProcedureDivision = false;
    
    cleanLines.forEach((line, index) => {
        const trimmed = line.trim().toUpperCase();
        
        // Only analyze business logic in procedure division
        if (trimmed.includes('PROCEDURE DIVISION')) {
            inProcedureDivision = true;
            return;
        }
        
        if (!inProcedureDivision) return;
        
        // MOVE operations
        const moveMatch = line.match(/^\s*MOVE\s+([A-Z0-9\-_\(\)'"]+)\s+TO\s+([A-Z0-9\-_\(\)]+)/i);
        if (moveMatch) {
            logic.push({
                type: 'MOVE',
                source: moveMatch[1],
                target: moveMatch[2],
                pattern: line.trim(),
                lineNumber: index + 1,
                confidence: 0.95
            });
        }
        
        // COMPUTE operations
        const computeMatch = line.match(/^\s*COMPUTE\s+([A-Z0-9\-_]+)\s*=\s*(.+?)(?:\.|$)/i);
        if (computeMatch) {
            logic.push({
                type: 'DERIVED',
                target: computeMatch[1],
                expression: computeMatch[2],
                pattern: line.trim(),
                lineNumber: index + 1,
                confidence: 0.90
            });
        }
        
        // Conditional operations (IF statements)
        if (trimmed.startsWith('IF ')) {
            // Handle multi-line IF statements
            let ifStatement = line;
            let nextIndex = index + 1;
            
            // Collect until END-IF or period
            while (nextIndex < cleanLines.length && 
                   !cleanLines[nextIndex].trim().toUpperCase().includes('END-IF') &&
                   !ifStatement.trim().endsWith('.')) {
                ifStatement += ' ' + cleanLines[nextIndex].trim();
                nextIndex++;
            }
            
            logic.push({
                type: 'CONDITIONAL',
                condition: trimmed.substring(3), // Remove 'IF '
                pattern: ifStatement.trim(),
                lineNumber: index + 1,
                confidence: 0.85
            });
        }
        
        // Arithmetic operations
        const arithMatch = line.match(/^\s*(ADD|SUBTRACT|MULTIPLY|DIVIDE)\s+(.+?)\s+(TO|FROM|BY|GIVING)\s+([A-Z0-9\-_]+)/i);
        if (arithMatch) {
            logic.push({
                type: 'CALCULATED',
                operation: arithMatch[1],
                operands: arithMatch[2],
                target: arithMatch[4],
                pattern: line.trim(),
                lineNumber: index + 1,
                confidence: 0.88
            });
        }
        
        // String manipulation
        if (trimmed.includes('STRING ') || trimmed.includes('UNSTRING ')) {
            let stringStatement = line;
            let nextIndex = index + 1;
            
            // Collect until END-STRING
            while (nextIndex < cleanLines.length && 
                   !stringStatement.includes('END-STRING') &&
                   !stringStatement.trim().endsWith('.')) {
                stringStatement += ' ' + cleanLines[nextIndex].trim();
                nextIndex++;
            }
            
            logic.push({
                type: 'STRING_MANIPULATION',
                operation: trimmed.includes('STRING ') ? 'STRING' : 'UNSTRING',
                pattern: stringStatement.trim(),
                lineNumber: index + 1,
                confidence: 0.82
            });
        }
    });
    
    return logic;
}

function extractCICSOperations(content) {
    const operations = [];
    const cleanLines = COBOLParser.cleanCOBOLLines(content);
    
    for (let i = 0; i < cleanLines.length; i++) {
        const line = cleanLines[i];
        const trimmed = line.trim().toUpperCase();
        
        // Look for EXEC CICS statements
        if (trimmed.includes('EXEC CICS')) {
            // Collect the complete CICS statement (may span multiple lines)
            let cicsStatement = line;
            let nextIndex = i + 1;
            
            // Continue reading until we find END-EXEC
            while (nextIndex < cleanLines.length && !cicsStatement.includes('END-EXEC')) {
                cicsStatement += ' ' + cleanLines[nextIndex].trim();
                nextIndex++;
            }
            
            // Extract CICS operation details
            const operationMatch = cicsStatement.match(/EXEC\s+CICS\s+([A-Z]+)\s+(.+?)\s+END-EXEC/i);
            if (operationMatch) {
                const operation = operationMatch[1].toUpperCase();
                const parameters = operationMatch[2];
                
                // Extract file name if present
                const fileMatch = parameters.match(/FILE\s*\(\s*['"]?([A-Z0-9\-_]+)['"]?\s*\)/i);
                const fileName = fileMatch ? fileMatch[1] : null;
                
                // Categorize CICS operation
                let category = 'OTHER';
                const readOps = ['READ', 'receive', 'readnext', 'readprev', 'startbr', 'endbr'];
                const writeOps = ['write', 'send', 'rewrite', 'delete'];
                const transOps = ['link', 'xctl', 'return', 'syncpoint'];
                const termOps = ['send', 'receive', 'converse'];
                const queueOps = ['writeq', 'readq', 'deleteq'];
                
                if (readOps.includes(operation.toLowerCase())) {
                    category = 'READ_OPERATION';
                } else if (writeOps.includes(operation.toLowerCase())) {
                    category = 'WRITE_OPERATION';
                } else if (transOps.includes(operation.toLowerCase())) {
                    category = 'TRANSACTION_OPERATION';
                } else if (termOps.includes(operation.toLowerCase())) {
                    category = 'TERMINAL_OPERATION';
                } else if (queueOps.includes(operation.toLowerCase())) {
                    category = 'QUEUE_OPERATION';
                }
                
                operations.push({
                    operation: operation,
                    category: category,
                    parameters: parameters,
                    fileName: fileName,
                    fullStatement: cicsStatement.trim(),
                    lineNumber: i + 1,
                    confidence: 0.93
                });
            }
            
            // Skip the lines we've already processed
            i = nextIndex - 1;
        }
    }
    
    return operations;
}

// Field Mapping Analysis Functions
async function analyzeFieldMapping() {
    const fileName = document.getElementById('targetFileName')?.value.trim();
    
    if (!fileName) {
        alert('Please enter a file name to analyze');
        return;
    }
    
    try {
        // Show progress
        const progressElement = document.getElementById('mappingProgress');
        if (progressElement) {
            progressElement.style.display = 'block';
        }
        updateProgress('mappingProgress', 0);
        
        // Perform analysis
        const mappings = await FieldMappingAnalyzer.analyzeTargetFile(fileName);
        
        // Update app state
        AppState.fieldMappings = mappings;
        
        // Update UI table
        updateFieldMappingTable(mappings);
        
        // Hide progress
        if (progressElement) {
            progressElement.style.display = 'none';
        }
        
    } catch (error) {
        alert(`Analysis failed: ${error.message}`);
        const progressElement = document.getElementById('mappingProgress');
        if (progressElement) {
            progressElement.style.display = 'none';
        }
    }
}

function updateFieldMappingTable(mappings) {
    const tbody = document.getElementById('fieldMappingTableBody');
    if (!tbody) return;
    
    tbody.innerHTML = '';
    
    if (mappings.length === 0) {
        tbody.innerHTML = `
            <tr>
                <td colspan="10" style="text-align: center; padding: 40px; color: #666;">
                    No field mappings found for the specified file.
                </td>
            </tr>
        `;
        return;
    }
    
    mappings.forEach(mapping => {
        const row = document.createElement('tr');
        
        const businessLogicBadge = `<span class="business-logic-badge logic-${mapping.businessLogicType.toLowerCase()}">${mapping.businessLogicType}</span>`;
        const programsList = mapping.programsInvolved.map(p => `<span style="font-size: 11px; background: #f0f0f0; padding: 2px 6px; border-radius: 3px; margin: 1px;">${p}</span>`).join(' ');
        const confidenceColor = mapping.confidenceScore >= 0.8 ? '#27ae60' : mapping.confidenceScore >= 0.6 ? '#f39c12' : '#e74c3c';
        
        row.innerHTML = `
            <td><strong>${mapping.fieldName}</strong></td>
            <td><code>${mapping.mainframeDataType}</code></td>
            <td><code>${mapping.oracleDataType}</code></td>
            <td>${mapping.mainframeLength}</td>
            <td>${mapping.oracleLength || 'N/A'}</td>
            <td>${mapping.populationSource}</td>
            <td>${mapping.sourceRecordLayout}</td>
            <td>
                ${businessLogicBadge}
                <div style="font-size: 12px; color: #666; margin-top: 4px;">
                    ${mapping.businessLogicDescription}
                </div>
            </td>
            <td class="programs-list">${programsList}</td>
            <td>
                <span style="color: ${confidenceColor}; font-weight: 600;">
                    ${(mapping.confidenceScore * 100).toFixed(0)}%
                </span>
            </td>
        `;
        
        tbody.appendChild(row);
    });
}

// Chat Functions
async function sendChatMessage() {
    const input = document.getElementById('chatInput');
    if (!input) return;
    
    const message = input.value.trim();
    if (!message) return;
    
    // Clear input
    input.value = '';
    updateCharCounter();
    
    // Add user message to chat
    addChatMessage('user', message);
    
    try {
        // Send to chat system
        const result = await ChatSystem.sendMessage(message);
        
        // Add assistant response
        addChatMessage('assistant', result.response, result.context, result.tokensUsed);
        
    } catch (error) {
        addChatMessage('assistant', `Sorry, I encountered an error: ${error.message}`, {}, 0);
    }
}

function addChatMessage(type, content, context = null, tokensUsed = 0) {
    const messagesContainer = document.getElementById('chatMessages');
    if (!messagesContainer) return;
    
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${type}`;
    
    let contextIndicator = '';
    if (context && Object.keys(context).length > 0) {
        const contextTypes = Object.keys(context).filter(key => context[key]?.length > 0);
        if (contextTypes.length > 0) {
            contextIndicator = `<div class="context-indicator">üéØ Context: ${contextTypes.join(', ')}</div>`;
        }
    }
    
    messageDiv.innerHTML = `
        ${contextIndicator}
        ${content.replace(/\n/g, '<br>')}
        <div class="message-tokens">Tokens: ${tokensUsed}</div>
    `;
    
    messagesContainer.appendChild(messageDiv);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
}
// Complete updateComponentsLibrary function that was cut off in Part 5

function updateComponentsLibrary() {
    const container = document.getElementById('componentsLibrary');
    if (!container) return;
    
    if (AppState.components.length === 0) {
        container.innerHTML = '<p>No components analyzed yet. Upload files to get started.</p>';
        return;
    }
    
    // Categorize components by type with business grouping
    const componentCategories = categorizeComponentsForLibrary();
    
    container.innerHTML = `
        <div class="components-library-header" style="background: white; padding: 25px; border-radius: 12px; margin-bottom: 25px; box-shadow: 0 4px 15px rgba(0,0,0,0.1);">
            <h2 style="color: #667eea; margin: 0 0 20px 0;">üè¢ Business Components Library</h2>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 15px; text-align: center;">
                ${Object.entries(componentCategories).map(([categoryName, categoryData]) => `
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; cursor: pointer;" onclick="scrollToCategory('${categoryName}')">
                        <div style="font-size: 20px; margin-bottom: 5px;">${categoryData.icon}</div>
                        <div style="font-size: 24px; font-weight: 600; color: ${categoryData.color};">${categoryData.components.length}</div>
                        <div style="font-size: 12px; color: #666;">${categoryData.title}</div>
                    </div>
                `).join('')}
            </div>
        </div>
        
        <div class="components-categories">
            ${Object.entries(componentCategories).map(([categoryName, categoryData]) => 
                generateComponentCategory(categoryName, categoryData)
            ).join('')}
        </div>
    `;
}

function categorizeComponentsForLibrary() {
    const categories = {
        BUSINESS_PROGRAMS: {
            title: 'Business Programs',
            icon: 'üíº',
            color: '#4CAF50',
            components: AppState.components.filter(c => c.type === 'CBL' || c.type === 'COB'),
            description: 'Main business logic and processing programs'
        },
        RECORD_LAYOUTS: {
            title: 'Data Structures',
            icon: 'üìã',
            color: '#2196F3',
            components: AppState.components.filter(c => c.type === 'RECORD_LAYOUT'),
            description: 'Data record definitions and field layouts'
        },
        COPYBOOKS: {
            title: 'Shared Libraries',
            icon: 'üìö',
            color: '#FF9800',
            components: AppState.components.filter(c => c.type === 'COPY'),
            description: 'Reusable code and data definitions'
        },
        JCL_PROCEDURES: {
            title: 'Job Controls',
            icon: '‚öôÔ∏è',
            color: '#9C27B0',
            components: AppState.components.filter(c => c.type === 'JCL' || c.type === 'PROC'),
            description: 'Job control and execution procedures'
        }
    };
    
    // Remove empty categories
    Object.keys(categories).forEach(key => {
        if (categories[key].components.length === 0) {
            delete categories[key];
        }
    });
    
    return categories;
}

function generateComponentCategory(categoryName, categoryData) {
    return `
        <div id="category-${categoryName}" class="component-category" style="background: white; border-radius: 15px; padding: 25px; margin-bottom: 25px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); border-left: 5px solid ${categoryData.color};">
            <div class="category-header" style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px;">
                <div style="display: flex; align-items: center;">
                    <span style="font-size: 28px; margin-right: 15px;">${categoryData.icon}</span>
                    <div>
                        <h3 style="color: ${categoryData.color}; margin: 0; font-size: 20px;">${categoryData.title}</h3>
                        <p style="margin: 5px 0 0 0; color: #666; font-size: 14px;">${categoryData.description}</p>
                    </div>
                </div>
                <div style="text-align: right;">
                    <div style="font-size: 24px; font-weight: 600; color: ${categoryData.color};">${categoryData.components.length}</div>
                    <div style="font-size: 12px; color: #666;">Components</div>
                </div>
            </div>
            
            <div class="component-cards" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 20px;">
                ${categoryData.components.map(component => generateEnhancedComponentCard(component, categoryData.color)).join('')}
            </div>
        </div>
    `;
}

function generateEnhancedComponentCard(component, categoryColor) {
    const displayName = component.displayName || component.friendlyName || component.name;
    const businessLogicCount = component.businessLogic?.length || 0;
    const fieldCount = component.fields?.length || 0;
    const dependencyCount = component.dependencies?.length || 0;
    const cicsCount = component.cicsOperations?.length || 0;
    
    // Get component's stored business logic and code
    const storedLogic = getStoredComponentLogic(component.name);
    const storedCode = getStoredComponentCode(component.name);
    
    return `
        <div class="enhanced-component-card" style="background: #f8f9fa; border-radius: 12px; padding: 20px; border: 1px solid #e0e0e0; transition: all 0.3s ease;" 
             onmouseover="this.style.boxShadow='0 8px 25px rgba(0,0,0,0.15)'; this.style.transform='translateY(-2px)'"
             onmouseout="this.style.boxShadow='none'; this.style.transform='translateY(0)'">
            
            <div class="card-header" style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 15px;">
                <div>
                    <h4 style="color: ${categoryColor}; margin: 0 0 5px 0; font-size: 16px; cursor: pointer;" 
                        onclick="viewComponentDetails('${component.name}')">${displayName}</h4>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <span style="background: ${categoryColor}; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px;">${component.type}</span>
                        ${component.parentComponent ? `<span style="background: #e9ecef; color: #495057; padding: 2px 6px; border-radius: 3px; font-size: 10px;">Child of ${component.parentComponent}</span>` : ''}
                    </div>
                </div>
                <button onclick="viewComponentCode('${component.name}')" 
                        style="background: #667eea; color: white; border: none; padding: 6px 10px; border-radius: 6px; cursor: pointer; font-size: 11px;">
                    üìÑ View Code
                </button>
            </div>
            
            <!-- Component Metrics -->
            <div class="card-metrics" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-bottom: 15px;">
                <div style="text-align: center; background: white; padding: 8px; border-radius: 6px;">
                    <div style="font-size: 16px; font-weight: 600; color: #2196F3;">${fieldCount}</div>
                    <div style="font-size: 10px; color: #666;">Fields</div>
                </div>
                <div style="text-align: center; background: white; padding: 8px; border-radius: 6px;">
                    <div style="font-size: 16px; font-weight: 600; color: #4CAF50;">${dependencyCount}</div>
                    <div style="font-size: 10px; color: #666;">Dependencies</div>
                </div>
                <div style="text-align: center; background: white; padding: 8px; border-radius: 6px;">
                    <div style="font-size: 16px; font-weight: 600; color: #FF9800;">${businessLogicCount}</div>
                    <div style="font-size: 10px; color: #666;">Logic Rules</div>
                </div>
                <div style="text-align: center; background: white; padding: 8px; border-radius: 6px;">
                    <div style="font-size: 16px; font-weight: 600; color: #9C27B0;">${cicsCount}</div>
                    <div style="font-size: 10px; color: #666;">CICS Ops</div>
                </div>
            </div>
            
            <!-- Record Layout Fields (for RECORD_LAYOUT type) -->
            ${component.type === 'RECORD_LAYOUT' && fieldCount > 0 ? `
                <div class="record-fields" style="margin-bottom: 15px;">
                    <h5 style="color: #667eea; margin: 0 0 8px 0; font-size: 12px;">üìã Record Fields</h5>
                    <div style="max-height: 120px; overflow-y: auto; background: white; padding: 10px; border-radius: 6px;">
                        ${component.fields.slice(0, 8).map(field => `
                            <div style="display: flex; justify-content: between; align-items: center; padding: 4px 0; border-bottom: 1px solid #f0f0f0;">
                                <span style="font-weight: 600; font-size: 11px; color: #2c3e50;">${field.name}</span>
                                <span style="font-family: monospace; font-size: 10px; color: #666; background: #f8f9fa; padding: 1px 4px; border-radius: 2px;">${field.dataType}</span>
                                <span style="font-size: 9px; color: #999;">Lv${field.level}</span>
                            </div>
                        `).join('')}
                        ${fieldCount > 8 ? `<div style="text-align: center; padding: 8px; font-size: 11px; color: #666; font-style: italic;">...and ${fieldCount - 8} more fields</div>` : ''}
                    </div>
                </div>
            ` : ''}
            
            <!-- Business Logic Preview -->
            ${businessLogicCount > 0 ? `
                <div class="business-logic" style="margin-bottom: 15px;">
                    <h5 style="color: #667eea; margin: 0 0 8px 0; font-size: 12px;">üß† Business Logic</h5>
                    <div style="display: flex; flex-wrap: wrap; gap: 4px;">
                        ${[...new Set(component.businessLogic.map(l => l.type))].slice(0, 5).map(logicType => {
                            const logicColors = {
                                'MOVE': '#4CAF50',
                                'DERIVED': '#2196F3',
                                'CONDITIONAL': '#FF9800',
                                'CALCULATED': '#9C27B0',
                                'STRING_MANIPULATION': '#607D8B'
                            };
                            return `<span style="background: ${logicColors[logicType] || '#999'}; color: white; padding: 2px 6px; border-radius: 3px; font-size: 9px;">${logicType}</span>`;
                        }).join('')}
                    </div>
                </div>
            ` : ''}
            
            <!-- Associated Code Status -->
            <div class="code-status" style="background: white; padding: 10px; border-radius: 6px; border: 1px solid #e0e0e0;">
                <div style="display: flex; justify-content: between; align-items: center;">
                    <div>
                        <span style="font-size: 11px; color: #666;">Code Status:</span>
                        <span style="font-size: 11px; color: ${storedCode ? '#4CAF50' : '#FF9800'}; font-weight: 600;">
                            ${storedCode ? '‚úÖ Stored in Database' : '‚ö†Ô∏è Code Analysis Pending'}
                        </span>
                    </div>
                    <div>
                        <span style="font-size: 11px; color: #666;">Logic Rules:</span>
                        <span style="font-size: 11px; color: ${storedLogic ? '#4CAF50' : '#ccc'}; font-weight: 600;">
                            ${storedLogic ? `‚úÖ ${businessLogicCount} Rules` : '‚ûñ No Rules'}
                        </span>
                    </div>
                </div>
            </div>
            
            <!-- Action Buttons -->
            <div class="card-actions" style="display: flex; gap: 8px; margin-top: 15px;">
                <button onclick="viewComponentDetails('${component.name}')" 
                        style="flex: 1; background: ${categoryColor}; color: white; border: none; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 11px;">
                    üìä Details
                </button>
                <button onclick="viewBusinessLogic('${component.name}')" 
                        style="flex: 1; background: #FF9800; color: white; border: none; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 11px;">
                    üß† Logic
                </button>
                ${component.type !== 'RECORD_LAYOUT' ? `
                    <button onclick="generateOracleMapping('${component.name}')" 
                            style="flex: 1; background: #4CAF50; color: white; border: none; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 11px;">
                        üîÑ Oracle
                    </button>
                ` : ''}
            </div>
        </div>
    `;
}

// Helper functions for stored data
function getStoredComponentLogic(componentName) {
    const component = db.tables.component_analysis.find(c => c.component_name === componentName);
    if (component && component.analysis_result_json) {
        try {
            const analysis = JSON.parse(component.analysis_result_json);
            return analysis.businessLogic || [];
        } catch (e) {
            return [];
        }
    }
    return [];
}

function getStoredComponentCode(componentName) {
    const component = AppState.components.find(c => c.name === componentName);
    return component?.content || '';
}

// New functions for enhanced component interactions
function scrollToCategory(categoryName) {
    const categoryElement = document.getElementById(`category-${categoryName}`);
    if (categoryElement) {
        categoryElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
}

function viewComponentCode(componentName) {
    const component = AppState.components.find(c => c.name === componentName);
    if (!component) return;
    
    const code = component.content || 'No code content available';
    const displayName = component.displayName || component.friendlyName || component.name;
    
    const codeHTML = `
        <div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
             background: white; padding: 30px; border-radius: 15px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); 
             z-index: 1000; max-width: 90vw; max-height: 80vh; overflow: hidden; display: flex; flex-direction: column;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 style="color: #667eea; margin: 0;">üìÑ ${displayName} - Source Code</h2>
                <button onclick="this.parentElement.parentElement.remove(); document.querySelector('.code-backdrop').remove();" 
                        style="background: #e74c3c; color: white; border: none; border-radius: 50%; 
                               width: 30px; height: 30px; cursor: pointer; font-size: 16px;">√ó</button>
            </div>
            
            <div style="margin-bottom: 15px;">
                <button onclick="copyCodeToClipboard('${componentName}')" 
                        style="background: #27ae60; color: white; border: none; padding: 8px 15px; border-radius: 6px; cursor: pointer; margin-right: 10px;">
                    üìã Copy Code
                </button>
                <button onclick="downloadCode('${componentName}')" 
                        style="background: #667eea; color: white; border: none; padding: 8px 15px; border-radius: 6px; cursor: pointer;">
                    üíæ Download
                </button>
            </div>
            
            <pre id="componentCode-${componentName}" style="flex: 1; background: #f8f9fa; padding: 20px; border-radius: 8px; overflow: auto; 
                     font-family: 'Courier New', monospace; font-size: 12px; white-space: pre-wrap; line-height: 1.4; margin: 0;">${code}</pre>
        </div>
        
        <div class="code-backdrop" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999;"
             onclick="this.previousElementSibling.remove(); this.remove();"></div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', codeHTML);
}

function viewBusinessLogic(componentName) {
    const component = AppState.components.find(c => c.name === componentName);
    if (!component || !component.businessLogic) return;
    
    const displayName = component.displayName || component.friendlyName || component.name;
    const businessLogic = component.businessLogic;
    
    const logicHTML = `
        <div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
             background: white; padding: 30px; border-radius: 15px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); 
             z-index: 1000; max-width: 80vw; max-height: 80vh; overflow-y: auto; width: 90%;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 style="color: #667eea; margin: 0;">üß† ${displayName} - Business Logic</h2>
                <button onclick="this.parentElement.parentElement.remove(); document.querySelector('.logic-backdrop').remove();" 
                        style="background: #e74c3c; color: white; border: none; border-radius: 50%; 
                               width: 30px; height: 30px; cursor: pointer; font-size: 16px;">√ó</button>
            </div>
            
            <div style="margin-bottom: 20px;">
                <div style="display: flex; gap: 15px; text-align: center;">
                    <div style="flex: 1; background: #f8f9fa; padding: 15px; border-radius: 8px;">
                        <div style="font-size: 20px; font-weight: 600; color: #667eea;">${businessLogic.length}</div>
                        <div style="font-size: 12px; color: #666;">Total Logic Rules</div>
                    </div>
                    <div style="flex: 1; background: #f8f9fa; padding: 15px; border-radius: 8px;">
                        <div style="font-size: 20px; font-weight: 600; color: #4CAF50;">${[...new Set(businessLogic.map(l => l.type))].length}</div>
                        <div style="font-size: 12px; color: #666;">Logic Types</div>
                    </div>
                    <div style="flex: 1; background: #f8f9fa; padding: 15px; border-radius: 8px;">
                        <div style="font-size: 20px; font-weight: 600; color: #FF9800;">${(businessLogic.reduce((sum, l) => sum + l.confidence, 0) / businessLogic.length * 100).toFixed(0)}%</div>
                        <div style="font-size: 12px; color: #666;">Avg Confidence</div>
                    </div>
                </div>
            </div>
            
            <div style="max-height: 400px; overflow-y: auto;">
                ${businessLogic.map((logic, index) => {
                    const logicColors = {
                        'MOVE': '#4CAF50',
                        'DERIVED': '#2196F3',
                        'CONDITIONAL': '#FF9800',
                        'CALCULATED': '#9C27B0',
                        'STRING_MANIPULATION': '#607D8B'
                    };
                    
                    return `
                        <div style="background: #f8f9fa; margin: 10px 0; padding: 15px; border-radius: 8px; border-left: 4px solid ${logicColors[logic.type] || '#999'};">
                            <div style="display: flex; justify-content: between; align-items: center; margin-bottom: 10px;">
                                <span style="background: ${logicColors[logic.type] || '#999'}; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; font-weight: 600;">${logic.type}</span>
                                <span style="font-size: 11px; color: #666;">Line ${logic.lineNumber || index + 1} ‚Ä¢ Confidence: ${(logic.confidence * 100).toFixed(0)}%</span>
                            </div>
                            
                            <div style="font-family: 'Courier New', monospace; background: white; padding: 10px; border-radius: 4px; font-size: 11px; overflow-x: auto;">
                                ${logic.pattern || 'No pattern available'}
                            </div>
                            
                            ${logic.source && logic.target ? `
                                <div style="margin-top: 8px; font-size: 12px; color: #555;">
                                    <strong>Source:</strong> ${logic.source} ‚Üí <strong>Target:</strong> ${logic.target}
                                </div>
                            ` : ''}
                        </div>
                    `;
                }).join('')}
            </div>
        </div>
        
        <div class="logic-backdrop" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999;"
             onclick="this.previousElementSibling.remove(); this.remove();"></div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', logicHTML);
}

function copyCodeToClipboard(componentName) {
    const codeElement = document.getElementById(`componentCode-${componentName}`);
    if (codeElement) {
        navigator.clipboard.writeText(codeElement.textContent).then(() => {
            alert('Code copied to clipboard!');
        }).catch(err => {
            console.error('Failed to copy code:', err);
        });
    }
}

function downloadCode(componentName) {
    const component = AppState.components.find(c => c.name === componentName);
    if (component && component.content) {
        const blob = new Blob([component.content], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${componentName}.${component.type.toLowerCase()}`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }
}

// Supporting functions for component library actions
function viewComponentDetails(componentName) {
    const component = AppState.components.find(c => c.name === componentName);
    if (!component) return;
    
    const detailsHTML = `
        <div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
             background: white; padding: 30px; border-radius: 15px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); 
             z-index: 1000; max-width: 800px; max-height: 80vh; overflow-y: auto; width: 90%;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 style="color: #667eea; margin: 0;">üìÑ ${component.name} - Details</h2>
                <button onclick="this.parentElement.parentElement.remove(); document.querySelector('.component-details-backdrop').remove();" 
                        style="background: #e74c3c; color: white; border: none; border-radius: 50%; 
                               width: 30px; height: 30px; cursor: pointer; font-size: 16px;">√ó</button>
            </div>
            
            <!-- Component Overview -->
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin-bottom: 25px;">
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 20px; font-weight: 600; color: #667eea;">${component.type}</div>
                    <div style="font-size: 12px; color: #666;">Type</div>
                </div>
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 20px; font-weight: 600; color: #27ae60;">${component.totalLines || 0}</div>
                    <div style="font-size: 12px; color: #666;">Lines of Code</div>
                </div>
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 20px; font-weight: 600; color: #f39c12;">${component.tokens || 0}</div>
                    <div style="font-size: 12px; color: #666;">Tokens</div>
                </div>
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 20px; font-weight: 600; color: #e74c3c;">${(component.confidence * 100).toFixed(0)}%</div>
                    <div style="font-size: 12px; color: #666;">Confidence</div>
                </div>
            </div>

            <!-- Fields Section -->
            ${component.fields && component.fields.length > 0 ? `
                <div style="margin-bottom: 25px;">
                    <h3 style="color: #667eea; margin-bottom: 15px;">üéØ Fields (${component.fields.length})</h3>
                    <div style="max-height: 200px; overflow-y: auto; background: #f8f9fa; padding: 15px; border-radius: 8px;">
                        ${component.fields.map(field => `
                            <div style="display: flex; justify-content: space-between; padding: 8px; margin: 4px 0; background: white; border-radius: 4px;">
                                <span style="font-weight: 600;">${field.name}</span>
                                <span style="font-family: monospace; color: #666;">${field.dataType}</span>
                                <span style="font-size: 11px; color: #999;">Line ${field.lineNumber}</span>
                            </div>
                        `).join('')}
                    </div>
                </div>
            ` : ''}

            <!-- Dependencies Section -->
            ${component.dependencies && component.dependencies.length > 0 ? `
                <div style="margin-bottom: 25px;">
                    <h3 style="color: #667eea; margin-bottom: 15px;">üîó Dependencies (${component.dependencies.length})</h3>
                    <div style="max-height: 200px; overflow-y: auto; background: #f8f9fa; padding: 15px; border-radius: 8px;">
                        ${component.dependencies.map(dep => {
                            const depIcons = {
                                'COPYBOOK': 'üìã',
                                'PROGRAM_CALL': 'üîÑ',
                                'FILE_OPERATION': 'üìÅ'
                            };
                            return `
                                <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px; margin: 4px 0; background: white; border-radius: 4px;">
                                    <span>${depIcons[dep.type] || 'üîó'} <strong>${dep.name}</strong></span>
                                    <span style="font-size: 11px; background: #667eea; color: white; padding: 2px 6px; border-radius: 3px;">${dep.type}</span>
                                    <span style="font-size: 11px; color: #999;">Line ${dep.lineNumber}</span>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
            ` : ''}

            <!-- Business Logic Section -->
            ${component.businessLogic && component.businessLogic.length > 0 ? `
                <div style="margin-bottom: 25px;">
                    <h3 style="color: #667eea; margin-bottom: 15px;">üß† Business Logic Patterns (${component.businessLogic.length})</h3>
                    <div style="max-height: 200px; overflow-y: auto; background: #f8f9fa; padding: 15px; border-radius: 8px;">
                        ${component.businessLogic.map(logic => {
                            const logicColors = {
                                'MOVE': '#27ae60',
                                'DERIVED': '#f39c12',
                                'CONDITIONAL': '#e74c3c',
                                'CALCULATED': '#9b59b6'
                            };
                            return `
                                <div style="padding: 8px; margin: 4px 0; background: white; border-radius: 4px;">
                                    <div style="display: flex; justify-content: between; align-items: center;">
                                        <span style="background: ${logicColors[logic.type] || '#95a5a6'}; color: white; padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: 600;">${logic.type}</span>
                                        <span style="font-size: 11px; color: #666; margin-left: auto;">Confidence: ${(logic.confidence * 100).toFixed(0)}%</span>
                                    </div>
                                    <div style="font-family: monospace; font-size: 11px; color: #333; margin-top: 5px; padding: 4px; background: #f0f0f0; border-radius: 3px; overflow-x: auto;">
                                        ${logic.pattern}
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
            ` : ''}

            <!-- CICS Operations Section -->
            ${component.cicsOperations && component.cicsOperations.length > 0 ? `
                <div>
                    <h3 style="color: #667eea; margin-bottom: 15px;">üíæ CICS Operations (${component.cicsOperations.length})</h3>
                    <div style="max-height: 200px; overflow-y: auto; background: #f8f9fa; padding: 15px; border-radius: 8px;">
                        ${component.cicsOperations.map(cics => `
                            <div style="padding: 8px; margin: 4px 0; background: white; border-radius: 4px;">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <span style="background: #3498db; color: white; padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: 600;">${cics.operation}</span>
                                    <span style="font-size: 11px; color: #666;">${cics.parameters}</span>
                                </div>
                                <div style="font-family: monospace; font-size: 10px; color: #333; margin-top: 4px; padding: 4px; background: #f0f0f0; border-radius: 3px; overflow-x: auto;">
                                    ${cics.fullStatement}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            ` : ''}
        </div>
        
        <div class="component-details-backdrop" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999;"
             onclick="this.previousElementSibling.remove(); this.remove();"></div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', detailsHTML);
}

function generateOracleMapping(componentName) {
    const component = AppState.components.find(c => c.name === componentName);
    if (!component || !component.fields || component.fields.length === 0) {
        alert('No fields found for Oracle mapping in this component.');
        return;
    }
    
    const tableName = componentName.toLowerCase().replace(/[^a-z0-9]/g, '_');
    let ddl = `-- Oracle DDL for ${componentName}\n-- Generated: ${new Date().toISOString()}\n\n`;
    ddl += `CREATE TABLE ${tableName} (\n`;
    
    const fieldDDLs = component.fields.map(field => {
        const columnName = field.name.toLowerCase().replace(/[^a-z0-9]/g, '_');
        let oracleType = 'VARCHAR2(100)'; // Default
        
        // Convert COBOL PIC to Oracle type
        if (field.dataType) {
            const dataType = field.dataType.toUpperCase();
            if (dataType.includes('9') && dataType.includes('V')) {
                const match = dataType.match(/9\((\d+)\)V9\((\d+)\)/);
                if (match) {
                    oracleType = `NUMBER(${parseInt(match[1]) + parseInt(match[2])}, ${match[2]})`;
                }
            } else if (dataType.includes('9')) {
                const match = dataType.match(/9\((\d+)\)/);
                if (match) {
                    oracleType = `NUMBER(${match[1]})`;
                }
            } else if (dataType.includes('X')) {
                const match = dataType.match(/X\((\d+)\)/);
                if (match) {
                    const len = parseInt(match[1]);
                    oracleType = len <= 4000 ? `VARCHAR2(${len})` : 'CLOB';
                }
            }
        }
        
        return `    ${columnName.padEnd(30)} ${oracleType}`;
    });
    
    ddl += fieldDDLs.join(',\n');
    ddl += '\n);\n\n';
    
    // Add comments
    ddl += `-- Field comments\n`;
    component.fields.forEach(field => {
        const columnName = field.name.toLowerCase().replace(/[^a-z0-9]/g, '_');
        ddl += `COMMENT ON COLUMN ${tableName}.${columnName} IS 'COBOL: ${field.dataType} - Level ${field.level} - Line ${field.lineNumber}';\n`;
    });
    
    // Show DDL in modal
    const ddlHTML = `
        <div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
             background: white; padding: 30px; border-radius: 15px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); 
             z-index: 1000; max-width: 800px; max-height: 80vh; overflow-y: auto; width: 90%;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 style="color: #667eea; margin: 0;">üîÑ Oracle DDL - ${componentName}</h2>
                <button onclick="this.parentElement.parentElement.remove(); document.querySelector('.ddl-backdrop').remove();" 
                        style="background: #e74c3c; color: white; border: none; border-radius: 50%; 
                               width: 30px; height: 30px; cursor: pointer; font-size: 16px;">√ó</button>
            </div>
            
            <div style="margin-bottom: 20px;">
                <button onclick="copyDDLToClipboard()" 
                        style="background: #27ae60; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; margin-right: 10px;">
                    üìã Copy DDL
                </button>
                <button onclick="downloadDDL('${componentName}')" 
                        style="background: #667eea; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer;">
                    üíæ Download SQL
                </button>
            </div>
            
            <pre style="background: #f8f9fa; padding: 20px; border-radius: 8px; overflow-x: auto; font-family: 'Courier New', monospace; font-size: 12px; white-space: pre-wrap;" id="ddlContent">${ddl}</pre>
        </div>
        
        <div class="ddl-backdrop" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999;"
             onclick="this.previousElementSibling.remove(); this.remove();"></div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', ddlHTML);
}

function copyDDLToClipboard() {
    const ddlContent = document.getElementById('ddlContent');
    if (ddlContent) {
        navigator.clipboard.writeText(ddlContent.textContent).then(() => {
            alert('DDL copied to clipboard!');
        }).catch(err => {
            console.error('Failed to copy DDL:', err);
            // Fallback selection method
            const range = document.createRange();
            range.selectNode(ddlContent);
            window.getSelection().removeAllRanges();
            window.getSelection().addRange(range);
        });
    }
}

function downloadDDL(componentName) {
    const ddlContent = document.getElementById('ddlContent');
    if (ddlContent) {
        const blob = new Blob([ddlContent.textContent], { type: 'text/sql' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${componentName.toLowerCase()}_oracle_ddl.sql`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }
}

// Add these functions to the global scope so they can be called from the HTML
window.viewComponentDetails = viewComponentDetails;
window.generateOracleMapping = generateOracleMapping;
window.copyDDLToClipboard = copyDDLToClipboard;
window.downloadDDL = downloadDDL;
// UI Update Functions
function updateMetrics() {
    const components = AppState.components;
    const programs = components.filter(c => c.type === 'CBL' || c.type === 'COB');
    const copybooks = components.filter(c => c.type === 'COPY');
    const totalFields = components.reduce((sum, c) => sum + (c.fields?.length || 0), 0);
    const totalLines = components.reduce((sum, c) => sum + (c.totalLines || 0), 0);
    
    const componentCountElement = document.getElementById('componentCount');
    if (componentCountElement) componentCountElement.textContent = components.length;
    
    const programCountElement = document.getElementById('programCount');
    if (programCountElement) programCountElement.textContent = programs.length;
    
    const copybookCountElement = document.getElementById('copybookCount');
    if (copybookCountElement) copybookCountElement.textContent = copybooks.length;
    
    const fieldCountElement = document.getElementById('fieldCount');
    if (fieldCountElement) fieldCountElement.textContent = totalFields;
    
    const linesOfCodeElement = document.getElementById('linesOfCode');
    if (linesOfCodeElement) linesOfCodeElement.textContent = totalLines.toLocaleString();
}


        // Fix the typo in showNodeDetails function
        function showNodeDetails(nodeId) {
            const relatedDependencies = AppState.dependencies.filter(d => 
                d.sourceComponent === nodeId || d.targetComponent === nodeId
            );
            
            const incomingDeps = relatedDependencies.filter(d => d.targetComponent === nodeId);
            const outgoingDeps = relatedDependencies.filter(d => d.sourceComponent === nodeId);
            
            const detailsHTML = `
                <div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
                     background: white; padding: 30px; border-radius: 15px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); 
                     z-index: 1000; max-width: 600px; max-height: 80vh; overflow-y: auto;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3 style="color: #667eea; margin: 0;">üìä ${nodeId} Details</h3>
                        <button onclick="this.parentElement.parentElement.remove(); document.querySelector('.modal-backdrop').remove();" 
                                style="background: #e74c3c; color: white; border: none; border-radius: 50%; 
                                       width: 30px; height: 30px; cursor: pointer; font-size: 16px;">√ó</button>
                    </div>
                    
                    <div style="margin-bottom: 20px;">
                        <h4 style="color: #27ae60; margin-bottom: 10px;">üì• Incoming Dependencies (${incomingDeps.length})</h4>
                        ${incomingDeps.length > 0 ? 
                            incomingDeps.map(dep => `
                                <div style="background: #f8f9fa; padding: 10px; margin: 5px 0; border-radius: 6px; border-left: 4px solid #27ae60;">
                                    <strong>${dep.sourceComponent}</strong> ‚Üí ${dep.relationshipType}
                                    <div style="font-size: 12px; color: #666;">${dep.interfaceType} (${(dep.confidenceScore * 100).toFixed(0)}% confidence)</div>
                                </div>
                            `).join('') : 
                            '<div style="color: #666; font-style: italic;">No incoming dependencies</div>'
                        }
                    </div>
                    
                    <div>
                        <h4 style="color: #f39c12; margin-bottom: 10px;">üì§ Outgoing Dependencies (${outgoingDeps.length})</h4>
                        ${outgoingDeps.length > 0 ? 
                            outgoingDeps.map(dep => `
                                <div style="background: #f8f9fa; padding: 10px; margin: 5px 0; border-radius: 6px; border-left: 4px solid #f39c12;">
                                    ${dep.relationshipType} ‚Üí <strong>${dep.targetComponent}</strong>
                                    <div style="font-size: 12px; color: #666;">${dep.interfaceType} (${(dep.confidenceScore * 100).toFixed(0)}% confidence)</div>
                                </div>
                            `).join('') : 
                            '<div style="color: #666; font-style: italic;">No outgoing dependencies</div>'
                        }
                    </div>
                </div>
                
                <div class="modal-backdrop" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999;"
                     onclick="this.previousElementSibling.remove(); this.remove();"></div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', detailsHTML);
        }

        // Enhanced Chat Response Generators for complete functionality
        ChatSystem.generateFieldMappingResponse = function(message, context) {
            const fieldMappings = context.fieldMappings || [];
            const summary = context.fieldMappingsSummary || {};

            if (fieldMappings.length === 0) {
                return `**Field Mapping Analysis**

I can help analyze field mappings in your mainframe code. After analyzing your COBOL programs, I'll show you:

üéØ **Field Mapping Features**:
‚Ä¢ **Business Logic Detection**: MOVE, COMPUTE, conditional, calculated operations
‚Ä¢ **Data Type Conversion**: Automatic COBOL PIC to Oracle type mapping
‚Ä¢ **Multi-Program Analysis**: Consolidate logic across all programs that use a field
‚Ä¢ **Confidence Scoring**: Rate the accuracy of each field mapping
‚Ä¢ **Oracle DDL Generation**: Complete table creation scripts

Upload your COBOL programs and use the ‚≠ê Field Mapping tab to analyze specific files.`;
            }

            const logicPatterns = {};
            fieldMappings.forEach(field => {
                const type = field.businessLogicType;
                logicPatterns[type] = (logicPatterns[type] || 0) + 1;
            });

            return `**Field Mapping Analysis Results**

üìä **Summary**: ${summary.totalFields} fields analyzed across ${summary.programsInvolved?.length || 0} programs

üîç **Business Logic Patterns**:
${Object.entries(logicPatterns).map(([type, count]) => {
    const icon = {
        'MOVE': '‚û°Ô∏è',
        'DERIVED': 'üßÆ',
        'CONDITIONAL': 'üîÄ',
        'CALCULATED': 'üî¢',
        'STRING_MANIPULATION': 'üî§',
        'MULTI_SOURCE': 'üîÑ'
    }[type] || 'üìã';
    
    return `${icon} **${type}**: ${count} fields`;
}).join('\n')}

üìà **Oracle Migration Readiness**: ${(summary.averageConfidence * 100).toFixed(0)}% average confidence

üéØ **Next Steps**:
‚Ä¢ Review fields with MULTI_SOURCE logic for conflicts
‚Ä¢ Generate Oracle DDL for validated field mappings
‚Ä¢ Plan data migration scripts for complex business logic

Would you like me to generate Oracle DDL for any specific file or analyze business logic patterns in more detail?`;
        };

        ChatSystem.generateOracleConversionResponse = function(message, context) {
            const fieldMappings = context.fieldMappings || [];

            if (fieldMappings.length === 0) {
                return `**Oracle Conversion Guide**

I can help convert your COBOL data structures to Oracle. Here are the key conversion patterns:

üîÑ **Data Type Conversions**:
‚Ä¢ **PIC 9(n)** ‚Üí **NUMBER(n)**
‚Ä¢ **PIC 9(n)V9(m)** ‚Üí **NUMBER(n+m, m)**  
‚Ä¢ **PIC X(n)** ‚Üí **VARCHAR2(n)** (max 4000, else CLOB)
‚Ä¢ **COMP-3** ‚Üí **NUMBER** with packed decimal calculation
‚Ä¢ **COMP** ‚Üí **NUMBER** with binary estimation

üìä **Business Logic Migration**:
‚Ä¢ **MOVE operations** ‚Üí Direct SQL INSERT/UPDATE
‚Ä¢ **COMPUTE statements** ‚Üí PL/SQL functions or triggers
‚Ä¢ **Conditional logic** ‚Üí CASE statements or stored procedures
‚Ä¢ **String operations** ‚Üí Oracle string functions

Upload COBOL programs to see specific conversion recommendations for your fields.`;
            }

            const conversionExamples = fieldMappings.slice(0, 5).map(field => {
                return `‚Ä¢ **${field.fieldName}**: ${field.mainframeDataType} ‚Üí ${field.oracleDataType}`;
            }).join('\n');

            return `**Oracle Conversion Analysis**

üîÑ **Data Type Conversions**:
${conversionExamples}

üìã **Migration Strategy**:
‚Ä¢ **${fieldMappings.filter(f => f.businessLogicType === 'MOVE').length} MOVE operations**: Direct field assignments ‚Üí SQL DML
‚Ä¢ **${fieldMappings.filter(f => f.businessLogicType === 'CALCULATED').length} Calculated fields**: Arithmetic operations ‚Üí PL/SQL functions
‚Ä¢ **${fieldMappings.filter(f => f.businessLogicType === 'CONDITIONAL').length} Conditional logic**: IF-THEN patterns ‚Üí CASE statements

üéØ **Generated Oracle DDL Example**:
\`\`\`sql
CREATE TABLE customer_data (
  customer_id NUMBER(10),
  account_balance NUMBER(11,2),
  status_code VARCHAR2(3),
  last_activity_date DATE
);
\`\`\`

Would you like me to generate complete Oracle DDL for a specific file or provide detailed migration scripts?`;
        };

        ChatSystem.generateCICSResponse = function(message, context) {
            const cicsOps = context.cicsOperations || [];
            const cicsSummary = context.cicsSummary || {};

            if (cicsOps.length === 0) {
                return `**CICS Operations Modernization**

I can help analyze CICS operations in your mainframe code. Here's what I look for:

üîç **CICS Operation Categories**:
‚Ä¢ **üìñ Read Operations**: READ, RECEIVE, READNEXT, READPREV, STARTBR
‚Ä¢ **‚úèÔ∏è Write Operations**: WRITE, SEND, REWRITE, DELETE
‚Ä¢ **üîÑ Transaction Operations**: LINK, XCTL, RETURN, SYNCPOINT
‚Ä¢ **üíª Terminal Operations**: SEND, RECEIVE, CONVERSE
‚Ä¢ **üìã Queue Operations**: WRITEQ, READQ, DELETEQ

Upload COBOL programs with CICS commands to see detailed modernization strategies.`;
            }

            const opsByCategory = {};
            cicsOps.forEach(op => {
                if (!opsByCategory[op.category]) {
                    opsByCategory[op.category] = [];
                }
                opsByCategory[op.category].push(op);
            });

            return `**CICS Operations Analysis**

üìä **Summary**: ${cicsSummary.totalOperations} CICS operations found

üéØ **Operation Categories**:
${Object.entries(opsByCategory).map(([category, ops]) => {
    const icon = {
        'read_operation': 'üìñ',
        'write_operation': '‚úèÔ∏è',
        'transaction_operation': 'üîÑ',
        'terminal_operation': 'üíª',
        'queue_operation': 'üìã'
    }[category.toLowerCase()] || 'üîß';
    
    return `${icon} **${category.replace('_', ' ').toUpperCase()}**: ${ops.length} operations`;
}).join('\n')}

üèóÔ∏è **Modernization Strategy**:

**üìñ File Operations** ‚Üí **Database Transactions**:
‚Ä¢ Replace EXEC CICS READ with SELECT statements
‚Ä¢ Convert EXEC CICS WRITE to INSERT/UPDATE operations
‚Ä¢ Implement connection pooling and transaction management

**üíª Terminal Operations** ‚Üí **Web Services**:
‚Ä¢ Replace 3270 terminal interaction with REST APIs
‚Ä¢ Convert SEND/RECEIVE to JSON request/response patterns
‚Ä¢ Implement modern authentication and session management

**Example Conversion**:
\`\`\`sql
-- CICS: EXEC CICS READ FILE('CUSTOMER') INTO(CUST-REC) END-EXEC
-- Oracle: SELECT * FROM customers WHERE customer_id = :cust_id;
\`\`\`

Would you like specific modernization recommendations for any CICS operation patterns?`;
        };

        ChatSystem.generateDependencyResponse = function(message, context) {
            const dependencies = context.dependencies || [];
            const summary = context.dependenciesSummary || {};

            if (dependencies.length === 0) {
                return `**Dependency Analysis**

I can help you understand component relationships in your mainframe system. After analyzing your code, I'll show you:

üîó **Dependency Types**:
‚Ä¢ **COPYBOOK_INCLUDE**: Shared data structures
‚Ä¢ **PROGRAM_CALL**: Program-to-program linkage  
‚Ä¢ **CICS_FILE_ACCESS**: Transaction file operations
‚Ä¢ **FILE_OPERATION**: Batch file processing
‚Ä¢ **INTERNAL_CALL**: PERFORM statements within programs

Upload your COBOL programs to see the complete dependency map and modernization impact analysis.`;
            }

            const depsByType = {};
            dependencies.forEach(dep => {
                if (!depsByType[dep.relationshipType]) {
                    depsByType[dep.relationshipType] = [];
                }
                depsByType[dep.relationshipType].push(dep);
            });

            const mostReferenced = summary.mostReferencedComponents || [];

            return `**Dependency Relationship Analysis**

üìä **Overview**: ${summary.totalDependencies} dependencies across ${summary.relationshipTypes?.length || 0} relationship types

üîó **Dependency Breakdown**:
${Object.entries(depsByType).map(([type, deps]) => {
    const icon = {
        'COPYBOOK_INCLUDE': 'üìã',
        'PROGRAM_CALL': 'üîÑ',
        'CICS_FILE_ACCESS': 'üíæ',
        'FILE_OPERATION': 'üìÅ',
        'INTERNAL_CALL': 'üéØ'
    }[type] || 'üîó';
    
    return `${icon} **${type}**: ${deps.length} relationships
   ${deps.slice(0, 2).map(dep => `   ‚Ä¢ ${dep.sourceComponent} ‚Üí ${dep.targetComponent} (${(dep.confidenceScore * 100).toFixed(0)}% confidence)`).join('\n   ')}`;
}).join('\n\n')}

üéØ **Most Referenced Components**:
${mostReferenced.slice(0, 5).map((item, index) => 
    `${index + 1}. **${item.component}** (${item.count} references)`
).join('\n')}

‚ö†Ô∏è **Impact Analysis**:
‚Ä¢ **High Impact**: Components with 5+ dependencies require careful migration planning
‚Ä¢ **Medium Impact**: Shared copybooks affect multiple programs
‚Ä¢ **Low Impact**: Isolated programs can be migrated independently

üöÄ **Modernization Strategy**:

**üìã Copybook Dependencies** ‚Üí **Data Transfer Objects (DTOs)**
\`\`\`java
// Convert COBOL copybook to Java DTO
public class CustomerData {
    private Long customerId;
    private String customerName;
    private BigDecimal accountBalance;
}
\`\`\`

**üîÑ Program Calls** ‚Üí **Microservice APIs**
\`\`\`yaml
# Convert CALL statements to REST calls
POST /api/customer/validate
Content-Type: application/json
{ "customerId": "12345", "operation": "validate" }
\`\`\`

**üíæ File Dependencies** ‚Üí **Database Relationships**
\`\`\`sql
-- Convert file relationships to foreign keys
ALTER TABLE accounts 
ADD CONSTRAINT fk_customer 
FOREIGN KEY (customer_id) REFERENCES customers(id);
\`\`\`

Would you like me to analyze the impact of changing any specific component?`;
        };

        ChatSystem.generateModernizationResponse = function(message, context) {
            const complexity = context.modernizationMetrics?.complexity || this.calculateModernizationComplexity();
            const riskAssessment = context.modernizationMetrics?.riskAssessment || this.calculateRiskAssessment();
            const recommendations = context.modernizationMetrics?.recommendations || this.generateModernizationRecommendations();

            return `**Mainframe Modernization Strategy**

üìä **Complexity Assessment**: **${complexity.level}** (Score: ${complexity.score.toFixed(1)}/10)

üéØ **Risk Distribution**:
‚Ä¢ üü¢ **Low Risk**: ${riskAssessment.lowRisk} components (${((riskAssessment.lowRisk/riskAssessment.totalComponents)*100).toFixed(0)}%)
‚Ä¢ üü° **Medium Risk**: ${riskAssessment.mediumRisk} components (${((riskAssessment.mediumRisk/riskAssessment.totalComponents)*100).toFixed(0)}%)
‚Ä¢ üî¥ **High Risk**: ${riskAssessment.highRisk} components (${((riskAssessment.highRisk/riskAssessment.totalComponents)*100).toFixed(0)}%)

üìà **Complexity Factors**:
‚Ä¢ **Components**: ${complexity.factors.componentCount} programs/copybooks
‚Ä¢ **Dependencies**: ${complexity.factors.dependencyCount} relationships
‚Ä¢ **CICS Operations**: ${complexity.factors.cicsComplexity} transaction calls
‚Ä¢ **Business Logic**: ${complexity.factors.businessLogicComplexity} complex patterns

üöÄ **Recommended Migration Approach**:

${recommendations.map((rec, index) => `**${rec.phase}**
‚Ä¢ **Approach**: ${rec.approach}
‚Ä¢ **Timeline**: ${rec.timeline}
‚Ä¢ **Priority**: ${rec.priority}
`).join('\n')}

üèóÔ∏è **Technology Stack Recommendations**:

**Database Layer**:
‚Ä¢ **Oracle 19c+** with PL/SQL for complex business logic
‚Ä¢ **Connection pooling** with Oracle UCP
‚Ä¢ **Automatic failover** with Oracle RAC

**Application Layer**:
‚Ä¢ **Java Spring Boot** for REST APIs and business services
‚Ä¢ **Apache Kafka** for event-driven architecture
‚Ä¢ **Redis** for caching and session management

**Integration Layer**:
‚Ä¢ **REST APIs** to replace CICS transactions
‚Ä¢ **GraphQL** for flexible data queries
‚Ä¢ **Message queues** for asynchronous processing

**DevOps & Monitoring**:
‚Ä¢ **Docker/Kubernetes** for containerized deployment
‚Ä¢ **Jenkins** for CI/CD pipelines  
‚Ä¢ **ELK Stack** for logging and monitoring

üìã **Migration Phases**:

**Phase 1: Foundation (Months 1-3)**
‚Ä¢ Set up Oracle database infrastructure
‚Ä¢ Migrate simple batch programs
‚Ä¢ Establish CI/CD pipelines

**Phase 2: Core Services (Months 4-8)**
‚Ä¢ Convert CICS file operations to database transactions
‚Ä¢ Implement REST APIs for program calls
‚Ä¢ Migrate business logic to Java services

**Phase 3: User Interfaces (Months 9-12)**
‚Ä¢ Replace 3270 terminals with web interfaces
‚Ä¢ Implement modern authentication/authorization
‚Ä¢ Performance optimization and testing

**üí∞ Cost-Benefit Analysis**:
‚Ä¢ **Development Cost**: Estimated ${complexity.level === 'Low' ? '$500K-1M' : complexity.level === 'Medium' ? '$1M-3M' : '$3M-5M+'}
‚Ä¢ **Timeline**: ${complexity.level === 'Low' ? '12-18' : complexity.level === 'Medium' ? '18-24' : '24-36'} months
‚Ä¢ **ROI**: Infrastructure cost reduction, improved maintainability, faster feature delivery

Would you like me to elaborate on any specific aspect of the modernization strategy?`;
        };

        // Advanced Analytics and Reporting Functions
        function generateComprehensiveReport() {
            const report = {
                executiveSummary: generateExecutiveSummary(),
                technicalAnalysis: generateTechnicalAnalysis(),
                migrationRoadmap: generateMigrationRoadmap(),
                riskAssessment: generateDetailedRiskAssessment(),
                costEstimation: generateCostEstimation(),
                recommendations: generateDetailedRecommendations()
            };

            const reportHTML = `
                <div style="font-family: 'Segoe UI', sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px;">
                    <header style="text-align: center; margin-bottom: 40px;">
                        <h1 style="color: #2c3e50; margin-bottom: 10px;">üìä Mainframe Modernization Analysis Report</h1>
                        <p style="color: #666; font-size: 16px;">Session: ${AppState.sessionId} | Generated: ${new Date().toLocaleDateString()}</p>
                    </header>

                    <section style="margin-bottom: 40px; background: white; padding: 30px; border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.1);">
                        <h2 style="color: #667eea; border-bottom: 2px solid #667eea; padding-bottom: 10px;">üéØ Executive Summary</h2>
                        ${report.executiveSummary}
                    </section>

                    <section style="margin-bottom: 40px; background: white; padding: 30px; border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.1);">
                        <h2 style="color: #667eea; border-bottom: 2px solid #667eea; padding-bottom: 10px;">üîß Technical Analysis</h2>
                        ${report.technicalAnalysis}
                    </section>

                    <section style="margin-bottom: 40px; background: white; padding: 30px; border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.1);">
                        <h2 style="color: #667eea; border-bottom: 2px solid #667eea; padding-bottom: 10px;">üó∫Ô∏è Migration Roadmap</h2>
                        ${report.migrationRoadmap}
                    </section>

                    <section style="margin-bottom: 40px; background: white; padding: 30px; border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.1);">
                        <h2 style="color: #667eea; border-bottom: 2px solid #667eea; padding-bottom: 10px;">‚ö†Ô∏è Risk Assessment</h2>
                        ${report.riskAssessment}
                    </section>

                    <section style="margin-bottom: 40px; background: white; padding: 30px; border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.1);">
                        <h2 style="color: #667eea; border-bottom: 2px solid #667eea; padding-bottom: 10px;">üí∞ Cost Estimation</h2>
                        ${report.costEstimation}
                    </section>

                    <section style="background: white; padding: 30px; border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.1);">
                        <h2 style="color: #667eea; border-bottom: 2px solid #667eea; padding-bottom: 10px;">üéØ Recommendations</h2>
                        ${report.recommendations}
                    </section>
                </div>
            `;

            // Create downloadable report
            const reportWindow = window.open('', '_blank');
            reportWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>Mainframe Modernization Report - ${AppState.sessionId}</title>
                    <style>
                        body { margin: 0; padding: 20px; background: #f5f5f5; }
                        @media print { body { background: white; } }
                    </style>
                </head>
                <body>${reportHTML}</body>
                </html>
            `);
            reportWindow.document.close();
        }

        function generateExecutiveSummary() {
            const components = AppState.components.length;
            const fields = AppState.fieldMappings.length;
            const dependencies = AppState.dependencies.length;
            const complexity = ChatSystem.calculateModernizationComplexity();

            return `
                <p><strong>Analysis Overview:</strong> This comprehensive analysis examined ${components} mainframe components, mapped ${fields} data fields, and identified ${dependencies} system dependencies.</p>
                
                <p><strong>Modernization Readiness:</strong> The system demonstrates <strong>${complexity.level}</strong> complexity with a modernization readiness score of <strong>${(100 - complexity.score * 10).toFixed(0)}%</strong>.</p>
                
                <p><strong>Key Findings:</strong></p>
                <ul>
                    <li>üéØ <strong>${fields}</strong> fields successfully mapped with Oracle conversion strategies</li>
                    <li>üîó <strong>${dependencies}</strong> dependencies analyzed for modernization impact</li>
                    <li>ü§ñ <strong>${VLLMAPIManager.serverConfigured ? 'AI-Enhanced' : 'Pattern-Based'}</strong> analysis using ${VLLMAPIManager.serverConfigured ? 'vLLM (Llama 3.1)' : 'rule-based algorithms'}</li>
                </ul>
                
                <p><strong>Strategic Recommendation:</strong> ${complexity.level === 'Low' ? 'Proceed with aggressive modernization timeline' : complexity.level === 'Medium' ? 'Implement phased modernization approach' : 'Recommend extensive analysis and risk mitigation before modernization'}</p>
            `;
        }

        function generateTechnicalAnalysis() {
            const businessLogicTypes = [...new Set(AppState.fieldMappings.map(f => f.businessLogicType))];
            const cicsOps = AppState.components.reduce((sum, c) => sum + (c.cicsOperations?.length || 0), 0);

            return `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                    <div>
                        <h4>üìä Component Breakdown</h4>
                        <ul>
                            <li><strong>Programs:</strong> ${AppState.components.filter(c => c.type === 'CBL' || c.type === 'COB').length}</li>
                            <li><strong>Copybooks:</strong> ${AppState.components.filter(c => c.type === 'COPY').length}</li>
                            <li><strong>Total Lines:</strong> ${AppState.components.reduce((sum, c) => sum + (c.totalLines || 0), 0).toLocaleString()}</li>
                        </ul>
                    </div>
                    <div>
                        <h4>üß† Business Logic Analysis</h4>
                        <ul>
                            ${businessLogicTypes.map(type => 
                                `<li><strong>${type}:</strong> ${AppState.fieldMappings.filter(f => f.businessLogicType === type).length} fields</li>`
                            ).join('')}
                        </ul>
                    </div>
                </div>
                
                <h4>üíæ CICS Operations: ${cicsOps} total</h4>
                <p>Transaction processing complexity indicates ${cicsOps > 50 ? 'high' : cicsOps > 20 ? 'medium' : 'low'} modernization effort required for online systems.</p>
                
                <h4>üîÑ Oracle Conversion Strategy</h4>
                <p>Data type mappings show ${((AppState.fieldMappings.filter(f => f.confidenceScore >= 0.8).length / AppState.fieldMappings.length) * 100).toFixed(0)}% high-confidence conversions ready for automated migration.</p>
            `;
        }

        function generateMigrationRoadmap() {
            const complexity = ChatSystem.calculateModernizationComplexity();
            const timeline = complexity.level === 'Low' ? '12-18' : complexity.level === 'Medium' ? '18-24' : '24-36';

            return `
                <div style="margin-bottom: 30px;">
                    <p><strong>Estimated Timeline:</strong> ${timeline} months</p>
                    <p><strong>Approach:</strong> ${complexity.level === 'Low' ? 'Aggressive parallel modernization' : complexity.level === 'Medium' ? 'Phased incremental migration' : 'Conservative risk-managed transformation'}</p>
                </div>

                <div style="display: flex; justify-content: space-between; margin-bottom: 20px;">
                    <div style="flex: 1; background: #e8f5e8; padding: 15px; margin-right: 10px; border-radius: 8px;">
                        <h4 style="color: #27ae60; margin-top: 0;">Phase 1: Foundation</h4>
                        <p><strong>Duration:</strong> 3-6 months</p>
                        <ul>
                            <li>Oracle database setup</li>
                            <li>CI/CD pipeline establishment</li>
                            <li>Simple batch program migration</li>
                        </ul>
                    </div>
                    <div style="flex: 1; background: #fff3e0; padding: 15px; margin: 0 5px; border-radius: 8px;">
                        <h4 style="color: #f57c00; margin-top: 0;">Phase 2: Core Systems</h4>
                        <p><strong>Duration:</strong> 6-12 months</p>
                        <ul>
                            <li>CICS transaction conversion</li>
                            <li>Business logic migration</li>
                            <li>API development</li>
                        </ul>
                    </div>
                    <div style="flex: 1; background: #e3f2fd; padding: 15px; margin-left: 10px; border-radius: 8px;">
                        <h4 style="color: #1976d2; margin-top: 0;">Phase 3: Integration</h4>
                        <p><strong>Duration:</strong> 3-6 months</p>
                        <ul>
                            <li>User interface modernization</li>
                            <li>Performance optimization</li>
                            <li>Production deployment</li>
                        </ul>
                    </div>
                </div>
            `;
        }

        function generateDetailedRiskAssessment() {
            const risks = ChatSystem.calculateRiskAssessment();

            return `
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px; margin-bottom: 30px;">
                    <div style="text-align: center; padding: 20px; background: #e8f5e8; border-radius: 8px;">
                        <h3 style="color: #27ae60; font-size: 36px; margin: 0;">${risks.lowRisk}</h3>
                        <p><strong>Low Risk Components</strong></p>
                        <p>Ready for automated migration</p>
                    </div>
                    <div style="text-align: center; padding: 20px; background: #fff3e0; border-radius: 8px;">
                        <h3 style="color: #f57c00; font-size: 36px; margin: 0;">${risks.mediumRisk}</h3>
                        <p><strong>Medium Risk Components</strong></p>
                        <p>Require careful analysis</p>
                    </div>
                    <div style="text-align: center; padding: 20px; background: #ffebee; border-radius: 8px;">
                        <h3 style="color: #d32f2f; font-size: 36px; margin: 0;">${risks.highRisk}</h3>
                        <p><strong>High Risk Components</strong></p>
                        <p>Need extensive manual review</p>
                    </div>
                </div>

                <h4>üéØ Risk Factors Analysis</h4>
                <ul>
                    <li><strong>Complex Dependencies:</strong> ${risks.riskFactors.complexDependencies} CICS file operations requiring transaction redesign</li>
                    <li><strong>Conditional Business Logic:</strong> ${risks.riskFactors.conditionalLogic} complex decision trees needing manual validation</li>
                    <li><strong>Multi-Source Fields:</strong> ${risks.riskFactors.multiSourceFields} fields with conflicting logic across programs</li>
                </ul>

                <h4>üõ°Ô∏è Mitigation Strategies</h4>
                <ul>
                    <li><strong>Comprehensive Testing:</strong> Implement parallel run strategy for high-risk components</li>
                    <li><strong>Incremental Migration:</strong> Break complex components into smaller, manageable pieces</li>
                    <li><strong>Expert Review:</strong> Engage mainframe SMEs for critical business logic validation</li>
                    <li><strong>Rollback Planning:</strong> Maintain mainframe systems during initial modernization phases</li>
                </ul>
            `;
        }

        function generateCostEstimation() {
            const complexity = ChatSystem.calculateModernizationComplexity();
            const componentCount = AppState.components.length;
            const fieldCount = AppState.fieldMappings.length;

            const baseCost = complexity.level === 'Low' ? 500000 : complexity.level === 'Medium' ? 1500000 : 3500000;
            const componentCost = componentCount * 5000;
            const fieldCost = fieldCount * 500;
            const totalCost = baseCost + componentCost + fieldCost;

            return `
                <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                    <h3 style="text-align: center; color: #2c3e50;">üí∞ Total Estimated Cost: ${totalCost.toLocaleString()}</h3>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px;">
                    <div>
                        <h4>üìä Cost Breakdown</h4>
                        <table style="width: 100%; border-collapse: collapse;">
                            <tr style="border-bottom: 1px solid #ddd;">
                                <td style="padding: 8px;"><strong>Base Development</strong></td>
                                <td style="padding: 8px; text-align: right;">${baseCost.toLocaleString()}</td>
                            </tr>
                            <tr style="border-bottom: 1px solid #ddd;">
                                <td style="padding: 8px;">Component Analysis</td>
                                <td style="padding: 8px; text-align: right;">${componentCost.toLocaleString()}</td>
                            </tr>
                            <tr style="border-bottom: 1px solid #ddd;">
                                <td style="padding: 8px;">Field Migration</td>
                                <td style="padding: 8px; text-align: right;">${fieldCost.toLocaleString()}</td>
                            </tr>
                            <tr style="border-bottom: 2px solid #667eea; font-weight: bold;">
                                <td style="padding: 8px;">Total Development</td>
                                <td style="padding: 8px; text-align: right;">${totalCost.toLocaleString()}</td>
                            </tr>
                        </table>
                    </div>
                    
                    <div>
                        <h4>üí° Cost Factors</h4>
                        <ul>
                            <li><strong>Complexity Level:</strong> ${complexity.level}</li>
                            <li><strong>Component Count:</strong> ${componentCount}</li>
                            <li><strong>Field Mappings:</strong> ${fieldCount}</li>
                            <li><strong>CICS Operations:</strong> ${AppState.components.reduce((sum, c) => sum + (c.cicsOperations?.length || 0), 0)}</li>
                        </ul>
                        
                        <h4>üìà ROI Projection</h4>
                        <p><strong>Annual Savings:</strong> ${(totalCost * 0.3).toLocaleString()}</p>
                        <p><strong>Payback Period:</strong> ${(totalCost / (totalCost * 0.3)).toFixed(1)} years</p>
                        <p><strong>5-Year ROI:</strong> ${((totalCost * 0.3 * 5 - totalCost) / totalCost * 100).toFixed(0)}%</p>
                    </div>
                </div>
            `;
        }

        function generateDetailedRecommendations() {
            const vllmConfigured = VLLMAPIManager.serverConfigured;
            const fieldMappings = AppState.fieldMappings.length;
            const complexity = ChatSystem.calculateModernizationComplexity();

            return `
                <div style="margin-bottom: 30px;">
                    <h4>üéØ Immediate Actions (Next 30 Days)</h4>
                    <ul>
                        <li>‚úÖ <strong>Analysis Complete:</strong> ${AppState.components.length} components analyzed</li>
                        ${!vllmConfigured ? '<li>üîß <strong>Configure vLLM:</strong> Enable AI-powered analysis for enhanced accuracy</li>' : ''}
                        <li>üìä <strong>Validate Field Mappings:</strong> Review ${fieldMappings} field conversions</li>
                        <li>üë• <strong>Stakeholder Review:</strong> Present findings to business and technical teams</li>
                        <li>üí∞ <strong>Budget Approval:</strong> Secure funding based on cost estimates</li>
                    </ul>
                </div>

                <div style="margin-bottom: 30px;">
                    <h4>üöÄ Short-term Goals (Next 90 Days)</h4>
                    <ul>
                        <li>üèóÔ∏è <strong>Infrastructure Setup:</strong> Provision Oracle database and development environments</li>
                        <li>üë®‚Äçüíª <strong>Team Assembly:</strong> Recruit modernization specialists and Oracle developers</li>
                        <li>üìã <strong>Detailed Planning:</strong> Create work breakdown structure for Phase 1</li>
                        <li>üß™ <strong>Proof of Concept:</strong> Migrate 2-3 low-risk components as pilot</li>
                    </ul>
                </div>

                <div style="margin-bottom: 30px;">
                    <h4>üéØ Technology Recommendations</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                        <div>
                            <h5>‚úÖ Recommended Technologies</h5>
                            <ul>
                                <li><strong>Database:</strong> Oracle 19c+ with RAC</li>
                                <li><strong>Application:</strong> Java Spring Boot</li>
                                <li><strong>Frontend:</strong> React or Angular</li>
                                <li><strong>Integration:</strong> REST APIs + GraphQL</li>
                                <li><strong>DevOps:</strong> Docker + Kubernetes</li>
                            </ul>
                        </div>
                        <div>
                            <h5>‚ö†Ô∏è Technologies to Consider Carefully</h5>
                            <ul>
                                <li><strong>Microservices:</strong> ${complexity.level === 'High' ? 'Not recommended initially' : 'Consider for Phase 2'}</li>
                                <li><strong>NoSQL:</strong> Evaluate for specific use cases</li>
                                <li><strong>Serverless:</strong> Consider for batch processing</li>
                                <li><strong>Blockchain:</strong> Not applicable for this migration</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div>
                    <h4>üéØ Success Metrics</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px;">
                        <div style="background: #e8f5e8; padding: 15px; border-radius: 8px;">
                            <h5 style="color: #27ae60; margin-top: 0;">Technical Metrics</h5>
                            <ul style="margin: 0; padding-left: 20px;">
                                <li>Migration completion %</li>
                                <li>Performance benchmarks</li>
                                <li>Code quality metrics</li>
                            </ul>
                        </div>
                        <div style="background: #fff3e0; padding: 15px; border-radius: 8px;">
                            <h5 style="color: #f57c00; margin-top: 0;">Business Metrics</h5>
                            <ul style="margin: 0; padding-left: 20px;">
                                <li>Time to market improvement</li>
                                <li>Operational cost reduction</li>
                                <li>User satisfaction scores</li>
                            </ul>
                        </div>
                        <div style="background: #e3f2fd; padding: 15px; border-radius: 8px;">
                            <h5 style="color: #1976d2; margin-top: 0;">Quality Metrics</h5>
                            <ul style="margin: 0; padding-left: 20px;">
                                <li>Defect density</li>
                                <li>Test coverage %</li>
                                <li>System availability</li>
                            </ul>
                        </div>
                    </div>
                </div>
            `;
        }

        // Advanced Export Functions
        function exportToExcel() {
            const csvContent = [
                ['Component Name', 'Type', 'Lines', 'Fields', 'Dependencies', 'Complexity'],
                ...AppState.components.map(c => [
                    c.name,
                    c.type,
                    c.totalLines || 0,
                    c.fields?.length || 0,
                    c.dependencies?.length || 0,
                    c.businessLogic?.length || 0
                ])
            ].map(row => row.join(',')).join('\n');

            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `mainframe_analysis_${AppState.sessionId}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function generateOracleDDL() {
            if (AppState.fieldMappings.length === 0) {
                alert('No field mappings available. Please run field mapping analysis first.');
                return;
            }

            const fileGroups = {};
            AppState.fieldMappings.forEach(field => {
                if (!fileGroups[field.sourceRecordLayout]) {
                    fileGroups[field.sourceRecordLayout] = [];
                }
                fileGroups[field.sourceRecordLayout].push(field);
            });

            let ddlContent = `-- Oracle DDL Generated from Mainframe Analysis\n-- Session: ${AppState.sessionId}\n-- Generated: ${new Date().toISOString()}\n\n`;

            Object.entries(fileGroups).forEach(([fileName, fields]) => {
                const tableName = fileName.toLowerCase().replace(/[-_]/g, '_');
                ddlContent += `-- Table: ${fileName}\n`;
                ddlContent += `CREATE TABLE ${tableName} (\n`;
                
                const fieldDDL = fields.map(field => {
                    const columnName = field.fieldName.toLowerCase().replace(/[-]/g, '_');
                    const constraints = field.businessLogicType === 'MOVE' && field.populationSource !== 'COMPUTED' ? ' NOT NULL' : '';
                    return `    ${columnName.padEnd(30)} ${field.oracleDataType}${constraints}`;
                }).join(',\n');
                
                ddlContent += fieldDDL;
                ddlContent += `\n);\n\n`;
                
                // Add comments
                ddlContent += `-- Field mapping comments for ${fileName}\n`;
                fields.forEach(field => {
                    const columnName = field.fieldName.toLowerCase().replace(/[-]/g, '_');
                    ddlContent += `COMMENT ON COLUMN ${tableName}.${columnName} IS '${field.businessLogicDescription} (Confidence: ${(field.confidenceScore * 100).toFixed(0)}%)';\n`;
                });
                ddlContent += '\n';
            });

            const blob = new Blob([ddlContent], { type: 'text/sql' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `oracle_ddl_${AppState.sessionId}.sql`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Add these functions to the MainframeAnalyzer object
        if (typeof window.MainframeAnalyzer !== 'undefined') {
            window.MainframeAnalyzer.generateReport = generateComprehensiveReport;
            window.MainframeAnalyzer.exportToExcel = exportToExcel;
            window.MainframeAnalyzer.generateOracleDDL = generateOracleDDL;
        }

        // Final System Verification and Health Check
        function performSystemHealthCheck() {
            const healthCheck = {
                timestamp: new Date().toISOString(),
                vllmConnection: VLLMAPIManager.serverConfigured,
                databaseTables: Object.keys(db.tables).length,
                tokenBudgetUsed: (AppState.tokenUsage.total / AppState.tokenUsage.budget * 100).toFixed(1),
                componentsLoaded: AppState.components.length,
                fieldMappingsGenerated: AppState.fieldMappings.length,
                dependenciesTracked: AppState.dependencies.length,
                memoryUsage: performance.memory ? {
                    used: (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(2) + ' MB',
                    total: (performance.memory.totalJSHeapSize / 1024 / 1024).toFixed(2) + ' MB',
                    limit: (performance.memory.jsHeapSizeLimit / 1024 / 1024).toFixed(2) + ' MB'
                } : 'Not available',
                systemStatus: 'Operational'
            };

            console.log('üè• System Health Check:', healthCheck);
            return healthCheck;
        }

        // Enhanced Error Handling and Recovery
        window.addEventListener('error', function(event) {
            console.error('‚ùå Application Error:', event.error);
            
            // Try to recover gracefully
            try {
                updateProcessingStatus('error', 'System error detected - attempting recovery');
                
                // Reset processing status after 5 seconds
                setTimeout(() => {
                    updateProcessingStatus('ready', 'System recovered - ready for operations');
                }, 5000);
                
                // Log error to database if possible
                if (db) {
                    db.tables.llm_analysis_calls.push({
                        id: db.tables.llm_analysis_calls.length + 1,
                        session_id: AppState.sessionId,
                        analysis_type: 'ERROR',
                        error_message: event.error.message,
                        created_at: new Date().toISOString(),
                        success: false
                    });
                }
            } catch (recoveryError) {
                console.error('‚ùå Recovery failed:', recoveryError);
            }
        });

        // Performance monitoring
        function monitorPerformance() {
            const stats = {
                loadTime: performance.timing.loadEventEnd - performance.timing.navigationStart,
                domReady: performance.timing.domContentLoadedEventEnd - performance.timing.navigationStart,
                tokensPerSecond: AppState.tokenUsage.total > 0 ? 
                    (AppState.tokenUsage.total / ((Date.now() - performance.timing.navigationStart) / 1000)).toFixed(2) : '0',
                componentsPerMinute: AppState.components.length > 0 ? 
                    (AppState.components.length / ((Date.now() - performance.timing.navigationStart) / 60000)).toFixed(2) : '0'
            };
            
            console.log('üìä Performance Stats:', stats);
            return stats;
        }

        // Add performance monitoring to MainframeAnalyzer
        if (typeof window.MainframeAnalyzer !== 'undefined') {
            window.MainframeAnalyzer.healthCheck = performSystemHealthCheck;
            window.MainframeAnalyzer.performanceStats = monitorPerformance;
        }

        console.log('‚úÖ Part 6: Final Integration completed successfully!');
        console.log('üéØ All 6 parts loaded - Enhanced Mainframe Code Analyzer is fully operational');
        console.log('üìä System Status:', performSystemHealthCheck());
        console.log('üöÄ Ready for enterprise-level mainframe modernization analysis');
        
        // Auto-run health check on startup
        setTimeout(() => {
            const health = performSystemHealthCheck();
            if (health.systemStatus === 'Operational') {
                updateProcessingStatus('ready', `System operational - ${health.databaseTables} tables ready, ${health.tokenBudgetUsed}% token budget used`);
            }
        }, 2000);
    </script>
</body>
</html>