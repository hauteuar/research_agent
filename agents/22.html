<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Mainframe Analyzer - Professional Edition</title>
    <style>
        /* ============================================
           PART 1: CORE STYLES AND LAYOUT
           White background with blue/grey theme
           ============================================ */
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Color Palette - Professional Blue/Grey Theme */
            --primary-blue: #2563eb;
            --primary-blue-dark: #1e40af;
            --primary-blue-light: #3b82f6;
            --secondary-blue: #60a5fa;
            --accent-blue: #93c5fd;
            
            --grey-50: #f9fafb;
            --grey-100: #f3f4f6;
            --grey-200: #e5e7eb;
            --grey-300: #d1d5db;
            --grey-400: #9ca3af;
            --grey-500: #6b7280;
            --grey-600: #4b5563;
            --grey-700: #374151;
            --grey-800: #1f2937;
            --grey-900: #111827;
            
            --success-green: #10b981;
            --warning-yellow: #f59e0b;
            --error-red: #ef4444;
            --info-blue: #3b82f6;
            
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
            
            --transition-fast: 150ms cubic-bezier(0.4, 0, 0.2, 1);
            --transition-normal: 300ms cubic-bezier(0.4, 0, 0.2, 1);
            --transition-slow: 500ms cubic-bezier(0.4, 0, 0.2, 1);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Inter', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #ffffff;
            color: var(--grey-800);
            line-height: 1.6;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Main Container */
        .main-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            background: var(--grey-50);
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--primary-blue-dark) 100%);
            color: white;
            padding: 1.5rem 2rem;
            box-shadow: var(--shadow-md);
            position: relative;
            z-index: 100;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 100%;
        }

        .header h1 {
            font-size: 1.75rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .header-icon {
            width: 32px;
            height: 32px;
            background: white;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--primary-blue);
            font-size: 1.25rem;
        }

        .header-subtitle {
            font-size: 0.9rem;
            opacity: 0.9;
            margin-left: 3rem;
        }

        /* Content Layout */
        .content-wrapper {
            flex: 1;
            display: flex;
            overflow: hidden;
            position: relative;
        }

        /* Collapsible Panels */
        .panel {
            background: white;
            position: relative;
            transition: all var(--transition-normal);
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--grey-200);
        }

        .panel.left {
            width: 420px;
            min-width: 60px;
        }

        .panel.left.collapsed {
            width: 60px;
        }

        .panel.right {
            width: 500px;
            min-width: 60px;
            border-left: 1px solid var(--grey-200);
            border-right: none;
        }

        .panel.right.collapsed {
            width: 60px;
        }

        .panel-header {
            padding: 1rem;
            background: var(--grey-50);
            border-bottom: 1px solid var(--grey-200);
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-height: 60px;
        }

        .panel-title {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
            color: var(--grey-700);
            font-size: 0.95rem;
        }

        .panel-icon {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--primary-blue);
        }

        .collapse-btn {
            width: 32px;
            height: 32px;
            border: none;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--grey-600);
            transition: all var(--transition-fast);
            box-shadow: var(--shadow-sm);
        }

        .collapse-btn:hover {
            background: var(--primary-blue);
            color: white;
            transform: scale(1.05);
            box-shadow: var(--shadow-md);
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
            transition: opacity var(--transition-normal);
        }

        .panel.collapsed .panel-content {
            opacity: 0;
            pointer-events: none;
            padding: 0;
        }

        .panel.collapsed .panel-title span {
            display: none;
        }

        .panel.collapsed .panel-header {
            flex-direction: column;
            padding: 1rem 0.5rem;
        }

        .panel.collapsed .collapse-btn {
            margin-top: 0.5rem;
        }

        /* Main Content Area */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: white;
            overflow: hidden;
        }

        /* Tabs */
        .tabs-container {
            background: white;
            border-bottom: 1px solid var(--grey-200);
            padding: 0 1.5rem;
            display: flex;
            align-items: center;
            min-height: 56px;
            box-shadow: var(--shadow-sm);
        }

        .tab {
            padding: 0.75rem 1.5rem;
            background: transparent;
            border: none;
            color: var(--grey-600);
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            position: relative;
            transition: all var(--transition-fast);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .tab:hover {
            color: var(--primary-blue);
            background: var(--grey-50);
        }

        .tab.active {
            color: var(--primary-blue);
        }

        .tab.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--primary-blue);
            border-radius: 3px 3px 0 0;
        }

        .tab-icon {
            width: 18px;
            height: 18px;
            opacity: 0.8;
        }

        /* Tab Content Area */
        .tab-content-container {
            flex: 1;
            overflow-y: auto;
            background: var(--grey-50);
        }

        .tab-content {
            display: none;
            padding: 1.5rem;
        }

        .tab-content.active {
            display: block;
        }

        /* Summary Section */
        .summary-section {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--grey-200);
        }

        .summary-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--grey-100);
        }

        .summary-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--secondary-blue) 100%);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
        }

        .summary-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--grey-800);
        }

        .summary-content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .summary-item {
            padding: 1rem;
            background: var(--grey-50);
            border-radius: 8px;
            border: 1px solid var(--grey-200);
        }

        .summary-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            color: var(--grey-500);
            margin-bottom: 0.25rem;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .summary-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary-blue);
        }

        .summary-description {
            font-size: 0.85rem;
            color: var(--grey-600);
            margin-top: 0.25rem;
        }

        /* Collapsible Sections */
        .collapsible-section {
            background: white;
            border-radius: 12px;
            margin-bottom: 1rem;
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--grey-200);
            overflow: hidden;
            transition: all var(--transition-normal);
        }

        .collapsible-header {
            padding: 1rem 1.5rem;
            background: white;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all var(--transition-fast);
            user-select: none;
        }

        .collapsible-header:hover {
            background: var(--grey-50);
        }

        .collapsible-title {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-weight: 600;
            color: var(--grey-700);
        }

        .collapsible-icon {
            width: 20px;
            height: 20px;
            color: var(--primary-blue);
        }

        .expand-icon {
            width: 20px;
            height: 20px;
            color: var(--grey-400);
            transition: transform var(--transition-fast);
        }

        .collapsible-section.expanded .expand-icon {
            transform: rotate(180deg);
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height var(--transition-normal);
            background: var(--grey-50);
        }

        .collapsible-section.expanded .collapsible-content {
            max-height: 2000px;
        }

        .collapsible-body {
            padding: 1.5rem;
        }

        /* Scrollbar Styles */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--grey-100);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--grey-400);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--grey-500);
        }

        /* Loading States */
        .loading-skeleton {
            background: linear-gradient(90deg, var(--grey-100) 25%, var(--grey-200) 50%, var(--grey-100) 75%);
            background-size: 200% 100%;
            animation: loading 1.5s infinite;
            border-radius: 4px;
            height: 20px;
            margin: 0.5rem 0;
        }

        @keyframes loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        /* ============================================
           PART 2: FORM COMPONENTS AND UI ELEMENTS
           ============================================ */

        /* Form Elements */
        .form-section {
            margin-bottom: 1.5rem;
            padding: 1.25rem;
            background: white;
            border-radius: 10px;
            border: 1px solid var(--grey-200);
            box-shadow: var(--shadow-sm);
        }

        .form-section-title {
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--grey-700);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-label {
            display: block;
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--grey-700);
            margin-bottom: 0.5rem;
        }

        .form-input {
            width: 100%;
            padding: 0.625rem 0.875rem;
            border: 1px solid var(--grey-300);
            border-radius: 6px;
            font-size: 0.9rem;
            transition: all var(--transition-fast);
            background: white;
            color: var(--grey-800);
        }

        .form-input:focus {
            outline: none;
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .form-input::placeholder {
            color: var(--grey-400);
        }

        /* Friendly Name Input Group */
        .input-group {
            display: flex;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }

        .input-group .form-input {
            flex: 1;
        }

        .friendly-name-tag {
            display: inline-flex;
            align-items: center;
            padding: 0.25rem 0.75rem;
            background: var(--primary-blue);
            color: white;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 500;
            margin-left: 0.5rem;
        }

        /* Buttons */
        .btn {
            padding: 0.625rem 1.25rem;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all var(--transition-fast);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            box-shadow: var(--shadow-sm);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: var(--primary-blue);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: var(--primary-blue-dark);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .btn-success {
            background: var(--success-green);
            color: white;
        }

        .btn-success:hover:not(:disabled) {
            background: #059669;
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .btn-secondary {
            background: var(--grey-200);
            color: var(--grey-700);
        }

        .btn-secondary:hover:not(:disabled) {
            background: var(--grey-300);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .btn-danger {
            background: var(--error-red);
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            background: #dc2626;
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .btn-block {
            width: 100%;
        }

        /* Upload Area */
        .upload-area {
            border: 2px dashed var(--grey-300);
            border-radius: 10px;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: all var(--transition-fast);
            background: var(--grey-50);
            margin-bottom: 1rem;
        }

        .upload-area:hover {
            border-color: var(--primary-blue);
            background: rgba(37, 99, 235, 0.05);
        }

        .upload-area.drag-over {
            border-color: var(--primary-blue);
            background: rgba(37, 99, 235, 0.1);
            transform: scale(0.98);
        }

        .upload-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
            color: var(--primary-blue);
        }

        .upload-text {
            color: var(--grey-700);
            font-weight: 500;
            margin-bottom: 0.25rem;
        }

        .upload-subtext {
            color: var(--grey-500);
            font-size: 0.85rem;
        }

        /* File List */
        .file-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 1rem;
        }

        .file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background: white;
            border: 1px solid var(--grey-200);
            border-radius: 6px;
            margin-bottom: 0.5rem;
            transition: all var(--transition-fast);
        }

        .file-item:hover {
            box-shadow: var(--shadow-sm);
            transform: translateX(2px);
        }

        .file-info {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex: 1;
        }

        .file-icon {
            width: 32px;
            height: 32px;
            background: var(--grey-100);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--primary-blue);
        }

        .file-details {
            flex: 1;
        }

        .file-name {
            font-weight: 500;
            color: var(--grey-800);
            font-size: 0.9rem;
        }

        .file-meta {
            font-size: 0.75rem;
            color: var(--grey-500);
            margin-top: 0.125rem;
        }

        .file-remove {
            width: 28px;
            height: 28px;
            border: none;
            background: var(--error-red);
            color: white;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--transition-fast);
        }

        .file-remove:hover {
            background: #dc2626;
            transform: scale(1.1);
        }

        /* Status Indicators */
        .status-indicator {
            padding: 0.75rem;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
            margin-bottom: 1rem;
        }

        .status-indicator.connected {
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.3);
            color: var(--success-green);
        }

        .status-indicator.connecting {
            background: rgba(245, 158, 11, 0.1);
            border: 1px solid rgba(245, 158, 11, 0.3);
            color: var(--warning-yellow);
        }

        .status-indicator.disconnected {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: var(--error-red);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Token Usage Bar */
        .token-info {
            background: var(--grey-50);
            border: 1px solid var(--grey-200);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .token-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .token-label {
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--grey-700);
        }

        .token-count {
            font-size: 0.85rem;
            color: var(--grey-600);
        }

        .token-bar {
            height: 6px;
            background: var(--grey-200);
            border-radius: 3px;
            overflow: hidden;
        }

        .token-fill {
            height: 100%;
            border-radius: 3px;
            transition: all var(--transition-normal);
        }

        .token-fill.safe {
            background: var(--success-green);
        }

        .token-fill.warning {
            background: var(--warning-yellow);
        }

        .token-fill.danger {
            background: var(--error-red);
        }

        .token-warning {
            font-size: 0.75rem;
            color: var(--grey-600);
            margin-top: 0.5rem;
        }

        /* Component Suggestions */
        .suggestions-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid var(--grey-200);
            border-radius: 6px;
            box-shadow: var(--shadow-lg);
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            margin-top: 0.25rem;
            display: none;
        }

        .suggestions-dropdown.show {
            display: block;
        }

        .suggestion-item {
            padding: 0.75rem;
            cursor: pointer;
            transition: all var(--transition-fast);
            border-bottom: 1px solid var(--grey-100);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .suggestion-item:last-child {
            border-bottom: none;
        }

        .suggestion-item:hover {
            background: var(--primary-blue);
            color: white;
        }

        .suggestion-item-name {
            font-weight: 500;
            font-size: 0.9rem;
        }

        .suggestion-item-type {
            font-size: 0.75rem;
            opacity: 0.8;
        }

        .suggestion-item-badge {
            margin-left: auto;
            padding: 0.125rem 0.5rem;
            background: var(--primary-blue);
            color: white;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .suggestion-item:hover .suggestion-item-badge {
            background: white;
            color: var(--primary-blue);
        }

        /* Chat Styles */
        .chat-container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .chat-suggestions {
            padding: 1rem;
            background: var(--grey-50);
            border-radius: 8px;
            margin-bottom: 1rem;
        }

        .chat-suggestions-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--grey-700);
            margin-bottom: 0.75rem;
        }

        .chat-suggestion-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .chat-suggestion-btn {
            padding: 0.375rem 0.75rem;
            background: white;
            border: 1px solid var(--grey-300);
            border-radius: 20px;
            font-size: 0.8rem;
            color: var(--grey-700);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .chat-suggestion-btn:hover {
            background: var(--primary-blue);
            color: white;
            border-color: var(--primary-blue);
            transform: translateY(-1px);
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            background: var(--grey-50);
            border-radius: 8px;
            margin-bottom: 1rem;
        }

        .chat-message {
            margin-bottom: 1rem;
            animation: fadeInUp 0.3s ease;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .chat-message.user {
            display: flex;
            justify-content: flex-end;
        }

        .chat-message.assistant {
            display: flex;
            justify-content: flex-start;
        }

        .chat-bubble {
            max-width: 95%;
            padding: 1.25rem;
            border-radius: 12px;
            position: relative;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .user .chat-bubble {
            background: var(--primary-blue);
            color: white;
            border-bottom-right-radius: 4px;
        }

        .assistant .chat-bubble {
            background: white;
            color: var(--grey-800);
            border: 1px solid var(--grey-200);
            border-bottom-left-radius: 4px;
        }

        .chat-message-header {
            font-size: 0.75rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            opacity: 0.8;
        }

        .chat-message-content {
            font-size: 0.85rem;
            line-height: 1.7;
            white-space: pre-wrap;
        }
        .chat-message-content strong {
            font-weight: 600;
            color: var(--primary-blue);
        }

        .assistant .chat-message-content strong {
            color: var(--primary-blue);
        }

        .user .chat-message-content strong {
            color: white;
        }

        .chat-message-time {
            font-size: 0.7rem;
            opacity: 0.6;
            margin-top: 0.5rem;
        }

        .chat-input-section {
            padding: 1rem;
            background: white;
            border-radius: 8px;
            border: 1px solid var(--grey-200);
        }

        .chat-input-group {
            display: flex;
            gap: 0.5rem;
        }

        .chat-input {
            flex: 1;
            padding: 0.75rem;
            border: 1px solid var(--grey-300);
            border-radius: 8px;
            resize: none;
            min-height: 60px;
            max-height: 150px;
            font-size: 0.9rem;
            transition: all var(--transition-fast);
        }

        .chat-input:focus {
            outline: none;
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .chat-send-btn {
            padding: 0.75rem 1.25rem;
            background: var(--primary-blue);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all var(--transition-fast);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 500;
        }

        .chat-send-btn:hover:not(:disabled) {
            background: var(--primary-blue-dark);
            transform: translateY(-1px);
        }

        .chat-send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Loading Indicator */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.95);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .loading-overlay.show {
            display: flex;
        }

        .loading-content {
            text-align: center;
        }

        .loading-spinner {
            width: 48px;
            height: 48px;
            border: 3px solid var(--grey-200);
            border-top-color: var(--primary-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--grey-800);
            margin-bottom: 0.5rem;
        }

        .loading-status {
            font-size: 0.9rem;
            color: var(--grey-600);
            margin-bottom: 1rem;
        }

        .loading-progress {
            width: 200px;
            height: 4px;
            background: var(--grey-200);
            border-radius: 2px;
            overflow: hidden;
            margin: 0 auto;
        }

        .loading-progress-fill {
            height: 100%;
            background: var(--primary-blue);
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        /* Alert Messages */
        .alert {
            position: fixed;
            top: 80px;
            right: 20px;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            box-shadow: var(--shadow-lg);
            display: flex;
            align-items: center;
            gap: 0.75rem;
            max-width: 400px;
            animation: slideInRight 0.3s ease;
            z-index: 10000;
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .alert-success {
            background: var(--success-green);
            color: white;
        }

        .alert-error {
            background: var(--error-red);
            color: white;
        }

        .alert-warning {
            background: var(--warning-yellow);
            color: white;
        }

        .alert-info {
            background: var(--info-blue);
            color: white;
        }

        .alert-icon {
            font-size: 1.25rem;
        }

        .alert-message {
            flex: 1;
            font-size: 0.9rem;
            font-weight: 500;
        }

        /* Metric Cards */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .metric-card {
            background: white;
            border: 1px solid var(--grey-200);
            border-radius: 10px;
            padding: 1.25rem;
            display: flex;
            align-items: center;
            gap: 1rem;
            transition: all var(--transition-fast);
        }

        .metric-card:hover {
            box-shadow: var(--shadow-md);
            transform: translateY(-2px);
        }

        .metric-icon {
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--secondary-blue) 100%);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.5rem;
        }

        .metric-details {
            flex: 1;
        }

        .metric-label {
            font-size: 0.75rem;
            color: var(--grey-500);
            text-transform: uppercase;
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .metric-value {
            font-size: 1.75rem;
            font-weight: bold;
            color: var(--grey-800);
        }

        .metric-change {
            font-size: 0.85rem;
            margin-top: 0.25rem;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .metric-change.positive {
            color: var(--success-green);
        }

        .metric-change.negative {
            color: var(--error-red);
        }

        /* Table Styles */
        .data-table {
            width: 100%;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid var(--grey-200);
        }

        .data-table thead {
            background: var(--grey-50);
        }

        .data-table th {
            padding: 0.75rem;
            text-align: left;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--grey-700);
            border-bottom: 1px solid var(--grey-200);
        }

        .data-table td {
            padding: 0.75rem;
            font-size: 0.9rem;
            color: var(--grey-800);
            border-bottom: 1px solid var(--grey-100);
        }

        .data-table tbody tr:hover {
            background: var(--grey-50);
        }

        .data-table tbody tr:last-child td {
            border-bottom: none;
        }

        /* Badge Styles */
        .badge {
            display: inline-flex;
            align-items: center;
            padding: 0.25rem 0.625rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .badge-primary {
            background: rgba(37, 99, 235, 0.1);
            color: var(--primary-blue);
        }

        .badge-success {
            background: rgba(16, 185, 129, 0.1);
            color: var(--success-green);
        }

        .badge-warning {
            background: rgba(245, 158, 11, 0.1);
            color: var(--warning-yellow);
        }

        .badge-danger {
            background: rgba(239, 68, 68, 0.1);
            color: var(--error-red);
        }

        .badge-grey {
            background: var(--grey-100);
            color: var(--grey-600);
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.js"></script>
</head>
<body>
    <div class="main-container">
        <!-- Header -->
        <div class="header">
            <div class="header-content">
                <h1>
                    <div class="header-icon">🔬</div>
                    Enhanced Mainframe Analyzer
                    <span class="header-subtitle">Professional Edition with LLM-Powered Analysis</span>
                </h1>
            </div>
        </div>

        <!-- Main Content Wrapper -->
        <div class="content-wrapper">
            <!-- Left Panel - Component Analysis -->
            <div class="panel left" id="leftPanel">
                <div class="panel-header">
                    <div class="panel-title">
                        <div class="panel-icon">🎯</div>
                        <span>Component Analysis</span>
                    </div>
                    <button class="collapse-btn" onclick="togglePanel('left')">
                        ◀
                    </button>
                </div>
                <div class="panel-content" id="leftPanelContent">
                    <!-- Component Analysis Section -->
                    <div class="form-section">
                        <div class="form-section-title">
                            <span style="color: var(--primary-blue);">🎯</span>
                            Component Analysis
                        </div>
                        
                        <!-- Component Name Inputs -->
                        <div class="form-group">
                            <label class="form-label">Component Name *</label>
                            <div style="position: relative;">
                                <input type="text" 
                                       id="componentName" 
                                       class="form-input" 
                                       placeholder="e.g., CUSTOMER-RECORD, ACCOUNT-COPY"
                                       autocomplete="off">
                                <div id="componentSuggestions" class="suggestions-dropdown"></div>
                            </div>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Friendly Name (Optional)</label>
                            <input type="text" 
                                   id="friendlyName" 
                                   class="form-input" 
                                   placeholder="e.g., Customer Master Record">
                            <small style="color: var(--grey-500); font-size: 0.75rem;">
                                This name will be displayed in all analysis results
                            </small>
                        </div>

                        <!-- Token Usage -->
                        <div id="tokenInfo" class="token-info" style="display: none;">
                            <div class="token-header">
                                <span class="token-label">Token Usage</span>
                                <span id="tokenCount" class="token-count">0 / 4000</span>
                            </div>
                            <div class="token-bar">
                                <div id="tokenFill" class="token-fill safe" style="width: 0%"></div>
                            </div>
                            <div id="tokenWarning" class="token-warning"></div>
                        </div>

                        <button id="analyzeComponentBtn" class="btn btn-primary btn-block" disabled>
                            <span>🔍</span>
                            Analyze Component
                        </button>
                    </div>

                    <!-- vLLM Server Setup -->
                    <div class="form-section">
                        <div class="form-section-title">
                            <span style="color: var(--success-green);">🚀</span>
                            vLLM Server Setup
                        </div>

                        <div class="form-group">
                            <label class="form-label">Server Endpoint</label>
                            <input type="text" 
                                   id="vllmEndpoint" 
                                   class="form-input" 
                                   placeholder="http://localhost:8000" 
                                   value="http://localhost:8000">
                        </div>

                        <div class="form-group">
                            <label class="form-label">Max Tokens</label>
                            <input type="number" 
                                   id="maxTokens" 
                                   class="form-input" 
                                   value="4000" 
                                   min="1000" 
                                   max="8000">
                        </div>

                        <button id="validateApiBtn" class="btn btn-success btn-block">
                            <span>🔐</span>
                            Test Connection
                        </button>

                        <div id="apiStatus" class="status-indicator disconnected">
                            <span class="status-dot"></span>
                            <span>Enter server details and test connection</span>
                        </div>
                    </div>

                    <!-- File Upload Section -->
                    <div class="form-section">
                        <div class="form-section-title">
                            <span style="color: var(--info-blue);">📁</span>
                            Upload Mainframe Files
                        </div>

                        <div class="upload-area" id="uploadArea">
                            <div class="upload-icon">📤</div>
                            <div class="upload-text">Drop files here or click to browse</div>
                            <div class="upload-subtext">COBOL (.cbl), Copybooks (.cpy), JCL (.jcl)</div>
                            <input type="file" 
                                   id="fileInput" 
                                   multiple 
                                   accept=".cbl,.cob,.cpy,.copybook,.jcl,.txt,.proc" 
                                   style="display: none;">
                        </div>

                        <div id="uploadedFiles" class="file-list"></div>
                    </div>

                    <!-- Quick Actions -->
                    <div class="form-section">
                        <div class="form-section-title">
                            <span style="color: var(--warning-yellow);">⚡</span>
                            Quick Actions
                        </div>

                        <button id="bulkAnalyzeBtn" class="btn btn-secondary btn-block" disabled style="margin-bottom: 0.75rem;">
                            <span>📊</span>
                            Bulk Analyze
                        </button>

                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-bottom: 0.75rem;">
                            <button id="exportJsonBtn" class="btn btn-secondary" disabled>
                                <span>📋</span>
                                Export JSON
                            </button>
                            <button id="exportMdBtn" class="btn btn-secondary" disabled>
                                <span>📝</span>
                                Export MD
                            </button>
                        </div>

                        <button id="clearBtn" class="btn btn-danger btn-block">
                            <span>🗑️</span>
                            Clear All Data
                        </button>
                    </div>
                </div>
            </div>

            <!-- Main Content Area -->
            <div class="main-content">
                <!-- Tabs -->
                <div class="tabs-container">
                    <button class="tab active" data-tab="lifecycle">
                        <span class="tab-icon">🔄</span>
                        Analysis Results
                    </button>
                    <button class="tab" data-tab="fieldmatrix">
                        <span class="tab-icon">📋</span>
                        Field Matrix
                    </button>
                    <button class="tab" data-tab="usage">
                        <span class="tab-icon">📈</span>
                        Usage Patterns
                    </button>
                    <button class="tab" data-tab="dependencies">
                        <span class="tab-icon">🔗</span>
                        Dependencies
                    </button>
                    <button class="tab" data-tab="fileflow">
                        <span class="tab-icon">🌊</span>
                        File Lifecycle
                    </button>
                </div>

                <!-- Tab Content -->
                <!-- Tab Content -->
                <div class="tab-content-container">
                    <!-- Analysis Results Tab -->
                    <div id="lifecycle" class="tab-content active">
                        <!-- Summary Section -->
                        <div class="summary-section">
                            <div class="summary-header">
                                <div class="summary-icon">📊</div>
                                <div class="summary-title">Analysis Summary</div>
                            </div>
                            <div class="summary-content">
                                <div class="summary-item">
                                    <div class="summary-label">Component</div>
                                    <div class="summary-value" id="summaryComponent">-</div>
                                    <div class="summary-description">Analyzed component</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">Quality Score</div>
                                    <div class="summary-value" id="summaryQuality">-</div>
                                    <div class="summary-description">Analysis quality</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">Files</div>
                                    <div class="summary-value" id="summaryFiles">0</div>
                                    <div class="summary-description">Files analyzed</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">Dependencies</div>
                                    <div class="summary-value" id="summaryDeps">0</div>
                                    <div class="summary-description">Total dependencies</div>
                                </div>
                            </div>
                        </div>

                        <!-- Collapsible Sections -->
                        <div class="collapsible-section expanded">
                            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                                <div class="collapsible-title">
                                    <span class="collapsible-icon">🔍</span>
                                    Component Details
                                </div>
                                <span class="expand-icon">▼</span>
                            </div>
                            <div class="collapsible-content">
                                <div class="collapsible-body" id="lifecycleDetails">
                                    <p>Component analysis details will appear here after analysis.</p>
                                </div>
                            </div>
                        </div>

                        <div class="collapsible-section">
                            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                                <div class="collapsible-title">
                                    <span class="collapsible-icon">🤖</span>
                                    LLM Analysis Results
                                </div>
                                <span class="expand-icon">▼</span>
                            </div>
                            <div class="collapsible-content">
                                <div class="collapsible-body" id="llmResults">
                                    <p>LLM analysis results will appear here.</p>
                                </div>
                            </div>
                        </div>

                        <div class="collapsible-section">
                            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                                <div class="collapsible-title">
                                    <span class="collapsible-icon">💡</span>
                                    Recommendations
                                </div>
                                <span class="expand-icon">▼</span>
                            </div>
                            <div class="collapsible-content">
                                <div class="collapsible-body" id="recommendations">
                                    <p>Analysis recommendations will appear here.</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Field Matrix Tab -->
                    <div id="fieldmatrix" class="tab-content">
                        <!-- Summary Section -->
                        <div class="summary-section">
                            <div class="summary-header">
                                <div class="summary-icon">📋</div>
                                <div class="summary-title">Field Matrix Summary</div>
                            </div>
                            <div class="summary-content">
                                <div class="summary-item">
                                    <div class="summary-label">Total Fields</div>
                                    <div class="summary-value" id="totalFields">0</div>
                                    <div class="summary-description">Fields identified</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">Input Fields</div>
                                    <div class="summary-value" id="inputFields">0</div>
                                    <div class="summary-description">Input operations</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">Output Fields</div>
                                    <div class="summary-value" id="outputFields">0</div>
                                    <div class="summary-description">Output operations</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">Unused Fields</div>
                                    <div class="summary-value" id="unusedFields">0</div>
                                    <div class="summary-description">Not referenced</div>
                                </div>
                            </div>
                        </div>

                        <!-- Field Matrix Content -->
                        <div class="collapsible-section expanded">
                            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                                <div class="collapsible-title">
                                    <span class="collapsible-icon">📊</span>
                                    Field Analysis Matrix
                                </div>
                                <span class="expand-icon">▼</span>
                            </div>
                            <div class="collapsible-content">
                                <div class="collapsible-body" id="fieldMatrixContent">
                                    <p>Field matrix analysis will appear here after component analysis.</p>
                                </div>
                            </div>
                        </div>

                        <div class="collapsible-section">
                            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                                <div class="collapsible-title">
                                    <span class="collapsible-icon">📈</span>
                                    Field Usage Statistics
                                </div>
                                <span class="expand-icon">▼</span>
                            </div>
                            <div class="collapsible-content">
                                <div class="collapsible-body" id="fieldStatistics">
                                    <p>Field usage statistics will appear here.</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Usage Patterns Tab -->
                    <div id="usage" class="tab-content">
                        <!-- Summary Section -->
                        <div class="summary-section">
                            <div class="summary-header">
                                <div class="summary-icon">📈</div>
                                <div class="summary-title">Usage Patterns Summary</div>
                            </div>
                            <div class="summary-content">
                                <div class="summary-item">
                                    <div class="summary-label">Pattern Type</div>
                                    <div class="summary-value" id="patternType">-</div>
                                    <div class="summary-description">Usage pattern</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">Creation</div>
                                    <div class="summary-value" id="creationCount">0</div>
                                    <div class="summary-description">Creation sources</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">Reading</div>
                                    <div class="summary-value" id="readingCount">0</div>
                                    <div class="summary-description">Read programs</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">Updates</div>
                                    <div class="summary-value" id="updateCount">0</div>
                                    <div class="summary-description">Update programs</div>
                                </div>
                            </div>
                        </div>

                        <!-- Usage Pattern Details -->
                        <div class="collapsible-section expanded">
                            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                                <div class="collapsible-title">
                                    <span class="collapsible-icon">🔄</span>
                                    Usage Pattern Analysis
                                </div>
                                <span class="expand-icon">▼</span>
                            </div>
                            <div class="collapsible-content">
                                <div class="collapsible-body" id="usageContent">
                                    <p>Usage pattern analysis will appear here after component analysis.</p>
                                </div>
                            </div>
                        </div>

                        <div class="collapsible-section">
                            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                                <div class="collapsible-title">
                                    <span class="collapsible-icon">📊</span>
                                    Program Usage Distribution
                                </div>
                                <span class="expand-icon">▼</span>
                            </div>
                            <div class="collapsible-content">
                                <div class="collapsible-body" id="programDistribution">
                                    <p>Program usage distribution will appear here.</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Dependencies Tab -->
                    <div id="dependencies" class="tab-content">
                        <!-- Summary Section -->
                        <div class="summary-section">
                            <div class="summary-header">
                                <div class="summary-icon">🔗</div>
                                <div class="summary-title">Dependencies Summary</div>
                            </div>
                            <div class="summary-content">
                                <div class="summary-item">
                                    <div class="summary-label">Found</div>
                                    <div class="summary-value" id="foundDeps">0</div>
                                    <div class="summary-description">Available deps</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">Missing</div>
                                    <div class="summary-value" id="missingDeps">0</div>
                                    <div class="summary-description">Missing deps</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">Copybooks</div>
                                    <div class="summary-value" id="copybookDeps">0</div>
                                    <div class="summary-description">Copybook refs</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">Programs</div>
                                    <div class="summary-value" id="programDeps">0</div>
                                    <div class="summary-description">Program calls</div>
                                </div>
                            </div>
                        </div>

                        <!-- Dependency Details -->
                        <div class="collapsible-section expanded">
                            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                                <div class="collapsible-title">
                                    <span class="collapsible-icon">✅</span>
                                    Found Dependencies
                                </div>
                                <span class="expand-icon">▼</span>
                            </div>
                            <div class="collapsible-content">
                                <div class="collapsible-body" id="foundDependencies">
                                    <p>Found dependencies will appear here.</p>
                                </div>
                            </div>
                        </div>

                        <div class="collapsible-section">
                            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                                <div class="collapsible-title">
                                    <span class="collapsible-icon">❌</span>
                                    Missing Dependencies
                                </div>
                                <span class="expand-icon">▼</span>
                            </div>
                            <div class="collapsible-content">
                                <div class="collapsible-body" id="missingDependencies">
                                    <p>Missing dependencies will appear here.</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- File Lifecycle Tab -->
                    <div id="fileflow" class="tab-content">
                        <!-- Summary Section -->
                        <div class="summary-section">
                            <div class="summary-header">
                                <div class="summary-icon">🌊</div>
                                <div class="summary-title">File Lifecycle Summary</div>
                            </div>
                            <div class="summary-content">
                                <div class="summary-item">
                                    <div class="summary-label">Lifecycle Stage</div>
                                    <div class="summary-value" id="lifecycleStage">-</div>
                                    <div class="summary-description">Current stage</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">Programs</div>
                                    <div class="summary-value" id="totalPrograms">0</div>
                                    <div class="summary-description">Total programs</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">CICS</div>
                                    <div class="summary-value" id="cicsCount">0</div>
                                    <div class="summary-description">CICS screens</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">Batch</div>
                                    <div class="summary-value" id="batchCount">0</div>
                                    <div class="summary-description">Batch jobs</div>
                                </div>
                            </div>
                        </div>

                        <!-- Lifecycle Flow Details -->
                        <div class="collapsible-section expanded">
                            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                                <div class="collapsible-title">
                                    <span class="collapsible-icon">🌊</span>
                                    Complete Lifecycle Flow
                                </div>
                                <span class="expand-icon">▼</span>
                            </div>
                            <div class="collapsible-content">
                                <div class="collapsible-body" id="fileflowContent">
                                    <p>File lifecycle flow analysis will appear here after component analysis.</p>
                                </div>
                            </div>
                        </div>

                        <div class="collapsible-section">
                            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                                <div class="collapsible-title">
                                    <span class="collapsible-icon">📋</span>
                                    Field Lifecycle Details
                                </div>
                                <span class="expand-icon">▼</span>
                            </div>
                            <div class="collapsible-content">
                                <div class="collapsible-body" id="fieldLifecycle">
                                    <p>Field lifecycle details will appear here.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Panel - Chat -->
            <div class="panel right" id="rightPanel">
                <div class="panel-header">
                    <div class="panel-title">
                        <div class="panel-icon">💬</div>
                        <span>Analysis Chat</span>
                    </div>
                    <button class="collapse-btn" onclick="togglePanel('right')">
                        ▶
                    </button>
                </div>
                <div class="panel-content" id="rightPanelContent">
                    <!-- Chat Container -->
                    <div class="chat-container">
                        <!-- Chat Header Info -->
                        <div style="padding: 1rem; background: linear-gradient(135deg, var(--primary-blue) 0%, var(--secondary-blue) 100%); color: white; border-radius: 10px; margin-bottom: 1rem;">
                            <h3 style="font-size: 1rem; margin-bottom: 0.5rem;">💬 LLM Analysis Chat</h3>
                            <p style="font-size: 0.8rem; opacity: 0.9;">Interactive chat with rich formatting and export</p>
                        </div>

                        <!-- Chat Suggestions -->
                        <div id="chatSuggestions" class="chat-suggestions" style="display: none;">
                            <div class="chat-suggestions-title">💡 Suggested Questions:</div>
                            <div class="chat-suggestion-chips">
                                <button class="chat-suggestion-btn" data-question="Explain the file lifecycle flow for this component">
                                    📊 File Lifecycle
                                </button>
                                <button class="chat-suggestion-btn" data-question="What fields are updated by which programs?">
                                    🔄 Field Updates
                                </button>
                                <button class="chat-suggestion-btn" data-question="Show me the creation and purge process">
                                    🌊 Creation/Purge
                                </button>
                                <button class="chat-suggestion-btn" data-question="Which programs only read vs modify data?">
                                    📖 Read/Write Patterns
                                </button>
                            </div>
                        </div>

                        <!-- Chat Messages Area -->
                        <div class="chat-messages" id="chatMessages">
                            <div class="chat-message assistant">
                                <div class="chat-bubble">
                                    <div class="chat-message-header">LLM Analysis Assistant</div>
                                    <div class="chat-message-content">
                                        👋 <strong>Welcome to LLM-Enhanced Mainframe Analysis!</strong>
                                        <br><br>
                                        I can provide detailed analysis using advanced language models including:
                                        <br><br>
                                        🧠 <strong>Smart Field Analysis:</strong> Context-aware field lifecycle tracking<br>
                                        ⚖️ <strong>Business Logic Extraction:</strong> Intelligent rule and validation discovery<br>
                                        🔗 <strong>Dependency Mapping:</strong> Comprehensive relationship analysis<br>
                                        🌊 <strong>File Lifecycle Flow:</strong> Creation to purge tracking with program mapping<br>
                                        💡 <strong>Modernization Guidance:</strong> AI-powered optimization recommendations
                                        <br><br>
                                        <em>Upload files and analyze a component to unlock the full power of LLM analysis!</em>
                                    </div>
                                    <div class="chat-message-time">${new Date().toLocaleTimeString()}</div>
                                </div>
                            </div>
                        </div>

                        <!-- Chat Input Section -->
                        <div class="chat-input-section">
                            <div class="chat-input-group">
                                <textarea id="chatInput" 
                                          class="chat-input" 
                                          placeholder="Ask about field flows, program dependencies, lifecycle patterns..." 
                                          disabled 
                                          rows="1"></textarea>
                                <button id="chatSendBtn" class="chat-send-btn" disabled>
                                    <span>Send</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingIndicator">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <div class="loading-title">🤖 Analyzing Component</div>
            <div class="loading-status" id="loadingStatus">Processing component analysis...</div>
            <div class="loading-progress">
                <div class="loading-progress-fill" id="progressFill" style="width: 0%"></div>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // PART 6: JavaScript Base and UI Functions
        // ============================================
        
        // Basic UI Functions
        function togglePanel(side) {
            const panel = document.getElementById(side + 'Panel');
            panel.classList.toggle('collapsed');
            
            // Update button icon
            const btn = panel.querySelector('.collapse-btn');
            if (side === 'left') {
                btn.textContent = panel.classList.contains('collapsed') ? '▶' : '◀';
            } else {
                btn.textContent = panel.classList.contains('collapsed') ? '◀' : '▶';
            }
            
            // Save state to localStorage
            localStorage.setItem(side + 'PanelCollapsed', panel.classList.contains('collapsed'));
        }

        function toggleCollapsible(header) {
            const section = header.parentElement;
            section.classList.toggle('expanded');
        }

        // Initialize tabs
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', function() {
                // Remove active from all tabs
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                // Add active to clicked tab
                this.classList.add('active');
                const tabId = this.getAttribute('data-tab');
                document.getElementById(tabId).classList.add('active');
            });
        });

        // Restore panel states from localStorage
        window.addEventListener('DOMContentLoaded', function() {
            if (localStorage.getItem('leftPanelCollapsed') === 'true') {
                togglePanel('left');
            }
            if (localStorage.getItem('rightPanelCollapsed') === 'true') {
                togglePanel('right');
            }
        });

        // Enhanced Mainframe Analyzer Class
        class EnhancedMainframeAnalyzer {
           togglePanel(side) {
            const panel = document.getElementById(side + 'Panel');
            panel.classList.toggle('collapsed');
            
            // Update button icon
            const btn = panel.querySelector('.collapse-btn');
            if (side === 'left') {
                btn.textContent = panel.classList.contains('collapsed') ? '▶' : '◀';
            } else {
                btn.textContent = panel.classList.contains('collapsed') ? '◀' : '▶';
            }
            
            // Save state to localStorage
            localStorage.setItem(side + 'PanelCollapsed', panel.classList.contains('collapsed'));
        }

        toggleCollapsible(header) {
            const section = header.parentElement;
            section.classList.toggle('expanded');
        }

            constructor() {
    // Core properties
    this.uploadedFiles = [];
    this.analysisResults = {};
    this.componentSuggestions = [];
    this.serverValidated = false;
    this.vllmEndpoint = 'http://localhost:8000';
    this.maxTokens = 4000;
    this.currentAnalyzedComponent = null;
    this.currentFriendlyName = null;
    this.chatHistory = [];
    
    // SQLite Database
    this.db = null;
    this.dbInitialized = false;
    
    // Token management
    this.averageCharsPerToken = 3;
    this.tokenSafetyMargin = 0.7;
    
    // Initialize
    this.initializeDatabase();
    this.initializeEventListeners();
    this.loadStoredData();
    this.initializeChat();
    this.addTypingAnimationStyles();
    
    console.log('🚀 Enhanced Mainframe Analyzer Initialized');
}

// Initialize SQLite Database
async initializeDatabase() {
    try {
        const SQL = await initSqlJs({
            locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${file}`
        });
        
        // Try to load existing database from localStorage
        const savedDb = localStorage.getItem('mainframe_analyzer_db');
        if (savedDb) {
            const uInt8Array = new Uint8Array(JSON.parse(savedDb));
            this.db = new SQL.Database(uInt8Array);
        } else {
            this.db = new SQL.Database();
        }
        
        // Create tables if they don't exist
        this.createTables();
        this.dbInitialized = true;
        console.log('✅ SQLite database initialized');
        
    } catch (error) {
        console.error('Failed to initialize SQLite database:', error);
        // Fallback to localStorage
        this.dbInitialized = false;
    }
}

// Create Database Tables
createTables() {
    if (!this.db) return;
    
    // Uploaded Files table
    this.db.run(`
        CREATE TABLE IF NOT EXISTS uploaded_files (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            file_id TEXT UNIQUE,
            name TEXT,
            content TEXT,
            size INTEGER,
            type TEXT,
            upload_date TEXT,
            components TEXT,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    `);
    
    // Analysis Results table
    this.db.run(`
        CREATE TABLE IF NOT EXISTS analysis_results (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            component_name TEXT UNIQUE,
            friendly_name TEXT,
            component_type TEXT,
            results_data TEXT,
            quality_score INTEGER,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    `);
    
    // Chat History table
    this.db.run(`
        CREATE TABLE IF NOT EXISTS chat_history (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            component_name TEXT,
            sender TEXT,
            content TEXT,
            timestamp TEXT,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    `);
    
    // Settings table
    this.db.run(`
        CREATE TABLE IF NOT EXISTS settings (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            key TEXT UNIQUE,
            value TEXT,
            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    `);
}

            // Initialize Event Listeners
            initializeEventListeners() {
                // Component Analysis
                const componentInput = document.getElementById('componentName');
                const friendlyNameInput = document.getElementById('friendlyName');
                const analyzeBtn = document.getElementById('analyzeComponentBtn');
                
                if (componentInput) {
                    componentInput.addEventListener('input', () => this.onComponentInput());
                }
                
                if (friendlyNameInput) {
                    friendlyNameInput.addEventListener('input', () => this.onFriendlyNameInput());
                }
                
                if (analyzeBtn) {
                    analyzeBtn.addEventListener('click', () => this.analyzeComponent());
                }
                
                // API Validation
                const validateBtn = document.getElementById('validateApiBtn');
                if (validateBtn) {
                    validateBtn.addEventListener('click', () => this.validateConnection());
                }
                
                // File Upload
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');
                
                if (uploadArea && fileInput) {
                    uploadArea.addEventListener('click', () => {
                        if (this.serverValidated) fileInput.click();
                    });
                    uploadArea.addEventListener('drop', (e) => this.handleFileDrop(e));
                    uploadArea.addEventListener('dragover', (e) => this.handleDragOver(e));
                    uploadArea.addEventListener('dragleave', (e) => this.handleDragLeave(e));
                    fileInput.addEventListener('change', (e) => this.handleFileSelect(e));
                }
                
                // Quick Actions
                const bulkBtn = document.getElementById('bulkAnalyzeBtn');
                const exportJsonBtn = document.getElementById('exportJsonBtn');
                const exportMdBtn = document.getElementById('exportMdBtn');
                const clearBtn = document.getElementById('clearBtn');
                
                if (bulkBtn) bulkBtn.addEventListener('click', () => this.bulkAnalyze());
                if (exportJsonBtn) exportJsonBtn.addEventListener('click', () => this.exportResults('json'));
                if (exportMdBtn) exportMdBtn.addEventListener('click', () => this.exportResults('markdown'));
                if (clearBtn) clearBtn.addEventListener('click', () => this.clearAllData());
                
                // Settings
                const endpointInput = document.getElementById('vllmEndpoint');
                const maxTokensInput = document.getElementById('maxTokens');
                
                if (endpointInput) {
                    endpointInput.addEventListener('input', () => this.onEndpointChange());
                }
                
                if (maxTokensInput) {
                    maxTokensInput.addEventListener('input', () => this.onSettingsChange());
                }
                
                // Hide suggestions when clicking outside
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('#componentName')) {
                        const suggestions = document.getElementById('componentSuggestions');
                        if (suggestions) suggestions.classList.remove('show');
                    }
                });
            }

            // Component Input Handler
            onComponentInput() {
                const input = document.getElementById('componentName');
                const suggestions = document.getElementById('componentSuggestions');
                
                if (!input || !suggestions) return;
                
                const value = input.value.trim().toUpperCase();
                
                if (value.length < 2) {
                    suggestions.classList.remove('show');
                    this.validateForm();
                    return;
                }
                
                const filtered = this.componentSuggestions.filter(item => 
                    item.name.includes(value)
                ).slice(0, 8);
                
                if (filtered.length > 0) {
                    let html = '';
                    filtered.forEach(item => {
                        const icon = this.getComponentIcon(item.type);
                        html += `
                            <div class="suggestion-item" onclick="analyzer.selectSuggestion('${item.name}')">
                                <span>${icon}</span>
                                <span class="suggestion-item-name">${item.name}</span>
                                <span class="suggestion-item-type">(${item.type})</span>
                                ${item.level ? `<span class="suggestion-item-badge">L${item.level}</span>` : ''}
                            </div>
                        `;
                    });
                    suggestions.innerHTML = html;
                    suggestions.classList.add('show');
                } else {
                    suggestions.classList.remove('show');
                }
                
                this.updateTokenDisplay();
                this.validateForm();
            }

            // Friendly Name Input Handler
            onFriendlyNameInput() {
                const input = document.getElementById('friendlyName');
                if (input) {
                    this.currentFriendlyName = input.value.trim() || null;
                }
            }

            // Select Component Suggestion
            selectSuggestion(componentName) {
                const input = document.getElementById('componentName');
                const suggestions = document.getElementById('componentSuggestions');
                
                if (input) input.value = componentName;
                if (suggestions) suggestions.classList.remove('show');
                
                this.validateForm();
                this.updateTokenDisplay();
            }

            // Get Component Icon
            getComponentIcon(type) {
                const icons = {
                    'RECORD_LAYOUT': '🎯',
                    'PROGRAM': '💼',
                    'COPYBOOK': '📚',
                    'FILE': '📁'
                };
                return icons[type] || '📋';
            }

            // Display Name Helper
            getDisplayName() {
                return this.currentFriendlyName || this.currentAnalyzedComponent || 'Component';
            }

            // Update Token Display
            updateTokenDisplay() {
                const input = document.getElementById('componentName');
                const tokenInfo = document.getElementById('tokenInfo');
                const tokenCount = document.getElementById('tokenCount');
                const tokenFill = document.getElementById('tokenFill');
                const tokenWarning = document.getElementById('tokenWarning');
                
                if (!input || !tokenInfo) return;
                
                const text = input.value;
                const estimatedTokens = Math.ceil(text.length / this.averageCharsPerToken);
                
                tokenInfo.style.display = 'block';
                tokenCount.textContent = `${estimatedTokens} / ${this.maxTokens}`;
                
                const percentage = (estimatedTokens / this.maxTokens) * 100;
                tokenFill.style.width = `${Math.min(percentage, 100)}%`;
                
                tokenFill.className = 'token-fill';
                if (percentage <= 50) {
                    tokenFill.classList.add('safe');
                    tokenWarning.textContent = '🟢 Optimal token usage';
                } else if (percentage <= 70) {
                    tokenFill.classList.add('warning');
                    tokenWarning.textContent = '🟡 Moderate usage';
                } else {
                    tokenFill.classList.add('danger');
                    tokenWarning.textContent = '🔴 High usage - consider simplifying';
                }
            }

            // Validate Form
            validateForm() {
                const hasFiles = this.uploadedFiles.length > 0;
                const hasComponent = document.getElementById('componentName')?.value.trim().length > 0;
                const hasConnection = this.serverValidated;
                
                const analyzeBtn = document.getElementById('analyzeComponentBtn');
                const bulkBtn = document.getElementById('bulkAnalyzeBtn');
                
                if (analyzeBtn) analyzeBtn.disabled = !(hasFiles && hasComponent && hasConnection);
                if (bulkBtn) bulkBtn.disabled = !(hasFiles && hasConnection);
                
                const hasResults = Object.keys(this.analysisResults).length > 0;
                const exportJsonBtn = document.getElementById('exportJsonBtn');
                const exportMdBtn = document.getElementById('exportMdBtn');
                
                if (exportJsonBtn) exportJsonBtn.disabled = !hasResults;
                if (exportMdBtn) exportMdBtn.disabled = !hasResults;
            }

            // Show/Hide Loading
            showLoading() {
                const loading = document.getElementById('loadingIndicator');
                if (loading) loading.classList.add('show');
            }

            hideLoading() {
                const loading = document.getElementById('loadingIndicator');
                if (loading) loading.classList.remove('show');
            }

            updateLoadingStatus(status) {
                const statusEl = document.getElementById('loadingStatus');
                if (statusEl) statusEl.textContent = status;
            }

            updateProgress(percentage) {
                const progressFill = document.getElementById('progressFill');
                if (progressFill) progressFill.style.width = `${percentage}%`;
            }

            // Alert Messages
            showMessage(type, message, duration = 3000) {
                const alert = document.createElement('div');
                alert.className = `alert alert-${type}`;
                alert.innerHTML = `
                    <span class="alert-icon">${type === 'success' ? '✅' : type === 'error' ? '❌' : type === 'warning' ? '⚠️' : 'ℹ️'}</span>
                    <span class="alert-message">${message}</span>
                `;
                document.body.appendChild(alert);
                
                setTimeout(() => {
                    if (alert.parentNode) {
                        alert.style.animation = 'slideInRight 0.3s ease reverse';
                        setTimeout(() => alert.remove(), 300);
                    }
                }, duration);
            }

            showSuccess(message) { this.showMessage('success', message); }
            showError(message) { this.showMessage('error', message, 5000); }
            showWarning(message) { this.showMessage('warning', message, 4000); }
            showInfo(message) { this.showMessage('info', message); }

           

            handleDragOver(e) {
                e.preventDefault();
                const uploadArea = document.getElementById('uploadArea');
                if (uploadArea) uploadArea.classList.add('drag-over');
            }

            handleDragLeave(e) {
                e.preventDefault();
                const uploadArea = document.getElementById('uploadArea');
                if (uploadArea) uploadArea.classList.remove('drag-over');
            }

           

            onEndpointChange() {
                this.serverValidated = false;
                this.updateConnectionStatus('disconnected', 'Connection not validated');
                this.validateForm();
            }

            onSettingsChange() {
                const maxTokensInput = document.getElementById('maxTokens');
                if (maxTokensInput) {
                    this.maxTokens = parseInt(maxTokensInput.value) || 4000;
                    this.saveToStorage();
                }
            }

            updateConnectionStatus(status, message) {
                const statusEl = document.getElementById('apiStatus');
                if (statusEl) {
                    statusEl.className = `status-indicator ${status}`;
                    statusEl.innerHTML = `
                        <span class="status-dot"></span>
                        <span>${message}</span>
                    `;
                }
            }

            bulkAnalyze() {
                this.showInfo('Bulk analysis feature coming soon');
            }

            exportResults(format) {
                this.showInfo(`Export as ${format} feature coming soon`);
            }

            clearAllData() {
                if (confirm('Are you sure you want to clear all data?')) {
                    this.uploadedFiles = [];
                    this.analysisResults = {};
                    localStorage.removeItem(this.storageKey);
                    this.showSuccess('All data cleared');
                    this.validateForm();
                }
            }
// ============================================
// PART 7: FILE HANDLING AND COMPONENT EXTRACTION
// Complete file upload, parsing, and component detection
// ============================================

// Add these methods to the EnhancedMainframeAnalyzer class

// File Upload Handling
async handleFileDrop(e) {
    e.preventDefault();
    e.stopPropagation();
    
    const uploadArea = document.getElementById('uploadArea');
    uploadArea.classList.remove('drag-over');
    
    if (!this.serverValidated) {
        this.showError('Please validate LLM API connection first');
        return;
    }
    
    const files = Array.from(e.dataTransfer.files);
    this.processFiles(files);
}

async handleFileSelect(e) {
    if (!this.serverValidated) {
        this.showError('Please validate LLM API connection first');
        return;
    }
    
    const files = Array.from(e.target.files);
    this.processFiles(files);
}

async processFiles(files) {
    for (const file of files) {
        try {
            const content = await this.readFile(file);
            const fileType = this.detectFileType(file.name, content);
            
            const fileObj = {
                name: file.name,
                content: content,
                size: file.size,
                type: fileType,
                uploadDate: new Date().toISOString(),
                id: Date.now() + Math.random(),
                components: this.extractComponentsFromFile(content, fileType)
            };
            
            this.uploadedFiles.push(fileObj);
            this.updateComponentSuggestions();
            
        } catch (error) {
            this.showError(`Failed to read ${file.name}: ${error.message}`);
        }
    }
    
    this.displayUploadedFiles();
    this.validateForm();
    this.saveToStorage();
    this.showSuccess(`📁 ${files.length} files uploaded successfully!`);
}

readFile(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = e => resolve(e.target.result);
        reader.onerror = e => reject(new Error('File read failed'));
        reader.readAsText(file);
    });
}

detectFileType(fileName, content) {
    const name = fileName.toLowerCase();
    const upperContent = content.toUpperCase();
    
    if (name.includes('.cpy') || name.includes('copybook')) {
        return 'Copybook';
    } else if (name.includes('.jcl') || upperContent.includes('//JOB ')) {
        return 'JCL Job';
    } else if (name.includes('.cbl') || name.includes('.cob') || 
              upperContent.includes('IDENTIFICATION DIVISION') ||
              upperContent.includes('PROGRAM-ID')) {
        return 'COBOL Program';
    } else if (name.includes('.proc')) {
        return 'JCL Procedure';
    } else {
        return 'Text File';
    }
}

// Extract Components from Files - CRITICAL FOR FIELD ANALYSIS
extractComponentsFromFile(content, fileType) {
    const components = [];
    const lines = content.split('\n');
    const upperContent = content.toUpperCase();

    lines.forEach((line, index) => {
        const trimmed = line.trim().toUpperCase();
        
        // Extract COBOL 01-level fields (main focus for copybooks)
        const field01Match = trimmed.match(/^\s*01\s+([A-Z][A-Z0-9\-_]{2,})/);
        if (field01Match) {
            components.push({
                name: field01Match[1],
                type: 'RECORD_LAYOUT',
                level: '01',
                lineNumber: index + 1,
                fileType: fileType,
                isMainComponent: true
            });
        }
        
        // Extract ALL field levels for complete analysis
        const fieldMatch = trimmed.match(/^\s*(\d{2})\s+([A-Z][A-Z0-9\-_]*)/);
        if (fieldMatch) {
            const level = parseInt(fieldMatch[1]);
            const fieldName = fieldMatch[2];
            
            if (level !== 88 && fieldName) { // Skip 88-level conditions
                components.push({
                    name: fieldName,
                    type: level === 1 ? 'RECORD_LAYOUT' : 'FIELD',
                    level: level,
                    lineNumber: index + 1,
                    fileType: fileType,
                    isMainComponent: level === 1
                });
            }
        }
        
        // Extract copybook names
        const copyMatch = trimmed.match(/COPY\s+([A-Z][A-Z0-9\-_]{2,})/);
        if (copyMatch) {
            components.push({
                name: copyMatch[1],
                type: 'COPYBOOK',
                lineNumber: index + 1,
                fileType: fileType,
                isMainComponent: false
            });
        }
        
        // Extract program names
        const programMatch = trimmed.match(/PROGRAM-ID\.?\s+([A-Z][A-Z0-9\-_]{2,})/);
        if (programMatch) {
            components.push({
                name: programMatch[1],
                type: 'PROGRAM',
                lineNumber: index + 1,
                fileType: fileType,
                isMainComponent: true
            });
        }

        // Extract file names from FD statements
        const fileMatch = trimmed.match(/FD\s+([A-Z][A-Z0-9\-_]{2,})/);
        if (fileMatch) {
            components.push({
                name: fileMatch[1],
                type: 'FILE',
                lineNumber: index + 1,
                fileType: fileType,
                isMainComponent: false
            });
        }
    });
    
    return components;
}

// Extract Detailed Field Information from Copybook
extractCopybookFields(copybookName, relevantFiles) {
    const fields = [];
    
    // Find the copybook file or file containing the copybook
    const copybookFile = relevantFiles.find(f => 
        f.type === 'Copybook' || 
        f.name.toUpperCase().includes(copybookName.toUpperCase()) ||
        (f.components && f.components.some(c => c.name.toUpperCase() === copybookName.toUpperCase()))
    );
    
    if (!copybookFile) {
        console.warn('Copybook file not found for:', copybookName);
        return fields;
    }

    const lines = copybookFile.content.split('\n');
    
    lines.forEach((line, index) => {
        const trimmed = line.trim();
        
        // Extract ALL field levels with complete details
        const fieldMatch = trimmed.match(/^\s*(\d{2})\s+([A-Z][A-Z0-9\-_]*)/);
        if (fieldMatch) {
            const level = parseInt(fieldMatch[1]);
            const fieldName = fieldMatch[2];
            
            // Skip 88-level conditions
            if (level === 88) return;
            
            // Extract PIC clause
            const picMatch = trimmed.match(/PIC\s+([X9VS\(\)]+)/i);
            const picture = picMatch ? picMatch[1] : '';
            
            // Extract VALUE clause
            const valueMatch = trimmed.match(/VALUE\s+([^.]+)/i);
            const value = valueMatch ? valueMatch[1].trim() : '';
            
            // Extract OCCURS clause
            const occursMatch = trimmed.match(/OCCURS\s+(\d+)/i);
            const occurs = occursMatch ? parseInt(occursMatch[1]) : 0;
            
            // Extract REDEFINES clause
            const redefinesMatch = trimmed.match(/REDEFINES\s+([A-Z][A-Z0-9\-_]*)/i);
            const redefines = redefinesMatch ? redefinesMatch[1] : '';
            
            // Determine field type
            const isRecordLayout = level === 1 && !picture && !value;
            const isGroupField = !picture && !value && level > 1;
            const isElementaryField = !!picture;
            const isConstant = !!value;
            
            fields.push({
                name: fieldName,
                level: level,
                picture: picture,
                value: value,
                occurs: occurs,
                redefines: redefines,
                isRecordLayout: isRecordLayout,
                isGroupField: isGroupField,
                isElementaryField: isElementaryField,
                isConstant: isConstant,
                lineNumber: index + 1,
                definition: trimmed,
                // Lifecycle tracking properties
                lifecycle: {
                    createdBy: [],
                    updatedBy: [],
                    readBy: [],
                    displayedBy: [],
                    validatedBy: []
                }
            });
        }
    });
    
    console.log(`Extracted ${fields.length} fields from copybook ${copybookName}`);
    return fields;
}

// Find Programs Using a Copybook
// Find Programs Using a Copybook
findProgramsUsingCopybook(copybookName) {
    const usingPrograms = [];
    const copybookUpper = copybookName.toUpperCase();
    const copybookBase = copybookUpper.replace(/\.(CPY|COPYBOOK|COP)$/, ''); // Remove extension
    
    this.uploadedFiles.forEach(file => {
        if (file.type === 'COBOL Program' || file.content.toUpperCase().includes('PROGRAM-ID')) {
            const content = file.content.toUpperCase();
            
            // Check for COPY statements with various patterns
            const copyPatterns = [
                // Direct matches
                `COPY ${copybookUpper}`,
                `COPY ${copybookBase}`,
                // With quotes/apostrophes
                `COPY "${copybookUpper}"`,
                `COPY "${copybookBase}"`,
                `COPY '${copybookUpper}'`,
                `COPY '${copybookBase}'`,
                // With periods
                `COPY ${copybookUpper}.`,
                `COPY ${copybookBase}.`,
                // Include statements
                `INCLUDE ${copybookUpper}`,
                `INCLUDE ${copybookBase}`
            ];
            
            const usesCopybook = copyPatterns.some(pattern => content.includes(pattern));
            
            if (usesCopybook) {
                console.log(`Program ${file.name} uses copybook ${copybookName} (matched as ${copybookBase})`);
                usingPrograms.push(file);
            }
        }
    });
    
    return usingPrograms;
}

// Analyze Field Usage in Program
analyzeFieldUsageInProgram(fieldName, programFile) {
    const usage = {
        fieldName: fieldName,
        programName: '',
        isRead: false,
        isWritten: false,
        isDisplayed: false,
        isInput: false,
        isValidated: false,
        isCalculated: false,
        operations: []
    };

    if (!programFile || !programFile.content) {
        console.warn('Program file or content is missing for field analysis');
        return usage;
    }

    const lines = programFile.content.split('\n');
    const upperContent = programFile.content.toUpperCase();
    const fieldUpper = fieldName.toUpperCase();
    
    // Get program name
    const programMatch = upperContent.match(/PROGRAM-ID\.?\s+([A-Z][A-Z0-9\-_]+)/);
    usage.programName = programMatch ? programMatch[1] : programFile.name.replace(/\.[^/.]+$/, "");

    lines.forEach((line, lineNum) => {
        const trimmed = line.trim().toUpperCase();
        
        // Skip if line doesn't contain our field
        if (!trimmed.includes(fieldUpper)) {
            return;
        }

        // MOVE operations (reading/writing)
        if (trimmed.includes('MOVE')) {
            const moveFromMatch = trimmed.match(new RegExp(`MOVE\\s+${fieldUpper}\\s+TO\\s+([A-Z][A-Z0-9\\-_]+)`));
            const moveToMatch = trimmed.match(new RegExp(`MOVE\\s+([A-Z][A-Z0-9\\-_]+)\\s+TO\\s+${fieldUpper}`));
            
            if (moveFromMatch) {
                usage.isRead = true;
                usage.operations.push({
                    type: 'read',
                    operation: 'MOVE FROM',
                    line: lineNum + 1,
                    context: trimmed.substring(0, 80),
                    target: moveFromMatch[1]
                });
            }
            
            if (moveToMatch) {
                usage.isWritten = true;
                usage.operations.push({
                    type: 'write',
                    operation: 'MOVE TO',
                    line: lineNum + 1,
                    context: trimmed.substring(0, 80),
                    source: moveToMatch[1]
                });
            }
        }

        // DISPLAY operations
        if (trimmed.includes('DISPLAY') && trimmed.includes(fieldUpper)) {
            usage.isDisplayed = true;
            usage.operations.push({
                type: 'display',
                operation: 'DISPLAY',
                line: lineNum + 1,
                context: trimmed.substring(0, 80)
            });
        }

        // ACCEPT operations
        if (trimmed.includes('ACCEPT') && trimmed.includes(fieldUpper)) {
            usage.isInput = true;
            usage.operations.push({
                type: 'input',
                operation: 'ACCEPT',
                line: lineNum + 1,
                context: trimmed.substring(0, 80)
            });
        }

        // IF/WHEN conditions
        if ((trimmed.includes('IF') || trimmed.includes('WHEN')) && trimmed.includes(fieldUpper)) {
            usage.isValidated = true;
            usage.operations.push({
                type: 'validation',
                operation: 'CONDITION',
                line: lineNum + 1,
                context: trimmed.substring(0, 80)
            });
        }

        // Calculations
        const calcOperations = ['COMPUTE', 'ADD', 'SUBTRACT', 'MULTIPLY', 'DIVIDE'];
        for (const op of calcOperations) {
            if (trimmed.includes(op) && trimmed.includes(fieldUpper)) {
                usage.isCalculated = true;
                usage.operations.push({
                    type: 'calculation',
                    operation: op,
                    line: lineNum + 1,
                    context: trimmed.substring(0, 80)
                });
                break;
            }
        }

        // CICS operations
        if (trimmed.includes('EXEC CICS')) {
            if (trimmed.includes('SEND MAP') && trimmed.includes(fieldUpper)) {
                usage.isDisplayed = true;
                usage.operations.push({
                    type: 'cics_output',
                    operation: 'CICS SEND MAP',
                    line: lineNum + 1,
                    context: trimmed.substring(0, 80)
                });
            }
            
            if (trimmed.includes('RECEIVE MAP') && trimmed.includes(fieldUpper)) {
                usage.isInput = true;
                usage.operations.push({
                    type: 'cics_input',
                    operation: 'CICS RECEIVE MAP',
                    line: lineNum + 1,
                    context: trimmed.substring(0, 80)
                });
            }
        }

        // File operations
        if (trimmed.includes('WRITE') && trimmed.includes(fieldUpper)) {
            usage.isWritten = true;
            usage.operations.push({
                type: 'file_write',
                operation: 'WRITE',
                line: lineNum + 1,
                context: trimmed.substring(0, 80)
            });
        }

        if (trimmed.includes('READ') && trimmed.includes(fieldUpper)) {
            usage.isRead = true;
            usage.operations.push({
                type: 'file_read',
                operation: 'READ',
                line: lineNum + 1,
                context: trimmed.substring(0, 80)
            });
        }
    });

    return usage;
}

// Update Component Suggestions
updateComponentSuggestions() {
    this.componentSuggestions = [];
    
    this.uploadedFiles.forEach(file => {
        if (file.components) {
            file.components.forEach(component => {
                // Focus on main components and fields
                if (component.isMainComponent || component.type === 'FIELD') {
                    this.componentSuggestions.push({
                        name: component.name,
                        type: component.type,
                        level: component.level,
                        file: file.name,
                        fileType: file.type,
                        lineNumber: component.lineNumber
                    });
                }
            });
        }
    });
    
    // Remove duplicates and sort by importance
    this.componentSuggestions = this.componentSuggestions
        .filter((item, index, self) => 
            index === self.findIndex(t => t.name === item.name && t.type === item.type)
        )
        .sort((a, b) => {
            // Prioritize 01-level fields and programs
            if (a.type === 'RECORD_LAYOUT' && b.type !== 'RECORD_LAYOUT') return -1;
            if (b.type === 'RECORD_LAYOUT' && a.type !== 'RECORD_LAYOUT') return 1;
            if (a.type === 'PROGRAM' && b.type !== 'PROGRAM') return -1;
            if (b.type === 'PROGRAM' && a.type !== 'PROGRAM') return 1;
            return a.name.localeCompare(b.name);
        });
}

// Display Uploaded Files
displayUploadedFiles() {
    const container = document.getElementById('uploadedFiles');
    if (!container) return;
    
    if (this.uploadedFiles.length === 0) {
        container.innerHTML = '';
        return;
    }
    
    let html = '';
    this.uploadedFiles.forEach(file => {
        const mainComponents = file.components ? 
            file.components.filter(c => c.isMainComponent).length : 0;
        const totalComponents = file.components ? file.components.length : 0;
        const fieldCount = file.components ? 
            file.components.filter(c => c.type === 'FIELD' || c.type === 'RECORD_LAYOUT').length : 0;
        
        html += `
            <div class="file-item">
                <div class="file-info">
                    <div class="file-icon">${this.getFileIcon(file.type)}</div>
                    <div class="file-details">
                        <div class="file-name">${file.name}</div>
                        <div class="file-meta">
                            ${file.type} • ${Math.round(file.size/1024)}KB
                            ${fieldCount > 0 ? ` • ${fieldCount} fields` : ''}
                            ${mainComponents > 0 ? ` • ${mainComponents} main` : ''}
                        </div>
                    </div>
                </div>
                <button class="file-remove" onclick="analyzer.removeFile('${file.id}')">×</button>
            </div>
        `;
    });
    
    container.innerHTML = html;
}

getFileIcon(type) {
    const icons = {
        'Copybook': '📚',
        'COBOL Program': '💼',
        'JCL Job': '📋',
        'JCL Procedure': '⚙️',
        'Text File': '📄'
    };
    return icons[type] || '📁';
}

removeFile(fileId) {
    this.uploadedFiles = this.uploadedFiles.filter(f => f.id != fileId);
    this.displayUploadedFiles();
    this.updateComponentSuggestions();
    this.validateForm();
    this.saveToStorage();
}

// Find Relevant Files for Component
// Find Relevant Files for Component
findRelevantFiles(componentName) {
    const componentUpper = componentName.toUpperCase();
    const componentBase = componentUpper.replace(/\.(CPY|COPYBOOK|COP)$/, ''); // Remove extensions
    
    return this.uploadedFiles.filter(file => {
        const fileNameUpper = file.name.toUpperCase();
        const fileNameBase = fileNameUpper.replace(/\.(CPY|COPYBOOK|COP)$/, '');
        
        // Direct name match (with or without extensions)
        if (fileNameUpper.includes(componentUpper) || 
            fileNameBase === componentBase ||
            componentBase === fileNameBase) {
            return true;
        }
        
        // Content-based matching with variations
        const contentUpper = file.content.toUpperCase();
        if (contentUpper.includes(componentUpper) ||
            contentUpper.includes(componentBase) ||
            contentUpper.includes(`COPY ${componentBase}`) ||
            contentUpper.includes(`"${componentBase}"`) ||
            contentUpper.includes(`'${componentBase}'`)) {
            return true;
        }
        
        // Check if any component in the file matches (with variations)
        if (file.components) {
            return file.components.some(comp => {
                const compNameUpper = comp.name.toUpperCase();
                const compNameBase = compNameUpper.replace(/\.(CPY|COPYBOOK|COP)$/, '');
                return compNameUpper === componentUpper || 
                       compNameBase === componentBase ||
                       componentBase === compNameBase;
            });
        }
        
        return false;
    });
}

// Detect Component Type
detectComponentType(componentName, files) {
    // Check if it's a field or record layout
    for (const file of files) {
        if (file.components) {
            const component = file.components.find(c => 
                c.name.toUpperCase() === componentName.toUpperCase()
            );
            if (component) {
                if (component.type === 'RECORD_LAYOUT') return 'Copybook';
                if (component.type === 'FIELD') return 'Field';
                if (component.type === 'PROGRAM') return 'COBOL Program';
                if (component.type === 'FILE') return 'File Definition';
            }
        }
    }
    
    // Fallback to file type detection
    const copybookFile = files.find(f => f.type === 'Copybook');
    if (copybookFile) return 'Copybook';
    
    const programFile = files.find(f => f.type === 'COBOL Program');
    if (programFile) return 'COBOL Program';
    
    return 'Component';
}
// ============================================
// PART 8: LLM CONNECTION AND API VALIDATION
// Complete LLM server validation and API calls
// ============================================

// Add these methods to the EnhancedMainframeAnalyzer class

// Validate LLM Connection
async validateConnection() {
    const endpoint = document.getElementById('vllmEndpoint').value.trim();
    if (!endpoint) {
        this.showError('Please enter vLLM endpoint');
        return;
    }

    this.updateConnectionStatus('connecting', 'Testing LLM connection...');

    try {
        const response = await fetch(`${endpoint}/generate`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                prompt: "Test connection. Respond with 'Connected'",
                max_tokens: 10,
                temperature: 0.1
            }),
            signal: AbortSignal.timeout(10000)
        });

        if (response.ok) {
            const data = await response.json();
            this.serverValidated = true;
            this.vllmEndpoint = endpoint;
            this.updateConnectionStatus('connected', `✅ LLM connection verified`);
            this.showSuccess('🚀 vLLM server connected successfully!');
            
            // Enable file upload area
            const uploadArea = document.getElementById('uploadArea');
            if (uploadArea) {
                uploadArea.style.opacity = '1';
                uploadArea.style.cursor = 'pointer';
            }
        } else {
            throw new Error(`HTTP ${response.status}`);
        }
    } catch (error) {
        this.serverValidated = false;
        this.updateConnectionStatus('disconnected', `❌ Connection failed: ${error.message}`);
        this.showError(`LLM connection failed: ${error.message}`);
    }
    
    this.validateForm();
}

// Call LLM API with retry logic
async callLLMAPI(prompt, retries = 0) {
    let resultText = '';
    
    try {
        console.log(`Making LLM API call attempt ${retries + 1}...`);
        
        const response = await fetch(`${this.vllmEndpoint}/generate`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                prompt: prompt,
                max_tokens: Math.min(this.maxTokens * 0.8, 4000),
                temperature: 0.1,
                top_p: 0.9,
                stop: [],
                stream: false,
                frequency_penalty: 0.1,
                presence_penalty: 0.0
            }),
            signal: AbortSignal.timeout(60000) // 60 second timeout
        });

        if (!response.ok) {
            throw new Error(`LLM API request failed: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();
        console.log('LLM API Response received');
        
        // Extract text from various response formats
        if (data.text) {
            resultText = data.text.trim();
        } else if (data.choices && data.choices.length > 0) {
            if (data.choices[0].text) {
                resultText = data.choices[0].text.trim();
            } else if (data.choices[0].message && data.choices[0].message.content) {
                resultText = data.choices[0].message.content.trim();
            }
        } else if (data.generated_text) {
            resultText = data.generated_text.trim();
        } else if (data.response) {
            resultText = data.response.trim();
        } else if (typeof data === 'string') {
            resultText = data.trim();
        }

        if (!resultText) {
            throw new Error('No valid text content in LLM response');
        }

        console.log(`LLM response length: ${resultText.length} chars`);

        // Parse the response
        const parseResult = this.parseJSONResponse(resultText);
        
        if (parseResult.success) {
            console.log('LLM JSON parsing successful');
            return parseResult.data;
        } else {
            console.warn('LLM JSON parsing failed, using fallback');
            if (parseResult.fallbackData) {
                parseResult.fallbackData.rawResponse = resultText.substring(0, 1000);
                parseResult.fallbackData.parseError = parseResult.error;
                return parseResult.fallbackData;
            } else {
                throw new Error(`JSON parsing failed: ${parseResult.error}`);
            }
        }

    } catch (error) {
        console.error(`LLM API call attempt ${retries + 1} failed:`, error);
        
        if (retries < 2) { // Max 3 attempts
            console.log(`Retrying LLM API call (${retries + 1}/2)...`);
            await this.sleep(2000 * (retries + 1)); // Exponential backoff
            return this.callLLMAPI(prompt, retries + 1);
        }
        
        // Final fallback
        return {
            error: true,
            message: error.message,
            fallbackData: this.createComponentFallback(
                this.currentAnalyzedComponent || 'Unknown',
                'Unknown',
                null
            )
        };
    }
}

// Parse JSON Response from LLM
parseJSONResponse(text) {
    if (!text || typeof text !== 'string') {
        return { 
            success: false, 
            error: 'No text provided', 
            fallbackData: this.createBasicFallback() 
        };
    }

    console.log('Parsing LLM response...');

    // Try direct JSON parsing first
    try {
        const directParse = JSON.parse(text);
        if (directParse && typeof directParse === 'object') {
            console.log('✅ Direct JSON parsing successful!');
            return { success: true, data: directParse };
        }
    } catch (e) {
        console.log('Direct JSON parsing failed, trying extraction methods');
    }

    // Try to extract JSON from text
    const jsonStart = text.indexOf('{');
    const jsonEnd = text.lastIndexOf('}');
    
    if (jsonStart !== -1 && jsonEnd !== -1 && jsonStart < jsonEnd) {
        const jsonText = text.substring(jsonStart, jsonEnd + 1);
        
        try {
            const parsed = JSON.parse(this.cleanJSONText(jsonText));
            if (parsed && typeof parsed === 'object') {
                console.log('✅ Extracted JSON parsing successful!');
                return { success: true, data: parsed };
            }
        } catch (e) {
            console.log('Extracted JSON parsing failed');
        }
    }

    // Create structured response from text
    console.log('Creating structured response from text analysis...');
    
    const componentName = this.currentAnalyzedComponent || 'Unknown';
    const friendlyName = this.currentFriendlyName || componentName;
    
    // Extract information from text
    const structuredResponse = {
        componentName: componentName,
        friendlyName: friendlyName,
        componentType: this.detectComponentTypeFromText(text),
        analysisScope: 'TEXT_ANALYSIS',
        status: 'Analysis completed with text parsing',
        totalFields: this.extractFieldCount(text),
        primaryFields: this.extractFieldsFromText(text),
        recommendations: this.extractRecommendationsFromText(text),
        qualityScore: 6,
        source: 'TextAnalysis'
    };

    return { 
        success: true, 
        data: structuredResponse,
        source: 'StructuredTextAnalysis'
    };
}

// Clean JSON Text
cleanJSONText(text) {
    if (!text) return '{}';
    
    return text
        // Remove trailing commas
        .replace(/,(\s*[\}\]])/g, '$1')
        // Fix unquoted property names
        .replace(/([{,]\s*)([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g, '$1"$2":')
        // Fix single quotes to double quotes
        .replace(/'/g, '"')
        // Remove comments
        .replace(/\/\/.*$/gm, '')
        .replace(/\/\*[\s\S]*?\*\//g, '')
        // Fix line breaks in strings
        .replace(/"\s*\n\s*"/g, '" + "');
}

// Extract field count from text
extractFieldCount(text) {
    const fieldMatches = text.match(/\b[A-Z][A-Z0-9\-_]{3,}\b/g) || [];
    return Math.min(fieldMatches.length, 50);
}

// Extract fields from text
extractFieldsFromText(text) {
    const fields = [];
    const fieldNames = new Set();
    
    // Look for field patterns
    const patterns = [
        /field[:\s]+([A-Z][A-Z0-9\-_]{2,})/gi,
        /"([A-Z][A-Z0-9\-_]{3,})"/g,
        /\b([A-Z][A-Z0-9\-_]{4,})\b/g
    ];
    
    patterns.forEach(pattern => {
        let match;
        while ((match = pattern.exec(text)) !== null) {
            const fieldName = match[1];
            
            if (!fieldNames.has(fieldName) && fieldName.length >= 3 && fieldName.length <= 30) {
                fieldNames.add(fieldName);
                fields.push({
                    name: fieldName,
                    level: fieldName.includes('-RECORD') ? 1 : 5,
                    businessPurpose: this.generateFieldPurpose(fieldName),
                    usagePattern: 'ANALYZED'
                });
            }
        }
    });
    
    return Array.from(fields).slice(0, 20);
}

// Generate field purpose from name
generateFieldPurpose(fieldName) {
    if (fieldName.includes('RECORD') || fieldName.includes('REC')) {
        return `Main record structure for ${fieldName.toLowerCase().replace(/-/g, ' ')} data`;
    } else if (fieldName.includes('ID') || fieldName.includes('KEY')) {
        return `Unique identifier for ${fieldName.toLowerCase().replace(/-/g, ' ')}`;
    } else if (fieldName.includes('DATE') || fieldName.includes('TIME')) {
        return `Date/time field for ${fieldName.toLowerCase().replace(/-/g, ' ')} tracking`;
    } else if (fieldName.includes('AMT') || fieldName.includes('AMOUNT')) {
        return `Monetary amount for ${fieldName.toLowerCase().replace(/-/g, ' ')}`;
    } else if (fieldName.includes('DESC') || fieldName.includes('NAME')) {
        return `Descriptive text for ${fieldName.toLowerCase().replace(/-/g, ' ')}`;
    } else if (fieldName.includes('FLAG') || fieldName.includes('IND')) {
        return `Status indicator for ${fieldName.toLowerCase().replace(/-/g, ' ')}`;
    } else if (fieldName.includes('CODE') || fieldName.includes('CD')) {
        return `Coded value for ${fieldName.toLowerCase().replace(/-/g, ' ')}`;
    } else if (fieldName.includes('COUNT') || fieldName.includes('CNT')) {
        return `Counter/number field for ${fieldName.toLowerCase().replace(/-/g, ' ')}`;
    } else {
        return `Business data field for ${fieldName.toLowerCase().replace(/-/g, ' ')} processing`;
    }
}

// Extract recommendations from text
extractRecommendationsFromText(text) {
    const recommendations = [];
    
    // Look for recommendation patterns
    const patterns = [
        /recommend[a-z]*[:\s]*([^.]+)/gi,
        /suggest[a-z]*[:\s]*([^.]+)/gi,
        /should[:\s]*([^.]+)/gi,
        /consider[:\s]*([^.]+)/gi
    ];
    
    for (const pattern of patterns) {
        let match;
        while ((match = pattern.exec(text)) !== null && recommendations.length < 5) {
            const rec = match[1].trim();
            if (rec.length > 10 && rec.length < 200) {
                recommendations.push(rec);
            }
        }
    }
    
    // If no patterns found, provide generic recommendations
    if (recommendations.length === 0) {
        recommendations.push(
            'Review the component structure and dependencies',
            'Validate field usage patterns across programs',
            'Check for missing dependencies and resolve them',
            'Consider optimization opportunities based on usage patterns',
            'Document business rules and field relationships'
        );
    }
    
    return recommendations.slice(0, 5);
}

// Detect component type from text
detectComponentTypeFromText(text) {
    const upperText = text.toUpperCase();
    
    if (upperText.includes('COPYBOOK') || upperText.includes('RECORD')) {
        return 'Copybook';
    } else if (upperText.includes('PROGRAM') || upperText.includes('COBOL')) {
        return 'COBOL Program';
    } else if (upperText.includes('JCL') || upperText.includes('JOB')) {
        return 'JCL Job';
    } else {
        return 'Component';
    }
}

// Create component fallback
createComponentFallback(componentName, componentType, lifecycleFlow) {
    const friendlyName = this.currentFriendlyName || componentName;
    
    const fallback = {
        componentName: componentName,
        friendlyName: friendlyName,
        componentType: componentType,
        analysisScope: 'FALLBACK_ANALYSIS',
        status: 'LLM analysis failed - using extracted data',
        totalFields: 0,
        recommendations: [
            'Check LLM server connection and configuration',
            'Verify component exists in uploaded files',
            'Try simplifying the analysis scope',
            'Use chat interface for specific questions',
            'Review the extracted data for accuracy'
        ],
        qualityScore: 3
    };

    // Add lifecycle data if available
    if (lifecycleFlow) {
        fallback.lifecycleAnalysis = {
            creationPrograms: lifecycleFlow.creationSources?.map(s => s.program) || [],
            updatePrograms: lifecycleFlow.updatePrograms?.map(u => u.program) || [],
            readPrograms: lifecycleFlow.inputPrograms?.map(i => i.program) || []
        };
        
        if (lifecycleFlow.primaryFields) {
            fallback.totalFields = lifecycleFlow.primaryFields.length;
            fallback.primaryFields = lifecycleFlow.primaryFields.map(f => ({
                name: f.name,
                level: f.level,
                isRecordLayout: f.isRecordLayout,
                businessPurpose: 'Analysis failed - check component manually',
                usagePattern: 'UNKNOWN'
            }));
        }
    }

    return fallback;
}

// Create basic fallback
createBasicFallback() {
    return {
        componentName: 'Unknown',
        friendlyName: 'Unknown',
        componentType: 'Unknown',
        status: 'No data available',
        recommendations: ['Upload files and analyze component'],
        qualityScore: 1
    };
}

// Storage Management
// Save to SQLite Database
async saveToStorage() {
    if (!this.dbInitialized || !this.db) {
        // Fallback to localStorage
        try {
            const data = {
                uploadedFiles: this.uploadedFiles,
                analysisResults: this.analysisResults,
                chatHistory: this.chatHistory,
                vllmEndpoint: this.vllmEndpoint,
                maxTokens: this.maxTokens,
                timestamp: new Date().toISOString()
            };
            localStorage.setItem('enhanced_mainframe_analysis', JSON.stringify(data));
        } catch (error) {
            console.warn('Failed to save to localStorage:', error);
        }
        return;
    }

    try {
        // Save uploaded files
        this.db.run("DELETE FROM uploaded_files");
        for (const file of this.uploadedFiles) {
            this.db.run(`
                INSERT INTO uploaded_files (file_id, name, content, size, type, upload_date, components)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            `, [
                file.id, 
                file.name, 
                file.content, 
                file.size, 
                file.type, 
                file.uploadDate, 
                JSON.stringify(file.components || [])
            ]);
        }
        
        // Save analysis results
        this.db.run("DELETE FROM analysis_results");
        for (const [componentName, results] of Object.entries(this.analysisResults)) {
            this.db.run(`
                INSERT OR REPLACE INTO analysis_results 
                (component_name, friendly_name, component_type, results_data, quality_score)
                VALUES (?, ?, ?, ?, ?)
            `, [
                componentName,
                results.friendlyName || componentName,
                results.componentType,
                JSON.stringify(results),
                results.qualityScore || 0
            ]);
        }
        
        // Save chat history
        this.db.run("DELETE FROM chat_history");
        for (const chat of this.chatHistory) {
            this.db.run(`
                INSERT INTO chat_history (component_name, sender, content, timestamp)
                VALUES (?, ?, ?, ?)
            `, [
                this.currentAnalyzedComponent || 'general',
                chat.sender,
                chat.content,
                chat.timestamp
            ]);
        }
        
        // Save settings
        this.db.run("INSERT OR REPLACE INTO settings (key, value) VALUES (?, ?)", 
                   ['vllmEndpoint', this.vllmEndpoint]);
        this.db.run("INSERT OR REPLACE INTO settings (key, value) VALUES (?, ?)", 
                   ['maxTokens', this.maxTokens.toString()]);
        
        // Save database to localStorage as backup
        const data = this.db.export();
        localStorage.setItem('mainframe_analyzer_db', JSON.stringify(Array.from(data)));
        
        console.log('✅ Data saved to SQLite database');
        
    } catch (error) {
        console.error('Failed to save to database:', error);
    }
}

// Load from SQLite Database
async loadStoredData() {
    if (!this.dbInitialized || !this.db) {
        // Fallback to localStorage
        try {
            const stored = localStorage.getItem('enhanced_mainframe_analysis');
            if (stored) {
                const data = JSON.parse(stored);
                this.uploadedFiles = data.uploadedFiles || [];
                this.analysisResults = data.analysisResults || {};
                this.chatHistory = data.chatHistory || [];
                
                if (data.vllmEndpoint) this.vllmEndpoint = data.vllmEndpoint;
                if (data.maxTokens) this.maxTokens = data.maxTokens;
                
                this.updateUIFromLoadedData(data);
                console.log('📁 Data loaded from localStorage fallback');
            }
        } catch (error) {
            console.warn('Failed to load from localStorage:', error);
        }
        return;
    }

    try {
        // Load uploaded files
        const filesResult = this.db.exec("SELECT * FROM uploaded_files ORDER BY created_at");
        if (filesResult.length > 0) {
            this.uploadedFiles = filesResult[0].values.map(row => ({
                id: row[1],
                name: row[2],
                content: row[3],
                size: row[4],
                type: row[5],
                uploadDate: row[6],
                components: JSON.parse(row[7] || '[]')
            }));
        }
        
        // Load analysis results
        const resultsQuery = this.db.exec("SELECT * FROM analysis_results ORDER BY updated_at DESC");
        if (resultsQuery.length > 0) {
            resultsQuery[0].values.forEach(row => {
                const componentName = row[1];
                const resultsData = JSON.parse(row[4]);
                this.analysisResults[componentName] = resultsData;
            });
        }
        
        // Load chat history
        const chatQuery = this.db.exec("SELECT * FROM chat_history ORDER BY created_at");
        if (chatQuery.length > 0) {
            this.chatHistory = chatQuery[0].values.map(row => ({
                sender: row[2],
                content: row[3],
                timestamp: row[4]
            }));
        }
        
        // Load settings
        const settingsQuery = this.db.exec("SELECT key, value FROM settings");
        if (settingsQuery.length > 0) {
            settingsQuery[0].values.forEach(row => {
                const [key, value] = row;
                if (key === 'vllmEndpoint') this.vllmEndpoint = value;
                if (key === 'maxTokens') this.maxTokens = parseInt(value);
            });
        }
        
        this.updateUIFromLoadedData();
        console.log('✅ Data loaded from SQLite database');
        
    } catch (error) {
        console.error('Failed to load from database:', error);
    }
}

// Update UI from loaded data
updateUIFromLoadedData() {
    // Update UI elements
    const endpointInput = document.getElementById('vllmEndpoint');
    const maxTokensInput = document.getElementById('maxTokens');
    
    if (endpointInput) endpointInput.value = this.vllmEndpoint;
    if (maxTokensInput) maxTokensInput.value = this.maxTokens;
    
    this.displayUploadedFiles();
    this.updateComponentSuggestions();
    this.validateForm();
}

// Utility function
sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
// ============================================
// PART 9: MAIN COMPONENT ANALYSIS LOGIC
// Complete analysis workflow with field extraction
// ============================================

// Add these methods to the EnhancedMainframeAnalyzer class

// Main Component Analysis Method
async analyzeComponent() {
    const componentName = document.getElementById('componentName').value.trim();
    const friendlyName = document.getElementById('friendlyName').value.trim();
    
    if (!componentName) {
        this.showError('Please enter a component name');
        return;
    }

    if (!this.serverValidated) {
        this.showError('Please validate LLM server connection first');
        return;
    }

    this.currentAnalyzedComponent = componentName;
    this.currentFriendlyName = friendlyName || componentName;

    this.showLoading();
    this.updateProgress(0);

    try {
        console.log(`=== Starting Analysis for Component: ${componentName} ===`);
        console.log(`Friendly Name: ${this.currentFriendlyName}`);
        
        this.updateLoadingStatus('🚀 Initializing component analysis...');
        
        // Check if component exists in uploaded files
        const relevantFiles = this.findRelevantFiles(componentName);
        if (relevantFiles.length === 0) {
            throw new Error(`Component "${componentName}" not found in uploaded files. Please check the component name and ensure related files are uploaded.`);
        }

        console.log(`Found ${relevantFiles.length} relevant files:`, relevantFiles.map(f => f.name));

        // Run the analysis
        const results = await this.runComprehensiveAnalysis(componentName, relevantFiles);
        
        // Store results
        this.analysisResults[componentName] = results;
        
        // Update UI with results
        this.displayAnalysisResults(componentName, results);
        
        // Enable chat
        this.enableChat();
        
        // Save to storage
        this.saveToStorage();
        
        this.hideLoading();
        
        // Show success with details
        const displayName = this.getDisplayName();
        const successMessage = `✅ Analysis complete for ${displayName}! 
        Quality: ${results.qualityScore}/10 | 
        Files: ${results.filesAnalyzed.length} | 
        Fields: ${results.totalFields || 0}`;
        
        this.showSuccess(successMessage);
        
        console.log(`=== Analysis Complete for ${componentName} ===`);
        
    } catch (error) {
        this.hideLoading();
        console.error('Component analysis failed:', error);
        this.showError(`Analysis failed: ${error.message}`);
    }
}

// Run Comprehensive Analysis
async runComprehensiveAnalysis(componentName, relevantFiles) {
    console.log(`Starting comprehensive analysis for: ${componentName}`);
    
    try {
        // Stage 1: Detect component type
        this.updateLoadingStatus('🔍 Stage 1: Detecting component type...');
        this.updateProgress(10);
        
        const componentType = this.detectComponentType(componentName, relevantFiles);
        console.log(`Component type: ${componentType}`);

        // Stage 2: Extract dependencies
        this.updateLoadingStatus('🔗 Stage 2: Analyzing dependencies...');
        this.updateProgress(25);
        
        const dependencyAnalysis = await this.extractDependencies(relevantFiles);

        // Stage 3: Extract fields (for copybooks and programs)
        this.updateLoadingStatus('📋 Stage 3: Extracting fields...');
        this.updateProgress(40);
        
        let fieldAnalysis = null;
        if (componentType === 'Copybook' || componentType === 'Field') {
            fieldAnalysis = await this.analyzeFieldsInComponent(componentName, relevantFiles);
        }

        // Stage 4: Extract lifecycle flow
        this.updateLoadingStatus('🌊 Stage 4: Analyzing lifecycle...');
        this.updateProgress(55);
        
        const lifecycleFlow = await this.extractLifecycleFlow(componentName, relevantFiles, fieldAnalysis);

        // Stage 5: LLM analysis
        this.updateLoadingStatus('🤖 Stage 5: Running LLM analysis...');
        this.updateProgress(70);
        
        let llmAnalysis = null;
        try {
            if (componentType === 'Copybook' || componentType === 'Field') {
                llmAnalysis = await this.analyzeCopybookWithLLM(
                    componentName, relevantFiles, dependencyAnalysis, lifecycleFlow, fieldAnalysis
                );
            } else if (componentType === 'COBOL Program') {
                llmAnalysis = await this.analyzeProgramWithLLM(
                    componentName, relevantFiles, dependencyAnalysis, lifecycleFlow
                );
            } else {
                llmAnalysis = await this.analyzeGenericComponentWithLLM(
                    componentName, relevantFiles, dependencyAnalysis
                );
            }
        } catch (llmError) {
            console.error('LLM analysis failed:', llmError);
            llmAnalysis = {
                error: true,
                message: llmError.message,
                fallbackData: this.createComponentFallback(componentName, componentType, lifecycleFlow)
            };
        }

        // Stage 6: Finalize results
        this.updateLoadingStatus('📊 Stage 6: Finalizing analysis...');
        this.updateProgress(90);
        
        const results = {
            componentName: componentName,
            friendlyName: this.currentFriendlyName,
            timestamp: new Date().toISOString(),
            filesAnalyzed: relevantFiles.map(f => f.name),
            componentType: componentType,
            dependencyAnalysis: dependencyAnalysis,
            fieldAnalysis: fieldAnalysis,
            lifecycleFlow: lifecycleFlow,
            llmAnalysis: llmAnalysis,
            totalFields: fieldAnalysis?.fields?.length || 0,
            qualityScore: this.calculateQualityScore(llmAnalysis, fieldAnalysis),
            completeness: this.assessCompleteness(llmAnalysis, fieldAnalysis),
            analysisMethod: 'LLM-Enhanced-Field-Focused'
        };

        this.updateProgress(100);
        return results;

    } catch (error) {
        console.error('Analysis failed:', error);
        throw new Error(`Analysis failed: ${error.message}`);
    }
}

// Analyze Fields in Component
async analyzeFieldsInComponent(componentName, relevantFiles) {
    console.log(`Analyzing fields for component: ${componentName}`);
    
    // Extract all fields from the copybook
    const fields = this.extractCopybookFields(componentName, relevantFiles);
    
    if (fields.length === 0) {
        console.warn('No fields found in copybook');
        return null;
    }
    
    console.log(`Found ${fields.length} fields in copybook`);
    
    // Find programs that use this copybook
    const usingPrograms = this.findProgramsUsingCopybook(componentName);
    console.log(`Found ${usingPrograms.length} programs using copybook`);
    
    // Analyze field usage across programs
    const fieldUsageAnalysis = {
        fields: fields,
        programs: usingPrograms,
        inputFields: [],
        outputFields: [],
        referenceFields: [],
        unusedFields: [],
        fieldUsageDetails: {}
    };
    
    // Analyze each field's usage
    fields.forEach(field => {
        const fieldName = field.name;
        let usageCount = 0;
        let isInput = false;
        let isOutput = false;
        let isReference = false;
        
        const usageDetails = {
            readBy: [],
            writtenBy: [],
            referencedBy: [],
            operations: []
        };
        
        // Check usage in each program
        usingPrograms.forEach(program => {
            const fieldUsage = this.analyzeFieldUsageInProgram(fieldName, program);
            
            if (fieldUsage.operations.length > 0) {
                usageCount++;
                
                if (fieldUsage.isInput || fieldUsage.isWritten) {
                    isInput = true;
                    usageDetails.writtenBy.push(program.name);
                }
                
                if (fieldUsage.isDisplayed || fieldUsage.isRead) {
                    isOutput = true;
                    usageDetails.readBy.push(program.name);
                }
                
                if (fieldUsage.isValidated) {
                    isReference = true;
                    usageDetails.referencedBy.push(program.name);
                }
                
                usageDetails.operations.push(...fieldUsage.operations);
            }
        });
        
        // Categorize field
        if (usageCount === 0) {
            fieldUsageAnalysis.unusedFields.push(fieldName);
        } else if (isInput && !isOutput) {
            fieldUsageAnalysis.inputFields.push(fieldName);
        } else if (isOutput && !isInput) {
            fieldUsageAnalysis.outputFields.push(fieldName);
        } else {
            fieldUsageAnalysis.referenceFields.push(fieldName);
        }
        // Add business logic analysis for each field
fields.forEach(field => {
    const fieldName = field.name;
    let businessLogic = {
        validationRules: [],
        calculations: [],
        businessMeaning: '',
        constraints: []
    };
    
    // Extract business logic from programs
    usingPrograms.forEach(program => {
        const programLogic = this.extractBusinessLogic(program, [fieldName]);
        
        if (programLogic.validationRules.length > 0) {
            businessLogic.validationRules.push(...programLogic.validationRules);
        }
        
        if (programLogic.calculations.length > 0) {
            businessLogic.calculations.push(...programLogic.calculations);
        }
    });
    
    // Determine business meaning from field name and usage
    businessLogic.businessMeaning = this.determineBusinessMeaning(fieldName, businessLogic);
    
    // Add business logic to field
    field.businessLogic = businessLogic;
});

// Add business logic summary to field analysis
fieldUsageAnalysis.businessLogicSummary = {
    totalValidationRules: fields.reduce((sum, f) => sum + (f.businessLogic?.validationRules?.length || 0), 0),
    totalCalculations: fields.reduce((sum, f) => sum + (f.businessLogic?.calculations?.length || 0), 0),
    fieldsWithBusinessLogic: fields.filter(f => f.businessLogic?.validationRules?.length > 0 || f.businessLogic?.calculations?.length > 0).length
};
        
        fieldUsageAnalysis.fieldUsageDetails[fieldName] = usageDetails;
    });
    // Enhanced business logic extraction
// PERFORM statements with business logic
if (trimmed.includes('PERFORM') && trimmed.includes(fieldUpper)) {
    usage.isValidated = true;
    usage.operations.push({
        type: 'business_logic',
        operation: 'PERFORM',
        line: lineNum + 1,
        context: trimmed.substring(0, 100)
    });
}

// Business rule validations
const businessRulePatterns = [
    /IF\s+.*${fieldUpper}.*\s+(>|<|=|NOT)/,
    /WHEN\s+.*${fieldUpper}.*\s+(>|<|=|NOT)/,
    /EVALUATE\s+.*${fieldUpper}/,
    /SEARCH\s+.*${fieldUpper}/
];

businessRulePatterns.forEach((pattern, index) => {
    if (pattern.test(trimmed.replace('${fieldUpper}', fieldUpper))) {
        usage.isValidated = true;
        usage.operations.push({
            type: 'business_rule',
            operation: ['CONDITION', 'WHEN_CONDITION', 'EVALUATE', 'SEARCH'][index],
            line: lineNum + 1,
            context: trimmed.substring(0, 100),
            ruleType: 'validation'
        });
    }
});

// Data transformation logic
if ((trimmed.includes('STRING') || trimmed.includes('UNSTRING') || 
     trimmed.includes('INSPECT') || trimmed.includes('TRANSFORM')) && 
    trimmed.includes(fieldUpper)) {
    usage.isCalculated = true;
    usage.operations.push({
        type: 'transformation',
        operation: 'DATA_TRANSFORMATION',
        line: lineNum + 1,
        context: trimmed.substring(0, 100)
    });
}
    console.log('Field usage analysis complete:', {
        input: fieldUsageAnalysis.inputFields.length,
        output: fieldUsageAnalysis.outputFields.length,
        reference: fieldUsageAnalysis.referenceFields.length,
        unused: fieldUsageAnalysis.unusedFields.length
    });
    
    return fieldUsageAnalysis;
}

// Extract Dependencies
async extractDependencies(relevantFiles) {
    console.log('Extracting dependencies...');
    
    const dependencies = {
        found: {
            copybooks: [],
            programs: [],
            files: []
        },
        missing: {
            copybooks: [],
            programs: [],
            files: []
        },
        summary: {
            foundCount: 0,
            missingCount: 0
        }
    };
    
    // Extract all dependencies from files
    relevantFiles.forEach(file => {
        const lines = file.content.split('\n');
        
        lines.forEach(line => {
            const trimmed = line.trim().toUpperCase();
            
            // COPY statements
            const copyMatch = trimmed.match(/COPY\s+([A-Z][A-Z0-9\-_]+)/);
            if (copyMatch) {
                const copyName = copyMatch[1];
                const isFound = this.uploadedFiles.some(f => 
                    f.name.toUpperCase().includes(copyName) ||
                    (f.components && f.components.some(c => c.name === copyName))
                );
                
                if (isFound) {
                    if (!dependencies.found.copybooks.includes(copyName)) {
                        dependencies.found.copybooks.push(copyName);
                    }
                } else {
                    if (!dependencies.missing.copybooks.includes(copyName)) {
                        dependencies.missing.copybooks.push(copyName);
                    }
                }
            }
            
            // CALL statements
            const callMatch = trimmed.match(/CALL\s+['"]*([A-Z][A-Z0-9\-_]+)['"]*/);
            if (callMatch) {
                const programName = callMatch[1];
                const isFound = this.uploadedFiles.some(f => 
                    (f.components && f.components.some(c => c.type === 'PROGRAM' && c.name === programName))
                );
                
                if (isFound) {
                    if (!dependencies.found.programs.includes(programName)) {
                        dependencies.found.programs.push(programName);
                    }
                } else {
                    if (!dependencies.missing.programs.includes(programName)) {
                        dependencies.missing.programs.push(programName);
                    }
                }
            }
        });
    });
    
    // Calculate summary
    Object.keys(dependencies.found).forEach(key => {
        dependencies.summary.foundCount += dependencies.found[key].length;
    });
    
    Object.keys(dependencies.missing).forEach(key => {
        dependencies.summary.missingCount += dependencies.missing[key].length;
    });
    
    console.log('Dependency analysis complete:', dependencies.summary);
    return dependencies;
}

// Extract Lifecycle Flow
async extractLifecycleFlow(componentName, relevantFiles, fieldAnalysis) {
    console.log('Extracting lifecycle flow for:', componentName);
    
    const lifecycleFlow = {
        componentName: componentName,
        usagePattern: 'UNKNOWN',
        creationSources: [],
        inputPrograms: [],
        updatePrograms: [],
        readPrograms: [],
        cicsScreens: [],
        batchJobs: []
    };
    
    // Analyze each relevant file
    relevantFiles.forEach(file => {
        if (file.type === 'COBOL Program') {
            const programAnalysis = this.analyzeProgramOperations(file);
            
            if (programAnalysis.hasCreateOperations) {
                lifecycleFlow.creationSources.push({
                    program: file.name,
                    operations: programAnalysis.createOperations
                });
            }
            
            if (programAnalysis.hasReadOperations) {
                lifecycleFlow.readPrograms.push({
                    program: file.name,
                    operations: programAnalysis.readOperations
                });
            }
            
            if (programAnalysis.hasUpdateOperations) {
                lifecycleFlow.updatePrograms.push({
                    program: file.name,
                    operations: programAnalysis.updateOperations
                });
            }
            
            if (programAnalysis.hasCicsOperations) {
                lifecycleFlow.cicsScreens.push({
                    program: file.name,
                    operations: programAnalysis.cicsOperations
                });
            }
            
            if (programAnalysis.hasBatchOperations) {
                lifecycleFlow.batchJobs.push({
                    program: file.name,
                    operations: programAnalysis.batchOperations
                });
            }
        }
    });
    
    // Determine usage pattern
    if (lifecycleFlow.cicsScreens.length > 0) {
        lifecycleFlow.usagePattern = 'ONLINE_TRANSACTIONAL';
    } else if (lifecycleFlow.batchJobs.length > 0) {
        lifecycleFlow.usagePattern = 'BATCH_PROCESSING';
    } else if (lifecycleFlow.updatePrograms.length > 0) {
        lifecycleFlow.usagePattern = 'UPDATE_PROCESSING';
    } else if (lifecycleFlow.readPrograms.length > 0) {
        lifecycleFlow.usagePattern = 'READ_ONLY';
    }
    
    // Add field analysis to lifecycle if available
    if (fieldAnalysis) {
        lifecycleFlow.fieldAnalysis = fieldAnalysis;
    }
    
    return lifecycleFlow;
}

// Analyze Program Operations
analyzeProgramOperations(programFile) {
    const analysis = {
        hasCreateOperations: false,
        hasReadOperations: false,
        hasUpdateOperations: false,
        hasCicsOperations: false,
        hasBatchOperations: false,
        createOperations: [],
        readOperations: [],
        updateOperations: [],
        cicsOperations: [],
        batchOperations: []
    };


    const lines = programFile.content.split('\n');
    
    lines.forEach((line, lineNum) => {
        const trimmed = line.trim().toUpperCase();
        
        // CREATE operations
        if (trimmed.includes('OPEN OUTPUT') || trimmed.includes('WRITE ')) {
            analysis.hasCreateOperations = true;
            analysis.createOperations.push({
                type: 'create',
                line: lineNum + 1,
                context: trimmed.substring(0, 80)
            });
        }
        
        // READ operations
        if (trimmed.includes('OPEN INPUT') || trimmed.includes('READ ')) {
            analysis.hasReadOperations = true;
            analysis.readOperations.push({
                type: 'read',
                line: lineNum + 1,
                context: trimmed.substring(0, 80)
            });
        }
        
        // UPDATE operations
        if (trimmed.includes('OPEN I-O') || trimmed.includes('REWRITE')) {
            analysis.hasUpdateOperations = true;
            analysis.updateOperations.push({
                type: 'update',
                line: lineNum + 1,
                context: trimmed.substring(0, 80)
            });
        }
        
        // CICS operations
        if (trimmed.includes('EXEC CICS')) {
            analysis.hasCicsOperations = true;
            analysis.cicsOperations.push({
                type: 'cics',
                line: lineNum + 1,
                context: trimmed.substring(0, 80)
            });
        }
        
        // BATCH operations
        if (trimmed.includes('SORT ') || trimmed.includes('MERGE ')) {
            analysis.hasBatchOperations = true;
            analysis.batchOperations.push({
                type: 'batch',
                line: lineNum + 1,
                context: trimmed.substring(0, 80)
            });
        }
    });

    return analysis;
}

// Extract Business Rules and Logic
extractBusinessLogic(programFile, fieldNames) {
    const businessLogic = {
        validationRules: [],
        calculations: [],
        transformations: [],
        conditions: [],
        businessRules: []
    };

    const lines = programFile.content.split('\n');
    const fieldSet = new Set(fieldNames.map(f => f.toUpperCase()));
    
    lines.forEach((line, lineNum) => {
        const trimmed = line.trim().toUpperCase();
        
        // Extract validation rules
        const validationMatch = trimmed.match(/IF\s+(.*?)\s+THEN/);
        if (validationMatch) {
            const condition = validationMatch[1];
            fieldNames.forEach(fieldName => {
                if (condition.includes(fieldName.toUpperCase())) {
                    businessLogic.validationRules.push({
                        field: fieldName,
                        condition: condition,
                        line: lineNum + 1,
                        type: 'validation',
                        description: this.interpretValidationRule(condition, fieldName)
                    });
                }
            });
        }

        // Extract calculations
        if (trimmed.includes('COMPUTE') || trimmed.includes('ADD') || 
            trimmed.includes('SUBTRACT') || trimmed.includes('MULTIPLY') || 
            trimmed.includes('DIVIDE')) {
            
            fieldNames.forEach(fieldName => {
                if (trimmed.includes(fieldName.toUpperCase())) {
                    businessLogic.calculations.push({
                        field: fieldName,
                        operation: trimmed.match(/(COMPUTE|ADD|SUBTRACT|MULTIPLY|DIVIDE)/)?.[1] || 'CALC',
                        line: lineNum + 1,
                        formula: trimmed.substring(0, 120),
                        description: this.interpretCalculation(trimmed, fieldName)
                    });
                }
            });
        }

        // Extract business rules from comments
        if (trimmed.startsWith('*') && trimmed.length > 10) {
            const comment = trimmed.substring(1).trim();
            if (comment.toLowerCase().includes('business rule') || 
                comment.toLowerCase().includes('validation') ||
                comment.toLowerCase().includes('rule:')) {
                businessLogic.businessRules.push({
                    line: lineNum + 1,
                    rule: comment,
                    type: 'comment_rule'
                });
            }
        }
    });

    return businessLogic;
}

// Interpret validation rules
interpretValidationRule(condition, fieldName) {
    if (condition.includes('SPACE') || condition.includes('SPACES')) {
        return `${fieldName} must not be empty/spaces`;
    } else if (condition.includes('ZERO') || condition.includes('0')) {
        return `${fieldName} must not be zero`;
    } else if (condition.includes('>')) {
        return `${fieldName} must be greater than specified value`;
    } else if (condition.includes('<')) {
        return `${fieldName} must be less than specified value`;
    } else if (condition.includes('=')) {
        return `${fieldName} must equal specific value`;
    } else {
        return `${fieldName} has validation condition: ${condition}`;
    }
}

// Interpret calculations
interpretCalculation(formula, fieldName) {
    if (formula.includes('COMPUTE')) {
        return `${fieldName} is calculated using formula`;
    } else if (formula.includes('ADD')) {
        return `${fieldName} is incremented/added to`;
    } else if (formula.includes('SUBTRACT')) {
        return `${fieldName} is decremented/subtracted from`;
    } else {
        return `${fieldName} is used in mathematical operation`;
    }
}

// Calculate Quality Score
calculateQualityScore(analysisResult, fieldAnalysis) {
    if (!analysisResult) return 3;
    
    if (analysisResult.error) return 2;
    
    if (analysisResult.qualityScore) {
        return analysisResult.qualityScore;
    }
    
    let score = 5;
    
    // Bonus points for structured data
    if (fieldAnalysis && fieldAnalysis.fields && fieldAnalysis.fields.length > 0) score += 2;
    if (analysisResult.recommendations && analysisResult.recommendations.length > 0) score += 1;
    if (analysisResult.dependencyStatus) score += 1;
    if (fieldAnalysis && fieldAnalysis.fieldUsageDetails) score += 1;
    
    return Math.min(Math.max(score, 1), 10);
}

// Assess Completeness
assessCompleteness(analysisResult, fieldAnalysis) {
    const checkpoints = {
        'Component Analysis': !!analysisResult && !analysisResult.error,
        'Field Analysis': !!(fieldAnalysis && fieldAnalysis.fields && fieldAnalysis.fields.length > 0),
        'Dependencies': !!(analysisResult.dependencyStatus || analysisResult.dependencies),
        'Lifecycle Analysis': !!(analysisResult.lifecycleRole || analysisResult.lifecycleAnalysis),
        'Recommendations': !!(analysisResult.recommendations && analysisResult.recommendations.length > 0),
        'Field Usage': !!(fieldAnalysis && fieldAnalysis.fieldUsageDetails)
    };
    
    const completed = Object.values(checkpoints).filter(Boolean).length;
    const total = Object.keys(checkpoints).length;
    
    return {
        score: Math.round((completed / total) * 100),
        checkpoints: checkpoints,
        completed: completed,
        total: total
    };
}
// ============================================
// PART 10: LLM ANALYSIS PROMPTS
// Specific prompts for copybook and program analysis
// ============================================

// Add these methods to the EnhancedMainframeAnalyzer class

// Analyze Copybook with LLM
async analyzeCopybookWithLLM(copybookName, relevantFiles, dependencies, lifecycleFlow, fieldAnalysis) {
    console.log(`LLM analyzing copybook: ${copybookName}`);
    
    const friendlyName = this.currentFriendlyName || copybookName;
    
    // Prepare context
    const copybookFile = relevantFiles.find(f => 
        f.type === 'Copybook' || 
        f.name.toUpperCase().includes(copybookName.toUpperCase())
    );
    
    if (!copybookFile) {
        throw new Error(`Copybook file for ${copybookName} not found`);
    }
    
    // Prepare field summary
    const fieldSummary = fieldAnalysis ? `
FIELD ANALYSIS SUMMARY:
- Total Fields: ${fieldAnalysis.fields.length}
- Input Fields: ${fieldAnalysis.inputFields.length} (${fieldAnalysis.inputFields.slice(0, 5).join(', ')})
- Output Fields: ${fieldAnalysis.outputFields.length} (${fieldAnalysis.outputFields.slice(0, 5).join(', ')})
- Reference Fields: ${fieldAnalysis.referenceFields.length} (${fieldAnalysis.referenceFields.slice(0, 5).join(', ')})
- Unused Fields: ${fieldAnalysis.unusedFields.length} (${fieldAnalysis.unusedFields.slice(0, 5).join(', ')})
- Programs Using: ${fieldAnalysis.programs.length}
` : 'No field analysis available';

    // Prepare copybook content (truncated)
    const copybookContent = this.prepareContentForLLM(copybookFile.content, 'copybook');
    
    const llmPrompt = `ANALYZE MAINFRAME COPYBOOK WITH FIELD FOCUS

COMPONENT NAME: ${copybookName}
FRIENDLY NAME: ${friendlyName}
COMPONENT TYPE: Copybook

${fieldSummary}

COPYBOOK CONTENT (TRUNCATED):
${copybookContent}

DEPENDENCIES:
- Found Copybooks: ${dependencies.found.copybooks.join(', ') || 'None'}
- Missing Copybooks: ${dependencies.missing.copybooks.join(', ') || 'None'}
- Found Programs: ${dependencies.found.programs.join(', ') || 'None'}
- Missing Programs: ${dependencies.missing.programs.join(', ') || 'None'}

TASK: Analyze this copybook focusing on field-level details and usage patterns.

RETURN JSON FORMAT:
{
  "componentName": "${copybookName}",
  "friendlyName": "${friendlyName}",
  "componentType": "Copybook",
  "analysisScope": "FIELD_LEVEL_ANALYSIS",
  "totalFields": ${fieldAnalysis?.fields?.length || 0},
  "fieldSummary": {
    "primaryFields": ["list up to 10 most important fields with their purpose"],
    "inputFields": ${fieldAnalysis?.inputFields?.length || 0},
    "outputFields": ${fieldAnalysis?.outputFields?.length || 0},
    "unusedFields": ${fieldAnalysis?.unusedFields?.length || 0}
  },
  "businessPurpose": "describe the business purpose of this copybook",
  "businessLogic": {
    "validationRules": ["list key validation rules found"],
    "businessRules": ["list business rules and constraints"],
    "dataValidations": ["list data validation patterns"],
    "fieldRelationships": ["describe how fields relate to each other"]
  },
  "dataStructure": "describe the data structure and hierarchy",
  "fieldDetails": [
    {
      "fieldName": "field name",
      "businessMeaning": "what this field represents in business terms",
      "validationRules": ["rules that apply to this field"],
      "usagePattern": "how this field is typically used"
    }
  ],
  "usagePattern": "${lifecycleFlow?.usagePattern || 'UNKNOWN'}",
  "recommendations": [
    "provide 3-5 specific recommendations for optimization",
    "focus on field usage and structure improvements",
    "suggest business rule improvements"
  ],
  "qualityScore": 8
}

Provide ONLY the JSON response, no additional text.`;

    return await this.callLLMAPI(llmPrompt);
}

// Analyze Program with LLM
async analyzeProgramWithLLM(programName, relevantFiles, dependencies, lifecycleFlow) {
    console.log(`LLM analyzing program: ${programName}`);
    
    const friendlyName = this.currentFriendlyName || programName;
    
    const programFile = relevantFiles.find(f => 
        f.type === 'COBOL Program' && 
        (f.name.toUpperCase().includes(programName.toUpperCase()) || 
         f.content.toUpperCase().includes(`PROGRAM-ID. ${programName.toUpperCase()}`))
    );

    if (!programFile) {
        throw new Error(`Program file for ${programName} not found`);
    }

    const programContent = this.prepareContentForLLM(programFile.content, 'program');
    
    const llmPrompt = `ANALYZE MAINFRAME COBOL PROGRAM

COMPONENT NAME: ${programName}
FRIENDLY NAME: ${friendlyName}
COMPONENT TYPE: COBOL Program

PROGRAM CONTENT (TRUNCATED):
${programContent}

DEPENDENCIES:
- Found Copybooks: ${dependencies.found.copybooks.join(', ') || 'None'}
- Missing Copybooks: ${dependencies.missing.copybooks.join(', ') || 'None'}
- Found Programs: ${dependencies.found.programs.join(', ') || 'None'}
- Missing Programs: ${dependencies.missing.programs.join(', ') || 'None'}

LIFECYCLE CONTEXT:
- Usage Pattern: ${lifecycleFlow.usagePattern}
- Has CICS Operations: ${lifecycleFlow.cicsScreens.length > 0}
- Has Batch Operations: ${lifecycleFlow.batchJobs.length > 0}

TASK: Analyze this COBOL program focusing on its structure, business logic, and field operations.

RETURN JSON FORMAT:
{
  "componentName": "${programName}",
  "friendlyName": "${friendlyName}",
  "componentType": "COBOL Program",
  "programStructure": {
    "divisions": ["list the divisions found"],
    "mainParagraphs": ["list main processing paragraphs"],
    "complexity": "LOW/MEDIUM/HIGH"
  },
  "businessLogic": {
    "primaryFunction": "describe the main purpose",
    "keyOperations": ["list key operations performed"],
    "dataFlow": "describe how data flows through the program"
  },
  "fieldOperations": {
    "fieldsRead": ["list main fields read"],
    "fieldsWritten": ["list main fields written"],
    "fieldsValidated": ["list fields with validation"]
  },
  "dependencies": {
    "copybooks": ["list copybooks used"],
    "calledPrograms": ["list programs called"],
    "files": ["list files accessed"]
  },
  "recommendations": [
    "provide 3-5 specific recommendations",
    "focus on modernization and optimization"
  ],
  "qualityScore": 7
}

Provide ONLY the JSON response, no additional text.`;

    return await this.callLLMAPI(llmPrompt);
}

// Analyze Generic Component with LLM
async analyzeGenericComponentWithLLM(componentName, relevantFiles, dependencies) {
    console.log(`LLM analyzing generic component: ${componentName}`);
    
    const friendlyName = this.currentFriendlyName || componentName;
    const componentFile = relevantFiles[0];
    const componentContent = this.prepareContentForLLM(componentFile.content, 'generic');

    const llmPrompt = `ANALYZE MAINFRAME COMPONENT

COMPONENT NAME: ${componentName}
FRIENDLY NAME: ${friendlyName}
FILE TYPE: ${componentFile.type}

COMPONENT CONTENT (TRUNCATED):
${componentContent}

DEPENDENCIES FOUND:
${Object.entries(dependencies.found).map(([key, values]) => 
    `${key}: ${values.join(', ') || 'None'}`
).join('\n')}

TASK: Analyze this component and identify its purpose, structure, and recommendations.

RETURN JSON FORMAT:
{
  "componentName": "${componentName}",
  "friendlyName": "${friendlyName}",
  "componentType": "${componentFile.type}",
  "purpose": "describe the component purpose",
  "keyElements": ["list important elements found"],
  "patterns": ["identify any patterns or structures"],
  "recommendations": ["provide 3-5 recommendations"],
  "qualityScore": 6
}

Provide ONLY the JSON response, no additional text.`;

    return await this.callLLMAPI(llmPrompt);
}

// Prepare Content for LLM (truncate to fit token limits)
prepareContentForLLM(content, type) {
    const maxChars = this.maxTokens * this.averageCharsPerToken * 0.5; // Conservative limit
    
    if (content.length <= maxChars) {
        return content;
    }
    
    if (type === 'copybook') {
        // Focus on field definitions for copybooks
        const lines = content.split('\n');
        const importantLines = lines.filter(line => {
            const trimmed = line.trim().toUpperCase();
            return trimmed.match(/^\s*\d{2}\s+/) ||           // Field levels
                   trimmed.includes('PIC ') ||               // Picture clauses
                   trimmed.includes('VALUE ') ||             // Value clauses
                   trimmed.includes('REDEFINES ') ||         // Redefines
                   trimmed.includes('OCCURS ');             // Arrays
        });
        
        let result = importantLines.join('\n');
        if (result.length > maxChars) {
            result = result.substring(0, maxChars);
        }
        return result;
        
    } else if (type === 'program') {
        // Focus on procedure division for programs
        const procedureIndex = content.toUpperCase().indexOf('PROCEDURE DIVISION');
        if (procedureIndex > -1) {
            const procedureContent = content.substring(procedureIndex);
            if (procedureContent.length <= maxChars) {
                return procedureContent;
            }
            return procedureContent.substring(0, maxChars);
        }
    }
    
    // Generic truncation
    return content.substring(0, maxChars);
}
// ============================================
// PART 11: DISPLAY AND UI UPDATE METHODS
// Complete UI rendering and result display
// ============================================

// Add these methods to the EnhancedMainframeAnalyzer class

// Display Analysis Results
displayAnalysisResults(componentName, results) {
    console.log('Displaying analysis results for:', componentName);
    
    const displayName = results.friendlyName || componentName;
    
    // Update summary sections for all tabs
    this.updateSummarySection(displayName, results);
    
    // Display main analysis
    this.displayMainAnalysis(displayName, results);
    
    // Display field matrix
    this.displayFieldMatrix(displayName, results);
    
    // Display usage patterns
    this.displayUsagePatterns(displayName, results);
    
    // Display dependencies
    this.displayDependencies(displayName, results);
    
    // Display file lifecycle
    this.displayFileLifecycle(displayName, results);
    
    // Switch to main results tab
    document.querySelector('.tab[data-tab="lifecycle"]').click();
}

// Update Summary Section
updateSummarySection(displayName, results) {
    // Main summary
    const summaryComponent = document.getElementById('summaryComponent');
    const summaryQuality = document.getElementById('summaryQuality');
    const summaryFiles = document.getElementById('summaryFiles');
    const summaryDeps = document.getElementById('summaryDeps');
    
    if (summaryComponent) summaryComponent.textContent = displayName;
    if (summaryQuality) summaryQuality.textContent = `${results.qualityScore}/10`;
    if (summaryFiles) summaryFiles.textContent = results.filesAnalyzed.length;
    if (summaryDeps) {
        const totalDeps = (results.dependencyAnalysis?.summary?.foundCount || 0) + 
                         (results.dependencyAnalysis?.summary?.missingCount || 0);
        summaryDeps.textContent = totalDeps;
    }
    
    // Field matrix summary
    if (results.fieldAnalysis) {
        const totalFields = document.getElementById('totalFields');
        const inputFields = document.getElementById('inputFields');
        const outputFields = document.getElementById('outputFields');
        const unusedFields = document.getElementById('unusedFields');
        
        if (totalFields) totalFields.textContent = results.fieldAnalysis.fields.length;
        if (inputFields) inputFields.textContent = results.fieldAnalysis.inputFields.length;
        if (outputFields) outputFields.textContent = results.fieldAnalysis.outputFields.length;
        if (unusedFields) unusedFields.textContent = results.fieldAnalysis.unusedFields.length;
    }
    
    // Usage patterns summary
    const patternType = document.getElementById('patternType');
    const creationCount = document.getElementById('creationCount');
    const readingCount = document.getElementById('readingCount');
    const updateCount = document.getElementById('updateCount');
    
    if (patternType) patternType.textContent = results.lifecycleFlow?.usagePattern || 'N/A';
    if (creationCount) creationCount.textContent = results.lifecycleFlow?.creationSources?.length || 0;
    if (readingCount) readingCount.textContent = results.lifecycleFlow?.readPrograms?.length || 0;
    if (updateCount) updateCount.textContent = results.lifecycleFlow?.updatePrograms?.length || 0;
    
    // Dependencies summary
    const foundDeps = document.getElementById('foundDeps');
    const missingDeps = document.getElementById('missingDeps');
    const copybookDeps = document.getElementById('copybookDeps');
    const programDeps = document.getElementById('programDeps');
    
    if (foundDeps) foundDeps.textContent = results.dependencyAnalysis?.summary?.foundCount || 0;
    if (missingDeps) missingDeps.textContent = results.dependencyAnalysis?.summary?.missingCount || 0;
    if (copybookDeps) copybookDeps.textContent = results.dependencyAnalysis?.found?.copybooks?.length || 0;
    if (programDeps) programDeps.textContent = results.dependencyAnalysis?.found?.programs?.length || 0;
    
    // File lifecycle summary
    const lifecycleStage = document.getElementById('lifecycleStage');
    const totalPrograms = document.getElementById('totalPrograms');
    const cicsCount = document.getElementById('cicsCount');
    const batchCount = document.getElementById('batchCount');
    
    if (lifecycleStage) lifecycleStage.textContent = results.lifecycleFlow?.usagePattern || 'N/A';
    if (totalPrograms) {
        const total = (results.fieldAnalysis?.programs?.length || 0);
        totalPrograms.textContent = total;
    }
    if (cicsCount) cicsCount.textContent = results.lifecycleFlow?.cicsScreens?.length || 0;
    if (batchCount) batchCount.textContent = results.lifecycleFlow?.batchJobs?.length || 0;
}

// Display Main Analysis
displayMainAnalysis(displayName, results) {
    const container = document.getElementById('lifecycleDetails');
    if (!container) return;
    
    let html = `
        <div class="metrics-grid">
            <div class="metric-card">
                <div class="metric-icon">📊</div>
                <div class="metric-details">
                    <div class="metric-label">Component</div>
                    <div class="metric-value">${displayName}</div>
                </div>
            </div>
            <div class="metric-card">
                <div class="metric-icon">🎯</div>
                <div class="metric-details">
                    <div class="metric-label">Type</div>
                    <div class="metric-value">${results.componentType}</div>
                </div>
            </div>
            <div class="metric-card">
                <div class="metric-icon">📈</div>
                <div class="metric-details">
                    <div class="metric-label">Quality</div>
                    <div class="metric-value">${results.qualityScore}/10</div>
                </div>
            </div>
            <div class="metric-card">
                <div class="metric-icon">✅</div>
                <div class="metric-details">
                    <div class="metric-label">Completeness</div>
                    <div class="metric-value">${results.completeness?.score || 0}%</div>
                </div>
            </div>
        </div>
    `;
    
    // Add dependency analysis
    if (results.dependencyAnalysis) {
        html += this.renderDependencyAnalysis(results.dependencyAnalysis);
    }
    
    container.innerHTML = html;
    
    // Display LLM results
    const llmContainer = document.getElementById('llmResults');
    if (llmContainer && results.llmAnalysis) {
        llmContainer.innerHTML = this.renderLLMAnalysis(results.llmAnalysis, displayName);
    }
    
    // Display recommendations
    const recContainer = document.getElementById('recommendations');
    if (recContainer) {
        recContainer.innerHTML = this.renderRecommendations(results.llmAnalysis);
    }
}

// Display Field Matrix
displayFieldMatrix(displayName, results) {
    const container = document.getElementById('fieldMatrixContent');
    if (!container) return;
    
    if (!results.fieldAnalysis || !results.fieldAnalysis.fields || results.fieldAnalysis.fields.length === 0) {
        container.innerHTML = '<p>No field analysis available for this component.</p>';
        return;
    }
    
    const fields = results.fieldAnalysis.fields;
    
    let html = `
        <h4>Field Analysis for ${displayName}</h4>
        <table class="data-table">
           // Replace the existing table headers and rows with:
<thead>
    <tr>
        <th>Field Name</th>
        <th>Level</th>
        <th>Picture</th>
        <th>Usage</th>
        <th>Business Purpose</th>
        <th>Validation Rules</th>
    </tr>
</thead>
<tbody>
`;

fields.slice(0, 50).forEach(field => {
    const usage = this.determineFieldUsage(field, results.fieldAnalysis);
    const badgeClass = this.getUsageBadgeClass(usage);
    const validationCount = field.businessLogic?.validationRules?.length || 0;
    const hasCalculations = field.businessLogic?.calculations?.length > 0;
    
    html += `
        <tr>
            <td style="font-family: monospace; font-weight: 600;">${field.name}</td>
            <td>${field.level}</td>
            <td style="font-family: monospace;">${field.picture || '-'}</td>
            <td><span class="badge ${badgeClass}">${usage}</span></td>
            <td style="font-size: 0.85rem;">${field.businessLogic?.businessMeaning || this.generateFieldPurpose(field.name)}</td>
            <td>
                ${validationCount > 0 ? `<span class="badge badge-success">${validationCount} rules</span>` : ''}
                ${hasCalculations ? `<span class="badge badge-primary">Calculated</span>` : ''}
            </td>
        </tr>
    `;
});
    
    html += `
            </tbody>
        </table>
    `;
    
    if (fields.length > 50) {
        html += `<p style="margin-top: 1rem; color: var(--grey-500);">Showing 50 of ${fields.length} fields</p>`;
    }
    
    container.innerHTML = html;
    
    // Display field statistics
    const statsContainer = document.getElementById('fieldStatistics');
    if (statsContainer) {
        statsContainer.innerHTML = this.renderFieldStatistics(results.fieldAnalysis);
    }
}

// Determine Business Meaning
determineBusinessMeaning(fieldName, businessLogic) {
    const name = fieldName.toUpperCase();
    
    // Check validation rules for clues
    if (businessLogic.validationRules.length > 0) {
        const rule = businessLogic.validationRules[0];
        if (rule.description.includes('not be empty')) {
            return `Required ${this.generateFieldPurpose(fieldName).toLowerCase()}`;
        }
    }
    
    // Enhanced business meaning based on field patterns
    if (name.includes('CUSTOMER') || name.includes('CUST')) {
        return 'Customer information management field';
    } else if (name.includes('ACCOUNT') || name.includes('ACCT')) {
        return 'Account management and tracking field';
    } else if (name.includes('TRANSACTION') || name.includes('TRANS')) {
        return 'Transaction processing and audit field';
    } else if (name.includes('BALANCE') || name.includes('BAL')) {
        return 'Financial balance calculation field';
    } else if (name.includes('STATUS') || name.includes('STAT')) {
        return 'Status tracking and workflow field';
    } else if (name.includes('DATE') || name.includes('TIME')) {
        return 'Temporal tracking and audit field';
    } else if (name.includes('CODE') || name.includes('CD')) {
        return 'Reference code for business classification';
    } else {
        return this.generateFieldPurpose(fieldName);
    }
}
// Display Usage Patterns
displayUsagePatterns(displayName, results) {
    const container = document.getElementById('usageContent');
    if (!container) return;
    
    if (!results.lifecycleFlow) {
        container.innerHTML = '<p>No usage pattern analysis available.</p>';
        return;
    }
    
    const flow = results.lifecycleFlow;
    
    let html = `
        <h4>Usage Pattern Analysis for ${displayName}</h4>
        <div style="background: var(--primary-blue); color: white; padding: 1rem; border-radius: 8px; text-align: center; margin-bottom: 1.5rem;">
            <div style="font-size: 1.5rem; font-weight: bold;">${flow.usagePattern || 'UNKNOWN'}</div>
            <div style="font-size: 0.9rem; opacity: 0.9;">Primary Usage Pattern</div>
        </div>
        
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem;">
    `;
    
    // Creation sources
    if (flow.creationSources && flow.creationSources.length > 0) {
        html += `
            <div style="background: var(--grey-50); padding: 1rem; border-radius: 8px; border-left: 4px solid var(--success-green);">
                <h5 style="color: var(--success-green); margin-bottom: 0.75rem;">🌱 Creation Sources (${flow.creationSources.length})</h5>
                ${flow.creationSources.slice(0, 5).map(source => `
                    <div style="margin-bottom: 0.5rem; padding: 0.5rem; background: white; border-radius: 4px;">
                        <div style="font-weight: 600;">${source.program}</div>
                        ${source.operations ? `<div style="font-size: 0.8rem; color: var(--grey-600);">${source.operations.length} operations</div>` : ''}
                    </div>
                `).join('')}
            </div>
        `;
    }
    
    // Read programs
    if (flow.readPrograms && flow.readPrograms.length > 0) {
        html += `
            <div style="background: var(--grey-50); padding: 1rem; border-radius: 8px; border-left: 4px solid var(--info-blue);">
                <h5 style="color: var(--info-blue); margin-bottom: 0.75rem;">📖 Read Programs (${flow.readPrograms.length})</h5>
                ${flow.readPrograms.slice(0, 5).map(prog => `
                    <div style="margin-bottom: 0.5rem; padding: 0.5rem; background: white; border-radius: 4px;">
                        <div style="font-weight: 600;">${prog.program}</div>
                        ${prog.operations ? `<div style="font-size: 0.8rem; color: var(--grey-600);">${prog.operations.length} operations</div>` : ''}
                    </div>
                `).join('')}
            </div>
        `;
    }
    
    // Update programs
    if (flow.updatePrograms && flow.updatePrograms.length > 0) {
        html += `
            <div style="background: var(--grey-50); padding: 1rem; border-radius: 8px; border-left: 4px solid var(--warning-yellow);">
                <h5 style="color: var(--warning-yellow); margin-bottom: 0.75rem;">⚙️ Update Programs (${flow.updatePrograms.length})</h5>
                ${flow.updatePrograms.slice(0, 5).map(prog => `
                    <div style="margin-bottom: 0.5rem; padding: 0.5rem; background: white; border-radius: 4px;">
                        <div style="font-weight: 600;">${prog.program}</div>
                        ${prog.operations ? `<div style="font-size: 0.8rem; color: var(--grey-600);">${prog.operations.length} operations</div>` : ''}
                    </div>
                `).join('')}
            </div>
        `;
    }
    
    html += '</div>';
    container.innerHTML = html;
}

// Display Dependencies
displayDependencies(displayName, results) {
    const foundContainer = document.getElementById('foundDependencies');
    const missingContainer = document.getElementById('missingDependencies');
    
    if (!results.dependencyAnalysis) {
        if (foundContainer) foundContainer.innerHTML = '<p>No dependency analysis available.</p>';
        if (missingContainer) missingContainer.innerHTML = '<p>No dependency analysis available.</p>';
        return;
    }
    
    const deps = results.dependencyAnalysis;
    
    // Found dependencies
    if (foundContainer) {
        let foundHtml = `<h4>Found Dependencies for ${displayName}</h4>`;
        
        if (deps.found.copybooks && deps.found.copybooks.length > 0) {
            foundHtml += `
                <div style="margin-bottom: 1rem;">
                    <h5 style="color: var(--success-green);">📚 Copybooks (${deps.found.copybooks.length})</h5>
                    <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
                        ${deps.found.copybooks.map(cb => `
                            <span class="badge badge-success">${cb}</span>
                        `).join('')}
                    </div>
                </div>
            `;
        }
        
        if (deps.found.programs && deps.found.programs.length > 0) {
            foundHtml += `
                <div style="margin-bottom: 1rem;">
                    <h5 style="color: var(--success-green);">💼 Programs (${deps.found.programs.length})</h5>
                    <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
                        ${deps.found.programs.map(prog => `
                            <span class="badge badge-success">${prog}</span>
                        `).join('')}
                    </div>
                </div>
            `;
        }
        
        foundContainer.innerHTML = foundHtml;
    }
    
    // Missing dependencies
    if (missingContainer) {
        let missingHtml = `<h4>Missing Dependencies for ${displayName}</h4>`;
        
        if (deps.missing.copybooks && deps.missing.copybooks.length > 0) {
            missingHtml += `
                <div style="margin-bottom: 1rem;">
                    <h5 style="color: var(--error-red);">📚 Copybooks (${deps.missing.copybooks.length})</h5>
                    <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
                        ${deps.missing.copybooks.map(cb => `
                            <span class="badge badge-danger">${cb}</span>
                        `).join('')}
                    </div>
                </div>
            `;
        }
        
        if (deps.missing.programs && deps.missing.programs.length > 0) {
            missingHtml += `
                <div style="margin-bottom: 1rem;">
                    <h5 style="color: var(--error-red);">💼 Programs (${deps.missing.programs.length})</h5>
                    <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
                        ${deps.missing.programs.map(prog => `
                            <span class="badge badge-danger">${prog}</span>
                        `).join('')}
                    </div>
                </div>
            `;
        }
        
        missingContainer.innerHTML = missingHtml;
    }
}

// Display File Lifecycle
displayFileLifecycle(displayName, results) {
    const container = document.getElementById('fileflowContent');
    if (!container) return;
    
    if (!results.lifecycleFlow) {
        container.innerHTML = '<p>No lifecycle flow analysis available.</p>';
        return;
    }
    
    const flow = results.lifecycleFlow;
    
    let html = `
        <h4>File Lifecycle Flow for ${displayName}</h4>
        <div style="background: linear-gradient(135deg, var(--primary-blue) 0%, var(--secondary-blue) 100%); color: white; padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem;">
            <div style="font-size: 1.2rem; font-weight: bold;">Usage Pattern: ${flow.usagePattern || 'UNKNOWN'}</div>
        </div>
    `;
    
    // Add lifecycle stages visualization
    if (flow.creationSources?.length > 0 || flow.readPrograms?.length > 0 || flow.updatePrograms?.length > 0) {
        html += `
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1.5rem;">
                <div style="text-align: center; padding: 1rem; background: var(--grey-50); border-radius: 8px;">
                    <div style="font-size: 2rem;">🌱</div>
                    <div style="font-weight: bold; color: var(--success-green);">Creation</div>
                    <div style="font-size: 1.5rem; color: var(--primary-blue);">${flow.creationSources?.length || 0}</div>
                    <div style="font-size: 0.8rem; color: var(--grey-600);">Programs</div>
                </div>
                <div style="text-align: center; padding: 1rem; background: var(--grey-50); border-radius: 8px;">
                    <div style="font-size: 2rem;">📖</div>
                    <div style="font-weight: bold; color: var(--info-blue);">Reading</div>
                    <div style="font-size: 1.5rem; color: var(--primary-blue);">${flow.readPrograms?.length || 0}</div>
                    <div style="font-size: 0.8rem; color: var(--grey-600);">Programs</div>
                </div>
                <div style="text-align: center; padding: 1rem; background: var(--grey-50); border-radius: 8px;">
                    <div style="font-size: 2rem;">⚙️</div>
                    <div style="font-weight: bold; color: var(--warning-yellow);">Updates</div>
                    <div style="font-size: 1.5rem; color: var(--primary-blue);">${flow.updatePrograms?.length || 0}</div>
                    <div style="font-size: 0.8rem; color: var(--grey-600);">Programs</div>
                </div>
            </div>
        `;
    }
    
    // Add field lifecycle details if available
    if (flow.fieldAnalysis && flow.fieldAnalysis.fields && flow.fieldAnalysis.fields.length > 0) {
        html += `
            <h5>Field Lifecycle Details</h5>
            <div style="background: var(--grey-50); padding: 1rem; border-radius: 8px;">
                <p>Total Fields Analyzed: <strong>${flow.fieldAnalysis.fields.length}</strong></p>
                <p>Fields with Input Operations: <strong>${flow.fieldAnalysis.inputFields.length}</strong></p>
                <p>Fields with Output Operations: <strong>${flow.fieldAnalysis.outputFields.length}</strong></p>
                <p>Reference-Only Fields: <strong>${flow.fieldAnalysis.referenceFields.length}</strong></p>
                <p>Unused Fields: <strong>${flow.fieldAnalysis.unusedFields.length}</strong></p>
            </div>
        `;
    }
    
    container.innerHTML = html;
}

// Render helper methods
renderDependencyAnalysis(deps) {
    return `
        <div style="margin-top: 1.5rem;">
            <h4>Dependency Analysis</h4>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                <div style="background: rgba(16, 185, 129, 0.1); padding: 1rem; border-radius: 8px; border-left: 4px solid var(--success-green);">
                    <h5 style="color: var(--success-green);">✅ Found Dependencies</h5>
                    <p>Total: <strong>${deps.summary?.foundCount || 0}</strong></p>
                    <div style="font-size: 0.85rem;">
                        ${deps.found?.copybooks?.length > 0 ? `<p>Copybooks: ${deps.found.copybooks.length}</p>` : ''}
                        ${deps.found?.programs?.length > 0 ? `<p>Programs: ${deps.found.programs.length}</p>` : ''}
                        ${deps.found?.files?.length > 0 ? `<p>Files: ${deps.found.files.length}</p>` : ''}
                    </div>
                </div>
                <div style="background: rgba(239, 68, 68, 0.1); padding: 1rem; border-radius: 8px; border-left: 4px solid var(--error-red);">
                    <h5 style="color: var(--error-red);">❌ Missing Dependencies</h5>
                    <p>Total: <strong>${deps.summary?.missingCount || 0}</strong></p>
                    <div style="font-size: 0.85rem;">
                        ${deps.missing?.copybooks?.length > 0 ? `<p>Copybooks: ${deps.missing.copybooks.length}</p>` : ''}
                        ${deps.missing?.programs?.length > 0 ? `<p>Programs: ${deps.missing.programs.length}</p>` : ''}
                        ${deps.missing?.files?.length > 0 ? `<p>Files: ${deps.missing.files.length}</p>` : ''}
                    </div>
                </div>
            </div>
        </div>
    `;
}

renderLLMAnalysis(llmAnalysis, displayName) {
    if (!llmAnalysis) {
        return '<p>No LLM analysis results available.</p>';
    }
    
    if (llmAnalysis.error) {
        return `
            <div style="background: rgba(239, 68, 68, 0.1); padding: 1rem; border-radius: 8px; border-left: 4px solid var(--error-red);">
                <h4 style="color: var(--error-red);">⚠️ LLM Analysis Error</h4>
                <p>${llmAnalysis.message || 'LLM analysis encountered an error'}</p>
            </div>
        `;
    }
    
    let html = `<h4>LLM Analysis Results for ${displayName}</h4>`;
    
    // Business purpose
    if (llmAnalysis.businessPurpose || llmAnalysis.purpose) {
        html += `
            <div style="margin-bottom: 1rem;">
                <h5>🎯 Business Purpose</h5>
                <p>${llmAnalysis.businessPurpose || llmAnalysis.purpose}</p>
            </div>
        `;
    }
    
    // Field summary (for copybooks)
    if (llmAnalysis.fieldSummary) {
        html += `
            <div style="margin-bottom: 1rem;">
                <h5>📋 Field Summary</h5>
                <div style="background: var(--grey-50); padding: 1rem; border-radius: 8px;">
                    ${llmAnalysis.fieldSummary.primaryFields ? 
                        `<p><strong>Primary Fields:</strong> ${llmAnalysis.fieldSummary.primaryFields.join(', ')}</p>` : ''}
                    <p><strong>Input Fields:</strong> ${llmAnalysis.fieldSummary.inputFields || 0}</p>
                    <p><strong>Output Fields:</strong> ${llmAnalysis.fieldSummary.outputFields || 0}</p>
                    <p><strong>Unused Fields:</strong> ${llmAnalysis.fieldSummary.unusedFields || 0}</p>
                </div>
            </div>
        `;
    }
    
    // Program structure (for programs)
    if (llmAnalysis.programStructure) {
        html += `
            <div style="margin-bottom: 1rem;">
                <h5>🏗️ Program Structure</h5>
                <div style="background: var(--grey-50); padding: 1rem; border-radius: 8px;">
                    ${llmAnalysis.programStructure.divisions ? 
                        `<p><strong>Divisions:</strong> ${llmAnalysis.programStructure.divisions.join(', ')}</p>` : ''}
                    ${llmAnalysis.programStructure.complexity ? 
                        `<p><strong>Complexity:</strong> <span class="badge badge-primary">${llmAnalysis.programStructure.complexity}</span></p>` : ''}
                </div>
            </div>
        `;
    }
    
    // Field operations (for programs)
    if (llmAnalysis.fieldOperations) {
        html += `
            <div style="margin-bottom: 1rem;">
                <h5>🔄 Field Operations</h5>
                <div style="background: var(--grey-50); padding: 1rem; border-radius: 8px;">
                    ${llmAnalysis.fieldOperations.fieldsRead ? 
                        `<p><strong>Fields Read:</strong> ${llmAnalysis.fieldOperations.fieldsRead.join(', ')}</p>` : ''}
                    ${llmAnalysis.fieldOperations.fieldsWritten ? 
                        `<p><strong>Fields Written:</strong> ${llmAnalysis.fieldOperations.fieldsWritten.join(', ')}</p>` : ''}
                    ${llmAnalysis.fieldOperations.fieldsValidated ? 
                        `<p><strong>Fields Validated:</strong> ${llmAnalysis.fieldOperations.fieldsValidated.join(', ')}</p>` : ''}
                </div>
            </div>
        `;
    }
    
    return html;
}

renderRecommendations(llmAnalysis) {
    if (!llmAnalysis || !llmAnalysis.recommendations || llmAnalysis.recommendations.length === 0) {
        return '<p>No recommendations available.</p>';
    }
    
    let html = '<h4>💡 Recommendations</h4><ol>';
    
    llmAnalysis.recommendations.forEach(rec => {
        html += `
            <li style="margin-bottom: 0.75rem; padding: 0.75rem; background: var(--grey-50); border-radius: 6px;">
                ${rec}
            </li>
        `;
    });
    
    html += '</ol>';
    return html;
}

renderFieldStatistics(fieldAnalysis) {
    if (!fieldAnalysis) {
        return '<p>No field statistics available.</p>';
    }
    
    const total = fieldAnalysis.fields.length;
    const inputPct = total > 0 ? Math.round((fieldAnalysis.inputFields.length / total) * 100) : 0;
    const outputPct = total > 0 ? Math.round((fieldAnalysis.outputFields.length / total) * 100) : 0;
    const refPct = total > 0 ? Math.round((fieldAnalysis.referenceFields.length / total) * 100) : 0;
    const unusedPct = total > 0 ? Math.round((fieldAnalysis.unusedFields.length / total) * 100) : 0;
    
    return `
        <h4>Field Usage Statistics</h4>
        <div style="margin-bottom: 1rem;">
            <div style="margin-bottom: 0.5rem;">
                <div style="display: flex; justify-content: space-between;">
                    <span>Input Fields</span>
                    <span>${fieldAnalysis.inputFields.length} (${inputPct}%)</span>
                </div>
                <div style="height: 8px; background: var(--grey-200); border-radius: 4px; overflow: hidden;">
                    <div style="width: ${inputPct}%; height: 100%; background: var(--success-green);"></div>
                </div>
            </div>
            <div style="margin-bottom: 0.5rem;">
                <div style="display: flex; justify-content: space-between;">
                    <span>Output Fields</span>
                    <span>${fieldAnalysis.outputFields.length} (${outputPct}%)</span>
                </div>
                <div style="height: 8px; background: var(--grey-200); border-radius: 4px; overflow: hidden;">
                    <div style="width: ${outputPct}%; height: 100%; background: var(--info-blue);"></div>
                </div>
            </div>
            <div style="margin-bottom: 0.5rem;">
                <div style="display: flex; justify-content: space-between;">
                    <span>Reference Fields</span>
                    <span>${fieldAnalysis.referenceFields.length} (${refPct}%)</span>
                </div>
                <div style="height: 8px; background: var(--grey-200); border-radius: 4px; overflow: hidden;">
                    <div style="width: ${refPct}%; height: 100%; background: var(--warning-yellow);"></div>
                </div>
            </div>
            <div style="margin-bottom: 0.5rem;">
                <div style="display: flex; justify-content: space-between;">
                    <span>Unused Fields</span>
                    <span>${fieldAnalysis.unusedFields.length} (${unusedPct}%)</span>
                </div>
                <div style="height: 8px; background: var(--grey-200); border-radius: 4px; overflow: hidden;">
                    <div style="width: ${unusedPct}%; height: 100%; background: var(--error-red);"></div>
                </div>
            </div>
        </div>
    `;
}

// Helper methods
determineFieldUsage(field, fieldAnalysis) {
    const fieldName = field.name;
    
    if (fieldAnalysis.inputFields.includes(fieldName)) return 'INPUT';
    if (fieldAnalysis.outputFields.includes(fieldName)) return 'OUTPUT';
    if (fieldAnalysis.referenceFields.includes(fieldName)) return 'REFERENCE';
    if (fieldAnalysis.unusedFields.includes(fieldName)) return 'UNUSED';
    
    return 'UNKNOWN';
}

getUsageBadgeClass(usage) {
    switch(usage) {
        case 'INPUT': return 'badge-success';
        case 'OUTPUT': return 'badge-primary';
        case 'REFERENCE': return 'badge-warning';
        case 'UNUSED': return 'badge-danger';
        default: return 'badge-grey';
    }
}
// ============================================
// PART 12: CHAT AND EXPORT FUNCTIONALITY
// Complete chat interface and export features
// ============================================

// Add these methods to the EnhancedMainframeAnalyzer class

// Initialize Chat
initializeChat() {
    const chatSendBtn = document.getElementById('chatSendBtn');
    const chatInput = document.getElementById('chatInput');
    
    if (chatSendBtn && chatInput) {
        chatSendBtn.addEventListener('click', () => this.sendChatMessage());
        
        chatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                this.sendChatMessage();
            }
        });
        
        // Auto-resize textarea
        chatInput.addEventListener('input', () => {
            chatInput.style.height = 'auto';
            chatInput.style.height = Math.min(chatInput.scrollHeight, 120) + 'px';
        });
    }

    // Chat suggestions
    document.querySelectorAll('.chat-suggestion-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const question = e.target.dataset.question;
            if (chatInput && question) {
                chatInput.value = question;
                this.sendChatMessage();
            }
        });
    });
}

// Enable Chat after analysis
enableChat() {
    const chatInput = document.getElementById('chatInput');
    const chatSendBtn = document.getElementById('chatSendBtn');
    const chatSuggestions = document.getElementById('chatSuggestions');
    
    if (chatInput && chatSendBtn) {
        chatInput.disabled = false;
        chatSendBtn.disabled = false;
        
        if (chatSuggestions) {
            chatSuggestions.style.display = 'block';
        }
        
        const displayName = this.getDisplayName();
        this.addChatMessage('assistant', 
            `🎯 **Analysis complete for ${displayName}!**
            
I can now provide detailed insights about this component:

🧠 **Field Analysis:** ${this.analysisResults[this.currentAnalyzedComponent]?.totalFields || 0} fields analyzed with usage patterns
⚖️ **Business Logic:** Extracted rules and validation patterns  
🔗 **Dependency Analysis:** ${this.analysisResults[this.currentAnalyzedComponent]?.dependencyAnalysis?.summary?.foundCount || 0} found, ${this.analysisResults[this.currentAnalyzedComponent]?.dependencyAnalysis?.summary?.missingCount || 0} missing
🌊 **Lifecycle Flow:** ${this.analysisResults[this.currentAnalyzedComponent]?.lifecycleFlow?.usagePattern || 'Pattern identified'}

**Ask me about:**
• Which fields are most important in this component?
• What programs create vs update this data?  
• What dependencies are missing and why?
• How can we optimize this component?
• What are the business rules for specific fields?`
        );
    }
}

// Send Chat Message
async sendChatMessage() {
    const input = document.getElementById('chatInput');
    const sendBtn = document.getElementById('chatSendBtn');
    const message = input.value.trim();
    
    if (!message) {
        this.showError('Please enter a message');
        return;
    }
    
    if (!this.currentAnalyzedComponent) {
        this.showError('Please analyze a component first');
        return;
    }
    
    // Disable input while processing
    input.disabled = true;
    sendBtn.disabled = true;
    sendBtn.textContent = 'Processing...';
    
    // Add user message
    this.addChatMessage('user', message);
    
    // Clear input and reset height
    input.value = '';
    input.style.height = 'auto';
    
    // Show typing indicator
    this.showChatTyping();
    
    try {
        const response = await this.processChatQuery(message);
        this.hideChatTyping();
        this.addChatMessage('assistant', response);
    } catch (error) {
        console.error('Chat error:', error);
        this.hideChatTyping();
        this.addChatMessage('assistant', 
            `I apologize, but I encountered an error: ${error.message}. Please try rephrasing your question.`
        );
    } finally {
        input.disabled = false;
        sendBtn.disabled = false;
        sendBtn.textContent = 'Send';
        input.focus();
    }
}

// Process Chat Query
async processChatQuery(question) {
    const analysisData = this.analysisResults[this.currentAnalyzedComponent];
    const displayName = this.getDisplayName();
    
    // Build context for LLM
    let context = `MAINFRAME COMPONENT ANALYSIS CHAT

COMPONENT: ${this.currentAnalyzedComponent}
FRIENDLY NAME: ${displayName}
COMPONENT TYPE: ${analysisData.componentType}
ANALYSIS METHOD: ${analysisData.analysisMethod}
FILES ANALYZED: ${analysisData.filesAnalyzed.join(', ')}

FIELD ANALYSIS:
- Total Fields: ${analysisData.totalFields || 0}
- Input Fields: ${analysisData.fieldAnalysis?.inputFields?.length || 0}
- Output Fields: ${analysisData.fieldAnalysis?.outputFields?.length || 0}
- Unused Fields: ${analysisData.fieldAnalysis?.unusedFields?.length || 0}

LIFECYCLE FLOW:
- Usage Pattern: ${analysisData.lifecycleFlow?.usagePattern || 'Unknown'}
- Creation Programs: ${analysisData.lifecycleFlow?.creationSources?.length || 0}
- Read Programs: ${analysisData.lifecycleFlow?.readPrograms?.length || 0}
- Update Programs: ${analysisData.lifecycleFlow?.updatePrograms?.length || 0}

DEPENDENCY SUMMARY:
- Found Dependencies: ${analysisData.dependencyAnalysis?.summary?.foundCount || 0}
- Missing Dependencies: ${analysisData.dependencyAnalysis?.summary?.missingCount || 0}

LLM ANALYSIS RESULTS:
${JSON.stringify(analysisData.llmAnalysis || {}, null, 2)}

USER QUESTION: "${question}"

Provide a detailed, helpful response based on the analysis data above. If the question is about specific fields, reference the field analysis. Use the friendly name "${displayName}" when referring to the component.`;

    // Call LLM for response
    const response = await this.callLLMAPI(context);
    
    if (typeof response === 'string') {
        return response;
    } else if (response.error) {
        return `Based on the available analysis data: The component "${displayName}" has ${analysisData.totalFields || 0} fields analyzed. ${response.fallbackData?.recommendations?.join('. ') || 'Please check the analysis results for more details.'}`;
    } else if (response.answer) {
        return response.answer;
    } else {
        // Extract relevant information from analysis
        return this.generateChatResponse(question, analysisData, displayName);
    }
}

// Generate Chat Response (fallback)
generateChatResponse(question, analysisData, displayName) {
    const lowerQuestion = question.toLowerCase();
    
    // Field-related questions
    if (lowerQuestion.includes('field') || lowerQuestion.includes('important')) {
        if (analysisData.fieldAnalysis && analysisData.fieldAnalysis.fields) {
            const topFields = analysisData.fieldAnalysis.fields.slice(0, 5);
            return `For the component "${displayName}", here are the key fields analyzed:

${topFields.map(f => `• **${f.name}** (Level ${f.level}): ${this.generateFieldPurpose(f.name)}`).join('\n')}

Total fields analyzed: ${analysisData.totalFields}
Input fields: ${analysisData.fieldAnalysis.inputFields.length}
Output fields: ${analysisData.fieldAnalysis.outputFields.length}
Unused fields: ${analysisData.fieldAnalysis.unusedFields.length}`;
        }
    }
    
    // Dependency questions
    if (lowerQuestion.includes('depend') || lowerQuestion.includes('missing')) {
        const deps = analysisData.dependencyAnalysis;
        if (deps) {
            return `Dependency analysis for "${displayName}":

**Found Dependencies (${deps.summary.foundCount}):**
• Copybooks: ${deps.found.copybooks?.join(', ') || 'None'}
• Programs: ${deps.found.programs?.join(', ') || 'None'}

**Missing Dependencies (${deps.summary.missingCount}):**
• Copybooks: ${deps.missing.copybooks?.join(', ') || 'None'}
• Programs: ${deps.missing.programs?.join(', ') || 'None'}

These missing dependencies should be uploaded for complete analysis.`;
        }
    }
    
    // Usage pattern questions
    if (lowerQuestion.includes('usage') || lowerQuestion.includes('pattern') || lowerQuestion.includes('lifecycle')) {
        const flow = analysisData.lifecycleFlow;
        if (flow) {
            return `Lifecycle analysis for "${displayName}":

**Usage Pattern:** ${flow.usagePattern || 'Unknown'}

**Programs Involved:**
• Creation: ${flow.creationSources?.length || 0} programs
• Reading: ${flow.readPrograms?.length || 0} programs
• Updates: ${flow.updatePrograms?.length || 0} programs

This indicates that the component is primarily used for ${flow.usagePattern?.toLowerCase().replace(/_/g, ' ') || 'data processing'}.`;
        }
    }
    
    // Default response
    return `For the component "${displayName}":
    
• Type: ${analysisData.componentType}
• Total Fields: ${analysisData.totalFields || 0}
• Quality Score: ${analysisData.qualityScore}/10
• Files Analyzed: ${analysisData.filesAnalyzed.length}

Please ask a more specific question about fields, dependencies, usage patterns, or recommendations.`;
}

// Add Chat Message
addChatMessage(sender, content) {
    const messagesContainer = document.getElementById('chatMessages');
    if (!messagesContainer) return;
    
    const messageDiv = document.createElement('div');
    messageDiv.className = `chat-message ${sender}`;
    
    const bubbleContent = this.formatChatContent(content);
    
    messageDiv.innerHTML = `
        <div class="chat-bubble">
            <div class="chat-message-header">${sender === 'user' ? 'You' : 'LLM Assistant'}</div>
            <div class="chat-message-content">${bubbleContent}</div>
            <div class="chat-message-time">${new Date().toLocaleTimeString()}</div>
        </div>
    `;
    
    messagesContainer.appendChild(messageDiv);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
    
    // Add to chat history
    this.chatHistory.push({
        sender: sender,
        content: content,
        timestamp: new Date().toISOString()
    });
    
    this.saveToStorage();
}

// Format Chat Content
formatChatContent(content) {
    return content
        .replace(/\n/g, '<br>')
        .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
        .replace(/•/g, '&bull;')
        .replace(/`([^`]+)`/g, '<code style="background: var(--grey-100); padding: 2px 4px; border-radius: 3px;">$1</code>');
}

// Show Chat Typing Indicator
showChatTyping() {
    const messagesContainer = document.getElementById('chatMessages');
    if (!messagesContainer) return;
    
    this.hideChatTyping();
    
    const typingDiv = document.createElement('div');
    typingDiv.id = 'typingIndicator';
    typingDiv.className = 'chat-message assistant';
    
    typingDiv.innerHTML = `
        <div class="chat-bubble">
            <div class="chat-message-header">LLM Assistant</div>
            <div class="chat-message-content">
                <span style="opacity: 0.7;">Processing your question...</span>
                <span class="typing-dots">
                    <span>.</span><span>.</span><span>.</span>
                </span>
            </div>
        </div>
    `;
    
    messagesContainer.appendChild(typingDiv);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

// Hide Chat Typing Indicator
hideChatTyping() {
    const typingIndicator = document.getElementById('typingIndicator');
    if (typingIndicator && typingIndicator.parentNode) {
        typingIndicator.parentNode.removeChild(typingIndicator);
    }
}

// Bulk Analyze
async bulkAnalyze() {
    if (this.uploadedFiles.length === 0) {
        this.showError('No files uploaded for bulk analysis');
        return;
    }

    this.showLoading();
    this.updateLoadingStatus('🔄 Starting bulk analysis...');

    const components = this.componentSuggestions
        .filter(c => c.type === 'RECORD_LAYOUT' || c.type === 'PROGRAM')
        .slice(0, 5); // Limit to 5 components
    
    let completed = 0;

    try {
        for (const component of components) {
            this.updateLoadingStatus(`Analyzing ${component.name} (${completed + 1}/${components.length})...`);
            this.updateProgress((completed / components.length) * 100);
            
            try {
                this.currentAnalyzedComponent = component.name;
                this.currentFriendlyName = component.name;
                
                const relevantFiles = this.findRelevantFiles(component.name);
                const results = await this.runComprehensiveAnalysis(component.name, relevantFiles);
                
                this.analysisResults[component.name] = results;
                completed++;
                
                await this.sleep(2000); // Brief pause between analyses
            } catch (error) {
                console.warn(`Failed to analyze ${component.name}:`, error);
            }
        }

        this.hideLoading();
        this.saveToStorage();
        this.showSuccess(`✨ Bulk analysis complete! ${completed}/${components.length} components analyzed`);

        // Display results of first component
        if (completed > 0 && components[0]) {
            this.displayAnalysisResults(components[0].name, this.analysisResults[components[0].name]);
        }

    } catch (error) {
        this.hideLoading();
        this.showError(`Bulk analysis failed: ${error.message}`);
    }
}

// Export Results
async exportResults(format) {
    if (Object.keys(this.analysisResults).length === 0) {
        this.showError('No analysis results to export');
        return;
    }

    try {
        if (format === 'json') {
            this.exportAsJSON();
        } else if (format === 'markdown') {
            this.exportAsMarkdown();
        }
    } catch (error) {
        this.showError(`Export failed: ${error.message}`);
    }
}

// Export as JSON
exportAsJSON() {
    const exportData = {
        metadata: {
            timestamp: new Date().toISOString(),
            totalComponents: Object.keys(this.analysisResults).length,
            totalFiles: this.uploadedFiles.length,
            analysisMethod: 'LLM-Enhanced-Field-Focused',
            version: '2.0.0'
        },
        analysisResults: this.analysisResults,
        chatHistory: this.chatHistory
    };

    const dataStr = JSON.stringify(exportData, null, 2);
    const filename = `mainframe-analysis-${new Date().toISOString().split('T')[0]}.json`;
    
    this.downloadTextFile(dataStr, filename, 'application/json');
    this.showSuccess(`📋 Analysis results exported as ${filename}`);
}

// Export as Markdown
exportAsMarkdown() {
    let markdown = `# Mainframe Component Analysis Report\n\n`;
    markdown += `**Generated:** ${new Date().toLocaleString()}\n`;
    markdown += `**Analysis Method:** LLM-Enhanced Field-Focused Analysis\n\n`;
    markdown += `---\n\n`;

    for (const [componentName, results] of Object.entries(this.analysisResults)) {
        const displayName = results.friendlyName || componentName;
        
        markdown += `## ${displayName}\n\n`;
        markdown += `**Component Name:** ${componentName}\n`;
        markdown += `**Type:** ${results.componentType}\n`;
        markdown += `**Quality Score:** ${results.qualityScore}/10\n`;
        markdown += `**Completeness:** ${results.completeness?.score || 0}%\n`;
        markdown += `**Files Analyzed:** ${results.filesAnalyzed.length}\n\n`;
        
        // Field Analysis
        if (results.fieldAnalysis && results.fieldAnalysis.fields) {
            markdown += `### Field Analysis\n\n`;
            markdown += `- **Total Fields:** ${results.fieldAnalysis.fields.length}\n`;
            markdown += `- **Input Fields:** ${results.fieldAnalysis.inputFields.length}\n`;
            markdown += `- **Output Fields:** ${results.fieldAnalysis.outputFields.length}\n`;
            markdown += `- **Reference Fields:** ${results.fieldAnalysis.referenceFields.length}\n`;
            markdown += `- **Unused Fields:** ${results.fieldAnalysis.unusedFields.length}\n\n`;
            
            if (results.fieldAnalysis.fields.length > 0) {
                markdown += `#### Top Fields\n\n`;
                markdown += `| Field Name | Level | Picture | Usage |\n`;
                markdown += `|------------|-------|---------|-------|\n`;
                
                results.fieldAnalysis.fields.slice(0, 10).forEach(field => {
                    const usage = this.determineFieldUsage(field, results.fieldAnalysis);
                    markdown += `| ${field.name} | ${field.level} | ${field.picture || '-'} | ${usage} |\n`;
                });
                markdown += `\n`;
            }
        }
        
        // Lifecycle Flow
        if (results.lifecycleFlow) {
            markdown += `### Lifecycle Analysis\n\n`;
            markdown += `**Usage Pattern:** ${results.lifecycleFlow.usagePattern || 'Unknown'}\n\n`;
            markdown += `- Creation Sources: ${results.lifecycleFlow.creationSources?.length || 0} programs\n`;
            markdown += `- Read Programs: ${results.lifecycleFlow.readPrograms?.length || 0} programs\n`;
            markdown += `- Update Programs: ${results.lifecycleFlow.updatePrograms?.length || 0} programs\n`;
            markdown += `- CICS Screens: ${results.lifecycleFlow.cicsScreens?.length || 0}\n`;
            markdown += `- Batch Jobs: ${results.lifecycleFlow.batchJobs?.length || 0}\n\n`;
        }
        
        // Dependencies
        if (results.dependencyAnalysis) {
            markdown += `### Dependencies\n\n`;
            markdown += `**Found:** ${results.dependencyAnalysis.summary?.foundCount || 0} | `;
            markdown += `**Missing:** ${results.dependencyAnalysis.summary?.missingCount || 0}\n\n`;
            
            if (results.dependencyAnalysis.found?.copybooks?.length > 0) {
                markdown += `**Found Copybooks:** ${results.dependencyAnalysis.found.copybooks.join(', ')}\n\n`;
            }
            if (results.dependencyAnalysis.missing?.copybooks?.length > 0) {
                markdown += `**Missing Copybooks:** ${results.dependencyAnalysis.missing.copybooks.join(', ')}\n\n`;
            }
        }
        
        // Recommendations
        if (results.llmAnalysis?.recommendations && results.llmAnalysis.recommendations.length > 0) {
            markdown += `### Recommendations\n\n`;
            results.llmAnalysis.recommendations.forEach((rec, index) => {
                markdown += `${index + 1}. ${rec}\n`;
            });
            markdown += '\n';
        }
        
        markdown += `---\n\n`;
    }
    
    // Add chat history if available
    if (this.chatHistory.length > 0) {
        markdown += `## Chat History\n\n`;
        this.chatHistory.forEach(msg => {
            const time = new Date(msg.timestamp).toLocaleString();
            markdown += `**[${time}] ${msg.sender === 'user' ? 'User' : 'Assistant'}:**\n`;
            markdown += `${msg.content}\n\n`;
        });
    }
    
    const filename = `mainframe-analysis-report-${new Date().toISOString().split('T')[0]}.md`;
    this.downloadTextFile(markdown, filename, 'text/markdown');
    this.showSuccess(`📝 Analysis report exported as ${filename}`);
}

// Download Text File
downloadTextFile(content, filename, mimeType = 'text/plain') {
    const blob = new Blob([content], { type: `${mimeType};charset=utf-8` });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(link.href);
}

// Clear All Data
// Clear All Data
clearAllData() {
    if (confirm('Are you sure you want to clear all analysis data? This cannot be undone.')) {
        // Clear in-memory data
        this.uploadedFiles = [];
        this.analysisResults = {};
        this.componentSuggestions = [];
        this.currentAnalyzedComponent = null;
        this.currentFriendlyName = null;
        this.chatHistory = [];
        
        // Clear SQLite database
        if (this.dbInitialized && this.db) {
            try {
                this.db.run("DELETE FROM uploaded_files");
                this.db.run("DELETE FROM analysis_results");
                this.db.run("DELETE FROM chat_history");
                this.db.run("DELETE FROM settings");
                
                // Update localStorage backup
                const data = this.db.export();
                localStorage.setItem('mainframe_analyzer_db', JSON.stringify(Array.from(data)));
            } catch (error) {
                console.error('Failed to clear database:', error);
            }
        }
        
        // Clear localStorage fallback
        localStorage.removeItem('enhanced_mainframe_analysis');
        localStorage.removeItem('mainframe_analyzer_db');
        
        // Reset UI (existing code...)
        this.displayUploadedFiles();
        this.validateForm();
        // ... rest of UI reset code ...
        
     
        
        // Clear display areas
        document.getElementById('lifecycleDetails').innerHTML = '<p>No analysis results yet.</p>';
        document.getElementById('llmResults').innerHTML = '<p>LLM analysis results will appear here.</p>';
        document.getElementById('recommendations').innerHTML = '<p>Analysis recommendations will appear here.</p>';
        document.getElementById('fieldMatrixContent').innerHTML = '<p>Field matrix analysis will appear here after component analysis.</p>';
        document.getElementById('fieldStatistics').innerHTML = '<p>Field usage statistics will appear here.</p>';
        document.getElementById('usageContent').innerHTML = '<p>Usage pattern analysis will appear here after component analysis.</p>';
        document.getElementById('foundDependencies').innerHTML = '<p>Found dependencies will appear here.</p>';
        document.getElementById('missingDependencies').innerHTML = '<p>Missing dependencies will appear here.</p>';
        document.getElementById('fileflowContent').innerHTML = '<p>File lifecycle flow analysis will appear here after component analysis.</p>';
        
        // Reset summaries
        document.getElementById('summaryComponent').textContent = '-';
        document.getElementById('summaryQuality').textContent = '-';
        document.getElementById('summaryFiles').textContent = '0';
        document.getElementById('summaryDeps').textContent = '0';
        
        // Reset chat
        const chatMessages = document.getElementById('chatMessages');
        if (chatMessages) {
            chatMessages.innerHTML = `
                <div class="chat-message assistant">
                    <div class="chat-bubble">
                        <div class="chat-message-header">LLM Analysis Assistant</div>
                        <div class="chat-message-content">
                            👋 <strong>Welcome to LLM-Enhanced Mainframe Analysis!</strong>
                            <br><br>
                            I can provide detailed analysis using advanced language models including:
                            <br><br>
                            🧠 <strong>Smart Field Analysis:</strong> Context-aware field lifecycle tracking<br>
                            ⚖️ <strong>Business Logic Extraction:</strong> Intelligent rule and validation discovery<br>
                            🔗 <strong>Dependency Mapping:</strong> Comprehensive relationship analysis<br>
                            🌊 <strong>File Lifecycle Flow:</strong> Creation to purge tracking with program mapping<br>
                            💡 <strong>Modernization Guidance:</strong> AI-powered optimization recommendations
                            <br><br>
                            <em>Upload files and analyze a component to unlock the full power of LLM analysis!</em>
                        </div>
                        <div class="chat-message-time">${new Date().toLocaleTimeString()}</div>
                    </div>
                </div>
            `;
        }
        
        // Disable chat
        const chatInput = document.getElementById('chatInput');
        const chatSendBtn = document.getElementById('chatSendBtn');
        const chatSuggestions = document.getElementById('chatSuggestions');
        
        if (chatInput) chatInput.disabled = true;
        if (chatSendBtn) chatSendBtn.disabled = true;
        if (chatSuggestions) chatSuggestions.style.display = 'none';
        
        this.showSuccess('🗑️ All analysis data cleared successfully');
    }
}

// Add typing animation styles
addTypingAnimationStyles() {
    if (!document.getElementById('typing-animation-styles')) {
        const style = document.createElement('style');
        style.id = 'typing-animation-styles';
        style.textContent = `
            .typing-dots {
                display: inline-block;
                margin-left: 5px;
            }
            .typing-dots span {
                display: inline-block;
                animation: typing 1.4s infinite;
            }
            .typing-dots span:nth-child(2) {
                animation-delay: 0.2s;
            }
            .typing-dots span:nth-child(3) {
                animation-delay: 0.4s;
            }
            @keyframes typing {
                0%, 60%, 100% {
                    opacity: 0.3;
                }
                30% {
                    opacity: 1;
                }
            }
        `;
        document.head.appendChild(style);
    }
}


            
        }

        // Initialize analyzer on page load
        let analyzer;
        document.addEventListener('DOMContentLoaded', function() {
            analyzer = new EnhancedMainframeAnalyzer();
            console.log('✅ Enhanced Mainframe Analyzer Ready!');
        });
    </script>
</body>
</html>