<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Mainframe Analyzer - Professional Edition</title>
    <style>
        /* ============================================
           PART 1: CORE STYLES AND LAYOUT
           White background with blue/grey theme
           ============================================ */
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Color Palette - Professional Blue/Grey Theme */
            --primary-blue: #2563eb;
            --primary-blue-dark: #1e40af;
            --primary-blue-light: #3b82f6;
            --secondary-blue: #60a5fa;
            --accent-blue: #93c5fd;
            
            --grey-50: #f9fafb;
            --grey-100: #f3f4f6;
            --grey-200: #e5e7eb;
            --grey-300: #d1d5db;
            --grey-400: #9ca3af;
            --grey-500: #6b7280;
            --grey-600: #4b5563;
            --grey-700: #374151;
            --grey-800: #1f2937;
            --grey-900: #111827;
            
            --success-green: #10b981;
            --warning-yellow: #f59e0b;
            --error-red: #ef4444;
            --info-blue: #3b82f6;
            
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
            
            --transition-fast: 150ms cubic-bezier(0.4, 0, 0.2, 1);
            --transition-normal: 300ms cubic-bezier(0.4, 0, 0.2, 1);
            --transition-slow: 500ms cubic-bezier(0.4, 0, 0.2, 1);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Inter', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #ffffff;
            color: var(--grey-800);
            line-height: 1.6;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Main Container */
        .main-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            background: var(--grey-50);
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--primary-blue-dark) 100%);
            color: white;
            padding: 1.5rem 2rem;
            box-shadow: var(--shadow-md);
            position: relative;
            z-index: 100;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 100%;
        }

        .header h1 {
            font-size: 1.75rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .header-icon {
            width: 32px;
            height: 32px;
            background: white;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--primary-blue);
            font-size: 1.25rem;
        }

        .header-subtitle {
            font-size: 0.9rem;
            opacity: 0.9;
            margin-left: 3rem;
        }

        /* Content Layout */
        .content-wrapper {
            flex: 1;
            display: flex;
            overflow: hidden;
            position: relative;
        }

        /* Collapsible Panels */
        .panel {
            background: white;
            position: relative;
            transition: all var(--transition-normal);
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--grey-200);
        }

        .panel.left {
            width: 420px;
            min-width: 60px;
        }

        .panel.left.collapsed {
            width: 60px;
        }

        .panel.right {
            width: 500px;
            min-width: 60px;
            border-left: 1px solid var(--grey-200);
            border-right: none;
        }

        .panel.right.collapsed {
            width: 60px;
        }

        .panel-header {
            padding: 1rem;
            background: var(--grey-50);
            border-bottom: 1px solid var(--grey-200);
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-height: 60px;
        }

        .panel-title {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
            color: var(--grey-700);
            font-size: 0.95rem;
        }

        .panel-icon {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--primary-blue);
        }

        .collapse-btn {
            width: 32px;
            height: 32px;
            border: none;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--grey-600);
            transition: all var(--transition-fast);
            box-shadow: var(--shadow-sm);
        }

        .collapse-btn:hover {
            background: var(--primary-blue);
            color: white;
            transform: scale(1.05);
            box-shadow: var(--shadow-md);
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
            transition: opacity var(--transition-normal);
        }

        .panel.collapsed .panel-content {
            opacity: 0;
            pointer-events: none;
            padding: 0;
        }

        .panel.collapsed .panel-title span {
            display: none;
        }

        .panel.collapsed .panel-header {
            flex-direction: column;
            padding: 1rem 0.5rem;
        }

        .panel.collapsed .collapse-btn {
            margin-top: 0.5rem;
        }

        /* Main Content Area */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: white;
            overflow: hidden;
        }

        /* Tabs */
        .tabs-container {
            background: white;
            border-bottom: 1px solid var(--grey-200);
            padding: 0 1.5rem;
            display: flex;
            align-items: center;
            min-height: 56px;
            box-shadow: var(--shadow-sm);
        }

        .tab {
            padding: 0.75rem 1.5rem;
            background: transparent;
            border: none;
            color: var(--grey-600);
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            position: relative;
            transition: all var(--transition-fast);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .tab:hover {
            color: var(--primary-blue);
            background: var(--grey-50);
        }

        .tab.active {
            color: var(--primary-blue);
        }

        .tab.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--primary-blue);
            border-radius: 3px 3px 0 0;
        }

        .tab-icon {
            width: 18px;
            height: 18px;
            opacity: 0.8;
        }

        /* Tab Content Area */
        .tab-content-container {
            flex: 1;
            overflow-y: auto;
            background: var(--grey-50);
        }

        .tab-content {
            display: none;
            padding: 1.5rem;
        }

        .tab-content.active {
            display: block;
        }

        /* Summary Section */
        .summary-section {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--grey-200);
        }

        .summary-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--grey-100);
        }

        .summary-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--secondary-blue) 100%);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
        }

        .summary-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--grey-800);
        }

        .summary-content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .summary-item {
            padding: 1rem;
            background: var(--grey-50);
            border-radius: 8px;
            border: 1px solid var(--grey-200);
        }

        .summary-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            color: var(--grey-500);
            margin-bottom: 0.25rem;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .summary-value {
            font-size: 0.75rem;
            font-weight: bold;
            color: var(--primary-blue);
        }

        .summary-description {
            font-size: 0.85rem;
            color: var(--grey-600);
            margin-top: 0.25rem;
        }

        /* Collapsible Sections */
        .collapsible-section {
            background: white;
            border-radius: 12px;
            margin-bottom: 1rem;
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--grey-200);
            overflow: hidden;
            transition: all var(--transition-normal);
        }

        .collapsible-header {
            padding: 1rem 1.5rem;
            background: white;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all var(--transition-fast);
            user-select: none;
        }

        .collapsible-header:hover {
            background: var(--grey-50);
        }

        .collapsible-title {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-weight: 600;
            color: var(--grey-700);
        }

        .collapsible-icon {
            width: 20px;
            height: 20px;
            color: var(--primary-blue);
        }

        .expand-icon {
            width: 20px;
            height: 20px;
            color: var(--grey-400);
            transition: transform var(--transition-fast);
        }

        .collapsible-section.expanded .expand-icon {
            transform: rotate(180deg);
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height var(--transition-normal);
            background: var(--grey-50);
        }

        .collapsible-section.expanded .collapsible-content {
            max-height: 2000px;
        }

        .collapsible-body {
            padding: 1.5rem;
        }

        /* Scrollbar Styles */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--grey-100);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--grey-400);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--grey-500);
        }

        /* Loading States */
        .loading-skeleton {
            background: linear-gradient(90deg, var(--grey-100) 25%, var(--grey-200) 50%, var(--grey-100) 75%);
            background-size: 200% 100%;
            animation: loading 1.5s infinite;
            border-radius: 4px;
            height: 20px;
            margin: 0.5rem 0;
        }

        @keyframes loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        /* ============================================
           PART 2: FORM COMPONENTS AND UI ELEMENTS
           ============================================ */

        /* Form Elements */
        .form-section {
            margin-bottom: 1.5rem;
            padding: 1.25rem;
            background: white;
            border-radius: 10px;
            border: 1px solid var(--grey-200);
            box-shadow: var(--shadow-sm);
        }

        .form-section-title {
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--grey-700);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-label {
            display: block;
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--grey-700);
            margin-bottom: 0.5rem;
        }

        .form-input {
            width: 100%;
            padding: 0.625rem 0.875rem;
            border: 1px solid var(--grey-300);
            border-radius: 6px;
            font-size: 0.9rem;
            transition: all var(--transition-fast);
            background: white;
            color: var(--grey-800);
        }

        .form-input:focus {
            outline: none;
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .form-input::placeholder {
            color: var(--grey-400);
        }

        /* Friendly Name Input Group */
        .input-group {
            display: flex;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }

        .input-group .form-input {
            flex: 1;
        }

        .friendly-name-tag {
            display: inline-flex;
            align-items: center;
            padding: 0.25rem 0.75rem;
            background: var(--primary-blue);
            color: white;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 500;
            margin-left: 0.5rem;
        }

        /* Buttons */
        .btn {
            padding: 0.625rem 1.25rem;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all var(--transition-fast);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            box-shadow: var(--shadow-sm);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: var(--primary-blue);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: var(--primary-blue-dark);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .btn-success {
            background: var(--success-green);
            color: white;
        }

        .btn-success:hover:not(:disabled) {
            background: #059669;
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .btn-secondary {
            background: var(--grey-200);
            color: var(--grey-700);
        }

        .btn-secondary:hover:not(:disabled) {
            background: var(--grey-300);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .btn-danger {
            background: var(--error-red);
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            background: #dc2626;
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .btn-block {
            width: 100%;
        }

        /* Upload Area */
        .upload-area {
            border: 2px dashed var(--grey-300);
            border-radius: 10px;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: all var(--transition-fast);
            background: var(--grey-50);
            margin-bottom: 1rem;
        }

        .upload-area:hover {
            border-color: var(--primary-blue);
            background: rgba(37, 99, 235, 0.05);
        }

        .upload-area.drag-over {
            border-color: var(--primary-blue);
            background: rgba(37, 99, 235, 0.1);
            transform: scale(0.98);
        }

        .upload-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
            color: var(--primary-blue);
        }

        .upload-text {
            color: var(--grey-700);
            font-weight: 500;
            margin-bottom: 0.25rem;
        }

        .upload-subtext {
            color: var(--grey-500);
            font-size: 0.85rem;
        }

        /* File List */
        .file-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 1rem;
        }

        .file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background: white;
            border: 1px solid var(--grey-200);
            border-radius: 6px;
            margin-bottom: 0.5rem;
            transition: all var(--transition-fast);
        }

        .file-item:hover {
            box-shadow: var(--shadow-sm);
            transform: translateX(2px);
        }

        .file-info {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex: 1;
        }

        .file-icon {
            width: 32px;
            height: 32px;
            background: var(--grey-100);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--primary-blue);
        }

        .file-details {
            flex: 1;
        }

        .file-name {
            font-weight: 500;
            color: var(--grey-800);
            font-size: 0.9rem;
        }

        .file-meta {
            font-size: 0.75rem;
            color: var(--grey-500);
            margin-top: 0.125rem;
        }

        .file-remove {
            width: 28px;
            height: 28px;
            border: none;
            background: var(--error-red);
            color: white;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--transition-fast);
        }

        .file-remove:hover {
            background: #dc2626;
            transform: scale(1.1);
        }

        /* Status Indicators */
        .status-indicator {
            padding: 0.75rem;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
            margin-bottom: 1rem;
        }

        .status-indicator.connected {
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.3);
            color: var(--success-green);
        }

        .status-indicator.connecting {
            background: rgba(245, 158, 11, 0.1);
            border: 1px solid rgba(245, 158, 11, 0.3);
            color: var(--warning-yellow);
        }

        .status-indicator.disconnected {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: var(--error-red);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Token Usage Bar */
        .token-info {
            background: var(--grey-50);
            border: 1px solid var(--grey-200);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .token-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .token-label {
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--grey-700);
        }

        .token-count {
            font-size: 0.85rem;
            color: var(--grey-600);
        }

        .token-bar {
            height: 6px;
            background: var(--grey-200);
            border-radius: 3px;
            overflow: hidden;
        }

        .token-fill {
            height: 100%;
            border-radius: 3px;
            transition: all var(--transition-normal);
        }

        .token-fill.safe {
            background: var(--success-green);
        }

        .token-fill.warning {
            background: var(--warning-yellow);
        }

        .token-fill.danger {
            background: var(--error-red);
        }

        .token-warning {
            font-size: 0.75rem;
            color: var(--grey-600);
            margin-top: 0.5rem;
        }

        /* Component Suggestions */
        .suggestions-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid var(--grey-200);
            border-radius: 6px;
            box-shadow: var(--shadow-lg);
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            margin-top: 0.25rem;
            display: none;
        }

        .suggestions-dropdown.show {
            display: block;
        }

        .suggestion-item {
            padding: 0.75rem;
            cursor: pointer;
            transition: all var(--transition-fast);
            border-bottom: 1px solid var(--grey-100);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .suggestion-item:last-child {
            border-bottom: none;
        }

        .suggestion-item:hover {
            background: var(--primary-blue);
            color: white;
        }

        .suggestion-item-name {
            font-weight: 500;
            font-size: 0.9rem;
        }

        .suggestion-item-type {
            font-size: 0.75rem;
            opacity: 0.8;
        }

        .suggestion-item-badge {
            margin-left: auto;
            padding: 0.125rem 0.5rem;
            background: var(--primary-blue);
            color: white;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .suggestion-item:hover .suggestion-item-badge {
            background: white;
            color: var(--primary-blue);
        }

        /* Chat Styles - Enhanced Layout */
.chat-container {
    display: flex;
    flex-direction: column;
    height: 100%;
}

/* Reduced Chat Header */
.chat-suggestions {
    padding: 0.75rem;
    background: var(--grey-50);
    border-radius: 6px;
    margin-bottom: 0.75rem;
}

.chat-suggestions-title {
    font-size: 0.75rem;
    font-weight: 600;
    color: var(--grey-700);
    margin-bottom: 0.5rem;
}

.chat-suggestion-chips {
    display: flex;
    flex-wrap: wrap;
    gap: 0.25rem;
}

.chat-suggestion-btn {
    padding: 0.25rem 0.5rem;
    background: white;
    border: 1px solid var(--grey-300);
    border-radius: 16px;
    font-size: 0.7rem;
    color: var(--grey-700);
    cursor: pointer;
    transition: all var(--transition-fast);
}

.chat-suggestion-btn:hover {
    background: var(--primary-blue);
    color: white;
    border-color: var(--primary-blue);
    transform: translateY(-1px);
}

/* Enhanced Chat Messages Area - Much Bigger */
.chat-messages {
    flex: 1;
    overflow-y: auto;
    padding: 1rem;
    background: var(--grey-50);
    border-radius: 8px;
    margin-bottom: 1rem;
    min-height: 400px;
    max-height: calc(100vh - 300px); /* Take most of the available height */
}

.chat-message {
    margin-bottom: 1rem;
    animation: fadeInUp 0.3s ease;
}

@keyframes fadeInUp {
    from {
        opacity: 0;
        transform: translateY(10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.chat-message.user {
    display: flex;
    justify-content: flex-end;
}

.chat-message.assistant {
    display: flex;
    justify-content: flex-start;
}

/* Enhanced Chat Bubbles */
.chat-bubble {
    max-width: 95%;
    padding: 1rem;
    border-radius: 12px;
    position: relative;
    word-wrap: break-word;
    overflow-wrap: break-word;
    line-height: 1.6;
}

.user .chat-bubble {
    background: var(--primary-blue);
    color: white;
    border-bottom-right-radius: 4px;
}

.assistant .chat-bubble {
    background: white;
    color: var(--grey-800);
    border: 1px solid var(--grey-200);
    border-bottom-left-radius: 4px;
    box-shadow: var(--shadow-sm);
}

/* Smaller Chat Message Headers */
.chat-message-header {
    font-size: 0.7rem;
    font-weight: 600;
    margin-bottom: 0.25rem;
    opacity: 0.7;
}

/* Enhanced Chat Content */
.chat-message-content {
    font-size: 0.9rem;
    line-height: 1.6;
    white-space: pre-wrap;
}

.chat-message-content strong {
    font-weight: 600;
    color: var(--primary-blue);
}

.assistant .chat-message-content strong {
    color: var(--primary-blue);
}

.user .chat-message-content strong {
    color: white;
}

/* Smaller Time Stamps */
.chat-message-time {
    font-size: 0.65rem;
    opacity: 0.5;
    margin-top: 0.25rem;
}

/* Enhanced Chat Input Section - Bigger */
.chat-input-section {
    padding: 1rem;
    background: white;
    border-radius: 8px;
    border: 1px solid var(--grey-200);
    box-shadow: var(--shadow-sm);
}

.chat-input-group {
    display: flex;
    gap: 0.75rem;
    align-items: flex-end;
}

/* Much Larger Chat Input */
.chat-input {
    flex: 1;
    padding: 1rem;
    border: 1px solid var(--grey-300);
    border-radius: 8px;
    resize: none;
    min-height: 80px;
    max-height: 160px;
    font-size: 0.95rem;
    transition: all var(--transition-fast);
    font-family: inherit;
    line-height: 1.4;
}

.chat-input:focus {
    outline: none;
    border-color: var(--primary-blue);
    box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
}

.chat-input::placeholder {
    color: var(--grey-400);
    font-size: 0.9rem;
}

/* Enhanced Send Button */
.chat-send-btn {
    padding: 1rem 1.5rem;
    background: var(--primary-blue);
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: all var(--transition-fast);
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-weight: 600;
    font-size: 0.9rem;
    min-height: 80px;
    align-self: stretch;
}

.chat-send-btn:hover:not(:disabled) {
    background: var(--primary-blue-dark);
    transform: translateY(-1px);
    box-shadow: var(--shadow-md);
}

.chat-send-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

/* Reduced Chat Header Info */
.chat-container > div:first-child {
    padding: 0.75rem;
    margin-bottom: 0.75rem;
}

.chat-container > div:first-child h3 {
    font-size: 0.9rem;
    margin-bottom: 0.25rem;
}

.chat-container > div:first-child p {
    font-size: 0.75rem;
    opacity: 0.85;
}

        /* Loading Indicator */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.95);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .loading-overlay.show {
            display: flex;
        }

        .loading-content {
            text-align: center;
        }

        .loading-spinner {
            width: 48px;
            height: 48px;
            border: 3px solid var(--grey-200);
            border-top-color: var(--primary-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--grey-800);
            margin-bottom: 0.5rem;
        }

        .loading-status {
            font-size: 0.9rem;
            color: var(--grey-600);
            margin-bottom: 1rem;
        }

        .loading-progress {
            width: 200px;
            height: 4px;
            background: var(--grey-200);
            border-radius: 2px;
            overflow: hidden;
            margin: 0 auto;
        }

        .loading-progress-fill {
            height: 100%;
            background: var(--primary-blue);
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        /* Alert Messages */
        .alert {
            position: fixed;
            top: 80px;
            right: 20px;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            box-shadow: var(--shadow-lg);
            display: flex;
            align-items: center;
            gap: 0.75rem;
            max-width: 400px;
            animation: slideInRight 0.3s ease;
            z-index: 10000;
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .alert-success {
            background: var(--success-green);
            color: white;
        }

        .alert-error {
            background: var(--error-red);
            color: white;
        }

        .alert-warning {
            background: var(--warning-yellow);
            color: white;
        }

        .alert-info {
            background: var(--info-blue);
            color: white;
        }

        .alert-icon {
            font-size: 1.25rem;
        }

        .alert-message {
            flex: 1;
            font-size: 0.9rem;
            font-weight: 500;
        }

        /* Metric Cards */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .metric-card {
            background: white;
            border: 1px solid var(--grey-200);
            border-radius: 10px;
            padding: 1.25rem;
            display: flex;
            align-items: center;
            gap: 1rem;
            transition: all var(--transition-fast);
        }

        .metric-card:hover {
            box-shadow: var(--shadow-md);
            transform: translateY(-2px);
        }

        .metric-icon {
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--secondary-blue) 100%);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.5rem;
        }

        .metric-details {
            flex: 1;
        }

        .metric-label {
            font-size: 0.75rem;
            color: var(--grey-500);
            text-transform: uppercase;
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .metric-value {
            font-size: 0.75rem;
            font-weight: bold;
            color: var(--grey-800);
        }

        .metric-change {
            font-size: 0.85rem;
            margin-top: 0.25rem;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .metric-change.positive {
            color: var(--success-green);
        }

        .metric-change.negative {
            color: var(--error-red);
        }

        /* Table Styles */
        .data-table {
            width: 100%;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid var(--grey-200);
        }

        .data-table thead {
            background: var(--grey-50);
        }

        .data-table th {
            padding: 0.75rem;
            text-align: left;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--grey-700);
            border-bottom: 1px solid var(--grey-200);
        }

        .data-table td {
            padding: 0.75rem;
            font-size: 0.9rem;
            color: var(--grey-800);
            border-bottom: 1px solid var(--grey-100);
        }

        .data-table tbody tr:hover {
            background: var(--grey-50);
        }

        .data-table tbody tr:last-child td {
            border-bottom: none;
        }

        /* Badge Styles */
        .badge {
            display: inline-flex;
            align-items: center;
            padding: 0.25rem 0.625rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .badge-primary {
            background: rgba(37, 99, 235, 0.1);
            color: var(--primary-blue);
        }

        .badge-success {
            background: rgba(16, 185, 129, 0.1);
            color: var(--success-green);
        }

        .badge-warning {
            background: rgba(245, 158, 11, 0.1);
            color: var(--warning-yellow);
        }

        .badge-danger {
            background: rgba(239, 68, 68, 0.1);
            color: var(--error-red);
        }

        .badge-grey {
            background: var(--grey-100);
            color: var(--grey-600);
        }
        /* Dependency Flow Visualization */
.flow-container {
    background: white;
    border-radius: 12px;
    padding: 1.5rem;
    margin-bottom: 1rem;
    overflow-x: auto;
}

.flow-diagram {
    min-width: 800px;
    padding: 2rem;
    background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
    border-radius: 8px;
    position: relative;
}

.flow-level {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 3rem;
    position: relative;
}

.flow-level:last-child {
    margin-bottom: 0;
}

.flow-level-title {
    position: absolute;
    left: -120px;
    top: 50%;
    transform: translateY(-50%);
    font-weight: 600;
    color: var(--grey-600);
    font-size: 0.9rem;
    writing-mode: vertical-rl;
    text-orientation: mixed;
}

.flow-nodes {
    display: flex;
    gap: 2rem;
    flex-wrap: wrap;
    justify-content: center;
    flex: 1;
}

.flow-node {
    background: white;
    border: 2px solid var(--grey-300);
    border-radius: 12px;
    padding: 1rem;
    min-width: 120px;
    text-align: center;
    position: relative;
    transition: all var(--transition-fast);
    cursor: pointer;
}

.flow-node:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-lg);
    border-color: var(--primary-blue);
}

.flow-node.current {
    border-color: var(--primary-blue);
    background: linear-gradient(135deg, var(--primary-blue) 0%, var(--secondary-blue) 100%);
    color: white;
    box-shadow: var(--shadow-lg);
}

.flow-node.upstream {
    border-color: var(--success-green);
    background: rgba(16, 185, 129, 0.1);
}

.flow-node.downstream {
    border-color: var(--warning-yellow);
    background: rgba(245, 158, 11, 0.1);
}

.flow-node.missing {
    border-color: var(--error-red);
    background: rgba(239, 68, 68, 0.1);
    border-style: dashed;
}

.flow-node-icon {
    font-size: 1.5rem;
    margin-bottom: 0.5rem;
}

.flow-node-name {
    font-weight: 600;
    font-size: 0.9rem;
    margin-bottom: 0.25rem;
}

.flow-node-type {
    font-size: 0.75rem;
    opacity: 0.8;
}

.flow-node-badge {
    position: absolute;
    top: -8px;
    right: -8px;
    background: var(--primary-blue);
    color: white;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    font-size: 0.7rem;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 600;
}

/* Flow Arrows */
.flow-arrow {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    bottom: -2rem;
    color: var(--primary-blue);
    font-size: 1.5rem;
    opacity: 0.7;
}

/* Flow Legend */
.flow-legend {
    display: flex;
    gap: 1rem;
    flex-wrap: wrap;
    margin-top: 2rem;
    padding: 1rem;
    background: white;
    border-radius: 8px;
    border: 1px solid var(--grey-200);
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.85rem;
}

.legend-color {
    width: 16px;
    height: 16px;
    border-radius: 4px;
}

/* Impact Analysis Grid */
.impact-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 1rem;
    margin-bottom: 1.5rem;
}

.impact-card {
    background: white;
    border: 1px solid var(--grey-200);
    border-radius: 10px;
    padding: 1.25rem;
    transition: all var(--transition-fast);
}

.impact-card:hover {
    box-shadow: var(--shadow-md);
    transform: translateY(-2px);
}

.impact-header {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    margin-bottom: 1rem;
}

.impact-icon {
    width: 32px;
    height: 32px;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.25rem;
}

.impact-high {
    background: rgba(239, 68, 68, 0.1);
    color: var(--error-red);
}

.impact-medium {
    background: rgba(245, 158, 11, 0.1);
    color: var(--warning-yellow);
}

.impact-low {
    background: rgba(16, 185, 129, 0.1);
    color: var(--success-green);
}

.impact-title {
    font-weight: 600;
    color: var(--grey-800);
}

.impact-description {
    font-size: 0.85rem;
    color: var(--grey-600);
    line-height: 1.5;
}
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.js"></script>
</head>
<body>
    <div class="main-container">
        <!-- Header -->
        <div class="header">
            <div class="header-content">
                <h1>
                    <div class="header-icon">üî¨</div>
                    Enhanced Mainframe Analyzer
                    <span class="header-subtitle">Professional Edition with LLM-Powered Analysis</span>
                </h1>
            </div>
        </div>

        <!-- Main Content Wrapper -->
        <div class="content-wrapper">
            <!-- Left Panel - Component Analysis -->
            <div class="panel left" id="leftPanel">
                <div class="panel-header">
                    <div class="panel-title">
                        <div class="panel-icon">üéØ</div>
                        <span>Component Analysis</span>
                    </div>
                    <button class="collapse-btn" onclick="togglePanel('left')">
                        ‚óÄ
                    </button>
                </div>
                <div class="panel-content" id="leftPanelContent">
                    <!-- Component Analysis Section -->
                    <div class="form-section">
                        <div class="form-section-title">
                            <span style="color: var(--primary-blue);">üéØ</span>
                            Component Analysis
                        </div>
                        
                        <!-- Component Name Inputs -->
                        <div class="form-group">
                            <label class="form-label">Component Name *</label>
                            <div style="position: relative;">
                                <input type="text" 
                                       id="componentName" 
                                       class="form-input" 
                                       placeholder="e.g., CUSTOMER-RECORD, ACCOUNT-COPY"
                                       autocomplete="off">
                                <div id="componentSuggestions" class="suggestions-dropdown"></div>
                            </div>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Friendly Name (Optional)</label>
                            <input type="text" 
                                   id="friendlyName" 
                                   class="form-input" 
                                   placeholder="e.g., Customer Master Record">
                            <small style="color: var(--grey-500); font-size: 0.75rem;">
                                This name will be displayed in all analysis results
                            </small>
                        </div>

                        <!-- Token Usage -->
                        <div id="tokenInfo" class="token-info" style="display: none;">
                            <div class="token-header">
                                <span class="token-label">Token Usage</span>
                                <span id="tokenCount" class="token-count">0 / 4000</span>
                            </div>
                            <div class="token-bar">
                                <div id="tokenFill" class="token-fill safe" style="width: 0%"></div>
                            </div>
                            <div id="tokenWarning" class="token-warning"></div>
                        </div>

                        <button id="analyzeComponentBtn" class="btn btn-primary btn-block" disabled>
                            <span>üîç</span>
                            Analyze Component
                        </button>
                    </div>

                    <!-- vLLM Server Setup -->
                    <div class="form-section">
                        <div class="form-section-title">
                            <span style="color: var(--success-green);">üöÄ</span>
                            vLLM Server Setup
                        </div>

                        <div class="form-group">
                            <label class="form-label">Server Endpoint</label>
                            <input type="text" 
                                   id="vllmEndpoint" 
                                   class="form-input" 
                                   placeholder="http://localhost:8000" 
                                   value="http://localhost:8000">
                        </div>

                        <div class="form-group">
                            <label class="form-label">Max Tokens</label>
                            <input type="number" 
                                   id="maxTokens" 
                                   class="form-input" 
                                   value="4000" 
                                   min="1000" 
                                   max="8000">
                        </div>

                        <button id="validateApiBtn" class="btn btn-success btn-block">
                            <span>üîê</span>
                            Test Connection
                        </button>

                        <div id="apiStatus" class="status-indicator disconnected">
                            <span class="status-dot"></span>
                            <span>Enter server details and test connection</span>
                        </div>
                    </div>

                    <!-- File Upload Section -->
                    <div class="form-section">
                        <div class="form-section-title">
                            <span style="color: var(--info-blue);">üìÅ</span>
                            Upload Mainframe Files
                        </div>

                        <div class="upload-area" id="uploadArea">
                            <div class="upload-icon">üì§</div>
                            <div class="upload-text">Drop files here or click to browse</div>
                            <div class="upload-subtext">COBOL (.cbl), Copybooks (.cpy), JCL (.jcl)</div>
                            <input type="file" 
                                   id="fileInput" 
                                   multiple 
                                   accept=".cbl,.cob,.cpy,.copybook,.jcl,.txt,.proc" 
                                   style="display: none;">
                        </div>

                        <div id="uploadedFiles" class="file-list"></div>
                    </div>

                    <!-- Quick Actions -->
                    <div class="form-section">
                        <div class="form-section-title">
                            <span style="color: var(--warning-yellow);">‚ö°</span>
                            Quick Actions
                        </div>

                        <button id="bulkAnalyzeBtn" class="btn btn-secondary btn-block" disabled style="margin-bottom: 0.75rem;">
                            <span>üìä</span>
                            Bulk Analyze
                        </button>

                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-bottom: 0.75rem;">
                            <button id="exportJsonBtn" class="btn btn-secondary" disabled>
                                <span>üìã</span>
                                Export JSON
                            </button>
                            <button id="exportMdBtn" class="btn btn-secondary" disabled>
                                <span>üìù</span>
                                Export MD
                            </button>
                        </div>

                        <button id="clearBtn" class="btn btn-danger btn-block">
                            <span>üóëÔ∏è</span>
                            Clear All Data
                        </button>
                    </div>
                </div>
            </div>

            <!-- Main Content Area -->
            <div class="main-content">
                <!-- Tabs -->
                <div class="tabs-container">
                    <button class="tab active" data-tab="lifecycle">
                        <span class="tab-icon">üîÑ</span>
                        Analysis Results
                    </button>
                    <button class="tab" data-tab="fieldmatrix">
                        <span class="tab-icon">üìã</span>
                        Field Matrix
                    </button>
                    <button class="tab" data-tab="usage">
                        <span class="tab-icon">üìà</span>
                        Usage Patterns
                    </button>
                    <button class="tab" data-tab="dependencies">
                        <span class="tab-icon">üîó</span>
                        Dependencies
                    </button>
                    <button class="tab" data-tab="depflow">
                        <span class="tab-icon">üó∫Ô∏è</span>
                        Dependency Flow
                    </button>
                    <button class="tab" data-tab="fileflow">
                        <span class="tab-icon">üåä</span>
                        File Lifecycle
                    </button>
                </div>

                <!-- Tab Content -->
                <!-- Tab Content -->
                <div class="tab-content-container">
                    <!-- Analysis Results Tab -->
                    <div id="lifecycle" class="tab-content active">
                        <!-- Summary Section -->
                        <div class="summary-section">
                            <div class="summary-header">
                                <div class="summary-icon">üìä</div>
                                <div class="summary-title">Analysis Summary</div>
                            </div>
                            <div class="summary-content">
                                <div class="summary-item">
                                    <div class="summary-label">Component</div>
                                    <div class="summary-value" id="summaryComponent">-</div>
                                    <div class="summary-description">Analyzed component</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">Quality Score</div>
                                    <div class="summary-value" id="summaryQuality">-</div>
                                    <div class="summary-description">Analysis quality</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">Files</div>
                                    <div class="summary-value" id="summaryFiles">0</div>
                                    <div class="summary-description">Files analyzed</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">Dependencies</div>
                                    <div class="summary-value" id="summaryDeps">0</div>
                                    <div class="summary-description">Total dependencies</div>
                                </div>
                            </div>
                        </div>

                        <!-- Collapsible Sections -->
                        <div class="collapsible-section expanded">
                            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                                <div class="collapsible-title">
                                    <span class="collapsible-icon">üîç</span>
                                    Component Details
                                </div>
                                <span class="expand-icon">‚ñº</span>
                            </div>
                            <div class="collapsible-content">
                                <div class="collapsible-body" id="lifecycleDetails">
                                    <p>Component analysis details will appear here after analysis.</p>
                                </div>
                            </div>
                        </div>

                        <div class="collapsible-section">
                            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                                <div class="collapsible-title">
                                    <span class="collapsible-icon">ü§ñ</span>
                                    LLM Analysis Results
                                </div>
                                <span class="expand-icon">‚ñº</span>
                            </div>
                            <div class="collapsible-content">
                                <div class="collapsible-body" id="llmResults">
                                    <p>LLM analysis results will appear here.</p>
                                </div>
                            </div>
                        </div>

                        <div class="collapsible-section">
                            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                                <div class="collapsible-title">
                                    <span class="collapsible-icon">üí°</span>
                                    Recommendations
                                </div>
                                <span class="expand-icon">‚ñº</span>
                            </div>
                            <div class="collapsible-content">
                                <div class="collapsible-body" id="recommendations">
                                    <p>Analysis recommendations will appear here.</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Field Matrix Tab -->
                    <div id="fieldmatrix" class="tab-content">
                        <!-- Summary Section -->
                        <div class="summary-section">
                            <div class="summary-header">
                                <div class="summary-icon">üìã</div>
                                <div class="summary-title">Field Matrix Summary</div>
                            </div>
                            <div class="summary-content">
                                <div class="summary-item">
                                    <div class="summary-label">Total Fields</div>
                                    <div class="summary-value" id="totalFields">0</div>
                                    <div class="summary-description">Fields identified</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">Input Fields</div>
                                    <div class="summary-value" id="inputFields">0</div>
                                    <div class="summary-description">Input operations</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">Output Fields</div>
                                    <div class="summary-value" id="outputFields">0</div>
                                    <div class="summary-description">Output operations</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">Unused Fields</div>
                                    <div class="summary-value" id="unusedFields">0</div>
                                    <div class="summary-description">Not referenced</div>
                                </div>
                            </div>
                        </div>

                        <!-- Field Matrix Content -->
                        <div class="collapsible-section expanded">
                            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                                <div class="collapsible-title">
                                    <span class="collapsible-icon">üìä</span>
                                    Field Analysis Matrix
                                </div>
                                <span class="expand-icon">‚ñº</span>
                            </div>
                            <div class="collapsible-content">
                                <div class="collapsible-body" id="fieldMatrixContent">
                                    <p>Field matrix analysis will appear here after component analysis.</p>
                                </div>
                            </div>
                        </div>

                        <div class="collapsible-section">
                            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                                <div class="collapsible-title">
                                    <span class="collapsible-icon">üìà</span>
                                    Field Usage Statistics
                                </div>
                                <span class="expand-icon">‚ñº</span>
                            </div>
                            <div class="collapsible-content">
                                <div class="collapsible-body" id="fieldStatistics">
                                    <p>Field usage statistics will appear here.</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Usage Patterns Tab -->
                    <div id="usage" class="tab-content">
                        <!-- Summary Section -->
                        <div class="summary-section">
                            <div class="summary-header">
                                <div class="summary-icon">üìà</div>
                                <div class="summary-title">Usage Patterns Summary</div>
                            </div>
                            <div class="summary-content">
                                <div class="summary-item">
                                    <div class="summary-label">Pattern Type</div>
                                    <div class="summary-value" id="patternType">-</div>
                                    <div class="summary-description">Usage pattern</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">Creation</div>
                                    <div class="summary-value" id="creationCount">0</div>
                                    <div class="summary-description">Creation sources</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">Reading</div>
                                    <div class="summary-value" id="readingCount">0</div>
                                    <div class="summary-description">Read programs</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">Updates</div>
                                    <div class="summary-value" id="updateCount">0</div>
                                    <div class="summary-description">Update programs</div>
                                </div>
                            </div>
                        </div>

                        <!-- Usage Pattern Details -->
                        <div class="collapsible-section expanded">
                            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                                <div class="collapsible-title">
                                    <span class="collapsible-icon">üîÑ</span>
                                    Usage Pattern Analysis
                                </div>
                                <span class="expand-icon">‚ñº</span>
                            </div>
                            <div class="collapsible-content">
                                <div class="collapsible-body" id="usageContent">
                                    <p>Usage pattern analysis will appear here after component analysis.</p>
                                </div>
                            </div>
                        </div>

                        <div class="collapsible-section">
                            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                                <div class="collapsible-title">
                                    <span class="collapsible-icon">üìä</span>
                                    Program Usage Distribution
                                </div>
                                <span class="expand-icon">‚ñº</span>
                            </div>
                            <div class="collapsible-content">
                                <div class="collapsible-body" id="programDistribution">
                                    <p>Program usage distribution will appear here.</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Dependencies Tab -->
                    <div id="dependencies" class="tab-content">
                        <!-- Summary Section -->
                        <div class="summary-section">
                            <div class="summary-header">
                                <div class="summary-icon">üîó</div>
                                <div class="summary-title">Dependencies Summary</div>
                            </div>
                            <div class="summary-content">
                                <div class="summary-item">
                                    <div class="summary-label">Found</div>
                                    <div class="summary-value" id="foundDeps">0</div>
                                    <div class="summary-description">Available deps</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">Missing</div>
                                    <div class="summary-value" id="missingDeps">0</div>
                                    <div class="summary-description">Missing deps</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">Copybooks</div>
                                    <div class="summary-value" id="copybookDeps">0</div>
                                    <div class="summary-description">Copybook refs</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">Programs</div>
                                    <div class="summary-value" id="programDeps">0</div>
                                    <div class="summary-description">Program calls</div>
                                </div>
                            </div>
                        </div>

                        <!-- Dependency Details -->
                        <div class="collapsible-section expanded">
                            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                                <div class="collapsible-title">
                                    <span class="collapsible-icon">‚úÖ</span>
                                    Found Dependencies
                                </div>
                                <span class="expand-icon">‚ñº</span>
                            </div>
                            <div class="collapsible-content">
                                <div class="collapsible-body" id="foundDependencies">
                                    <p>Found dependencies will appear here.</p>
                                </div>
                            </div>
                        </div>

                        <div class="collapsible-section">
                            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                                <div class="collapsible-title">
                                    <span class="collapsible-icon">‚ùå</span>
                                    Missing Dependencies
                                </div>
                                <span class="expand-icon">‚ñº</span>
                            </div>
                            <div class="collapsible-content">
                                <div class="collapsible-body" id="missingDependencies">
                                    <p>Missing dependencies will appear here.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <!-- Dependency Flow Tab -->
<div id="depflow" class="tab-content">
    <!-- Summary Section -->
    <div class="summary-section">
        <div class="summary-header">
            <div class="summary-icon">üó∫Ô∏è</div>
            <div class="summary-title">Dependency Flow Summary</div>
        </div>
        <div class="summary-content">
            <div class="summary-item">
                <div class="summary-label">Flow Type</div>
                <div class="summary-value" id="flowType">-</div>
                <div class="summary-description">Dependency pattern</div>
            </div>
            <div class="summary-item">
                <div class="summary-label">Upstream</div>
                <div class="summary-value" id="upstreamCount">0</div>
                <div class="summary-description">Dependencies</div>
            </div>
            <div class="summary-item">
                <div class="summary-label">Downstream</div>
                <div class="summary-value" id="downstreamCount">0</div>
                <div class="summary-description">Dependents</div>
            </div>
            <div class="summary-item">
                <div class="summary-label">Complexity</div>
                <div class="summary-value" id="complexityScore">-</div>
                <div class="summary-description">Flow complexity</div>
            </div>
        </div>
    </div>

    <!-- High-Level Flow Visualization -->
    <div class="collapsible-section expanded">
        <div class="collapsible-header" onclick="toggleCollapsible(this)">
            <div class="collapsible-title">
                <span class="collapsible-icon">üåê</span>
                High-Level Dependency Flow
            </div>
            <span class="expand-icon">‚ñº</span>
        </div>
        <div class="collapsible-content">
            <div class="collapsible-body" id="dependencyFlowChart">
                <p>Dependency flow visualization will appear here after component analysis.</p>
            </div>
        </div>
    </div>

    <!-- Detailed Flow Analysis -->
    <div class="collapsible-section">
        <div class="collapsible-header" onclick="toggleCollapsible(this)">
            <div class="collapsible-title">
                <span class="collapsible-icon">üîç</span>
                Detailed Flow Analysis
            </div>
            <span class="expand-icon">‚ñº</span>
        </div>
        <div class="collapsible-content">
            <div class="collapsible-body" id="detailedFlowAnalysis">
                <p>Detailed flow analysis will appear here.</p>
            </div>
        </div>
    </div>

    <!-- Impact Analysis -->
    <div class="collapsible-section">
        <div class="collapsible-header" onclick="toggleCollapsible(this)">
            <div class="collapsible-title">
                <span class="collapsible-icon">‚ö°</span>
                Impact Analysis
            </div>
            <span class="expand-icon">‚ñº</span>
        </div>
        <div class="collapsible-content">
            <div class="collapsible-body" id="impactAnalysis">
                <p>Impact analysis will appear here.</p>
            </div>
        </div>
    </div>
</div>
                    <!-- File Lifecycle Tab -->
                    <div id="fileflow" class="tab-content">
                        <!-- Summary Section -->
                        <div class="summary-section">
                            <div class="summary-header">
                                <div class="summary-icon">üåä</div>
                                <div class="summary-title">File Lifecycle Summary</div>
                            </div>
                            <div class="summary-content">
                                <div class="summary-item">
                                    <div class="summary-label">Lifecycle Stage</div>
                                    <div class="summary-value" id="lifecycleStage">-</div>
                                    <div class="summary-description">Current stage</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">Programs</div>
                                    <div class="summary-value" id="totalPrograms">0</div>
                                    <div class="summary-description">Total programs</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">CICS</div>
                                    <div class="summary-value" id="cicsCount">0</div>
                                    <div class="summary-description">CICS screens</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">Batch</div>
                                    <div class="summary-value" id="batchCount">0</div>
                                    <div class="summary-description">Batch jobs</div>
                                </div>
                            </div>
                        </div>

                        <!-- Lifecycle Flow Details -->
                        <div class="collapsible-section expanded">
                            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                                <div class="collapsible-title">
                                    <span class="collapsible-icon">üåä</span>
                                    Complete Lifecycle Flow
                                </div>
                                <span class="expand-icon">‚ñº</span>
                            </div>
                            <div class="collapsible-content">
                                <div class="collapsible-body" id="fileflowContent">
                                    <p>File lifecycle flow analysis will appear here after component analysis.</p>
                                </div>
                            </div>
                        </div>

                        <div class="collapsible-section">
                            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                                <div class="collapsible-title">
                                    <span class="collapsible-icon">üìã</span>
                                    Field Lifecycle Details
                                </div>
                                <span class="expand-icon">‚ñº</span>
                            </div>
                            <div class="collapsible-content">
                                <div class="collapsible-body" id="fieldLifecycle">
                                    <p>Field lifecycle details will appear here.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Panel - Chat -->
            <div class="panel right" id="rightPanel">
                <div class="panel-header">
                    <div class="panel-title">
                        <div class="panel-icon">üí¨</div>
                        <span>Analysis Chat</span>
                    </div>
                    <button class="collapse-btn" onclick="togglePanel('right')">
                        ‚ñ∂
                    </button>
                </div>
                <div class="panel-content" id="rightPanelContent">
                    <!-- Chat Container -->
                    <div class="chat-container">
                        <!-- Chat Header Info -->
                        <div style="padding: 1rem; background: linear-gradient(135deg, var(--primary-blue) 0%, var(--secondary-blue) 100%); color: white; border-radius: 10px; margin-bottom: 1rem;">
                            <h3 style="font-size: 1rem; margin-bottom: 0.5rem;">üí¨ LLM Analysis Chat</h3>
                            <p style="font-size: 0.8rem; opacity: 0.9;">Interactive chat with rich formatting and export</p>
                        </div>

                        <!-- Chat Suggestions -->
                        <div id="chatSuggestions" class="chat-suggestions" style="display: none;">
                            <div class="chat-suggestions-title">üí° Suggested Questions:</div>
                            <div class="chat-suggestion-chips">
                                <button class="chat-suggestion-btn" data-question="Explain the file lifecycle flow for this component">
                                    üìä File Lifecycle
                                </button>
                                <button class="chat-suggestion-btn" data-question="What fields are updated by which programs?">
                                    üîÑ Field Updates
                                </button>
                                <button class="chat-suggestion-btn" data-question="Show me the creation and purge process">
                                    üåä Creation/Purge
                                </button>
                                <button class="chat-suggestion-btn" data-question="Which programs only read vs modify data?">
                                    üìñ Read/Write Patterns
                                </button>
                            </div>
                        </div>

                        <!-- Chat Messages Area -->
                        <div class="chat-messages" id="chatMessages">
                            <div class="chat-message assistant">
                                <div class="chat-bubble">
                                    <div class="chat-message-header">LLM Analysis Assistant</div>
                                    <div class="chat-message-content">
                                        üëã <strong>Welcome to LLM-Enhanced Mainframe Analysis!</strong>
                                        <br><br>
                                        I can provide detailed analysis using advanced language models including:
                                        <br><br>
                                        üß† <strong>Smart Field Analysis:</strong> Context-aware field lifecycle tracking<br>
                                        ‚öñÔ∏è <strong>Business Logic Extraction:</strong> Intelligent rule and validation discovery<br>
                                        üîó <strong>Dependency Mapping:</strong> Comprehensive relationship analysis<br>
                                        üåä <strong>File Lifecycle Flow:</strong> Creation to purge tracking with program mapping<br>
                                        üí° <strong>Modernization Guidance:</strong> AI-powered optimization recommendations
                                        <br><br>
                                        <em>Upload files and analyze a component to unlock the full power of LLM analysis!</em>
                                    </div>
                                    <div class="chat-message-time">${new Date().toLocaleTimeString()}</div>
                                </div>
                            </div>
                        </div>

                        <!-- Chat Input Section -->
                        <div class="chat-input-section">
                            <div class="chat-input-group">
                                <textarea id="chatInput" 
                                          class="chat-input" 
                                          placeholder="Ask about field flows, program dependencies, lifecycle patterns..." 
                                          disabled 
                                          rows="1"></textarea>
                                <button id="chatSendBtn" class="chat-send-btn" disabled>
                                    <span>Send</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingIndicator">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <div class="loading-title">ü§ñ Analyzing Component</div>
            <div class="loading-status" id="loadingStatus">Processing component analysis...</div>
            <div class="loading-progress">
                <div class="loading-progress-fill" id="progressFill" style="width: 0%"></div>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // PART 6: JavaScript Base and UI Functions
        // ============================================
        
        // Basic UI Functions
        function togglePanel(side) {
            const panel = document.getElementById(side + 'Panel');
            panel.classList.toggle('collapsed');
            
            // Update button icon
            const btn = panel.querySelector('.collapse-btn');
            if (side === 'left') {
                btn.textContent = panel.classList.contains('collapsed') ? '‚ñ∂' : '‚óÄ';
            } else {
                btn.textContent = panel.classList.contains('collapsed') ? '‚óÄ' : '‚ñ∂';
            }
            
            // Save state to localStorage
            localStorage.setItem(side + 'PanelCollapsed', panel.classList.contains('collapsed'));
        }

        function toggleCollapsible(header) {
            const section = header.parentElement;
            section.classList.toggle('expanded');
        }

        // Initialize tabs
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', function() {
                // Remove active from all tabs
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                // Add active to clicked tab
                this.classList.add('active');
                const tabId = this.getAttribute('data-tab');
                document.getElementById(tabId).classList.add('active');
            });
        });

        // Restore panel states from localStorage
        window.addEventListener('DOMContentLoaded', function() {
            if (localStorage.getItem('leftPanelCollapsed') === 'true') {
                togglePanel('left');
            }
            if (localStorage.getItem('rightPanelCollapsed') === 'true') {
                togglePanel('right');
            }
        });

        // Enhanced Mainframe Analyzer Class
        class EnhancedMainframeAnalyzer {
           togglePanel(side) {
            const panel = document.getElementById(side + 'Panel');
            panel.classList.toggle('collapsed');
            
            // Update button icon
            const btn = panel.querySelector('.collapse-btn');
            if (side === 'left') {
                btn.textContent = panel.classList.contains('collapsed') ? '‚ñ∂' : '‚óÄ';
            } else {
                btn.textContent = panel.classList.contains('collapsed') ? '‚óÄ' : '‚ñ∂';
            }
            
            // Save state to localStorage
            localStorage.setItem(side + 'PanelCollapsed', panel.classList.contains('collapsed'));
        }

        toggleCollapsible(header) {
            const section = header.parentElement;
            section.classList.toggle('expanded');
        }

            constructor() {
    // Core properties
    this.uploadedFiles = [];
    this.analysisResults = {};
    this.componentSuggestions = [];
    this.serverValidated = false;
    this.vllmEndpoint = 'http://localhost:8000';
    this.maxTokens = 4000;
    this.currentAnalyzedComponent = null;
    this.currentFriendlyName = null;
    this.chatHistory = [];
    
    // SQLite Database
    this.db = null;
    this.dbInitialized = false;
    
    // Token management
    this.averageCharsPerToken = 3;
    this.tokenSafetyMargin = 0.7;
    
    // Initialize
    this.initializeDatabase();
    this.initializeEventListeners();
    this.loadStoredData();
    this.initializeChat();
    this.addTypingAnimationStyles();
    this.friendlyNameCache = new Map(); // Cache for LLM-generated friendly names
    this.businessContextCache = new Map();

    console.log('üöÄ Enhanced Mainframe Analyzer Initialized');
}

// Initialize SQLite Database
async initializeDatabase() {
    try {
        const SQL = await initSqlJs({
            locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${file}`
        });
        
        // Try to load existing database from localStorage
        const savedDb = localStorage.getItem('mainframe_analyzer_db');
        if (savedDb) {
            const uInt8Array = new Uint8Array(JSON.parse(savedDb));
            this.db = new SQL.Database(uInt8Array);
        } else {
            this.db = new SQL.Database();
        }
        
        // Create tables if they don't exist
        this.createTables();
        this.dbInitialized = true;
        console.log('‚úÖ SQLite database initialized');
        
    } catch (error) {
        console.error('Failed to initialize SQLite database:', error);
        // Fallback to localStorage
        this.dbInitialized = false;
    }
}

// Create Database Tables
createTables() {
    if (!this.db) return;
    
    // Uploaded Files table
    this.db.run(`
        CREATE TABLE IF NOT EXISTS uploaded_files (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            file_id TEXT UNIQUE,
            name TEXT,
            content TEXT,
            size INTEGER,
            type TEXT,
            upload_date TEXT,
            components TEXT,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    `);
    
    // Analysis Results table
    this.db.run(`
        CREATE TABLE IF NOT EXISTS analysis_results (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            component_name TEXT UNIQUE,
            friendly_name TEXT,
            component_type TEXT,
            results_data TEXT,
            quality_score INTEGER,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    `);
    
    // Chat History table
    this.db.run(`
        CREATE TABLE IF NOT EXISTS chat_history (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            component_name TEXT,
            sender TEXT,
            content TEXT,
            timestamp TEXT,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    `);
    
    // Settings table
    this.db.run(`
        CREATE TABLE IF NOT EXISTS settings (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            key TEXT UNIQUE,
            value TEXT,
            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    `);

    // Friendly Names cache table
this.db.run(`
    CREATE TABLE IF NOT EXISTS friendly_names (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        tech_name TEXT UNIQUE,
        friendly_name TEXT,
        source TEXT DEFAULT 'LLM',
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )
`);

}

            // Initialize Event Listeners
            initializeEventListeners() {
                // Component Analysis
                const componentInput = document.getElementById('componentName');
                const friendlyNameInput = document.getElementById('friendlyName');
                const analyzeBtn = document.getElementById('analyzeComponentBtn');
                
                if (componentInput) {
                    componentInput.addEventListener('input', () => this.onComponentInput());
                }
                
                if (friendlyNameInput) {
                    friendlyNameInput.addEventListener('input', () => this.onFriendlyNameInput());
                }
                
                if (analyzeBtn) {
                    analyzeBtn.addEventListener('click', () => this.analyzeComponent());
                }
                
                // API Validation
                const validateBtn = document.getElementById('validateApiBtn');
                if (validateBtn) {
                    validateBtn.addEventListener('click', () => this.validateConnection());
                }
                
                // File Upload
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');
                
                if (uploadArea && fileInput) {
                    uploadArea.addEventListener('click', () => {
                        if (this.serverValidated) fileInput.click();
                    });
                    uploadArea.addEventListener('drop', (e) => this.handleFileDrop(e));
                    uploadArea.addEventListener('dragover', (e) => this.handleDragOver(e));
                    uploadArea.addEventListener('dragleave', (e) => this.handleDragLeave(e));
                    fileInput.addEventListener('change', (e) => this.handleFileSelect(e));
                }
                
                // Quick Actions
                const bulkBtn = document.getElementById('bulkAnalyzeBtn');
                const exportJsonBtn = document.getElementById('exportJsonBtn');
                const exportMdBtn = document.getElementById('exportMdBtn');
                const clearBtn = document.getElementById('clearBtn');
                
                if (bulkBtn) bulkBtn.addEventListener('click', () => this.bulkAnalyze());
                if (exportJsonBtn) exportJsonBtn.addEventListener('click', () => this.exportResults('json'));
                if (exportMdBtn) exportMdBtn.addEventListener('click', () => this.exportResults('markdown'));
                if (clearBtn) clearBtn.addEventListener('click', () => this.clearAllData());
                
                // Settings
                const endpointInput = document.getElementById('vllmEndpoint');
                const maxTokensInput = document.getElementById('maxTokens');
                
                if (endpointInput) {
                    endpointInput.addEventListener('input', () => this.onEndpointChange());
                }
                
                if (maxTokensInput) {
                    maxTokensInput.addEventListener('input', () => this.onSettingsChange());
                }
                
                // Hide suggestions when clicking outside
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('#componentName')) {
                        const suggestions = document.getElementById('componentSuggestions');
                        if (suggestions) suggestions.classList.remove('show');
                    }
                });
            }

            // Component Input Handler
            onComponentInput() {
                const input = document.getElementById('componentName');
                const suggestions = document.getElementById('componentSuggestions');
                
                if (!input || !suggestions) return;
                
                const value = input.value.trim().toUpperCase();
                
                if (value.length < 2) {
                    suggestions.classList.remove('show');
                    this.validateForm();
                    return;
                }
                
                const filtered = this.componentSuggestions.filter(item => 
                    item.name.includes(value)
                ).slice(0, 8);
                
                if (filtered.length > 0) {
                    let html = '';
                    filtered.forEach(item => {
                        const icon = this.getComponentIcon(item.type);
                        html += `
                            <div class="suggestion-item" onclick="analyzer.selectSuggestion('${item.name}')">
                                <span>${icon}</span>
                                <span class="suggestion-item-name">${item.name}</span>
                                <span class="suggestion-item-type">(${item.type})</span>
                                ${item.level ? `<span class="suggestion-item-badge">L${item.level}</span>` : ''}
                            </div>
                        `;
                    });
                    suggestions.innerHTML = html;
                    suggestions.classList.add('show');
                } else {
                    suggestions.classList.remove('show');
                }
                
                this.updateTokenDisplay();
                this.validateForm();
            }

            // Friendly Name Input Handler
            onFriendlyNameInput() {
                const input = document.getElementById('friendlyName');
                if (input) {
                    this.currentFriendlyName = input.value.trim() || null;
                }
            }

            // Select Component Suggestion
            selectSuggestion(componentName) {
                const input = document.getElementById('componentName');
                const suggestions = document.getElementById('componentSuggestions');
                
                if (input) input.value = componentName;
                if (suggestions) suggestions.classList.remove('show');
                
                this.validateForm();
                this.updateTokenDisplay();
            }

            // Get Component Icon
            getComponentIcon(type) {
                const icons = {
                    'RECORD_LAYOUT': 'üéØ',
                    'PROGRAM': 'üíº',
                    'COPYBOOK': 'üìö',
                    'FILE': 'üìÅ'
                };
                return icons[type] || 'üìã';
            }

            // Display Name Helper
            getDisplayName() {
                return this.currentFriendlyName || this.currentAnalyzedComponent || 'Component';
            }

            // Update Token Display
            updateTokenDisplay() {
                const input = document.getElementById('componentName');
                const tokenInfo = document.getElementById('tokenInfo');
                const tokenCount = document.getElementById('tokenCount');
                const tokenFill = document.getElementById('tokenFill');
                const tokenWarning = document.getElementById('tokenWarning');
                
                if (!input || !tokenInfo) return;
                
                const text = input.value;
                const estimatedTokens = Math.ceil(text.length / this.averageCharsPerToken);
                
                tokenInfo.style.display = 'block';
                tokenCount.textContent = `${estimatedTokens} / ${this.maxTokens}`;
                
                const percentage = (estimatedTokens / this.maxTokens) * 100;
                tokenFill.style.width = `${Math.min(percentage, 100)}%`;
                
                tokenFill.className = 'token-fill';
                if (percentage <= 50) {
                    tokenFill.classList.add('safe');
                    tokenWarning.textContent = 'üü¢ Optimal token usage';
                } else if (percentage <= 70) {
                    tokenFill.classList.add('warning');
                    tokenWarning.textContent = 'üü° Moderate usage';
                } else {
                    tokenFill.classList.add('danger');
                    tokenWarning.textContent = 'üî¥ High usage - consider simplifying';
                }
            }

            // Validate Form
            validateForm() {
                const hasFiles = this.uploadedFiles.length > 0;
                const hasComponent = document.getElementById('componentName')?.value.trim().length > 0;
                const hasConnection = this.serverValidated;
                
                const analyzeBtn = document.getElementById('analyzeComponentBtn');
                const bulkBtn = document.getElementById('bulkAnalyzeBtn');
                
                if (analyzeBtn) analyzeBtn.disabled = !(hasFiles && hasComponent && hasConnection);
                if (bulkBtn) bulkBtn.disabled = !(hasFiles && hasConnection);
                
                const hasResults = Object.keys(this.analysisResults).length > 0;
                const exportJsonBtn = document.getElementById('exportJsonBtn');
                const exportMdBtn = document.getElementById('exportMdBtn');
                
                if (exportJsonBtn) exportJsonBtn.disabled = !hasResults;
                if (exportMdBtn) exportMdBtn.disabled = !hasResults;
            }

            // Show/Hide Loading
            showLoading() {
                const loading = document.getElementById('loadingIndicator');
                if (loading) loading.classList.add('show');
            }

            hideLoading() {
                const loading = document.getElementById('loadingIndicator');
                if (loading) loading.classList.remove('show');
            }

            updateLoadingStatus(status) {
                const statusEl = document.getElementById('loadingStatus');
                if (statusEl) statusEl.textContent = status;
            }

            updateProgress(percentage) {
                const progressFill = document.getElementById('progressFill');
                if (progressFill) progressFill.style.width = `${percentage}%`;
            }

            // Alert Messages
            showMessage(type, message, duration = 3000) {
                const alert = document.createElement('div');
                alert.className = `alert alert-${type}`;
                alert.innerHTML = `
                    <span class="alert-icon">${type === 'success' ? '‚úÖ' : type === 'error' ? '‚ùå' : type === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è'}</span>
                    <span class="alert-message">${message}</span>
                `;
                document.body.appendChild(alert);
                
                setTimeout(() => {
                    if (alert.parentNode) {
                        alert.style.animation = 'slideInRight 0.3s ease reverse';
                        setTimeout(() => alert.remove(), 300);
                    }
                }, duration);
            }

            showSuccess(message) { this.showMessage('success', message); }
            showError(message) { this.showMessage('error', message, 5000); }
            showWarning(message) { this.showMessage('warning', message, 4000); }
            showInfo(message) { this.showMessage('info', message); }

           

            handleDragOver(e) {
                e.preventDefault();
                const uploadArea = document.getElementById('uploadArea');
                if (uploadArea) uploadArea.classList.add('drag-over');
            }

            handleDragLeave(e) {
                e.preventDefault();
                const uploadArea = document.getElementById('uploadArea');
                if (uploadArea) uploadArea.classList.remove('drag-over');
            }

           

            onEndpointChange() {
                this.serverValidated = false;
                this.updateConnectionStatus('disconnected', 'Connection not validated');
                this.validateForm();
            }

            onSettingsChange() {
                const maxTokensInput = document.getElementById('maxTokens');
                if (maxTokensInput) {
                    this.maxTokens = parseInt(maxTokensInput.value) || 4000;
                    this.saveToStorage();
                }
            }

            updateConnectionStatus(status, message) {
                const statusEl = document.getElementById('apiStatus');
                if (statusEl) {
                    statusEl.className = `status-indicator ${status}`;
                    statusEl.innerHTML = `
                        <span class="status-dot"></span>
                        <span>${message}</span>
                    `;
                }
            }

            bulkAnalyze() {
                this.showInfo('Bulk analysis feature coming soon');
            }

            exportResults(format) {
                this.showInfo(`Export as ${format} feature coming soon`);
            }

            clearAllData() {
                if (confirm('Are you sure you want to clear all data?')) {
                    this.uploadedFiles = [];
                    this.analysisResults = {};
                    localStorage.removeItem(this.storageKey);
                    this.showSuccess('All data cleared');
                    this.validateForm();
                }
            }
// ============================================
// PART 7: FILE HANDLING AND COMPONENT EXTRACTION
// Complete file upload, parsing, and component detection
// ============================================

// Add these methods to the EnhancedMainframeAnalyzer class

// File Upload Handling
async handleFileDrop(e) {
    e.preventDefault();
    e.stopPropagation();
    
    const uploadArea = document.getElementById('uploadArea');
    uploadArea.classList.remove('drag-over');
    
    if (!this.serverValidated) {
        this.showError('Please validate LLM API connection first');
        return;
    }
    
    const files = Array.from(e.dataTransfer.files);
    this.processFiles(files);
}

async handleFileSelect(e) {
    if (!this.serverValidated) {
        this.showError('Please validate LLM API connection first');
        return;
    }
    
    const files = Array.from(e.target.files);
    this.processFiles(files);
}

async processFiles(files) {
    for (const file of files) {
        try {
            const content = await this.readFile(file);
            const fileType = this.detectFileType(file.name, content);
            
            const fileObj = {
                name: file.name,
                content: content,
                size: file.size,
                type: fileType,
                uploadDate: new Date().toISOString(),
                id: Date.now() + Math.random(),
                components: this.extractComponentsFromFile(content, fileType)
            };
            
            this.uploadedFiles.push(fileObj);
            this.updateComponentSuggestions();
            
        } catch (error) {
            this.showError(`Failed to read ${file.name}: ${error.message}`);
        }
    }
    
    this.displayUploadedFiles();
    this.validateForm();
    this.saveToStorage();
    this.showSuccess(`üìÅ ${files.length} files uploaded successfully!`);
}

readFile(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = e => resolve(e.target.result);
        reader.onerror = e => reject(new Error('File read failed'));
        reader.readAsText(file);
    });
}

detectFileType(fileName, content) {
    const name = fileName.toLowerCase();
    const upperContent = content.toUpperCase();
    
    if (name.includes('.cpy') || name.includes('copybook')) {
        return 'Copybook';
    } else if (name.includes('.jcl') || upperContent.includes('//JOB ')) {
        return 'JCL Job';
    } else if (name.includes('.cbl') || name.includes('.cob') || 
              upperContent.includes('IDENTIFICATION DIVISION') ||
              upperContent.includes('PROGRAM-ID')) {
        return 'COBOL Program';
    } else if (name.includes('.proc')) {
        return 'JCL Procedure';
    } else {
        return 'Text File';
    }
}

// Extract Components from Files - CRITICAL FOR FIELD ANALYSIS
extractComponentsFromFile(content, fileType) {
    const components = [];
    const lines = content.split('\n');
    const upperContent = content.toUpperCase();

    lines.forEach((line, index) => {
        const trimmed = line.trim().toUpperCase();
        
        // Extract COBOL 01-level fields (main focus for copybooks)
        const field01Match = trimmed.match(/^\s*01\s+([A-Z][A-Z0-9\-_]{2,})/);
        if (field01Match) {
            components.push({
                name: field01Match[1],
                type: 'RECORD_LAYOUT',
                level: '01',
                lineNumber: index + 1,
                fileType: fileType,
                isMainComponent: true
            });
        }
        
        // Extract ALL field levels for complete analysis
        const fieldMatch = trimmed.match(/^\s*(\d{2})\s+([A-Z][A-Z0-9\-_]*)/);
        if (fieldMatch) {
            const level = parseInt(fieldMatch[1]);
            const fieldName = fieldMatch[2];
            
            if (level !== 88 && fieldName) { // Skip 88-level conditions
                components.push({
                    name: fieldName,
                    type: level === 1 ? 'RECORD_LAYOUT' : 'FIELD',
                    level: level,
                    lineNumber: index + 1,
                    fileType: fileType,
                    isMainComponent: level === 1
                });
            }
        }
        
        // Extract copybook names
        const copyMatch = trimmed.match(/COPY\s+([A-Z][A-Z0-9\-_]{2,})/);
        if (copyMatch) {
            components.push({
                name: copyMatch[1],
                type: 'COPYBOOK',
                lineNumber: index + 1,
                fileType: fileType,
                isMainComponent: false
            });
        }
        
        // Extract program names
        const programMatch = trimmed.match(/PROGRAM-ID\.?\s+([A-Z][A-Z0-9\-_]{2,})/);
        if (programMatch) {
            components.push({
                name: programMatch[1],
                type: 'PROGRAM',
                lineNumber: index + 1,
                fileType: fileType,
                isMainComponent: true
            });
        }

        // Extract file names from FD statements
        const fileMatch = trimmed.match(/FD\s+([A-Z][A-Z0-9\-_]{2,})/);
        if (fileMatch) {
            components.push({
                name: fileMatch[1],
                type: 'FILE',
                lineNumber: index + 1,
                fileType: fileType,
                isMainComponent: false
            });
        }
    });
    
    return components;
}

// Extract Detailed Field Information from Copybook
extractCopybookFields(copybookName, relevantFiles) {
    const fields = [];
    
    // Find the copybook file or file containing the copybook
    const copybookFile = relevantFiles.find(f => 
        f.type === 'Copybook' || 
        f.name.toUpperCase().includes(copybookName.toUpperCase()) ||
        (f.components && f.components.some(c => c.name.toUpperCase() === copybookName.toUpperCase()))
    );
    
    if (!copybookFile) {
        console.warn('Copybook file not found for:', copybookName);
        return fields;
    }

    const lines = copybookFile.content.split('\n');
    
    lines.forEach((line, index) => {
        const trimmed = line.trim();
        
        // Extract ALL field levels with complete details
        const fieldMatch = trimmed.match(/^\s*(\d{2})\s+([A-Z][A-Z0-9\-_]*)/);
        if (fieldMatch) {
            const level = parseInt(fieldMatch[1]);
            const fieldName = fieldMatch[2];
            
            // Skip 88-level conditions
            if (level === 88) return;
            
            // Extract PIC clause
            const picMatch = trimmed.match(/PIC\s+([X9VS\(\)]+)/i);
            const picture = picMatch ? picMatch[1] : '';
            
            // Extract VALUE clause
            const valueMatch = trimmed.match(/VALUE\s+([^.]+)/i);
            const value = valueMatch ? valueMatch[1].trim() : '';
            
            // Extract OCCURS clause
            const occursMatch = trimmed.match(/OCCURS\s+(\d+)/i);
            const occurs = occursMatch ? parseInt(occursMatch[1]) : 0;
            
            // Extract REDEFINES clause
            const redefinesMatch = trimmed.match(/REDEFINES\s+([A-Z][A-Z0-9\-_]*)/i);
            const redefines = redefinesMatch ? redefinesMatch[1] : '';
            
            // Determine field type
            const isRecordLayout = level === 1 && !picture && !value;
            const isGroupField = !picture && !value && level > 1;
            const isElementaryField = !!picture;
            const isConstant = !!value;
            
            fields.push({
                name: fieldName,
                level: level,
                picture: picture,
                value: value,
                occurs: occurs,
                redefines: redefines,
                isRecordLayout: isRecordLayout,
                isGroupField: isGroupField,
                isElementaryField: isElementaryField,
                isConstant: isConstant,
                lineNumber: index + 1,
                definition: trimmed,
                // Lifecycle tracking properties
                lifecycle: {
                    createdBy: [],
                    updatedBy: [],
                    readBy: [],
                    displayedBy: [],
                    validatedBy: []
                }
            });
        }
    });
    
    console.log(`Extracted ${fields.length} fields from copybook ${copybookName}`);
    return fields;
}

// Find Programs Using a Copybook
// Find Programs Using a Copybook
findProgramsUsingCopybook(copybookName) {
    const usingPrograms = [];
    const copybookUpper = copybookName.toUpperCase();
    const copybookBase = copybookUpper.replace(/\.(CPY|COPYBOOK|COP)$/, ''); // Remove extension
    
    this.uploadedFiles.forEach(file => {
        if (file.type === 'COBOL Program' || file.content.toUpperCase().includes('PROGRAM-ID')) {
            const content = file.content.toUpperCase();
            
            // Check for COPY statements with various patterns
            const copyPatterns = [
                // Direct matches
                `COPY ${copybookUpper}`,
                `COPY ${copybookBase}`,
                // With quotes/apostrophes
                `COPY "${copybookUpper}"`,
                `COPY "${copybookBase}"`,
                `COPY '${copybookUpper}'`,
                `COPY '${copybookBase}'`,
                // With periods
                `COPY ${copybookUpper}.`,
                `COPY ${copybookBase}.`,
                // Include statements
                `INCLUDE ${copybookUpper}`,
                `INCLUDE ${copybookBase}`
            ];
            
            const usesCopybook = copyPatterns.some(pattern => content.includes(pattern));
            
            if (usesCopybook) {
                console.log(`Program ${file.name} uses copybook ${copybookName} (matched as ${copybookBase})`);
                usingPrograms.push(file);
            }
        }
    });
    
    return usingPrograms;
}

// Analyze Field Usage in Program
analyzeFieldUsageInProgram(fieldName, programFile) {
    const usage = {
        fieldName: fieldName,
        programName: '',
        isRead: false,
        isWritten: false,
        isDisplayed: false,
        isInput: false,
        isValidated: false,
        isCalculated: false,
        operations: []
    };

    if (!programFile || !programFile.content) {
        console.warn('Program file or content is missing for field analysis');
        return usage;
    }

    const lines = programFile.content.split('\n');
    const upperContent = programFile.content.toUpperCase();
    const fieldUpper = fieldName.toUpperCase();
    
    // Get program name
    const programMatch = upperContent.match(/PROGRAM-ID\.?\s+([A-Z][A-Z0-9\-_]+)/);
    usage.programName = programMatch ? programMatch[1] : programFile.name.replace(/\.[^/.]+$/, "");

    lines.forEach((line, lineNum) => {
        const trimmed = line.trim().toUpperCase();
        
        // Skip if line doesn't contain our field
        if (!trimmed.includes(fieldUpper)) {
            return;
        }

        // MOVE operations (reading/writing)
        if (trimmed.includes('MOVE')) {
            const moveFromMatch = trimmed.match(new RegExp(`MOVE\\s+${fieldUpper}\\s+TO\\s+([A-Z][A-Z0-9\\-_]+)`));
            const moveToMatch = trimmed.match(new RegExp(`MOVE\\s+([A-Z][A-Z0-9\\-_]+)\\s+TO\\s+${fieldUpper}`));
            
            if (moveFromMatch) {
                usage.isRead = true;
                usage.operations.push({
                    type: 'read',
                    operation: 'MOVE FROM',
                    line: lineNum + 1,
                    context: trimmed.substring(0, 80),
                    target: moveFromMatch[1]
                });
            }
            
            if (moveToMatch) {
                usage.isWritten = true;
                usage.operations.push({
                    type: 'write',
                    operation: 'MOVE TO',
                    line: lineNum + 1,
                    context: trimmed.substring(0, 80),
                    source: moveToMatch[1]
                });
            }
        }

        // DISPLAY operations
        if (trimmed.includes('DISPLAY') && trimmed.includes(fieldUpper)) {
            usage.isDisplayed = true;
            usage.operations.push({
                type: 'display',
                operation: 'DISPLAY',
                line: lineNum + 1,
                context: trimmed.substring(0, 80)
            });
        }

        // ACCEPT operations
        if (trimmed.includes('ACCEPT') && trimmed.includes(fieldUpper)) {
            usage.isInput = true;
            usage.operations.push({
                type: 'input',
                operation: 'ACCEPT',
                line: lineNum + 1,
                context: trimmed.substring(0, 80)
            });
        }

        // IF/WHEN conditions
        if ((trimmed.includes('IF') || trimmed.includes('WHEN')) && trimmed.includes(fieldUpper)) {
            usage.isValidated = true;
            usage.operations.push({
                type: 'validation',
                operation: 'CONDITION',
                line: lineNum + 1,
                context: trimmed.substring(0, 80)
            });
        }

        // Calculations
        const calcOperations = ['COMPUTE', 'ADD', 'SUBTRACT', 'MULTIPLY', 'DIVIDE'];
        for (const op of calcOperations) {
            if (trimmed.includes(op) && trimmed.includes(fieldUpper)) {
                usage.isCalculated = true;
                usage.operations.push({
                    type: 'calculation',
                    operation: op,
                    line: lineNum + 1,
                    context: trimmed.substring(0, 80)
                });
                break;
            }
        }

        // CICS operations
        if (trimmed.includes('EXEC CICS')) {
            if (trimmed.includes('SEND MAP') && trimmed.includes(fieldUpper)) {
                usage.isDisplayed = true;
                usage.operations.push({
                    type: 'cics_output',
                    operation: 'CICS SEND MAP',
                    line: lineNum + 1,
                    context: trimmed.substring(0, 80)
                });
            }
            
            if (trimmed.includes('RECEIVE MAP') && trimmed.includes(fieldUpper)) {
                usage.isInput = true;
                usage.operations.push({
                    type: 'cics_input',
                    operation: 'CICS RECEIVE MAP',
                    line: lineNum + 1,
                    context: trimmed.substring(0, 80)
                });
            }
        }

        // File operations
        if (trimmed.includes('WRITE') && trimmed.includes(fieldUpper)) {
            usage.isWritten = true;
            usage.operations.push({
                type: 'file_write',
                operation: 'WRITE',
                line: lineNum + 1,
                context: trimmed.substring(0, 80)
            });
        }

        if (trimmed.includes('READ') && trimmed.includes(fieldUpper)) {
            usage.isRead = true;
            usage.operations.push({
                type: 'file_read',
                operation: 'READ',
                line: lineNum + 1,
                context: trimmed.substring(0, 80)
            });
        }
  

    // PERFORM statements with business logic
if (trimmed.includes('PERFORM') && trimmed.includes(fieldUpper)) {
    usage.isValidated = true;
    usage.operations.push({
        type: 'business_logic',
        operation: 'PERFORM',
        line: lineNum + 1,
        context: trimmed.substring(0, 100)
    });
}

// Business rule validations
const businessRulePatterns = [
    /IF\s+.*${fieldUpper}.*\s+(>|<|=|NOT)/,
    /WHEN\s+.*${fieldUpper}.*\s+(>|<|=|NOT)/,
    /EVALUATE\s+.*${fieldUpper}/,
    /SEARCH\s+.*${fieldUpper}/
];

businessRulePatterns.forEach((pattern, index) => {
    if (pattern.test(trimmed.replace('${fieldUpper}', fieldUpper))) {
        usage.isValidated = true;
        usage.operations.push({
            type: 'business_rule',
            operation: ['CONDITION', 'WHEN_CONDITION', 'EVALUATE', 'SEARCH'][index],
            line: lineNum + 1,
            context: trimmed.substring(0, 100),
            ruleType: 'validation'
        });
    }
});

// Data transformation logic
if ((trimmed.includes('STRING') || trimmed.includes('UNSTRING') || 
     trimmed.includes('INSPECT') || trimmed.includes('TRANSFORM')) && 
    trimmed.includes(fieldUpper)) {
    usage.isCalculated = true;
    usage.operations.push({
        type: 'transformation',
        operation: 'DATA_TRANSFORMATION',
        line: lineNum + 1,
        context: trimmed.substring(0, 100)
    });
}
});
    return usage;
}

// Update Component Suggestions
updateComponentSuggestions() {
    this.componentSuggestions = [];
    
    this.uploadedFiles.forEach(file => {
        if (file.components) {
            file.components.forEach(component => {
                // Focus on main components and fields
                if (component.isMainComponent || component.type === 'FIELD') {
                    this.componentSuggestions.push({
                        name: component.name,
                        type: component.type,
                        level: component.level,
                        file: file.name,
                        fileType: file.type,
                        lineNumber: component.lineNumber
                    });
                }
            });
        }
    });
    
    // Remove duplicates and sort by importance
    this.componentSuggestions = this.componentSuggestions
        .filter((item, index, self) => 
            index === self.findIndex(t => t.name === item.name && t.type === item.type)
        )
        .sort((a, b) => {
            // Prioritize 01-level fields and programs
            if (a.type === 'RECORD_LAYOUT' && b.type !== 'RECORD_LAYOUT') return -1;
            if (b.type === 'RECORD_LAYOUT' && a.type !== 'RECORD_LAYOUT') return 1;
            if (a.type === 'PROGRAM' && b.type !== 'PROGRAM') return -1;
            if (b.type === 'PROGRAM' && a.type !== 'PROGRAM') return 1;
            return a.name.localeCompare(b.name);
        });
}

// Display Uploaded Files
displayUploadedFiles() {
    const container = document.getElementById('uploadedFiles');
    if (!container) return;
    
    if (this.uploadedFiles.length === 0) {
        container.innerHTML = '';
        return;
    }
    
    let html = '';
    this.uploadedFiles.forEach(file => {
        const mainComponents = file.components ? 
            file.components.filter(c => c.isMainComponent).length : 0;
        const totalComponents = file.components ? file.components.length : 0;
        const fieldCount = file.components ? 
            file.components.filter(c => c.type === 'FIELD' || c.type === 'RECORD_LAYOUT').length : 0;
        
        html += `
            <div class="file-item">
                <div class="file-info">
                    <div class="file-icon">${this.getFileIcon(file.type)}</div>
                    <div class="file-details">
                        <div class="file-name">${file.name}</div>
                        <div class="file-meta">
                            ${file.type} ‚Ä¢ ${Math.round(file.size/1024)}KB
                            ${fieldCount > 0 ? ` ‚Ä¢ ${fieldCount} fields` : ''}
                            ${mainComponents > 0 ? ` ‚Ä¢ ${mainComponents} main` : ''}
                        </div>
                    </div>
                </div>
                <button class="file-remove" onclick="analyzer.removeFile('${file.id}')">√ó</button>
            </div>
        `;
    });
    
    container.innerHTML = html;
}

getFileIcon(type) {
    const icons = {
        'Copybook': 'üìö',
        'COBOL Program': 'üíº',
        'JCL Job': 'üìã',
        'JCL Procedure': '‚öôÔ∏è',
        'Text File': 'üìÑ'
    };
    return icons[type] || 'üìÅ';
}

removeFile(fileId) {
    this.uploadedFiles = this.uploadedFiles.filter(f => f.id != fileId);
    this.displayUploadedFiles();
    this.updateComponentSuggestions();
    this.validateForm();
    this.saveToStorage();
}

// Find Relevant Files for Component
// Find Relevant Files for Component
findRelevantFiles(componentName) {
    const componentUpper = componentName.toUpperCase();
    const componentBase = componentUpper.replace(/\.(CPY|COPYBOOK|COP)$/, ''); // Remove extensions
    
    return this.uploadedFiles.filter(file => {
        const fileNameUpper = file.name.toUpperCase();
        const fileNameBase = fileNameUpper.replace(/\.(CPY|COPYBOOK|COP)$/, '');
        
        // Direct name match (with or without extensions)
        if (fileNameUpper.includes(componentUpper) || 
            fileNameBase === componentBase ||
            componentBase === fileNameBase) {
            return true;
        }
        
        // Content-based matching with variations
        const contentUpper = file.content.toUpperCase();
        if (contentUpper.includes(componentUpper) ||
            contentUpper.includes(componentBase) ||
            contentUpper.includes(`COPY ${componentBase}`) ||
            contentUpper.includes(`"${componentBase}"`) ||
            contentUpper.includes(`'${componentBase}'`)) {
            return true;
        }
        
        // Check if any component in the file matches (with variations)
        if (file.components) {
            return file.components.some(comp => {
                const compNameUpper = comp.name.toUpperCase();
                const compNameBase = compNameUpper.replace(/\.(CPY|COPYBOOK|COP)$/, '');
                return compNameUpper === componentUpper || 
                       compNameBase === componentBase ||
                       componentBase === compNameBase;
            });
        }
        
        return false;
    });
}

// Detect Component Type
detectComponentType(componentName, files) {
    // Check if it's a field or record layout
    for (const file of files) {
        if (file.components) {
            const component = file.components.find(c => 
                c.name.toUpperCase() === componentName.toUpperCase()
            );
            if (component) {
                if (component.type === 'RECORD_LAYOUT') return 'Copybook';
                if (component.type === 'FIELD') return 'Field';
                if (component.type === 'PROGRAM') return 'COBOL Program';
                if (component.type === 'FILE') return 'File Definition';
            }
        }
    }
    
    // Fallback to file type detection
    const copybookFile = files.find(f => f.type === 'Copybook');
    if (copybookFile) return 'Copybook';
    
    const programFile = files.find(f => f.type === 'COBOL Program');
    if (programFile) return 'COBOL Program';
    
    return 'Component';
}
// ============================================
// PART 8: LLM CONNECTION AND API VALIDATION
// Complete LLM server validation and API calls
// ============================================

// Add these methods to the EnhancedMainframeAnalyzer class

// Validate LLM Connection
async validateConnection() {
    const endpoint = document.getElementById('vllmEndpoint').value.trim();
    if (!endpoint) {
        this.showError('Please enter vLLM endpoint');
        return;
    }

    this.updateConnectionStatus('connecting', 'Testing LLM connection...');

    try {
        const response = await fetch(`${endpoint}/generate`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                prompt: "Test connection. Respond with 'Connected'",
                max_tokens: 10,
                temperature: 0.1
            }),
            signal: AbortSignal.timeout(10000)
        });

        if (response.ok) {
            const data = await response.json();
            this.serverValidated = true;
            this.vllmEndpoint = endpoint;
            this.updateConnectionStatus('connected', `‚úÖ LLM connection verified`);
            this.showSuccess('üöÄ vLLM server connected successfully!');
            
            // Enable file upload area
            const uploadArea = document.getElementById('uploadArea');
            if (uploadArea) {
                uploadArea.style.opacity = '1';
                uploadArea.style.cursor = 'pointer';
            }
        } else {
            throw new Error(`HTTP ${response.status}`);
        }
    } catch (error) {
        this.serverValidated = false;
        this.updateConnectionStatus('disconnected', `‚ùå Connection failed: ${error.message}`);
        this.showError(`LLM connection failed: ${error.message}`);
    }
    
    this.validateForm();
}

// Call LLM API with retry logic
async callLLMAPI(prompt, retries = 0) {
    let resultText = '';
    
    try {
        console.log(`Making LLM API call attempt ${retries + 1}...`);
        
        const response = await fetch(`${this.vllmEndpoint}/generate`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                prompt: prompt,
                max_tokens: Math.min(this.maxTokens * 0.8, 4000),
                temperature: 0.1,
                top_p: 0.9,
                stop: [],
                stream: false,
                frequency_penalty: 0.1,
                presence_penalty: 0.0
            }),
            signal: AbortSignal.timeout(60000) // 60 second timeout
        });

        if (!response.ok) {
            throw new Error(`LLM API request failed: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();
        console.log('LLM API Response received');
        
        // Extract text from various response formats
        if (data.text) {
            resultText = data.text.trim();
        } else if (data.choices && data.choices.length > 0) {
            if (data.choices[0].text) {
                resultText = data.choices[0].text.trim();
            } else if (data.choices[0].message && data.choices[0].message.content) {
                resultText = data.choices[0].message.content.trim();
            }
        } else if (data.generated_text) {
            resultText = data.generated_text.trim();
        } else if (data.response) {
            resultText = data.response.trim();
        } else if (typeof data === 'string') {
            resultText = data.trim();
        }

        if (!resultText) {
            throw new Error('No valid text content in LLM response');
        }

        console.log(`LLM response length: ${resultText.length} chars`);

        // Parse the response
        const parseResult = this.parseJSONResponse(resultText);
        
        if (parseResult.success) {
            console.log('LLM JSON parsing successful');
            return parseResult.data;
        } else {
            console.warn('LLM JSON parsing failed, using fallback');
            if (parseResult.fallbackData) {
                parseResult.fallbackData.rawResponse = resultText.substring(0, 1000);
                parseResult.fallbackData.parseError = parseResult.error;
                return parseResult.fallbackData;
            } else {
                throw new Error(`JSON parsing failed: ${parseResult.error}`);
            }
        }

    } catch (error) {
        console.error(`LLM API call attempt ${retries + 1} failed:`, error);
        
        if (retries < 2) { // Max 3 attempts
            console.log(`Retrying LLM API call (${retries + 1}/2)...`);
            await this.sleep(2000 * (retries + 1)); // Exponential backoff
            return this.callLLMAPI(prompt, retries + 1);
        }
        
        // Final fallback
        return {
            error: true,
            message: error.message,
            fallbackData: this.createComponentFallback(
                this.currentAnalyzedComponent || 'Unknown',
                'Unknown',
                null
            )
        };
    }
}

// Parse JSON Response from LLM
// Parse JSON Response from LLM
parseJSONResponse(text) {
    if (!text || typeof text !== 'string') {
        return { 
            success: false, 
            error: 'No text provided', 
            fallbackData: this.createBasicFallback() 
        };
    }

    console.log('Parsing LLM response...');
    console.log('Raw LLM response:', text.substring(0, 500) + '...');

    // Try direct JSON parsing first
    try {
        const directParse = JSON.parse(text);
        if (directParse && typeof directParse === 'object') {
            console.log('‚úÖ Direct JSON parsing successful!');
            return { success: true, data: directParse };
        }
    } catch (e) {
        console.log('Direct JSON parsing failed:', e.message);
    }

    // Try to extract JSON from text with better patterns
    const jsonPatterns = [
        // Standard JSON block
        /\{[\s\S]*\}/,
        // JSON with markdown code blocks
        /```(?:json)?\s*(\{[\s\S]*?\})\s*```/,
        // JSON with backticks
        /`(\{[\s\S]*?\})`/
    ];
    
    for (const pattern of jsonPatterns) {
        const match = text.match(pattern);
        if (match) {
            const jsonCandidate = match[1] || match[0];
            console.log('Found JSON candidate:', jsonCandidate.substring(0, 200) + '...');
            
            try {
                const cleaned = this.cleanJSONText(jsonCandidate);
                const parsed = JSON.parse(cleaned);
                if (parsed && typeof parsed === 'object') {
                    console.log('‚úÖ Pattern-based JSON parsing successful!');
                    return { success: true, data: parsed };
                }
            } catch (e) {
                console.log('Pattern parsing failed:', e.message);
                continue;
            }
        }
    }

    // Enhanced extraction from visible structured data like in your image
    console.log('Attempting structured data extraction from response...');
    
    const componentName = this.currentAnalyzedComponent || 'Unknown';
    const friendlyName = this.currentFriendlyName || componentName;
    
    // Extract structured data from the LLM response
    const structuredResponse = this.extractStructuredDataFromResponse(text, componentName, friendlyName);
    
    return { 
        success: true, 
        data: structuredResponse,
        source: 'StructuredExtraction'
    };
}

// Clean JSON Text
cleanJSONText(text) {
    if (!text) return '{}';
    
    return text
        // Remove trailing commas
        .replace(/,(\s*[\}\]])/g, '$1')
        // Fix unquoted property names
        .replace(/([{,]\s*)([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g, '$1"$2":')
        // Fix single quotes to double quotes
        .replace(/'/g, '"')
        // Remove comments
        .replace(/\/\/.*$/gm, '')
        .replace(/\/\*[\s\S]*?\*\//g, '')
        // Fix line breaks in strings
        .replace(/"\s*\n\s*"/g, '" + "');
}

// Extract field count from text
extractFieldCount(text) {
    const fieldMatches = text.match(/\b[A-Z][A-Z0-9\-_]{3,}\b/g) || [];
    return Math.min(fieldMatches.length, 50);
}

// Extract fields from text
extractFieldsFromText(text) {
    const fields = [];
    const fieldNames = new Set();
    
    // Look for field patterns
    const patterns = [
        /field[:\s]+([A-Z][A-Z0-9\-_]{2,})/gi,
        /"([A-Z][A-Z0-9\-_]{3,})"/g,
        /\b([A-Z][A-Z0-9\-_]{4,})\b/g
    ];
    
    patterns.forEach(pattern => {
        let match;
        while ((match = pattern.exec(text)) !== null) {
            const fieldName = match[1];
            
            if (!fieldNames.has(fieldName) && fieldName.length >= 3 && fieldName.length <= 30) {
                fieldNames.add(fieldName);
                fields.push({
                    name: fieldName,
                    level: fieldName.includes('-RECORD') ? 1 : 5,
                    businessPurpose: this.generateFieldPurpose(fieldName),
                    usagePattern: 'ANALYZED'
                });
            }
        }
    });
    
    return Array.from(fields).slice(0, 20);
}

// Generate field purpose from name
generateFieldPurpose(fieldName) {
    if (fieldName.includes('RECORD') || fieldName.includes('REC')) {
        return `Main record structure for ${fieldName.toLowerCase().replace(/-/g, ' ')} data`;
    } else if (fieldName.includes('ID') || fieldName.includes('KEY')) {
        return `Unique identifier for ${fieldName.toLowerCase().replace(/-/g, ' ')}`;
    } else if (fieldName.includes('DATE') || fieldName.includes('TIME')) {
        return `Date/time field for ${fieldName.toLowerCase().replace(/-/g, ' ')} tracking`;
    } else if (fieldName.includes('AMT') || fieldName.includes('AMOUNT')) {
        return `Monetary amount for ${fieldName.toLowerCase().replace(/-/g, ' ')}`;
    } else if (fieldName.includes('DESC') || fieldName.includes('NAME')) {
        return `Descriptive text for ${fieldName.toLowerCase().replace(/-/g, ' ')}`;
    } else if (fieldName.includes('FLAG') || fieldName.includes('IND')) {
        return `Status indicator for ${fieldName.toLowerCase().replace(/-/g, ' ')}`;
    } else if (fieldName.includes('CODE') || fieldName.includes('CD')) {
        return `Coded value for ${fieldName.toLowerCase().replace(/-/g, ' ')}`;
    } else if (fieldName.includes('COUNT') || fieldName.includes('CNT')) {
        return `Counter/number field for ${fieldName.toLowerCase().replace(/-/g, ' ')}`;
    } else {
        return `Business data field for ${fieldName.toLowerCase().replace(/-/g, ' ')} processing`;
    }
}

// Extract recommendations from text
extractRecommendationsFromText(text) {
    const recommendations = [];
    
    // Look for recommendation patterns
    const patterns = [
        /recommend[a-z]*[:\s]*([^.]+)/gi,
        /suggest[a-z]*[:\s]*([^.]+)/gi,
        /should[:\s]*([^.]+)/gi,
        /consider[:\s]*([^.]+)/gi
    ];
    
    for (const pattern of patterns) {
        let match;
        while ((match = pattern.exec(text)) !== null && recommendations.length < 5) {
            const rec = match[1].trim();
            if (rec.length > 10 && rec.length < 200) {
                recommendations.push(rec);
            }
        }
    }
    
    // If no patterns found, provide generic recommendations
    if (recommendations.length === 0) {
        recommendations.push(
            'Review the component structure and dependencies',
            'Validate field usage patterns across programs',
            'Check for missing dependencies and resolve them',
            'Consider optimization opportunities based on usage patterns',
            'Document business rules and field relationships'
        );
    }
    
    return recommendations.slice(0, 5);
}

// Detect component type from text
detectComponentTypeFromText(text) {
    const upperText = text.toUpperCase();
    
    if (upperText.includes('COPYBOOK') || upperText.includes('RECORD')) {
        return 'Copybook';
    } else if (upperText.includes('PROGRAM') || upperText.includes('COBOL')) {
        return 'COBOL Program';
    } else if (upperText.includes('JCL') || upperText.includes('JOB')) {
        return 'JCL Job';
    } else {
        return 'Component';
    }
}

// Create component fallback
createComponentFallback(componentName, componentType, lifecycleFlow) {
    const friendlyName = this.currentFriendlyName || componentName;
    
    const fallback = {
        componentName: componentName,
        friendlyName: friendlyName,
        componentType: componentType,
        analysisScope: 'FALLBACK_ANALYSIS',
        status: 'LLM analysis failed - using extracted data',
        totalFields: 0,
        recommendations: [
            'Check LLM server connection and configuration',
            'Verify component exists in uploaded files',
            'Try simplifying the analysis scope',
            'Use chat interface for specific questions',
            'Review the extracted data for accuracy'
        ],
        qualityScore: 3
    };

    // Add lifecycle data if available
    if (lifecycleFlow) {
        fallback.lifecycleAnalysis = {
            creationPrograms: lifecycleFlow.creationSources?.map(s => s.program) || [],
            updatePrograms: lifecycleFlow.updatePrograms?.map(u => u.program) || [],
            readPrograms: lifecycleFlow.inputPrograms?.map(i => i.program) || []
        };
        
        if (lifecycleFlow.primaryFields) {
            fallback.totalFields = lifecycleFlow.primaryFields.length;
            fallback.primaryFields = lifecycleFlow.primaryFields.map(f => ({
                name: f.name,
                level: f.level,
                isRecordLayout: f.isRecordLayout,
                businessPurpose: 'Analysis failed - check component manually',
                usagePattern: 'UNKNOWN'
            }));
        }
    }

    return fallback;
}

// Create basic fallback
createBasicFallback() {
    return {
        componentName: 'Unknown',
        friendlyName: 'Unknown',
        componentType: 'Unknown',
        status: 'No data available',
        recommendations: ['Upload files and analyze component'],
        qualityScore: 1
    };
}

// Storage Management
// Save to SQLite Database
async saveToStorage() {
    if (!this.dbInitialized || !this.db) {
        // Fallback to localStorage
        try {
            const data = {
                uploadedFiles: this.uploadedFiles,
                analysisResults: this.analysisResults,
                chatHistory: this.chatHistory,
                vllmEndpoint: this.vllmEndpoint,
                maxTokens: this.maxTokens,
                timestamp: new Date().toISOString()
            };
            localStorage.setItem('enhanced_mainframe_analysis', JSON.stringify(data));
        } catch (error) {
            console.warn('Failed to save to localStorage:', error);
        }
        return;
    }

    try {
        // Save uploaded files
        this.db.run("DELETE FROM uploaded_files");
        for (const file of this.uploadedFiles) {
            this.db.run(`
                INSERT INTO uploaded_files (file_id, name, content, size, type, upload_date, components)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            `, [
                file.id, 
                file.name, 
                file.content, 
                file.size, 
                file.type, 
                file.uploadDate, 
                JSON.stringify(file.components || [])
            ]);
        }
        
        // Save analysis results
        this.db.run("DELETE FROM analysis_results");
        for (const [componentName, results] of Object.entries(this.analysisResults)) {
            this.db.run(`
                INSERT OR REPLACE INTO analysis_results 
                (component_name, friendly_name, component_type, results_data, quality_score)
                VALUES (?, ?, ?, ?, ?)
            `, [
                componentName,
                results.friendlyName || componentName,
                results.componentType,
                JSON.stringify(results),
                results.qualityScore || 0
            ]);
        }
        
        // Save chat history
        this.db.run("DELETE FROM chat_history");
        for (const chat of this.chatHistory) {
            this.db.run(`
                INSERT INTO chat_history (component_name, sender, content, timestamp)
                VALUES (?, ?, ?, ?)
            `, [
                this.currentAnalyzedComponent || 'general',
                chat.sender,
                chat.content,
                chat.timestamp
            ]);
        }
        
        // Save settings
        this.db.run("INSERT OR REPLACE INTO settings (key, value) VALUES (?, ?)", 
                   ['vllmEndpoint', this.vllmEndpoint]);
        this.db.run("INSERT OR REPLACE INTO settings (key, value) VALUES (?, ?)", 
                   ['maxTokens', this.maxTokens.toString()]);
        
        // Save database to localStorage as backup
        const data = this.db.export();
        localStorage.setItem('mainframe_analyzer_db', JSON.stringify(Array.from(data)));
        
        console.log('‚úÖ Data saved to SQLite database');
        
    } catch (error) {
        console.error('Failed to save to database:', error);
    }
    try {
                // Save friendly name cache to database
        this.db.run("DELETE FROM friendly_names");
        for (const [techName, friendlyName] of this.friendlyNameCache) {
            this.db.run(`
                INSERT INTO friendly_names (tech_name, friendly_name, source, created_at)
                VALUES (?, ?, ?, ?)
            `, [techName, friendlyName, 'LLM', new Date().toISOString()]);
        }
                console.log('‚úÖ Friendly name cache saved to database');
            } catch (error) {
                console.error('Failed to save friendly name cache:', error);
    }
}

// Load from SQLite Database
async loadStoredData() {
    if (!this.dbInitialized || !this.db) {
        // Fallback to localStorage
        try {
            const stored = localStorage.getItem('enhanced_mainframe_analysis');
            if (stored) {
                const data = JSON.parse(stored);
                this.uploadedFiles = data.uploadedFiles || [];
                this.analysisResults = data.analysisResults || {};
                this.chatHistory = data.chatHistory || [];
                
                if (data.vllmEndpoint) this.vllmEndpoint = data.vllmEndpoint;
                if (data.maxTokens) this.maxTokens = data.maxTokens;
                
                this.updateUIFromLoadedData(data);
                console.log('üìÅ Data loaded from localStorage fallback');
            }
        } catch (error) {
            console.warn('Failed to load from localStorage:', error);
        }
        return;
    }

    try {
        // Load uploaded files
        const filesResult = this.db.exec("SELECT * FROM uploaded_files ORDER BY created_at");
        if (filesResult.length > 0) {
            this.uploadedFiles = filesResult[0].values.map(row => ({
                id: row[1],
                name: row[2],
                content: row[3],
                size: row[4],
                type: row[5],
                uploadDate: row[6],
                components: JSON.parse(row[7] || '[]')
            }));
        }
        
        // Load analysis results
        const resultsQuery = this.db.exec("SELECT * FROM analysis_results ORDER BY updated_at DESC");
        if (resultsQuery.length > 0) {
            resultsQuery[0].values.forEach(row => {
                const componentName = row[1];
                const resultsData = JSON.parse(row[4]);
                this.analysisResults[componentName] = resultsData;
            });
        }
        
        // Load chat history
        const chatQuery = this.db.exec("SELECT * FROM chat_history ORDER BY created_at");
        if (chatQuery.length > 0) {
            this.chatHistory = chatQuery[0].values.map(row => ({
                sender: row[2],
                content: row[3],
                timestamp: row[4]
            }));
        }
        
        // Load settings
        const settingsQuery = this.db.exec("SELECT key, value FROM settings");
        if (settingsQuery.length > 0) {
            settingsQuery[0].values.forEach(row => {
                const [key, value] = row;
                if (key === 'vllmEndpoint') this.vllmEndpoint = value;
                if (key === 'maxTokens') this.maxTokens = parseInt(value);
            });
        }
        
        this.updateUIFromLoadedData();
        console.log('‚úÖ Data loaded from SQLite database');
        
    } catch (error) {
        console.error('Failed to load from database:', error);
    }


    // Load friendly name cache
        const friendlyNamesQuery = this.db.exec("SELECT tech_name, friendly_name FROM friendly_names");
        if (friendlyNamesQuery.length > 0) {
            friendlyNamesQuery[0].values.forEach(row => {
                this.friendlyNameCache.set(row[0], row[1]);
            });
        }
}

// Update UI from loaded data
updateUIFromLoadedData() {
    // Update UI elements
    const endpointInput = document.getElementById('vllmEndpoint');
    const maxTokensInput = document.getElementById('maxTokens');
    
    if (endpointInput) endpointInput.value = this.vllmEndpoint;
    if (maxTokensInput) maxTokensInput.value = this.maxTokens;
    
    this.displayUploadedFiles();
    this.updateComponentSuggestions();
    this.validateForm();
}

// Utility function
sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
// ============================================
// PART 9: MAIN COMPONENT ANALYSIS LOGIC
// Complete analysis workflow with field extraction
// ============================================

// Add these methods to the EnhancedMainframeAnalyzer class

// Main Component Analysis Method
async analyzeComponent() {
    const componentName = document.getElementById('componentName').value.trim();
    const friendlyName = document.getElementById('friendlyName').value.trim();
    
    if (!componentName) {
        this.showError('Please enter a component name');
        return;
    }

    if (!this.serverValidated) {
        this.showError('Please validate LLM server connection first');
        return;
    }

    this.currentAnalyzedComponent = componentName;
    this.currentFriendlyName = friendlyName || componentName;

    this.showLoading();
    this.updateProgress(0);

    try {
        console.log(`=== Starting Analysis for Component: ${componentName} ===`);
        console.log(`Friendly Name: ${this.currentFriendlyName}`);
        
        this.updateLoadingStatus('üöÄ Initializing component analysis...');
        
        // Check if component exists in uploaded files
        const relevantFiles = this.findRelevantFiles(componentName);
        if (relevantFiles.length === 0) {
            throw new Error(`Component "${componentName}" not found in uploaded files. Please check the component name and ensure related files are uploaded.`);
        }

        console.log(`Found ${relevantFiles.length} relevant files:`, relevantFiles.map(f => f.name));

        // Run the analysis
        const results = await this.runComprehensiveAnalysis(componentName, relevantFiles);
        
        // Store results
        this.analysisResults[componentName] = results;
        
        // Update UI with results
        this.displayAnalysisResults(componentName, results);
        
        // Enable chat
        this.enableChat();
        
        // Save to storage
        this.saveToStorage();
        
        this.hideLoading();
        
        // Show success with details
        const displayName = this.getDisplayName();
        const successMessage = `‚úÖ Analysis complete for ${displayName}! 
        Quality: ${results.qualityScore}/10 | 
        Files: ${results.filesAnalyzed.length} | 
        Fields: ${results.totalFields || 0}`;
        
        this.showSuccess(successMessage);
        
        console.log(`=== Analysis Complete for ${componentName} ===`);
        
    } catch (error) {
        this.hideLoading();
        console.error('Component analysis failed:', error);
        this.showError(`Analysis failed: ${error.message}`);
    }
}

// Run Comprehensive Analysis
async runComprehensiveAnalysis(componentName, relevantFiles) {
    console.log(`Starting comprehensive analysis for: ${componentName}`);
    
    try {
        // Stage 1: Detect component type
        this.updateLoadingStatus('üîç Stage 1: Detecting component type...');
        this.updateProgress(10);
        
        const componentType = this.detectComponentType(componentName, relevantFiles);
        console.log(`Component type: ${componentType}`);

        // Stage 2: Extract dependencies
        this.updateLoadingStatus('üîó Stage 2: Analyzing dependencies...');
        this.updateProgress(25);
        
        const dependencyAnalysis = await this.extractDependencies(relevantFiles);

        // Stage 3: Extract fields (for copybooks and programs)
        this.updateLoadingStatus('üìã Stage 3: Extracting fields...');
        this.updateProgress(40);
        
        let fieldAnalysis = null;
        if (componentType === 'Copybook' || componentType === 'Field') {
            fieldAnalysis = await this.analyzeFieldsInComponent(componentName, relevantFiles);
        }

        // Stage 4: Extract lifecycle flow
        this.updateLoadingStatus('üåä Stage 4: Analyzing lifecycle...');
        this.updateProgress(55);
        
        const lifecycleFlow = await this.extractLifecycleFlow(componentName, relevantFiles, fieldAnalysis);
        // Stage 4.5: Extract dependency flow
        this.updateLoadingStatus('üó∫Ô∏è Stage 4.5: Mapping dependency flow...');
        this.updateProgress(60);

        const dependencyFlow = await this.extractDependencyFlow(componentName, relevantFiles, this.uploadedFiles);
        // Stage 5: LLM analysis
        this.updateLoadingStatus('ü§ñ Stage 5: Running LLM analysis...');
        this.updateProgress(70);
        
        let llmAnalysis = null;
        try {
            if (componentType === 'Copybook' || componentType === 'Field') {
                llmAnalysis = await this.analyzeCopybookWithLLM(
                    componentName, relevantFiles, dependencyAnalysis, lifecycleFlow, fieldAnalysis
                );
            } else if (componentType === 'COBOL Program') {
                llmAnalysis = await this.analyzeProgramWithLLM(
                    componentName, relevantFiles, dependencyAnalysis, lifecycleFlow
                );
            } else {
                llmAnalysis = await this.analyzeGenericComponentWithLLM(
                    componentName, relevantFiles, dependencyAnalysis
                );
            }
        } catch (llmError) {
            console.error('LLM analysis failed:', llmError);
            llmAnalysis = {
                error: true,
                message: llmError.message,
                fallbackData: this.createComponentFallback(componentName, componentType, lifecycleFlow)
            };
        }

        // Stage 6: Finalize results
        this.updateLoadingStatus('üìä Stage 6: Finalizing analysis...');
        this.updateProgress(90);
        
        const results = {
            componentName: componentName,
            friendlyName: this.currentFriendlyName,
            timestamp: new Date().toISOString(),
            filesAnalyzed: relevantFiles.map(f => f.name),
            componentType: componentType,
            dependencyAnalysis: dependencyAnalysis,
            dependencyFlow: dependencyFlow,  // Add this line
            fieldAnalysis: fieldAnalysis,
            lifecycleFlow: lifecycleFlow,
            llmAnalysis: llmAnalysis,
            totalFields: fieldAnalysis?.fields?.length || 0,
            qualityScore: this.calculateQualityScore(llmAnalysis, fieldAnalysis),
            completeness: this.assessCompleteness(llmAnalysis, fieldAnalysis),
            analysisMethod: 'LLM-Enhanced-Field-Focused'
        };
        // Store friendly names from LLM analysis if available
        if (results.llmAnalysis?.dependencyFriendlyNames) {
            Object.entries(results.llmAnalysis.dependencyFriendlyNames).forEach(([techName, friendlyName]) => {
                this.friendlyNameCache.set(techName.toUpperCase(), friendlyName);
            });
        }

        if (results.llmAnalysis?.businessContext) {
            this.businessContextCache.set(componentName, results.llmAnalysis.businessContext);
        }
        // Stage 7: Discover friendly names for dependencies
        this.updateLoadingStatus('üîç Stage 7: Discovering friendly names...');
        this.updateProgress(95);

        await this.discoverDependencyFriendlyNames();

        this.updateProgress(100);
        return results;

    } catch (error) {
        console.error('Analysis failed:', error);
        throw new Error(`Analysis failed: ${error.message}`);
    }
}

// Analyze Fields in Component
async analyzeFieldsInComponent(componentName, relevantFiles) {
    console.log(`Analyzing fields for component: ${componentName}`);
    
    // Extract all fields from the copybook
    const fields = this.extractCopybookFields(componentName, relevantFiles);
    
    if (fields.length === 0) {
        console.warn('No fields found in copybook');
        return null;
    }
    
    console.log(`Found ${fields.length} fields in copybook`);
    
    // Find programs that use this copybook
    const usingPrograms = this.findProgramsUsingCopybook(componentName);
    console.log(`Found ${usingPrograms.length} programs using copybook`);
    
    // Analyze field usage across programs
    const fieldUsageAnalysis = {
        fields: fields,
        programs: usingPrograms,
        inputFields: [],
        outputFields: [],
        referenceFields: [],
        unusedFields: [],
        fieldUsageDetails: {}
    };
    
    // Analyze each field's usage
    fields.forEach(field => {
        const fieldName = field.name;
        let usageCount = 0;
        let isInput = false;
        let isOutput = false;
        let isReference = false;
        
        const usageDetails = {
            readBy: [],
            writtenBy: [],
            referencedBy: [],
            operations: []
        };
        
        // Check usage in each program
        usingPrograms.forEach(program => {
            const fieldUsage = this.analyzeFieldUsageInProgram(fieldName, program);
            
            if (fieldUsage.operations.length > 0) {
                usageCount++;
                
                if (fieldUsage.isInput || fieldUsage.isWritten) {
                    isInput = true;
                    usageDetails.writtenBy.push(program.name);
                }
                
                if (fieldUsage.isDisplayed || fieldUsage.isRead) {
                    isOutput = true;
                    usageDetails.readBy.push(program.name);
                }
                
                if (fieldUsage.isValidated) {
                    isReference = true;
                    usageDetails.referencedBy.push(program.name);
                }
                
                usageDetails.operations.push(...fieldUsage.operations);
            }
        });
        
        // Categorize field
        if (usageCount === 0) {
            fieldUsageAnalysis.unusedFields.push(fieldName);
        } else if (isInput && !isOutput) {
            fieldUsageAnalysis.inputFields.push(fieldName);
        } else if (isOutput && !isInput) {
            fieldUsageAnalysis.outputFields.push(fieldName);
        } else {
            fieldUsageAnalysis.referenceFields.push(fieldName);
        }
        // Add business logic analysis for each field
 

// Add business logic summary to field analysis

        fieldUsageAnalysis.fieldUsageDetails[fieldName] = usageDetails;
    });
    fields.forEach(field => {
        const fieldName = field.name;
        let businessLogic = {
            validationRules: [],
            calculations: [],
            businessMeaning: '',
            constraints: []
        };
        
        // Extract business logic from programs
        usingPrograms.forEach(program => {
            const programLogic = this.extractBusinessLogic(program, [fieldName]);
            
            if (programLogic.validationRules.length > 0) {
                businessLogic.validationRules.push(...programLogic.validationRules);
            }
            
            if (programLogic.calculations.length > 0) {
                businessLogic.calculations.push(...programLogic.calculations);
            }
        });
        
        // Determine business meaning from field name and usage
        businessLogic.businessMeaning = this.determineBusinessMeaning(fieldName, businessLogic);
        
        // Add business logic to field
        field.businessLogic = businessLogic;
    });

    fieldUsageAnalysis.businessLogicSummary = {
    totalValidationRules: fields.reduce((sum, f) => sum + (f.businessLogic?.validationRules?.length || 0), 0),
    totalCalculations: fields.reduce((sum, f) => sum + (f.businessLogic?.calculations?.length || 0), 0),
    fieldsWithBusinessLogic: fields.filter(f => f.businessLogic?.validationRules?.length > 0 || f.businessLogic?.calculations?.length > 0).length
};

    console.log('Field usage analysis complete:', {
        input: fieldUsageAnalysis.inputFields.length,
        output: fieldUsageAnalysis.outputFields.length,
        reference: fieldUsageAnalysis.referenceFields.length,
        unused: fieldUsageAnalysis.unusedFields.length
    });
    
    return fieldUsageAnalysis;
}


// Extract Business Rules and Logic
extractBusinessLogic(programFile, fieldNames) {
    const businessLogic = {
        validationRules: [],
        calculations: [],
        transformations: [],
        conditions: [],
        businessRules: []
    };

    if (!programFile || !programFile.content) {
        return businessLogic;
    }

    const lines = programFile.content.split('\n');
    
    lines.forEach((line, lineNum) => {
        const trimmed = line.trim().toUpperCase();
        
        // Extract validation rules
        const validationMatch = trimmed.match(/IF\s+(.*?)\s+THEN/);
        if (validationMatch) {
            const condition = validationMatch[1];
            fieldNames.forEach(fieldName => {
                if (condition.includes(fieldName.toUpperCase())) {
                    businessLogic.validationRules.push({
                        field: fieldName,
                        condition: condition,
                        line: lineNum + 1,
                        type: 'validation',
                        description: this.interpretValidationRule(condition, fieldName)
                    });
                }
            });
        }

        // Extract calculations
        if (trimmed.includes('COMPUTE') || trimmed.includes('ADD') || 
            trimmed.includes('SUBTRACT') || trimmed.includes('MULTIPLY') || 
            trimmed.includes('DIVIDE')) {
            
            fieldNames.forEach(fieldName => {
                if (trimmed.includes(fieldName.toUpperCase())) {
                    businessLogic.calculations.push({
                        field: fieldName,
                        operation: trimmed.match(/(COMPUTE|ADD|SUBTRACT|MULTIPLY|DIVIDE)/)?.[1] || 'CALC',
                        line: lineNum + 1,
                        formula: trimmed.substring(0, 120),
                        description: this.interpretCalculation(trimmed, fieldName)
                    });
                }
            });
        }

        // Extract business rules from comments
        if (trimmed.startsWith('*') && trimmed.length > 10) {
            const comment = trimmed.substring(1).trim();
            if (comment.toLowerCase().includes('business rule') || 
                comment.toLowerCase().includes('validation') ||
                comment.toLowerCase().includes('rule:')) {
                businessLogic.businessRules.push({
                    line: lineNum + 1,
                    rule: comment,
                    type: 'comment_rule'
                });
            }
        }
    });

    return businessLogic;
}

// Interpret validation rules
interpretValidationRule(condition, fieldName) {
    if (condition.includes('SPACE') || condition.includes('SPACES')) {
        return `${fieldName} must not be empty/spaces`;
    } else if (condition.includes('ZERO') || condition.includes('0')) {
        return `${fieldName} must not be zero`;
    } else if (condition.includes('>')) {
        return `${fieldName} must be greater than specified value`;
    } else if (condition.includes('<')) {
        return `${fieldName} must be less than specified value`;
    } else if (condition.includes('=')) {
        return `${fieldName} must equal specific value`;
    } else {
        return `${fieldName} has validation condition: ${condition}`;
    }
}

// Interpret calculations
interpretCalculation(formula, fieldName) {
    if (formula.includes('COMPUTE')) {
        return `${fieldName} is calculated using formula`;
    } else if (formula.includes('ADD')) {
        return `${fieldName} is incremented/added to`;
    } else if (formula.includes('SUBTRACT')) {
        return `${fieldName} is decremented/subtracted from`;
    } else {
        return `${fieldName} is used in mathematical operation`;
    }
}

// Determine Business Meaning
determineBusinessMeaning(fieldName, businessLogic) {
    const name = fieldName.toUpperCase();
    
    // Check validation rules for clues
    if (businessLogic.validationRules.length > 0) {
        const rule = businessLogic.validationRules[0];
        if (rule.description.includes('not be empty')) {
            return `Required ${this.generateFieldPurpose(fieldName).toLowerCase()}`;
        }
    }
    
    // Enhanced business meaning based on field patterns
    if (name.includes('CUSTOMER') || name.includes('CUST')) {
        return 'Customer information management field';
    } else if (name.includes('ACCOUNT') || name.includes('ACCT')) {
        return 'Account management and tracking field';
    } else if (name.includes('TRANSACTION') || name.includes('TRANS')) {
        return 'Transaction processing and audit field';
    } else if (name.includes('BALANCE') || name.includes('BAL')) {
        return 'Financial balance calculation field';
    } else if (name.includes('STATUS') || name.includes('STAT')) {
        return 'Status tracking and workflow field';
    } else if (name.includes('DATE') || name.includes('TIME')) {
        return 'Temporal tracking and audit field';
    } else if (name.includes('CODE') || name.includes('CD')) {
        return 'Reference code for business classification';
    } else {
        return this.generateFieldPurpose(fieldName);
    }
}
// Extract Dependencies
async extractDependencies(relevantFiles) {
    console.log('Extracting dependencies...');
    
    const dependencies = {
        found: {
            copybooks: [],
            programs: [],
            files: []
        },
        missing: {
            copybooks: [],
            programs: [],
            files: []
        },
        summary: {
            foundCount: 0,
            missingCount: 0
        }
    };
    
    // Extract all dependencies from files
    relevantFiles.forEach(file => {
        const lines = file.content.split('\n');
        
        lines.forEach(line => {
            const trimmed = line.trim().toUpperCase();
            
            // COPY statements
            const copyMatch = trimmed.match(/COPY\s+([A-Z][A-Z0-9\-_]+)/);
            if (copyMatch) {
                const copyName = copyMatch[1];
                const isFound = this.uploadedFiles.some(f => 
                    f.name.toUpperCase().includes(copyName) ||
                    (f.components && f.components.some(c => c.name === copyName))
                );
                
                if (isFound) {
                    if (!dependencies.found.copybooks.includes(copyName)) {
                        dependencies.found.copybooks.push(copyName);
                    }
                } else {
                    if (!dependencies.missing.copybooks.includes(copyName)) {
                        dependencies.missing.copybooks.push(copyName);
                    }
                }
            }
            
            // CALL statements
            const callMatch = trimmed.match(/CALL\s+['"]*([A-Z][A-Z0-9\-_]+)['"]*/);
            if (callMatch) {
                const programName = callMatch[1];
                const isFound = this.uploadedFiles.some(f => 
                    (f.components && f.components.some(c => c.type === 'PROGRAM' && c.name === programName))
                );
                
                if (isFound) {
                    if (!dependencies.found.programs.includes(programName)) {
                        dependencies.found.programs.push(programName);
                    }
                } else {
                    if (!dependencies.missing.programs.includes(programName)) {
                        dependencies.missing.programs.push(programName);
                    }
                }
            }
        });
    });
    
    // Calculate summary
    Object.keys(dependencies.found).forEach(key => {
        dependencies.summary.foundCount += dependencies.found[key].length;
    });
    
    Object.keys(dependencies.missing).forEach(key => {
        dependencies.summary.missingCount += dependencies.missing[key].length;
    });
    
    console.log('Dependency analysis complete:', dependencies.summary);
    return dependencies;
}

// Enhanced Dependency Flow Analysis
async extractDependencyFlow(componentName, relevantFiles, allFiles) {
    console.log('Extracting comprehensive dependency flow for:', componentName);
    
    const dependencyFlow = {
        componentName: componentName,
        componentType: this.detectComponentType(componentName, relevantFiles),
        
        // Upstream dependencies (what this component needs)
        upstream: {
            copybooks: [],
            programs: [],
            files: [],
            databases: []
        },
        
        // Downstream dependents (what depends on this component)
        downstream: {
            programs: [],
            jobs: [],
            screens: [],
            reports: []
        },
        
        // Flow characteristics
        flowType: 'UNKNOWN',
        complexity: 'LOW',
        criticalPath: [],
        impactAnalysis: {
            high: [],
            medium: [],
            low: []
        }
    };
    
    // Analyze upstream dependencies
    await this.analyzeUpstreamDependencies(componentName, relevantFiles, allFiles, dependencyFlow);
    
    // Analyze downstream dependents
    await this.analyzeDownstreamDependents(componentName, allFiles, dependencyFlow);
    
    // Determine flow characteristics
    this.analyzeDependencyFlowCharacteristics(dependencyFlow);
    
    // Perform impact analysis
    this.performImpactAnalysis(dependencyFlow);

   
    
    return dependencyFlow;
}

getFriendlyName(componentName) {
    const upperName = componentName.toUpperCase();
    
    // 1. Check LLM-generated cache first (highest priority)
    if (this.friendlyNameCache.has(upperName)) {
        return this.friendlyNameCache.get(upperName);
    }
    
    // 2. Check analyzed results
    for (const [analyzedName, results] of Object.entries(this.analysisResults)) {
        if (analyzedName === componentName || results.componentName === componentName) {
            return results.friendlyName || null;
        }
        
        // Check if this component had dependency friendly names
        if (results.llmAnalysis?.dependencyFriendlyNames?.[upperName]) {
            const friendlyName = results.llmAnalysis.dependencyFriendlyNames[upperName];
            this.friendlyNameCache.set(upperName, friendlyName); // Cache it
            return friendlyName;
        }
    }
    
    // 3. Check uploaded files
    for (const file of this.uploadedFiles) {
        if (file.components) {
            for (const component of file.components) {
                if (component.name === componentName && component.friendlyName) {
                    return component.friendlyName;
                }
            }
        }
    }
    
    // 4. Generate using enhanced patterns (lowest priority)
    return this.generateFriendlyName(componentName);
}

// Discover friendly names for all dependencies across analyses
async discoverDependencyFriendlyNames() {
    console.log('üîç Discovering friendly names for all dependencies...');
    
    const allDependencies = new Set();
    
    // Collect all dependencies from all analyses
    Object.values(this.analysisResults).forEach(results => {
        if (results.dependencyAnalysis) {
            [...(results.dependencyAnalysis.found.copybooks || []),
             ...(results.dependencyAnalysis.found.programs || []),
             ...(results.dependencyAnalysis.missing.copybooks || []),
             ...(results.dependencyAnalysis.missing.programs || [])]
            .forEach(dep => allDependencies.add(dep));
        }
    });
    
    // Filter out ones we already have friendly names for
    const unknownDeps = Array.from(allDependencies).filter(dep => 
        !this.friendlyNameCache.has(dep.toUpperCase())
    );
    
    if (unknownDeps.length > 0 && this.serverValidated) {
        console.log(`üìù Asking LLM for friendly names for ${unknownDeps.length} dependencies...`);
        
        const prompt = `GENERATE BUSINESS FRIENDLY NAMES

Given these mainframe component names, suggest business-friendly names based on common patterns:

COMPONENTS: ${unknownDeps.slice(0, 20).join(', ')}

Return JSON with technical name to friendly name mapping:
{
  "friendlyNames": {
    "TECH-NAME": "Business Friendly Name",
    "ANOTHER-TECH": "Another Business Name"
  }
}

Use business context clues from the names. Examples:
- CUST-MASTER ‚Üí "Customer Master File"
- ACCT-VALIDATE ‚Üí "Account Validation Routine"
- TRANS-LOG ‚Üí "Transaction Log Handler"`;

        try {
            const response = await this.callLLMAPI(prompt);
            if (response?.friendlyNames) {
                Object.entries(response.friendlyNames).forEach(([tech, friendly]) => {
                    this.friendlyNameCache.set(tech.toUpperCase(), friendly);
                });
                console.log(`‚úÖ Added ${Object.keys(response.friendlyNames).length} friendly names to cache`);
            }
        } catch (error) {
            console.warn('Failed to get LLM friendly names:', error);
        }
    }
}
// Analyze Upstream Dependencies
async analyzeUpstreamDependencies(componentName, relevantFiles, allFiles, dependencyFlow) {
    const componentUpper = componentName.toUpperCase();
    
    relevantFiles.forEach(file => {
        const lines = file.content.split('\n');
        
        lines.forEach((line, lineNum) => {
            const trimmed = line.trim().toUpperCase();
            
            // COPY statements - copybook dependencies
            const copyMatch = trimmed.match(/COPY\s+([A-Z][A-Z0-9\-_]+)/);
            if (copyMatch) {
                const copybookName = copyMatch[1];
                const isAvailable = allFiles.some(f => 
                    f.name.toUpperCase().includes(copybookName) ||
                    (f.components && f.components.some(c => c.name === copybookName))
                );
                
                dependencyFlow.upstream.copybooks.push({
                    name: copybookName,
                    available: isAvailable,
                    usage: 'INCLUDE',
                    line: lineNum + 1,
                    file: file.name
                });
            }
            
            // CALL statements - program dependencies
            const callMatch = trimmed.match(/CALL\s+['"]*([A-Z][A-Z0-9\-_]+)['"]*/);
            if (callMatch) {
                const programName = callMatch[1];
                const isAvailable = allFiles.some(f => 
                    f.components && f.components.some(c => 
                        c.type === 'PROGRAM' && c.name === programName
                    )
                );
                
                dependencyFlow.upstream.programs.push({
                    name: programName,
                    available: isAvailable,
                    usage: 'CALL',
                    line: lineNum + 1,
                    file: file.name
                });
            }
            
            // File dependencies
            const filePatterns = [
                /SELECT\s+([A-Z][A-Z0-9\-_]+)/,
                /FD\s+([A-Z][A-Z0-9\-_]+)/,
                /OPEN\s+(INPUT|OUTPUT|I-O)\s+([A-Z][A-Z0-9\-_]+)/
            ];
            
            filePatterns.forEach(pattern => {
                const match = trimmed.match(pattern);
                if (match) {
                    const fileName = match[match.length - 1]; // Get the last capture group
                    if (!dependencyFlow.upstream.files.find(f => f.name === fileName)) {
                        dependencyFlow.upstream.files.push({
                            name: fileName,
                            available: false, // File availability would need external checking
                            usage: 'FILE_ACCESS',
                            line: lineNum + 1,
                            file: file.name
                        });
                    }
                }
            });
            
            // Database dependencies (EXEC SQL)
            if (trimmed.includes('EXEC SQL')) {
                const tableMatch = trimmed.match(/FROM\s+([A-Z][A-Z0-9\-_]+)/);
                if (tableMatch) {
                    const tableName = tableMatch[1];
                    if (!dependencyFlow.upstream.databases.find(d => d.name === tableName)) {
                        dependencyFlow.upstream.databases.push({
                            name: tableName,
                            available: false,
                            usage: 'SQL_ACCESS',
                            line: lineNum + 1,
                            file: file.name
                        });
                    }
                }
            }
        });
    });
}

// Analyze Downstream Dependents
async analyzeDownstreamDependents(componentName, allFiles, dependencyFlow) {
    const componentUpper = componentName.toUpperCase();
    const componentBase = componentUpper.replace(/\.(CPY|COPYBOOK|COP)$/, '');
    
    allFiles.forEach(file => {
        const contentUpper = file.content.toUpperCase();
        const fileName = file.name.toUpperCase();
        
        // Programs that use this copybook
        const copyPatterns = [
            `COPY ${componentUpper}`,
            `COPY ${componentBase}`,
            `COPY "${componentUpper}"`,
            `COPY "${componentBase}"`,
            `COPY '${componentUpper}'`,
            `COPY '${componentBase}'`
        ];
        
        const usesCopybook = copyPatterns.some(pattern => contentUpper.includes(pattern));
        
        if (usesCopybook && file.type === 'COBOL Program') {
            const programName = this.extractProgramName(file);
            if (programName) {
                dependencyFlow.downstream.programs.push({
                    name: programName,
                    file: file.name,
                    type: 'COBOL_PROGRAM',
                    usage: 'INCLUDES_COPYBOOK'
                });
            }
        }
        
        // JCL jobs that reference this component
        if (file.type === 'JCL Job' && (contentUpper.includes(componentUpper) || contentUpper.includes(componentBase))) {
            const jobName = this.extractJobName(file);
            if (jobName) {
                dependencyFlow.downstream.jobs.push({
                    name: jobName,
                    file: file.name,
                    type: 'JCL_JOB',
                    usage: 'EXECUTES_PROGRAM'
                });
            }
        }
        
        // CICS screens (look for CICS operations in programs)
        if (contentUpper.includes('EXEC CICS') && usesCopybook) {
            const programName = this.extractProgramName(file);
            if (programName) {
                dependencyFlow.downstream.screens.push({
                    name: programName,
                    file: file.name,
                    type: 'CICS_SCREEN',
                    usage: 'ONLINE_TRANSACTION'
                });
            }
        }
    });
}

// Helper Methods
extractProgramName(file) {
    const match = file.content.toUpperCase().match(/PROGRAM-ID\.?\s+([A-Z][A-Z0-9\-_]+)/);
    return match ? match[1] : null;
}

extractJobName(file) {
    const match = file.content.toUpperCase().match(/\/\/([A-Z][A-Z0-9\-_]+)\s+JOB/);
    return match ? match[1] : null;
}

// Analyze Flow Characteristics
analyzeDependencyFlowCharacteristics(dependencyFlow) {
    const totalUpstream = Object.values(dependencyFlow.upstream).reduce((sum, arr) => sum + arr.length, 0);
    const totalDownstream = Object.values(dependencyFlow.downstream).reduce((sum, arr) => sum + arr.length, 0);
    
    // Determine flow type
    if (totalUpstream === 0 && totalDownstream > 0) {
        dependencyFlow.flowType = 'SOURCE';
    } else if (totalUpstream > 0 && totalDownstream === 0) {
        dependencyFlow.flowType = 'SINK';
    } else if (totalUpstream > 0 && totalDownstream > 0) {
        dependencyFlow.flowType = 'TRANSFORMER';
    } else {
        dependencyFlow.flowType = 'ISOLATED';
    }
    
    // Determine complexity
    const totalDependencies = totalUpstream + totalDownstream;
    if (totalDependencies <= 3) {
        dependencyFlow.complexity = 'LOW';
    } else if (totalDependencies <= 8) {
        dependencyFlow.complexity = 'MEDIUM';
    } else {
        dependencyFlow.complexity = 'HIGH';
    }
    
    // Build critical path
    dependencyFlow.criticalPath = [
        ...dependencyFlow.upstream.copybooks.filter(c => c.available),
        { name: dependencyFlow.componentName, type: 'CURRENT' },
        ...dependencyFlow.downstream.programs.slice(0, 3)
    ];
}

// Perform Impact Analysis
performImpactAnalysis(dependencyFlow) {
    const analysis = dependencyFlow.impactAnalysis;
    
    // High impact items
    dependencyFlow.upstream.copybooks.forEach(copybook => {
        if (!copybook.available) {
            analysis.high.push({
                type: 'MISSING_DEPENDENCY',
                item: copybook.name,
                description: `Missing copybook ${copybook.name} will prevent compilation`
            });
        }
    });
    
    // Count downstream impacts
    const downstreamCount = Object.values(dependencyFlow.downstream).reduce((sum, arr) => sum + arr.length, 0);
    if (downstreamCount > 5) {
        analysis.high.push({
            type: 'HIGH_DOWNSTREAM_IMPACT',
            item: dependencyFlow.componentName,
            description: `Changes to this component will affect ${downstreamCount} downstream components`
        });
    } else if (downstreamCount > 2) {
        analysis.medium.push({
            type: 'MEDIUM_DOWNSTREAM_IMPACT',
            item: dependencyFlow.componentName,
            description: `Changes will affect ${downstreamCount} downstream components`
        });
    } else {
        analysis.low.push({
            type: 'LOW_DOWNSTREAM_IMPACT',
            item: dependencyFlow.componentName,
            description: `Limited downstream impact (${downstreamCount} components)`
        });
    }
    
    // Database dependencies
    if (dependencyFlow.upstream.databases.length > 0) {
        analysis.medium.push({
            type: 'DATABASE_DEPENDENCY',
            item: 'Database Access',
            description: `Component has ${dependencyFlow.upstream.databases.length} database dependencies`
        });
    }
}

// Extract Lifecycle Flow
async extractLifecycleFlow(componentName, relevantFiles, fieldAnalysis) {
    console.log('Extracting lifecycle flow for:', componentName);
    
    const lifecycleFlow = {
        componentName: componentName,
        usagePattern: 'UNKNOWN',
        creationSources: [],
        inputPrograms: [],
        updatePrograms: [],
        readPrograms: [],
        cicsScreens: [],
        batchJobs: []
    };
    
    // Analyze each relevant file
    relevantFiles.forEach(file => {
        if (file.type === 'COBOL Program') {
            const programAnalysis = this.analyzeProgramOperations(file);
            
            if (programAnalysis.hasCreateOperations) {
                lifecycleFlow.creationSources.push({
                    program: file.name,
                    operations: programAnalysis.createOperations
                });
            }
            
            if (programAnalysis.hasReadOperations) {
                lifecycleFlow.readPrograms.push({
                    program: file.name,
                    operations: programAnalysis.readOperations
                });
            }
            
            if (programAnalysis.hasUpdateOperations) {
                lifecycleFlow.updatePrograms.push({
                    program: file.name,
                    operations: programAnalysis.updateOperations
                });
            }
            
            if (programAnalysis.hasCicsOperations) {
                lifecycleFlow.cicsScreens.push({
                    program: file.name,
                    operations: programAnalysis.cicsOperations
                });
            }
            
            if (programAnalysis.hasBatchOperations) {
                lifecycleFlow.batchJobs.push({
                    program: file.name,
                    operations: programAnalysis.batchOperations
                });
            }
        }
    });
    
    // Determine usage pattern
    if (lifecycleFlow.cicsScreens.length > 0) {
        lifecycleFlow.usagePattern = 'ONLINE_TRANSACTIONAL';
    } else if (lifecycleFlow.batchJobs.length > 0) {
        lifecycleFlow.usagePattern = 'BATCH_PROCESSING';
    } else if (lifecycleFlow.updatePrograms.length > 0) {
        lifecycleFlow.usagePattern = 'UPDATE_PROCESSING';
    } else if (lifecycleFlow.readPrograms.length > 0) {
        lifecycleFlow.usagePattern = 'READ_ONLY';
    }
    
    // Add field analysis to lifecycle if available
    if (fieldAnalysis) {
        lifecycleFlow.fieldAnalysis = fieldAnalysis;
    }
    
    return lifecycleFlow;
}

// Analyze Program Operations
analyzeProgramOperations(programFile) {
    const analysis = {
        hasCreateOperations: false,
        hasReadOperations: false,
        hasUpdateOperations: false,
        hasCicsOperations: false,
        hasBatchOperations: false,
        createOperations: [],
        readOperations: [],
        updateOperations: [],
        cicsOperations: [],
        batchOperations: []
    };


    const lines = programFile.content.split('\n');
    
    lines.forEach((line, lineNum) => {
        const trimmed = line.trim().toUpperCase();
        
        // CREATE operations
        if (trimmed.includes('OPEN OUTPUT') || trimmed.includes('WRITE ')) {
            analysis.hasCreateOperations = true;
            analysis.createOperations.push({
                type: 'create',
                line: lineNum + 1,
                context: trimmed.substring(0, 80)
            });
        }
        
        // READ operations
        if (trimmed.includes('OPEN INPUT') || trimmed.includes('READ ')) {
            analysis.hasReadOperations = true;
            analysis.readOperations.push({
                type: 'read',
                line: lineNum + 1,
                context: trimmed.substring(0, 80)
            });
        }
        
        // UPDATE operations
        if (trimmed.includes('OPEN I-O') || trimmed.includes('REWRITE')) {
            analysis.hasUpdateOperations = true;
            analysis.updateOperations.push({
                type: 'update',
                line: lineNum + 1,
                context: trimmed.substring(0, 80)
            });
        }
        
        // CICS operations
        if (trimmed.includes('EXEC CICS')) {
            analysis.hasCicsOperations = true;
            analysis.cicsOperations.push({
                type: 'cics',
                line: lineNum + 1,
                context: trimmed.substring(0, 80)
            });
        }
        
        // BATCH operations
        if (trimmed.includes('SORT ') || trimmed.includes('MERGE ')) {
            analysis.hasBatchOperations = true;
            analysis.batchOperations.push({
                type: 'batch',
                line: lineNum + 1,
                context: trimmed.substring(0, 80)
            });
        }
    });

    return analysis;
}

// Extract Business Rules and Logic
extractBusinessLogic(programFile, fieldNames) {
    const businessLogic = {
        validationRules: [],
        calculations: [],
        transformations: [],
        conditions: [],
        businessRules: []
    };

    const lines = programFile.content.split('\n');
    const fieldSet = new Set(fieldNames.map(f => f.toUpperCase()));
    
    lines.forEach((line, lineNum) => {
        const trimmed = line.trim().toUpperCase();
        
        // Extract validation rules
        const validationMatch = trimmed.match(/IF\s+(.*?)\s+THEN/);
        if (validationMatch) {
            const condition = validationMatch[1];
            fieldNames.forEach(fieldName => {
                if (condition.includes(fieldName.toUpperCase())) {
                    businessLogic.validationRules.push({
                        field: fieldName,
                        condition: condition,
                        line: lineNum + 1,
                        type: 'validation',
                        description: this.interpretValidationRule(condition, fieldName)
                    });
                }
            });
        }

        // Extract calculations
        if (trimmed.includes('COMPUTE') || trimmed.includes('ADD') || 
            trimmed.includes('SUBTRACT') || trimmed.includes('MULTIPLY') || 
            trimmed.includes('DIVIDE')) {
            
            fieldNames.forEach(fieldName => {
                if (trimmed.includes(fieldName.toUpperCase())) {
                    businessLogic.calculations.push({
                        field: fieldName,
                        operation: trimmed.match(/(COMPUTE|ADD|SUBTRACT|MULTIPLY|DIVIDE)/)?.[1] || 'CALC',
                        line: lineNum + 1,
                        formula: trimmed.substring(0, 120),
                        description: this.interpretCalculation(trimmed, fieldName)
                    });
                }
            });
        }

        // Extract business rules from comments
        if (trimmed.startsWith('*') && trimmed.length > 10) {
            const comment = trimmed.substring(1).trim();
            if (comment.toLowerCase().includes('business rule') || 
                comment.toLowerCase().includes('validation') ||
                comment.toLowerCase().includes('rule:')) {
                businessLogic.businessRules.push({
                    line: lineNum + 1,
                    rule: comment,
                    type: 'comment_rule'
                });
            }
        }
    });

    return businessLogic;
}

// Interpret validation rules
interpretValidationRule(condition, fieldName) {
    if (condition.includes('SPACE') || condition.includes('SPACES')) {
        return `${fieldName} must not be empty/spaces`;
    } else if (condition.includes('ZERO') || condition.includes('0')) {
        return `${fieldName} must not be zero`;
    } else if (condition.includes('>')) {
        return `${fieldName} must be greater than specified value`;
    } else if (condition.includes('<')) {
        return `${fieldName} must be less than specified value`;
    } else if (condition.includes('=')) {
        return `${fieldName} must equal specific value`;
    } else {
        return `${fieldName} has validation condition: ${condition}`;
    }
}

// Interpret calculations
interpretCalculation(formula, fieldName) {
    if (formula.includes('COMPUTE')) {
        return `${fieldName} is calculated using formula`;
    } else if (formula.includes('ADD')) {
        return `${fieldName} is incremented/added to`;
    } else if (formula.includes('SUBTRACT')) {
        return `${fieldName} is decremented/subtracted from`;
    } else {
        return `${fieldName} is used in mathematical operation`;
    }
}

// Calculate Quality Score
calculateQualityScore(analysisResult, fieldAnalysis) {
    if (!analysisResult) return 3;
    
    if (analysisResult.error) return 2;
    
    if (analysisResult.qualityScore) {
        return analysisResult.qualityScore;
    }
    
    let score = 5;
    
    // Bonus points for structured data
    if (fieldAnalysis && fieldAnalysis.fields && fieldAnalysis.fields.length > 0) score += 2;
    if (analysisResult.recommendations && analysisResult.recommendations.length > 0) score += 1;
    if (analysisResult.dependencyStatus) score += 1;
    if (fieldAnalysis && fieldAnalysis.fieldUsageDetails) score += 1;
    
    return Math.min(Math.max(score, 1), 10);
}

// Assess Completeness
assessCompleteness(analysisResult, fieldAnalysis) {
    const checkpoints = {
        'Component Analysis': !!analysisResult && !analysisResult.error,
        'Field Analysis': !!(fieldAnalysis && fieldAnalysis.fields && fieldAnalysis.fields.length > 0),
        'Dependencies': !!(analysisResult.dependencyStatus || analysisResult.dependencies),
        'Lifecycle Analysis': !!(analysisResult.lifecycleRole || analysisResult.lifecycleAnalysis),
        'Recommendations': !!(analysisResult.recommendations && analysisResult.recommendations.length > 0),
        'Field Usage': !!(fieldAnalysis && fieldAnalysis.fieldUsageDetails)
    };
    
    const completed = Object.values(checkpoints).filter(Boolean).length;
    const total = Object.keys(checkpoints).length;
    
    return {
        score: Math.round((completed / total) * 100),
        checkpoints: checkpoints,
        completed: completed,
        total: total
    };
}
// ============================================
// PART 10: LLM ANALYSIS PROMPTS
// Specific prompts for copybook and program analysis
// ============================================

// Add these methods to the EnhancedMainframeAnalyzer class

// Analyze Copybook with LLM
async analyzeCopybookWithLLM(copybookName, relevantFiles, dependencies, lifecycleFlow, fieldAnalysis) {
    console.log(`LLM analyzing copybook: ${copybookName}`);
    
    const friendlyName = this.currentFriendlyName || copybookName;
    
    // Prepare context
    const copybookFile = relevantFiles.find(f => 
        f.type === 'Copybook' || 
        f.name.toUpperCase().includes(copybookName.toUpperCase())
    );
    
    if (!copybookFile) {
        throw new Error(`Copybook file for ${copybookName} not found`);
    }
    
    // Prepare field summary
    const fieldSummary = fieldAnalysis ? `
FIELD ANALYSIS SUMMARY:
- Total Fields: ${fieldAnalysis.fields.length}
- Input Fields: ${fieldAnalysis.inputFields.length} (${fieldAnalysis.inputFields.slice(0, 5).join(', ')})
- Output Fields: ${fieldAnalysis.outputFields.length} (${fieldAnalysis.outputFields.slice(0, 5).join(', ')})
- Reference Fields: ${fieldAnalysis.referenceFields.length} (${fieldAnalysis.referenceFields.slice(0, 5).join(', ')})
- Unused Fields: ${fieldAnalysis.unusedFields.length} (${fieldAnalysis.unusedFields.slice(0, 5).join(', ')})
- Programs Using: ${fieldAnalysis.programs.length}
` : 'No field analysis available';

    // Prepare copybook content (truncated)
    const copybookContent = this.prepareContentForLLM(copybookFile.content, 'copybook');
    
    const llmPrompt = `ANALYZE MAINFRAME COPYBOOK WITH FIELD FOCUS

COMPONENT NAME: ${copybookName}
FRIENDLY NAME: ${friendlyName}
COMPONENT TYPE: Copybook

${fieldSummary}

COPYBOOK CONTENT (TRUNCATED):
${copybookContent}

DEPENDENCIES:
- Found Copybooks: ${dependencies.found.copybooks.join(', ') || 'None'}
- Missing Copybooks: ${dependencies.missing.copybooks.join(', ') || 'None'}
- Found Programs: ${dependencies.found.programs.join(', ') || 'None'}
- Missing Programs: ${dependencies.missing.programs.join(', ') || 'None'}

TASK: Analyze this copybook AND suggest business-friendly names for all dependencies.

RETURN JSON FORMAT:
{
  "componentName": "${copybookName}",
  "friendlyName": "${friendlyName}",
  "componentType": "Copybook",
  "dependencyFriendlyNames": {
    "DEPENDENCY-NAME": "Business Friendly Name",
    "ANOTHER-DEP": "Another Business Name"
  },
  "businessContext": "Brief description of business domain",
  
  "analysisScope": "FIELD_LEVEL_ANALYSIS",
  "totalFields": ${fieldAnalysis?.fields?.length || 0},
  "fieldSummary": {
    "primaryFields": ["list up to 10 most important fields with their purpose"],
    "inputFields": ${fieldAnalysis?.inputFields?.length || 0},
    "outputFields": ${fieldAnalysis?.outputFields?.length || 0},
    "unusedFields": ${fieldAnalysis?.unusedFields?.length || 0}
  },
  "businessPurpose": "describe the business purpose of this copybook",
  "businessLogic": {
    "validationRules": ["list key validation rules found"],
    "businessRules": ["list business rules and constraints"],
    "dataValidations": ["list data validation patterns"],
    "fieldRelationships": ["describe how fields relate to each other"]
  },
  "dataStructure": "describe the data structure and hierarchy",
  "fieldDetails": [
    {
      "fieldName": "field name",
      "businessMeaning": "what this field represents in business terms",
      "validationRules": ["rules that apply to this field"],
      "usagePattern": "how this field is typically used"
    }
  ],
  "usagePattern": "${lifecycleFlow?.usagePattern || 'UNKNOWN'}",
  "recommendations": [
    "provide 3-5 specific recommendations for optimization",
    "focus on field usage and structure improvements",
    "suggest business rule improvements"
  ],
  "qualityScore": 8
}

Provide ONLY the JSON response, no additional text.`;

    return await this.callLLMAPI(llmPrompt);
}

// Analyze Program with LLM
async analyzeProgramWithLLM(programName, relevantFiles, dependencies, lifecycleFlow) {
    console.log(`LLM analyzing program: ${programName}`);
    
    const friendlyName = this.currentFriendlyName || programName;
    
    const programFile = relevantFiles.find(f => 
        f.type === 'COBOL Program' && 
        (f.name.toUpperCase().includes(programName.toUpperCase()) || 
         f.content.toUpperCase().includes(`PROGRAM-ID. ${programName.toUpperCase()}`))
    );

    if (!programFile) {
        throw new Error(`Program file for ${programName} not found`);
    }

    const programContent = this.prepareContentForLLM(programFile.content, 'program');
    
    const llmPrompt = `ANALYZE MAINFRAME COBOL PROGRAM

COMPONENT NAME: ${programName}
FRIENDLY NAME: ${friendlyName}
COMPONENT TYPE: COBOL Program

PROGRAM CONTENT (TRUNCATED):
${programContent}

DEPENDENCIES:
- Found Copybooks: ${dependencies.found.copybooks.join(', ') || 'None'}
- Missing Copybooks: ${dependencies.missing.copybooks.join(', ') || 'None'}
- Found Programs: ${dependencies.found.programs.join(', ') || 'None'}
- Missing Programs: ${dependencies.missing.programs.join(', ') || 'None'}

LIFECYCLE CONTEXT:
- Usage Pattern: ${lifecycleFlow.usagePattern}
- Has CICS Operations: ${lifecycleFlow.cicsScreens.length > 0}
- Has Batch Operations: ${lifecycleFlow.batchJobs.length > 0}

TASK: Analyze this COBOL program focusing on its structure, business logic, and field operations.

RETURN JSON FORMAT:
{
  "componentName": "${programName}",
  "friendlyName": "${friendlyName}",
  "componentType": "COBOL Program",
  "programStructure": {
    "divisions": ["list the divisions found"],
    "mainParagraphs": ["list main processing paragraphs"],
    "complexity": "LOW/MEDIUM/HIGH"
  },
  "businessLogic": {
    "primaryFunction": "describe the main purpose",
    "keyOperations": ["list key operations performed"],
    "dataFlow": "describe how data flows through the program"
  },
  "fieldOperations": {
    "fieldsRead": ["list main fields read"],
    "fieldsWritten": ["list main fields written"],
    "fieldsValidated": ["list fields with validation"]
  },
  "dependencies": {
    "copybooks": ["list copybooks used"],
    "calledPrograms": ["list programs called"],
    "files": ["list files accessed"]
  },
  "recommendations": [
    "provide 3-5 specific recommendations",
    "focus on modernization and optimization"
  ],
  "qualityScore": 7
}

Provide ONLY the JSON response, no additional text.`;

    return await this.callLLMAPI(llmPrompt);
}

// Analyze Generic Component with LLM
async analyzeGenericComponentWithLLM(componentName, relevantFiles, dependencies) {
    console.log(`LLM analyzing generic component: ${componentName}`);
    
    const friendlyName = this.currentFriendlyName || componentName;
    const componentFile = relevantFiles[0];
    const componentContent = this.prepareContentForLLM(componentFile.content, 'generic');

    const llmPrompt = `ANALYZE MAINFRAME COMPONENT

COMPONENT NAME: ${componentName}
FRIENDLY NAME: ${friendlyName}
FILE TYPE: ${componentFile.type}

COMPONENT CONTENT (TRUNCATED):
${componentContent}

DEPENDENCIES FOUND:
${Object.entries(dependencies.found).map(([key, values]) => 
    `${key}: ${values.join(', ') || 'None'}`
).join('\n')}

TASK: Analyze this component and identify its purpose, structure, and recommendations.

RETURN JSON FORMAT:
{
  "componentName": "${componentName}",
  "friendlyName": "${friendlyName}",
  "componentType": "${componentFile.type}",
  "purpose": "describe the component purpose",
  "keyElements": ["list important elements found"],
  "patterns": ["identify any patterns or structures"],
  "recommendations": ["provide 3-5 recommendations"],
  "qualityScore": 6
}

Provide ONLY the JSON response, no additional text.`;

    return await this.callLLMAPI(llmPrompt);
}

// Prepare Content for LLM (truncate to fit token limits)
prepareContentForLLM(content, type) {
    const maxChars = this.maxTokens * this.averageCharsPerToken * 0.5; // Conservative limit
    
    if (content.length <= maxChars) {
        return content;
    }
    
    if (type === 'copybook') {
        // Focus on field definitions for copybooks
        const lines = content.split('\n');
        const importantLines = lines.filter(line => {
            const trimmed = line.trim().toUpperCase();
            return trimmed.match(/^\s*\d{2}\s+/) ||           // Field levels
                   trimmed.includes('PIC ') ||               // Picture clauses
                   trimmed.includes('VALUE ') ||             // Value clauses
                   trimmed.includes('REDEFINES ') ||         // Redefines
                   trimmed.includes('OCCURS ');             // Arrays
        });
        
        let result = importantLines.join('\n');
        if (result.length > maxChars) {
            result = result.substring(0, maxChars);
        }
        return result;
        
    } else if (type === 'program') {
        // Focus on procedure division for programs
        const procedureIndex = content.toUpperCase().indexOf('PROCEDURE DIVISION');
        if (procedureIndex > -1) {
            const procedureContent = content.substring(procedureIndex);
            if (procedureContent.length <= maxChars) {
                return procedureContent;
            }
            return procedureContent.substring(0, maxChars);
        }
    }
    
    // Generic truncation
    return content.substring(0, maxChars);
}
// ============================================
// PART 11: DISPLAY AND UI UPDATE METHODS
// Complete UI rendering and result display
// ============================================

// Add these methods to the EnhancedMainframeAnalyzer class


// Display Analysis Results
displayAnalysisResults(componentName, results) {
    console.log('Displaying analysis results for:', componentName);
    
    const displayName = results.friendlyName || componentName;
    
    // Update summary sections for all tabs
    this.updateSummarySection(displayName, results);
    
    // Display main analysis
    this.displayMainAnalysis(displayName, results);
    
    // Display field matrix
    this.displayFieldMatrix(displayName, results);
    
    // Display usage patterns
    this.displayUsagePatterns(displayName, results);
    
    // Display dependencies
    this.displayDependencies(displayName, results);
    
    // Display dependency flow (if implemented)
    if (this.displayDependencyFlow) {
        this.displayDependencyFlow(displayName, results);
    }
    
    // Display file lifecycle - this will now populate field lifecycle details
    this.displayFileLifecycle(displayName, results);
    
    // Switch to main results tab
    document.querySelector('.tab[data-tab="lifecycle"]').click();
}

// Update Summary Section
updateSummarySection(displayName, results) {
    // Main summary
    const summaryComponent = document.getElementById('summaryComponent');
    const summaryQuality = document.getElementById('summaryQuality');
    const summaryFiles = document.getElementById('summaryFiles');
    const summaryDeps = document.getElementById('summaryDeps');
    
    if (summaryComponent) summaryComponent.textContent = displayName;
    if (summaryQuality) summaryQuality.textContent = `${results.qualityScore}/10`;
    if (summaryFiles) summaryFiles.textContent = results.filesAnalyzed.length;
    if (summaryDeps) {
        const totalDeps = (results.dependencyAnalysis?.summary?.foundCount || 0) + 
                         (results.dependencyAnalysis?.summary?.missingCount || 0);
        summaryDeps.textContent = totalDeps;
    }
    
    // Field matrix summary
    if (results.fieldAnalysis) {
        const totalFields = document.getElementById('totalFields');
        const inputFields = document.getElementById('inputFields');
        const outputFields = document.getElementById('outputFields');
        const unusedFields = document.getElementById('unusedFields');
        
        if (totalFields) totalFields.textContent = results.fieldAnalysis.fields.length;
        if (inputFields) inputFields.textContent = results.fieldAnalysis.inputFields.length;
        if (outputFields) outputFields.textContent = results.fieldAnalysis.outputFields.length;
        if (unusedFields) unusedFields.textContent = results.fieldAnalysis.unusedFields.length;
    }
    
    // Usage patterns summary
    const patternType = document.getElementById('patternType');
    const creationCount = document.getElementById('creationCount');
    const readingCount = document.getElementById('readingCount');
    const updateCount = document.getElementById('updateCount');
    
    if (patternType) patternType.textContent = results.lifecycleFlow?.usagePattern || 'N/A';
    if (creationCount) creationCount.textContent = results.lifecycleFlow?.creationSources?.length || 0;
    if (readingCount) readingCount.textContent = results.lifecycleFlow?.readPrograms?.length || 0;
    if (updateCount) updateCount.textContent = results.lifecycleFlow?.updatePrograms?.length || 0;
    
    // Dependencies summary
    const foundDeps = document.getElementById('foundDeps');
    const missingDeps = document.getElementById('missingDeps');
    const copybookDeps = document.getElementById('copybookDeps');
    const programDeps = document.getElementById('programDeps');
    
    if (foundDeps) foundDeps.textContent = results.dependencyAnalysis?.summary?.foundCount || 0;
    if (missingDeps) missingDeps.textContent = results.dependencyAnalysis?.summary?.missingCount || 0;
    if (copybookDeps) copybookDeps.textContent = results.dependencyAnalysis?.found?.copybooks?.length || 0;
    if (programDeps) programDeps.textContent = results.dependencyAnalysis?.found?.programs?.length || 0;
    
    // File lifecycle summary
    const lifecycleStage = document.getElementById('lifecycleStage');
    const totalPrograms = document.getElementById('totalPrograms');
    const cicsCount = document.getElementById('cicsCount');
    const batchCount = document.getElementById('batchCount');
    
    if (lifecycleStage) lifecycleStage.textContent = results.lifecycleFlow?.usagePattern || 'N/A';
    if (totalPrograms) {
        const total = (results.fieldAnalysis?.programs?.length || 0);
        totalPrograms.textContent = total;
    }
    if (cicsCount) cicsCount.textContent = results.lifecycleFlow?.cicsScreens?.length || 0;
    if (batchCount) batchCount.textContent = results.lifecycleFlow?.batchJobs?.length || 0;
}

// Display Main Analysis
displayMainAnalysis(displayName, results) {
    const container = document.getElementById('lifecycleDetails');
    if (!container) return;
    
    let html = `
        <div class="metrics-grid">
            <div class="metric-card">
                <div class="metric-icon">üìä</div>
                <div class="metric-details">
                    <div class="metric-label">Component</div>
                    <div class="metric-value">${displayName}</div>
                </div>
            </div>
            <div class="metric-card">
                <div class="metric-icon">üéØ</div>
                <div class="metric-details">
                    <div class="metric-label">Type</div>
                    <div class="metric-value">${results.componentType}</div>
                </div>
            </div>
            <div class="metric-card">
                <div class="metric-icon">üìà</div>
                <div class="metric-details">
                    <div class="metric-label">Quality</div>
                    <div class="metric-value">${results.qualityScore}/10</div>
                </div>
            </div>
            <div class="metric-card">
                <div class="metric-icon">‚úÖ</div>
                <div class="metric-details">
                    <div class="metric-label">Completeness</div>
                    <div class="metric-value">${results.completeness?.score || 0}%</div>
                </div>
            </div>
        </div>
    `;
    
    // Add dependency analysis
    if (results.dependencyAnalysis) {
        html += this.renderDependencyAnalysis(results.dependencyAnalysis);
    }
    
    container.innerHTML = html;
    
    // Display LLM results
    const llmContainer = document.getElementById('llmResults');
    if (llmContainer && results.llmAnalysis) {
        llmContainer.innerHTML = this.renderLLMAnalysis(results.llmAnalysis, displayName);
    }
    
    // Display recommendations
    const recContainer = document.getElementById('recommendations');
    if (recContainer) {
        recContainer.innerHTML = this.renderRecommendations(results.llmAnalysis);
    }
}

// Display Field Matrix
displayFieldMatrix(displayName, results) {
    const container = document.getElementById('fieldMatrixContent');
    if (!container) return;
    
    if (!results.fieldAnalysis || !results.fieldAnalysis.fields || results.fieldAnalysis.fields.length === 0) {
        container.innerHTML = '<p>No field analysis available for this component.</p>';
        return;
    }
    
    const fields = results.fieldAnalysis.fields;
    
    let html = `
        <h4>Field Analysis for ${displayName}</h4>
        <table class="data-table">
           // Replace the existing table headers and rows with:
<thead>
    <tr>
        <th>Field Name</th>
        <th>Level</th>
        <th>Picture</th>
        <th>Usage</th>
        <th>Business Purpose</th>
        <th>Validation Rules</th>
    </tr>
</thead>
<tbody>
`;

fields.slice(0, 50).forEach(field => {
    const usage = this.determineFieldUsage(field, results.fieldAnalysis);
    const badgeClass = this.getUsageBadgeClass(usage);
    const validationCount = field.businessLogic?.validationRules?.length || 0;
    const hasCalculations = field.businessLogic?.calculations?.length > 0;
    
    html += `
        <tr>
            <td style="font-family: monospace; font-weight: 600;">${field.name}</td>
            <td>${field.level}</td>
            <td style="font-family: monospace;">${field.picture || '-'}</td>
            <td><span class="badge ${badgeClass}">${usage}</span></td>
            <td style="font-size: 0.85rem;">${field.businessLogic?.businessMeaning || this.generateFieldPurpose(field.name)}</td>
            <td>
                ${validationCount > 0 ? `<span class="badge badge-success">${validationCount} rules</span>` : ''}
                ${hasCalculations ? `<span class="badge badge-primary">Calculated</span>` : ''}
            </td>
        </tr>
    `;
});
    
    html += `
            </tbody>
        </table>
    `;
    
    if (fields.length > 50) {
        html += `<p style="margin-top: 1rem; color: var(--grey-500);">Showing 50 of ${fields.length} fields</p>`;
    }
    
    container.innerHTML = html;
    
    // Display field statistics
    const statsContainer = document.getElementById('fieldStatistics');
    if (statsContainer) {
        statsContainer.innerHTML = this.renderFieldStatistics(results.fieldAnalysis);
    }
}

// Determine Business Meaning
determineBusinessMeaning(fieldName, businessLogic) {
    const name = fieldName.toUpperCase();
    
    // Check validation rules for clues
    if (businessLogic.validationRules.length > 0) {
        const rule = businessLogic.validationRules[0];
        if (rule.description.includes('not be empty')) {
            return `Required ${this.generateFieldPurpose(fieldName).toLowerCase()}`;
        }
    }
    
    // Enhanced business meaning based on field patterns
    if (name.includes('CUSTOMER') || name.includes('CUST')) {
        return 'Customer information management field';
    } else if (name.includes('ACCOUNT') || name.includes('ACCT')) {
        return 'Account management and tracking field';
    } else if (name.includes('TRANSACTION') || name.includes('TRANS')) {
        return 'Transaction processing and audit field';
    } else if (name.includes('BALANCE') || name.includes('BAL')) {
        return 'Financial balance calculation field';
    } else if (name.includes('STATUS') || name.includes('STAT')) {
        return 'Status tracking and workflow field';
    } else if (name.includes('DATE') || name.includes('TIME')) {
        return 'Temporal tracking and audit field';
    } else if (name.includes('CODE') || name.includes('CD')) {
        return 'Reference code for business classification';
    } else {
        return this.generateFieldPurpose(fieldName);
    }
}
// Display Usage Patterns
displayUsagePatterns(displayName, results) {
    const container = document.getElementById('usageContent');
    if (!container) return;
    
    if (!results.lifecycleFlow) {
        container.innerHTML = '<p>No usage pattern analysis available.</p>';
        return;
    }
    
    const flow = results.lifecycleFlow;
    
    let html = `
        <h4>Usage Pattern Analysis for ${displayName}</h4>
        <div style="background: var(--primary-blue); color: white; padding: 1rem; border-radius: 8px; text-align: center; margin-bottom: 1.5rem;">
            <div style="font-size: 1.5rem; font-weight: bold;">${flow.usagePattern || 'UNKNOWN'}</div>
            <div style="font-size: 0.9rem; opacity: 0.9;">Primary Usage Pattern</div>
        </div>
        
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem;">
    `;
    
    // Creation sources
    if (flow.creationSources && flow.creationSources.length > 0) {
        html += `
            <div style="background: var(--grey-50); padding: 1rem; border-radius: 8px; border-left: 4px solid var(--success-green);">
                <h5 style="color: var(--success-green); margin-bottom: 0.75rem;">üå± Creation Sources (${flow.creationSources.length})</h5>
                ${flow.creationSources.slice(0, 5).map(source => `
                    <div style="margin-bottom: 0.5rem; padding: 0.5rem; background: white; border-radius: 4px;">
                        <div style="font-weight: 600;">${source.program}</div>
                        ${source.operations ? `<div style="font-size: 0.8rem; color: var(--grey-600);">${source.operations.length} operations</div>` : ''}
                    </div>
                `).join('')}
            </div>
        `;
    }
    
    // Read programs
    if (flow.readPrograms && flow.readPrograms.length > 0) {
        html += `
            <div style="background: var(--grey-50); padding: 1rem; border-radius: 8px; border-left: 4px solid var(--info-blue);">
                <h5 style="color: var(--info-blue); margin-bottom: 0.75rem;">üìñ Read Programs (${flow.readPrograms.length})</h5>
                ${flow.readPrograms.slice(0, 5).map(prog => `
                    <div style="margin-bottom: 0.5rem; padding: 0.5rem; background: white; border-radius: 4px;">
                        <div style="font-weight: 600;">${prog.program}</div>
                        ${prog.operations ? `<div style="font-size: 0.8rem; color: var(--grey-600);">${prog.operations.length} operations</div>` : ''}
                    </div>
                `).join('')}
            </div>
        `;
    }
    
    // Update programs
    if (flow.updatePrograms && flow.updatePrograms.length > 0) {
        html += `
            <div style="background: var(--grey-50); padding: 1rem; border-radius: 8px; border-left: 4px solid var(--warning-yellow);">
                <h5 style="color: var(--warning-yellow); margin-bottom: 0.75rem;">‚öôÔ∏è Update Programs (${flow.updatePrograms.length})</h5>
                ${flow.updatePrograms.slice(0, 5).map(prog => `
                    <div style="margin-bottom: 0.5rem; padding: 0.5rem; background: white; border-radius: 4px;">
                        <div style="font-weight: 600;">${prog.program}</div>
                        ${prog.operations ? `<div style="font-size: 0.8rem; color: var(--grey-600);">${prog.operations.length} operations</div>` : ''}
                    </div>
                `).join('')}
            </div>
        `;
    }
    
    html += '</div>';
    container.innerHTML = html;
}

// Display Dependencies
displayDependencies(displayName, results) {
    const foundContainer = document.getElementById('foundDependencies');
    const missingContainer = document.getElementById('missingDependencies');
    
    if (!results.dependencyAnalysis) {
        if (foundContainer) foundContainer.innerHTML = '<p>No dependency analysis available.</p>';
        if (missingContainer) missingContainer.innerHTML = '<p>No dependency analysis available.</p>';
        return;
    }
    
    const deps = results.dependencyAnalysis;
    
    // Found dependencies
    if (foundContainer) {
        let foundHtml = `<h4>Found Dependencies for ${displayName}</h4>`;
        
        if (deps.found.copybooks && deps.found.copybooks.length > 0) {
            foundHtml += `
                <div style="margin-bottom: 1rem;">
                    <h5 style="color: var(--success-green);">üìö Copybooks (${deps.found.copybooks.length})</h5>
                    <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
                        ${deps.found.copybooks.map(cb => `
                            <span class="badge badge-success">${cb}</span>
                        `).join('')}
                    </div>
                </div>
            `;
        }
        
        if (deps.found.programs && deps.found.programs.length > 0) {
            foundHtml += `
                <div style="margin-bottom: 1rem;">
                    <h5 style="color: var(--success-green);">üíº Programs (${deps.found.programs.length})</h5>
                    <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
                        ${deps.found.programs.map(prog => `
                            <span class="badge badge-success">${prog}</span>
                        `).join('')}
                    </div>
                </div>
            `;
        }
        
        foundContainer.innerHTML = foundHtml;
    }
    
    // Missing dependencies
    if (missingContainer) {
        let missingHtml = `<h4>Missing Dependencies for ${displayName}</h4>`;
        
        if (deps.missing.copybooks && deps.missing.copybooks.length > 0) {
            missingHtml += `
                <div style="margin-bottom: 1rem;">
                    <h5 style="color: var(--error-red);">üìö Copybooks (${deps.missing.copybooks.length})</h5>
                    <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
                        ${deps.missing.copybooks.map(cb => `
                            <span class="badge badge-danger">${cb}</span>
                        `).join('')}
                    </div>
                </div>
            `;
        }
        
        if (deps.missing.programs && deps.missing.programs.length > 0) {
            missingHtml += `
                <div style="margin-bottom: 1rem;">
                    <h5 style="color: var(--error-red);">üíº Programs (${deps.missing.programs.length})</h5>
                    <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
                        ${deps.missing.programs.map(prog => `
                            <span class="badge badge-danger">${prog}</span>
                        `).join('')}
                    </div>
                </div>
            `;
        }
        
        missingContainer.innerHTML = missingHtml;
    }
}
// Display Dependency Flow
displayDependencyFlow(displayName, results) {
    if (!results.dependencyFlow) return;
    
    const flow = results.dependencyFlow;
    
    // Update summary
    const flowType = document.getElementById('flowType');
    const upstreamCount = document.getElementById('upstreamCount');
    const downstreamCount = document.getElementById('downstreamCount');
    const complexityScore = document.getElementById('complexityScore');
    
    if (flowType) flowType.textContent = flow.flowType;
    if (upstreamCount) {
        const total = Object.values(flow.upstream).reduce((sum, arr) => sum + arr.length, 0);
        upstreamCount.textContent = total;
    }
    if (downstreamCount) {
        const total = Object.values(flow.downstream).reduce((sum, arr) => sum + arr.length, 0);
        downstreamCount.textContent = total;
    }
    if (complexityScore) complexityScore.textContent = flow.complexity;
    
    // Display flow chart
    this.renderDependencyFlowChart(flow);
    
    // Display detailed analysis
    this.renderDetailedFlowAnalysis(flow);
    
    // Display impact analysis
    this.renderImpactAnalysis(flow);
}

// Render Dependency Flow Chart
renderDependencyFlowChart(flow) {
    const container = document.getElementById('dependencyFlowChart');
    if (!container) return;
    
    let html = `
        <div class="flow-container">
            <h4>High-Level Dependency Flow for ${flow.componentName}</h4>
            <div class="flow-diagram">
    `;
    
    // Upstream level
    if (flow.upstream.copybooks.length > 0 || flow.upstream.programs.length > 0) {
        html += `
            <div class="flow-level">
                <div class="flow-level-title">UPSTREAM DEPENDENCIES</div>
                <div class="flow-nodes">
        `;
        
        flow.upstream.copybooks.slice(0, 5).forEach(copybook => {
            html += `
                <div class="flow-node ${copybook.available ? 'upstream' : 'missing'}" 
                     title="${copybook.usage} - Line ${copybook.line}">
                    <div class="flow-node-icon">üìö</div>
                    <div class="flow-node-name">${copybook.name}</div>
                    <div class="flow-node-type">Copybook</div>
                    ${!copybook.available ? '<div class="flow-node-badge">!</div>' : ''}
                </div>
            `;
        });
        
        flow.upstream.programs.slice(0, 3).forEach(program => {
            html += `
                <div class="flow-node ${program.available ? 'upstream' : 'missing'}" 
                     title="${program.usage} - Line ${program.line}">
                    <div class="flow-node-icon">üíº</div>
                    <div class="flow-node-name">${program.name}</div>
                    <div class="flow-node-type">Program</div>
                    ${!program.available ? '<div class="flow-node-badge">!</div>' : ''}
                </div>
            `;
        });
        
        html += `
                </div>
                <div class="flow-arrow">‚¨áÔ∏è</div>
            </div>
        `;
    }
    
    // Current component level
    html += `
        <div class="flow-level">
            <div class="flow-level-title">CURRENT COMPONENT</div>
            <div class="flow-nodes">
                <div class="flow-node current">
                    <div class="flow-node-icon">${this.getComponentFlowIcon(flow.componentType)}</div>
                    <div class="flow-node-name">${flow.componentName}</div>
                    <div class="flow-node-type">${flow.componentType}</div>
                </div>
            </div>
            <div class="flow-arrow">‚¨áÔ∏è</div>
        </div>
    `;
    
    // Downstream level
    if (flow.downstream.programs.length > 0 || flow.downstream.jobs.length > 0) {
        html += `
            <div class="flow-level">
                <div class="flow-level-title">DOWNSTREAM DEPENDENTS</div>
                <div class="flow-nodes">
        `;
        
        flow.downstream.programs.slice(0, 5).forEach(program => {
            html += `
                <div class="flow-node downstream" title="${program.usage}">
                    <div class="flow-node-icon">üíº</div>
                    <div class="flow-node-name">${program.name}</div>
                    <div class="flow-node-type">Program</div>
                </div>
            `;
        });
        
        flow.downstream.jobs.slice(0, 3).forEach(job => {
            html += `
                <div class="flow-node downstream" title="${job.usage}">
                    <div class="flow-node-icon">üìã</div>
                    <div class="flow-node-name">${job.name}</div>
                    <div class="flow-node-type">Job</div>
                </div>
            `;
        });
        
        html += `
                </div>
            </div>
        `;
    }
    
    html += `
            </div>
            
            <!-- Flow Legend -->
            <div class="flow-legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: var(--primary-blue);"></div>
                    <span>Current Component</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(16, 185, 129, 0.3); border: 2px solid var(--success-green);"></div>
                    <span>Upstream Dependencies</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(245, 158, 11, 0.3); border: 2px solid var(--warning-yellow);"></div>
                    <span>Downstream Dependents</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(239, 68, 68, 0.3); border: 2px dashed var(--error-red);"></div>
                    <span>Missing Dependencies</span>
                </div>
            </div>
        </div>
    `;
    flow.upstream.copybooks.slice(0, 5).forEach(copybook => {
    const friendlyName = this.getFriendlyName(copybook.name) || copybook.name;
    const businessContext = this.getBusinessContext(copybook.name);
    html += `
        <div class="flow-node ${copybook.available ? 'upstream' : 'missing'}" 
             title="${friendlyName}${businessContext ? '\n' + businessContext : ''} - ${copybook.usage} - Line ${copybook.line}">
            <div class="flow-node-icon">üìö</div>
            <div class="flow-node-name">${friendlyName}</div>
            <div class="flow-node-type">Copybook</div>
            ${!copybook.available ? '<div class="flow-node-badge">!</div>' : ''}
        </div>
    `;
});

    container.innerHTML = html;
}


// Helper method for flow icons
getBusinessContext(componentName) {
    // Check if any analysis mentioned this component in business context
    for (const results of Object.values(this.analysisResults)) {
        if (results.llmAnalysis?.dependencyFriendlyNames?.[componentName.toUpperCase()]) {
            return results.llmAnalysis.businessContext;
        }
    }
    return null;
}

getComponentFlowIcon(componentType) {
    const icons = {
        'Copybook': 'üìö',
        'COBOL Program': 'üíº',
        'JCL Job': 'üìã',
        'Field': 'üéØ',
        'File Definition': 'üìÅ'
    };
    return icons[componentType] || 'üìã';
}

// Render Impact Analysis
renderImpactAnalysis(flow) {
    const container = document.getElementById('impactAnalysis');
    if (!container) return;
    
    const impact = flow.impactAnalysis;
    
    let html = `
        <h4>Impact Analysis for ${flow.componentName}</h4>
        <div class="impact-grid">
    `;
    
    // High Impact
    if (impact.high.length > 0) {
        html += `
            <div class="impact-card">
                <div class="impact-header">
                    <div class="impact-icon impact-high">‚ö†Ô∏è</div>
                    <div class="impact-title">High Impact (${impact.high.length})</div>
                </div>
                <div class="impact-description">
        `;
        impact.high.forEach(item => {
            html += `<p><strong>${item.type}:</strong> ${item.description}</p>`;
            });
       html += `
               </div>
           </div>
       `;
   }
   
   // Medium Impact
   if (impact.medium.length > 0) {
       html += `
           <div class="impact-card">
               <div class="impact-header">
                   <div class="impact-icon impact-medium">‚ö°</div>
                   <div class="impact-title">Medium Impact (${impact.medium.length})</div>
               </div>
               <div class="impact-description">
       `;
       impact.medium.forEach(item => {
           html += `<p><strong>${item.type}:</strong> ${item.description}</p>`;
       });
       html += `
               </div>
           </div>
       `;
   }
   
   // Low Impact
   if (impact.low.length > 0) {
       html += `
           <div class="impact-card">
               <div class="impact-header">
                   <div class="impact-icon impact-low">‚úÖ</div>
                   <div class="impact-title">Low Impact (${impact.low.length})</div>
               </div>
               <div class="impact-description">
       `;
       impact.low.forEach(item => {
           html += `<p><strong>${item.type}:</strong> ${item.description}</p>`;
       });
       html += `
               </div>
           </div>
       `;
   }
   
   html += `
       </div>
       
       <!-- Flow Characteristics -->
       <div style="margin-top: 1.5rem;">
           <h5>Flow Characteristics</h5>
           <div style="background: var(--grey-50); padding: 1rem; border-radius: 8px;">
               <p><strong>Flow Type:</strong> <span class="badge badge-primary">${flow.flowType}</span></p>
               <p><strong>Complexity:</strong> <span class="badge ${this.getComplexityBadgeClass(flow.complexity)}">${flow.complexity}</span></p>
               <p><strong>Total Dependencies:</strong> ${Object.values(flow.upstream).reduce((sum, arr) => sum + arr.length, 0)} upstream, ${Object.values(flow.downstream).reduce((sum, arr) => sum + arr.length, 0)} downstream</p>
           </div>
       </div>
   `;
   
   container.innerHTML = html;
}

// Render Detailed Flow Analysis
renderDetailedFlowAnalysis(flow) {
   const container = document.getElementById('detailedFlowAnalysis');
   if (!container) return;
   
   let html = `
       <h4>Detailed Dependency Flow Analysis</h4>
       
       <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin-bottom: 2rem;">
   `;
   
   // Upstream Details
   html += `
       <div>
           <h5 style="color: var(--success-green);">üîº Upstream Dependencies</h5>
   `;
   
   if (flow.upstream.copybooks.length > 0) {
       html += `
           <div style="margin-bottom: 1rem;">
               <h6>üìö Copybooks (${flow.upstream.copybooks.length})</h6>
               <div style="background: var(--grey-50); padding: 1rem; border-radius: 8px;">
       `;
       flow.upstream.copybooks.forEach(copybook => {
           const statusClass = copybook.available ? 'success' : 'danger';
           const statusIcon = copybook.available ? '‚úÖ' : '‚ùå';
           html += `
               <div style="margin-bottom: 0.5rem;">
                   <span class="badge badge-${statusClass}">${statusIcon} ${copybook.name}</span>
                   <small style="margin-left: 0.5rem; color: var(--grey-600);">
                       ${copybook.usage} in ${copybook.file} (line ${copybook.line})
                   </small>
               </div>
           `;
       });
       html += `</div></div>`;
   }
   
   if (flow.upstream.programs.length > 0) {
       html += `
           <div style="margin-bottom: 1rem;">
               <h6>üíº Programs (${flow.upstream.programs.length})</h6>
               <div style="background: var(--grey-50); padding: 1rem; border-radius: 8px;">
       `;
       flow.upstream.programs.forEach(program => {
           const statusClass = program.available ? 'success' : 'danger';
           const statusIcon = program.available ? '‚úÖ' : '‚ùå';
           html += `
               <div style="margin-bottom: 0.5rem;">
                   <span class="badge badge-${statusClass}">${statusIcon} ${program.name}</span>
                   <small style="margin-left: 0.5rem; color: var(--grey-600);">
                       ${program.usage} in ${program.file} (line ${program.line})
                   </small>
               </div>
           `;
       });
       html += `</div></div>`;
   }
   
   if (flow.upstream.files.length > 0) {
       html += `
           <div style="margin-bottom: 1rem;">
               <h6>üìÅ Files (${flow.upstream.files.length})</h6>
               <div style="background: var(--grey-50); padding: 1rem; border-radius: 8px;">
       `;
       flow.upstream.files.forEach(file => {
           html += `
               <div style="margin-bottom: 0.5rem;">
                   <span class="badge badge-grey">üìÅ ${file.name}</span>
                   <small style="margin-left: 0.5rem; color: var(--grey-600);">
                       ${file.usage} in ${file.file} (line ${file.line})
                   </small>
               </div>
           `;
       });
       html += `</div></div>`;
   }
   
   if (flow.upstream.databases.length > 0) {
       html += `
           <div style="margin-bottom: 1rem;">
               <h6>üóÑÔ∏è Databases (${flow.upstream.databases.length})</h6>
               <div style="background: var(--grey-50); padding: 1rem; border-radius: 8px;">
       `;
       flow.upstream.databases.forEach(db => {
           html += `
               <div style="margin-bottom: 0.5rem;">
                   <span class="badge badge-info">üóÑÔ∏è ${db.name}</span>
                   <small style="margin-left: 0.5rem; color: var(--grey-600);">
                       ${db.usage} in ${db.file} (line ${db.line})
                   </small>
               </div>
           `;
       });
       html += `</div></div>`;
   }
   
   html += `</div>`;
   
   // Downstream Details
   html += `
       <div>
           <h5 style="color: var(--warning-yellow);">üîΩ Downstream Dependents</h5>
   `;
   
   if (flow.downstream.programs.length > 0) {
       html += `
           <div style="margin-bottom: 1rem;">
               <h6>üíº Programs (${flow.downstream.programs.length})</h6>
               <div style="background: var(--grey-50); padding: 1rem; border-radius: 8px;">
       `;
       flow.downstream.programs.forEach(program => {
           html += `
               <div style="margin-bottom: 0.5rem;">
                   <span class="badge badge-warning">üíº ${program.name}</span>
                   <small style="margin-left: 0.5rem; color: var(--grey-600);">
                       ${program.usage} - ${program.type}
                   </small>
               </div>
           `;
       });
       html += `</div></div>`;
   }
   
   if (flow.downstream.jobs.length > 0) {
       html += `
           <div style="margin-bottom: 1rem;">
               <h6>üìã Jobs (${flow.downstream.jobs.length})</h6>
               <div style="background: var(--grey-50); padding: 1rem; border-radius: 8px;">
       `;
       flow.downstream.jobs.forEach(job => {
           html += `
               <div style="margin-bottom: 0.5rem;">
                   <span class="badge badge-warning">üìã ${job.name}</span>
                   <small style="margin-left: 0.5rem; color: var(--grey-600);">
                       ${job.usage} - ${job.type}
                   </small>
               </div>
           `;
       });
       html += `</div></div>`;
   }
   
   if (flow.downstream.screens.length > 0) {
       html += `
           <div style="margin-bottom: 1rem;">
               <h6>üñ•Ô∏è CICS Screens (${flow.downstream.screens.length})</h6>
               <div style="background: var(--grey-50); padding: 1rem; border-radius: 8px;">
       `;
       flow.downstream.screens.forEach(screen => {
           html += `
               <div style="margin-bottom: 0.5rem;">
                   <span class="badge badge-warning">üñ•Ô∏è ${screen.name}</span>
                   <small style="margin-left: 0.5rem; color: var(--grey-600);">
                       ${screen.usage} - ${screen.type}
                   </small>
               </div>
           `;
       });
       html += `</div></div>`;
   }
   
   html += `</div></div>`;
   
   // Critical Path Analysis
   if (flow.criticalPath && flow.criticalPath.length > 0) {
       html += `
           <div style="margin-top: 2rem;">
               <h5>üõ§Ô∏è Critical Path</h5>
               <div style="background: linear-gradient(135deg, var(--primary-blue) 0%, var(--secondary-blue) 100%); padding: 1rem; border-radius: 8px; color: white;">
                   <div style="display: flex; align-items: center; gap: 1rem; flex-wrap: wrap;">
       `;
       
       flow.criticalPath.forEach((item, index) => {
           const isLast = index === flow.criticalPath.length - 1;
           html += `
               <div style="display: flex; align-items: center; gap: 0.5rem;">
                   <div style="background: rgba(255,255,255,0.2); padding: 0.5rem 1rem; border-radius: 6px;">
                       ${item.name || item}
                   </div>
                   ${!isLast ? '<div style="font-size: 0.75rem;">‚Üí</div>' : ''}
               </div>
           `;
       });
       
       html += `
                   </div>
               </div>
           </div>
       `;
   }
   
   container.innerHTML = html;
}

// Helper method for complexity badge class
getComplexityBadgeClass(complexity) {
   switch(complexity) {
       case 'LOW': return 'badge-success';
       case 'MEDIUM': return 'badge-warning';
       case 'HIGH': return 'badge-danger';
       default: return 'badge-grey';
   }
}
// Display File Lifecycle
// Display File Lifecycle
displayFileLifecycle(displayName, results) {
    const container = document.getElementById('fileflowContent');
    const fieldLifecycleContainer = document.getElementById('fieldLifecycle');
    
    if (!container) return;
    
    if (!results.lifecycleFlow) {
        container.innerHTML = '<p>No lifecycle flow analysis available.</p>';
        return;
    }
    
    const flow = results.lifecycleFlow;
    
    let html = `
        <h4>File Lifecycle Flow for ${displayName}</h4>
        <div style="background: linear-gradient(135deg, var(--primary-blue) 0%, var(--secondary-blue) 100%); color: white; padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem;">
            <div style="font-size: 1.2rem; font-weight: bold;">Usage Pattern: ${flow.usagePattern || 'UNKNOWN'}</div>
        </div>
    `;
    
    // Add lifecycle stages visualization
    if (flow.creationSources?.length > 0 || flow.readPrograms?.length > 0 || flow.updatePrograms?.length > 0) {
        html += `
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1.5rem;">
                <div style="text-align: center; padding: 1rem; background: var(--grey-50); border-radius: 8px;">
                    <div style="font-size: 2rem;">üå±</div>
                    <div style="font-weight: bold; color: var(--success-green);">Creation</div>
                    <div style="font-size: 1.5rem; color: var(--primary-blue);">${flow.creationSources?.length || 0}</div>
                    <div style="font-size: 0.8rem; color: var(--grey-600);">Programs</div>
                </div>
                <div style="text-align: center; padding: 1rem; background: var(--grey-50); border-radius: 8px;">
                    <div style="font-size: 2rem;">üìñ</div>
                    <div style="font-weight: bold; color: var(--info-blue);">Reading</div>
                    <div style="font-size: 1.5rem; color: var(--primary-blue);">${flow.readPrograms?.length || 0}</div>
                    <div style="font-size: 0.8rem; color: var(--grey-600);">Programs</div>
                </div>
                <div style="text-align: center; padding: 1rem; background: var(--grey-50); border-radius: 8px;">
                    <div style="font-size: 2rem;">‚öôÔ∏è</div>
                    <div style="font-weight: bold; color: var(--warning-yellow);">Updates</div>
                    <div style="font-size: 1.5rem; color: var(--primary-blue);">${flow.updatePrograms?.length || 0}</div>
                    <div style="font-size: 0.8rem; color: var(--grey-600);">Programs</div>
                </div>
            </div>
        `;
    }
    
    // Add detailed program breakdown
    if (flow.creationSources?.length > 0 || flow.readPrograms?.length > 0 || flow.updatePrograms?.length > 0) {
        html += `
            <div style="margin-bottom: 1.5rem;">
                <h5>Program Breakdown by Operation</h5>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem;">
        `;
        
        // Creation Programs
        if (flow.creationSources?.length > 0) {
            html += `
                <div style="background: var(--grey-50); padding: 1rem; border-radius: 8px; border-left: 4px solid var(--success-green);">
                    <h6 style="color: var(--success-green); margin-bottom: 0.75rem;">üå± Creation Programs</h6>
            `;
            flow.creationSources.forEach(source => {
                html += `
                    <div style="margin-bottom: 0.5rem; padding: 0.5rem; background: white; border-radius: 4px;">
                        <div style="font-weight: 600;">${source.program}</div>
                        <div style="font-size: 0.8rem; color: var(--grey-600);">${source.operations?.length || 0} operations</div>
                    </div>
                `;
            });
            html += `</div>`;
        }
        
        // Read Programs
        if (flow.readPrograms?.length > 0) {
            html += `
                <div style="background: var(--grey-50); padding: 1rem; border-radius: 8px; border-left: 4px solid var(--info-blue);">
                    <h6 style="color: var(--info-blue); margin-bottom: 0.75rem;">üìñ Read Programs</h6>
            `;
            flow.readPrograms.forEach(prog => {
                html += `
                    <div style="margin-bottom: 0.5rem; padding: 0.5rem; background: white; border-radius: 4px;">
                        <div style="font-weight: 600;">${prog.program}</div>
                        <div style="font-size: 0.8rem; color: var(--grey-600);">${prog.operations?.length || 0} operations</div>
                    </div>
                `;
            });
            html += `</div>`;
        }
        
        // Update Programs
        if (flow.updatePrograms?.length > 0) {
            html += `
                <div style="background: var(--grey-50); padding: 1rem; border-radius: 8px; border-left: 4px solid var(--warning-yellow);">
                    <h6 style="color: var(--warning-yellow); margin-bottom: 0.75rem;">‚öôÔ∏è Update Programs</h6>
            `;
            flow.updatePrograms.forEach(prog => {
                html += `
                    <div style="margin-bottom: 0.5rem; padding: 0.5rem; background: white; border-radius: 4px;">
                        <div style="font-weight: 600;">${prog.program}</div>
                        <div style="font-size: 0.8rem; color: var(--grey-600);">${prog.operations?.length || 0} operations</div>
                    </div>
                `;
            });
            html += `</div>`;
        }
        
        html += `</div></div>`;
    }
    
    container.innerHTML = html;
    
    // Now populate the Field Lifecycle Details section
    if (fieldLifecycleContainer) {
        fieldLifecycleContainer.innerHTML = this.renderFieldLifecycleDetails(displayName, results);
    }
}

// Render Field Lifecycle Details
renderFieldLifecycleDetails(displayName, results) {
    if (!results.fieldAnalysis) {
        return '<p>No field lifecycle analysis available for this component.</p>';
    }
    
    const fieldAnalysis = results.fieldAnalysis;
    const lifecycleFlow = results.lifecycleFlow;
    
    let html = `
        <h4>Field Lifecycle Details for ${displayName}</h4>
        
        <!-- Field Overview -->
        <div style="background: var(--grey-50); padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem;">
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem; text-align: center;">
                <div>
                    <div style="font-size: 1.25rem; font-weight: bold; color: var(--primary-blue);">${fieldAnalysis.fields?.length || 0}</div>
                    <div style="font-size: 0.85rem; color: var(--grey-600);">Total Fields</div>
                </div>
                <div>
                    <div style="font-size: 1.25rem; font-weight: bold; color: var(--success-green);">${fieldAnalysis.inputFields?.length || 0}</div>
                    <div style="font-size: 0.85rem; color: var(--grey-600);">Input Fields</div>
                </div>
                <div>
                    <div style="font-size: 1.25rem; font-weight: bold; color: var(--info-blue);">${fieldAnalysis.outputFields?.length || 0}</div>
                    <div style="font-size: 0.85rem; color: var(--grey-600);">Output Fields</div>
                </div>
                <div>
                    <div style="font-size: 1.25rem; font-weight: bold; color: var(--warning-yellow);">${fieldAnalysis.referenceFields?.length || 0}</div>
                    <div style="font-size: 0.85rem; color: var(--grey-600);">Reference Fields</div>
                </div>
                <div>
                    <div style="font-size: 1.25rem; font-weight: bold; color: var(--error-red);">${fieldAnalysis.unusedFields?.length || 0}</div>
                    <div style="font-size: 0.85rem; color: var(--grey-600);">Unused Fields</div>
                </div>
            </div>
        </div>
    `;
    
    // Field Lifecycle Flow
    if (fieldAnalysis.fields && fieldAnalysis.fields.length > 0) {
        html += `
            <div style="margin-bottom: 1.5rem;">
                <h5>üìã Field Lifecycle Flow</h5>
                <div style="background: white; border: 1px solid var(--grey-200); border-radius: 8px; overflow: hidden;">
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>Field Name</th>
                                <th>Level</th>
                                <th>Lifecycle Stage</th>
                                <th>Used By</th>
                                <th>Operations</th>
                            </tr>
                        </thead>
                        <tbody>
        `;
        
        // Show top 20 fields with their lifecycle details
        fieldAnalysis.fields.slice(0, 20).forEach(field => {
            const fieldName = field.name;
            const usageDetails = fieldAnalysis.fieldUsageDetails?.[fieldName];
            const lifecycleStage = this.determineFieldLifecycleStage(fieldName, fieldAnalysis, usageDetails);
            const usedByPrograms = this.getFieldUsagePrograms(fieldName, fieldAnalysis, usageDetails);
            const operationCount = usageDetails?.operations?.length || 0;
            
            html += `
                <tr>
                    <td style="font-family: monospace; font-weight: 600;">${fieldName}</td>
                    <td>${field.level}</td>
                    <td><span class="badge ${this.getLifecycleStageBadgeClass(lifecycleStage)}">${lifecycleStage}</span></td>
                    <td style="font-size: 0.85rem;">${usedByPrograms}</td>
                    <td><span class="badge badge-primary">${operationCount} ops</span></td>
                </tr>
            `;
        });
        
        html += `
                        </tbody>
                    </table>
                </div>
        `;
        
        if (fieldAnalysis.fields.length > 20) {
            html += `<p style="margin-top: 0.5rem; color: var(--grey-500); font-size: 0.85rem;">Showing 20 of ${fieldAnalysis.fields.length} fields</p>`;
        }
        
        html += `</div>`;
    }
    
    // Field Usage by Program
    if (fieldAnalysis.programs && fieldAnalysis.programs.length > 0) {
        html += `
            <div style="margin-bottom: 1.5rem;">
                <h5>üíº Field Usage by Program</h5>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1rem;">
        `;
        
        fieldAnalysis.programs.forEach(program => {
            const programFields = this.getFieldsUsedByProgram(program, fieldAnalysis);
            
            html += `
                <div style="background: white; border: 1px solid var(--grey-200); border-radius: 8px; padding: 1rem;">
                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.75rem;">
                        <div style="font-weight: 600; color: var(--grey-800);">üíº ${program.name}</div>
                        <span class="badge badge-primary">${programFields.read.length + programFields.written.length} fields</span>
                    </div>
                    
                    ${programFields.read.length > 0 ? `
                        <div style="margin-bottom: 0.5rem;">
                            <div style="font-size: 0.8rem; font-weight: 600; color: var(--info-blue);">üìñ Reads (${programFields.read.length})</div>
                            <div style="font-size: 0.75rem; color: var(--grey-600);">${programFields.read.slice(0, 5).join(', ')}${programFields.read.length > 5 ? '...' : ''}</div>
                        </div>
                    ` : ''}
                    
                    ${programFields.written.length > 0 ? `
                        <div style="margin-bottom: 0.5rem;">
                            <div style="font-size: 0.8rem; font-weight: 600; color: var(--success-green);">‚úèÔ∏è Writes (${programFields.written.length})</div>
                            <div style="font-size: 0.75rem; color: var(--grey-600);">${programFields.written.slice(0, 5).join(', ')}${programFields.written.length > 5 ? '...' : ''}</div>
                        </div>
                    ` : ''}
                </div>
            `;
        });
        
        html += `</div></div>`;
    }
    
    // Business Logic Summary (if available)
    if (fieldAnalysis.businessLogicSummary) {
        const summary = fieldAnalysis.businessLogicSummary;
        html += `
            <div style="margin-bottom: 1.5rem;">
                <h5>‚öñÔ∏è Field Business Logic Summary</h5>
                <div style="background: linear-gradient(135deg, var(--accent-blue) 0%, var(--secondary-blue) 100%); padding: 1rem; border-radius: 8px; color: white;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem; text-align: center;">
                        <div>
                            <div style="font-size: 1.25rem; font-weight: bold;">${summary.totalValidationRules || 0}</div>
                            <div style="font-size: 0.85rem; opacity: 0.9;">Validation Rules</div>
                        </div>
                        <div>
                            <div style="font-size: 1.25rem; font-weight: bold;">${summary.totalCalculations || 0}</div>
                            <div style="font-size: 0.85rem; opacity: 0.9;">Calculations</div>
                        </div>
                        <div>
                            <div style="font-size: 1.25rem; font-weight: bold;">${summary.fieldsWithBusinessLogic || 0}</div>
                            <div style="font-size: 0.85rem; opacity: 0.9;">Fields with Logic</div>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }
    
    return html;
}

// Helper Methods for Field Lifecycle Details
determineFieldLifecycleStage(fieldName, fieldAnalysis, usageDetails) {
    if (!usageDetails || !usageDetails.operations || usageDetails.operations.length === 0) {
        return 'UNUSED';
    }
    
    const operations = usageDetails.operations;
    const hasInput = operations.some(op => op.type === 'input' || op.type === 'write');
    const hasOutput = operations.some(op => op.type === 'display' || op.type === 'read');
    const hasValidation = operations.some(op => op.type === 'validation' || op.type === 'business_rule');
    const hasCalculation = operations.some(op => op.type === 'calculation');
    
    if (hasCalculation) return 'CALCULATED';
    if (hasValidation) return 'VALIDATED';
    if (hasInput && hasOutput) return 'PROCESSED';
    if (hasInput) return 'INPUT';
    if (hasOutput) return 'OUTPUT';
    
    return 'REFERENCED';
}

getLifecycleStageBadgeClass(stage) {
    switch(stage) {
        case 'INPUT': return 'badge-success';
        case 'OUTPUT': return 'badge-primary';
        case 'PROCESSED': return 'badge-info';
        case 'CALCULATED': return 'badge-warning';
        case 'VALIDATED': return 'badge-success';
        case 'REFERENCED': return 'badge-grey';
        case 'UNUSED': return 'badge-danger';
        default: return 'badge-grey';
    }
}

getFieldUsagePrograms(fieldName, fieldAnalysis, usageDetails) {
    if (!usageDetails) return 'None';
    
    const programs = new Set();
    
    if (usageDetails.readBy) {
        usageDetails.readBy.forEach(prog => programs.add(prog));
    }
    
    if (usageDetails.writtenBy) {
        usageDetails.writtenBy.forEach(prog => programs.add(prog));
    }
    
    if (usageDetails.referencedBy) {
        usageDetails.referencedBy.forEach(prog => programs.add(prog));
    }
    
    const programArray = Array.from(programs);
    if (programArray.length === 0) return 'None';
    if (programArray.length <= 3) return programArray.join(', ');
    
    return `${programArray.slice(0, 2).join(', ')}, +${programArray.length - 2} more`;
}

getFieldsUsedByProgram(program, fieldAnalysis) {
    const result = {
        read: [],
        written: []
    };
    
    if (fieldAnalysis.fieldUsageDetails) {
        Object.entries(fieldAnalysis.fieldUsageDetails).forEach(([fieldName, details]) => {
            if (details.readBy && details.readBy.includes(program.name)) {
                result.read.push(fieldName);
            }
            if (details.writtenBy && details.writtenBy.includes(program.name)) {
                result.written.push(fieldName);
            }
        });
    }
    
    return result;
}
// Render helper methods
renderDependencyAnalysis(deps) {
    return `
        <div style="margin-top: 1.5rem;">
            <h4>Dependency Analysis</h4>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                <div style="background: rgba(16, 185, 129, 0.1); padding: 1rem; border-radius: 8px; border-left: 4px solid var(--success-green);">
                    <h5 style="color: var(--success-green);">‚úÖ Found Dependencies</h5>
                    <p>Total: <strong>${deps.summary?.foundCount || 0}</strong></p>
                    <div style="font-size: 0.85rem;">
                        ${deps.found?.copybooks?.length > 0 ? `<p>Copybooks: ${deps.found.copybooks.length}</p>` : ''}
                        ${deps.found?.programs?.length > 0 ? `<p>Programs: ${deps.found.programs.length}</p>` : ''}
                        ${deps.found?.files?.length > 0 ? `<p>Files: ${deps.found.files.length}</p>` : ''}
                    </div>
                </div>
                <div style="background: rgba(239, 68, 68, 0.1); padding: 1rem; border-radius: 8px; border-left: 4px solid var(--error-red);">
                    <h5 style="color: var(--error-red);">‚ùå Missing Dependencies</h5>
                    <p>Total: <strong>${deps.summary?.missingCount || 0}</strong></p>
                    <div style="font-size: 0.85rem;">
                        ${deps.missing?.copybooks?.length > 0 ? `<p>Copybooks: ${deps.missing.copybooks.length}</p>` : ''}
                        ${deps.missing?.programs?.length > 0 ? `<p>Programs: ${deps.missing.programs.length}</p>` : ''}
                        ${deps.missing?.files?.length > 0 ? `<p>Files: ${deps.missing.files.length}</p>` : ''}
                    </div>
                </div>
            </div>
        </div>
    `;
}

renderLLMAnalysis(llmAnalysis, displayName) {
    if (!llmAnalysis) {
        return '<p>No LLM analysis results available.</p>';
    }
    
    if (llmAnalysis.error) {
        return `
            <div style="background: rgba(239, 68, 68, 0.1); padding: 1rem; border-radius: 8px; border-left: 4px solid var(--error-red);">
                <h4 style="color: var(--error-red);">‚ö†Ô∏è LLM Analysis Error</h4>
                <p>${llmAnalysis.message || 'LLM analysis encountered an error'}</p>
            </div>
        `;
    }
    
    let html = `<h4>LLM Analysis Results for ${displayName}</h4>`;
    
    // Business purpose
    if (llmAnalysis.businessPurpose || llmAnalysis.purpose) {
        html += `
            <div style="margin-bottom: 1rem;">
                <h5>üéØ Business Purpose</h5>
                <p>${llmAnalysis.businessPurpose || llmAnalysis.purpose}</p>
            </div>
        `;
    }
    
    // Field summary (for copybooks)
    if (llmAnalysis.fieldSummary) {
        html += `
            <div style="margin-bottom: 1rem;">
                <h5>üìã Field Summary</h5>
                <div style="background: var(--grey-50); padding: 1rem; border-radius: 8px;">
                    ${llmAnalysis.fieldSummary.primaryFields ? 
                        `<p><strong>Primary Fields:</strong> ${llmAnalysis.fieldSummary.primaryFields.join(', ')}</p>` : ''}
                    <p><strong>Input Fields:</strong> ${llmAnalysis.fieldSummary.inputFields || 0}</p>
                    <p><strong>Output Fields:</strong> ${llmAnalysis.fieldSummary.outputFields || 0}</p>
                    <p><strong>Unused Fields:</strong> ${llmAnalysis.fieldSummary.unusedFields || 0}</p>
                </div>
            </div>
        `;
    }
    
    // Program structure (for programs)
    if (llmAnalysis.programStructure) {
        html += `
            <div style="margin-bottom: 1rem;">
                <h5>üèóÔ∏è Program Structure</h5>
                <div style="background: var(--grey-50); padding: 1rem; border-radius: 8px;">
                    ${llmAnalysis.programStructure.divisions ? 
                        `<p><strong>Divisions:</strong> ${llmAnalysis.programStructure.divisions.join(', ')}</p>` : ''}
                    ${llmAnalysis.programStructure.complexity ? 
                        `<p><strong>Complexity:</strong> <span class="badge badge-primary">${llmAnalysis.programStructure.complexity}</span></p>` : ''}
                </div>
            </div>
        `;
    }
    
    // Field operations (for programs)
    if (llmAnalysis.fieldOperations) {
        html += `
            <div style="margin-bottom: 1rem;">
                <h5>üîÑ Field Operations</h5>
                <div style="background: var(--grey-50); padding: 1rem; border-radius: 8px;">
                    ${llmAnalysis.fieldOperations.fieldsRead ? 
                        `<p><strong>Fields Read:</strong> ${llmAnalysis.fieldOperations.fieldsRead.join(', ')}</p>` : ''}
                    ${llmAnalysis.fieldOperations.fieldsWritten ? 
                        `<p><strong>Fields Written:</strong> ${llmAnalysis.fieldOperations.fieldsWritten.join(', ')}</p>` : ''}
                    ${llmAnalysis.fieldOperations.fieldsValidated ? 
                        `<p><strong>Fields Validated:</strong> ${llmAnalysis.fieldOperations.fieldsValidated.join(', ')}</p>` : ''}
                </div>
            </div>
        `;
    }
    
    return html;
}

renderRecommendations(llmAnalysis) {
    if (!llmAnalysis || !llmAnalysis.recommendations || llmAnalysis.recommendations.length === 0) {
        return '<p>No recommendations available.</p>';
    }
    
    let html = '<h4>üí° Recommendations</h4><ol>';
    
    llmAnalysis.recommendations.forEach(rec => {
        html += `
            <li style="margin-bottom: 0.75rem; padding: 0.75rem; background: var(--grey-50); border-radius: 6px;">
                ${rec}
            </li>
        `;
    });
    
    html += '</ol>';
    return html;
}

renderFieldStatistics(fieldAnalysis) {
    if (!fieldAnalysis) {
        return '<p>No field statistics available.</p>';
    }
    
    const total = fieldAnalysis.fields.length;
    const inputPct = total > 0 ? Math.round((fieldAnalysis.inputFields.length / total) * 100) : 0;
    const outputPct = total > 0 ? Math.round((fieldAnalysis.outputFields.length / total) * 100) : 0;
    const refPct = total > 0 ? Math.round((fieldAnalysis.referenceFields.length / total) * 100) : 0;
    const unusedPct = total > 0 ? Math.round((fieldAnalysis.unusedFields.length / total) * 100) : 0;
    
    return `
        <h4>Field Usage Statistics</h4>
        <div style="margin-bottom: 1rem;">
            <div style="margin-bottom: 0.5rem;">
                <div style="display: flex; justify-content: space-between;">
                    <span>Input Fields</span>
                    <span>${fieldAnalysis.inputFields.length} (${inputPct}%)</span>
                </div>
                <div style="height: 8px; background: var(--grey-200); border-radius: 4px; overflow: hidden;">
                    <div style="width: ${inputPct}%; height: 100%; background: var(--success-green);"></div>
                </div>
            </div>
            <div style="margin-bottom: 0.5rem;">
                <div style="display: flex; justify-content: space-between;">
                    <span>Output Fields</span>
                    <span>${fieldAnalysis.outputFields.length} (${outputPct}%)</span>
                </div>
                <div style="height: 8px; background: var(--grey-200); border-radius: 4px; overflow: hidden;">
                    <div style="width: ${outputPct}%; height: 100%; background: var(--info-blue);"></div>
                </div>
            </div>
            <div style="margin-bottom: 0.5rem;">
                <div style="display: flex; justify-content: space-between;">
                    <span>Reference Fields</span>
                    <span>${fieldAnalysis.referenceFields.length} (${refPct}%)</span>
                </div>
                <div style="height: 8px; background: var(--grey-200); border-radius: 4px; overflow: hidden;">
                    <div style="width: ${refPct}%; height: 100%; background: var(--warning-yellow);"></div>
                </div>
            </div>
            <div style="margin-bottom: 0.5rem;">
                <div style="display: flex; justify-content: space-between;">
                    <span>Unused Fields</span>
                    <span>${fieldAnalysis.unusedFields.length} (${unusedPct}%)</span>
                </div>
                <div style="height: 8px; background: var(--grey-200); border-radius: 4px; overflow: hidden;">
                    <div style="width: ${unusedPct}%; height: 100%; background: var(--error-red);"></div>
                </div>
            </div>
        </div>
    `;
}

// Helper methods
determineFieldUsage(field, fieldAnalysis) {
    const fieldName = field.name;
    
    if (fieldAnalysis.inputFields.includes(fieldName)) return 'INPUT';
    if (fieldAnalysis.outputFields.includes(fieldName)) return 'OUTPUT';
    if (fieldAnalysis.referenceFields.includes(fieldName)) return 'REFERENCE';
    if (fieldAnalysis.unusedFields.includes(fieldName)) return 'UNUSED';
    
    return 'UNKNOWN';
}

getUsageBadgeClass(usage) {
    switch(usage) {
        case 'INPUT': return 'badge-success';
        case 'OUTPUT': return 'badge-primary';
        case 'REFERENCE': return 'badge-warning';
        case 'UNUSED': return 'badge-danger';
        default: return 'badge-grey';
    }
}
// ============================================
// PART 12: CHAT AND EXPORT FUNCTIONALITY
// Complete chat interface and export features
// ============================================

// Add these methods to the EnhancedMainframeAnalyzer class

// Initialize Chat
initializeChat() {
    const chatSendBtn = document.getElementById('chatSendBtn');
    const chatInput = document.getElementById('chatInput');
    
    if (chatSendBtn && chatInput) {
        chatSendBtn.addEventListener('click', () => this.sendChatMessage());
        
        chatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                this.sendChatMessage();
            }
        });
        
        // Auto-resize textarea
        chatInput.addEventListener('input', () => {
            chatInput.style.height = 'auto';
            chatInput.style.height = Math.min(chatInput.scrollHeight, 120) + 'px';
        });
    }

    // Chat suggestions
    document.querySelectorAll('.chat-suggestion-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const question = e.target.dataset.question;
            if (chatInput && question) {
                chatInput.value = question;
                this.sendChatMessage();
            }
        });
    });
}

// Enable Chat after analysis
enableChat() {
    const chatInput = document.getElementById('chatInput');
    const chatSendBtn = document.getElementById('chatSendBtn');
    const chatSuggestions = document.getElementById('chatSuggestions');
    
    if (chatInput && chatSendBtn) {
        chatInput.disabled = false;
        chatSendBtn.disabled = false;
        
        if (chatSuggestions) {
            chatSuggestions.style.display = 'block';
        }
        
        const displayName = this.getDisplayName();
        this.addChatMessage('assistant', 
            `üéØ **Analysis complete for ${displayName}!**
            
I can now provide detailed insights about this component:

üß† **Field Analysis:** ${this.analysisResults[this.currentAnalyzedComponent]?.totalFields || 0} fields analyzed with usage patterns
‚öñÔ∏è **Business Logic:** Extracted rules and validation patterns  
üîó **Dependency Analysis:** ${this.analysisResults[this.currentAnalyzedComponent]?.dependencyAnalysis?.summary?.foundCount || 0} found, ${this.analysisResults[this.currentAnalyzedComponent]?.dependencyAnalysis?.summary?.missingCount || 0} missing
üåä **Lifecycle Flow:** ${this.analysisResults[this.currentAnalyzedComponent]?.lifecycleFlow?.usagePattern || 'Pattern identified'}

**Ask me about:**
‚Ä¢ Which fields are most important in this component?
‚Ä¢ What programs create vs update this data?  
‚Ä¢ What dependencies are missing and why?
‚Ä¢ How can we optimize this component?
‚Ä¢ What are the business rules for specific fields?`
        );
    }
}

// Send Chat Message
async sendChatMessage() {
    const input = document.getElementById('chatInput');
    const sendBtn = document.getElementById('chatSendBtn');
    const message = input.value.trim();
    
    if (!message) {
        this.showError('Please enter a message');
        return;
    }
    
    if (!this.currentAnalyzedComponent) {
        this.showError('Please analyze a component first');
        return;
    }
    
    // Disable input while processing
    input.disabled = true;
    sendBtn.disabled = true;
    sendBtn.textContent = 'Processing...';
    
    // Add user message
    this.addChatMessage('user', message);
    
    // Clear input and reset height
    input.value = '';
    input.style.height = 'auto';
    
    // Show typing indicator
    this.showChatTyping();
    
    try {
        const response = await this.processChatQuery(message);
        this.hideChatTyping();
        this.addChatMessage('assistant', response);
    } catch (error) {
        console.error('Chat error:', error);
        this.hideChatTyping();
        this.addChatMessage('assistant', 
            `I apologize, but I encountered an error: ${error.message}. Please try rephrasing your question.`
        );
    } finally {
        input.disabled = false;
        sendBtn.disabled = false;
        sendBtn.textContent = 'Send';
        input.focus();
    }
}

// Process Chat Query
async processChatQuery(question) {
    const analysisData = this.analysisResults[this.currentAnalyzedComponent];
    const displayName = this.getDisplayName();
    
    // Build context for LLM
    let context = `MAINFRAME COMPONENT ANALYSIS CHAT

COMPONENT: ${this.currentAnalyzedComponent}
FRIENDLY NAME: ${displayName}
COMPONENT TYPE: ${analysisData.componentType}
ANALYSIS METHOD: ${analysisData.analysisMethod}
FILES ANALYZED: ${analysisData.filesAnalyzed.join(', ')}

FIELD ANALYSIS:
- Total Fields: ${analysisData.totalFields || 0}
- Input Fields: ${analysisData.fieldAnalysis?.inputFields?.length || 0}
- Output Fields: ${analysisData.fieldAnalysis?.outputFields?.length || 0}
- Unused Fields: ${analysisData.fieldAnalysis?.unusedFields?.length || 0}

LIFECYCLE FLOW:
- Usage Pattern: ${analysisData.lifecycleFlow?.usagePattern || 'Unknown'}
- Creation Programs: ${analysisData.lifecycleFlow?.creationSources?.length || 0}
- Read Programs: ${analysisData.lifecycleFlow?.readPrograms?.length || 0}
- Update Programs: ${analysisData.lifecycleFlow?.updatePrograms?.length || 0}

DEPENDENCY SUMMARY:
- Found Dependencies: ${analysisData.dependencyAnalysis?.summary?.foundCount || 0}
- Missing Dependencies: ${analysisData.dependencyAnalysis?.summary?.missingCount || 0}

LLM ANALYSIS RESULTS:
${JSON.stringify(analysisData.llmAnalysis || {}, null, 2)}

USER QUESTION: "${question}"

Provide a detailed, helpful response based on the analysis data above. If the question is about specific fields, reference the field analysis. Use the friendly name "${displayName}" when referring to the component.`;

    // Call LLM for response
    const response = await this.callLLMAPI(context);
    
    if (typeof response === 'string') {
        return response;
    } else if (response.error) {
        return `Based on the available analysis data: The component "${displayName}" has ${analysisData.totalFields || 0} fields analyzed. ${response.fallbackData?.recommendations?.join('. ') || 'Please check the analysis results for more details.'}`;
    } else if (response.answer) {
        return response.answer;
    } else {
        // Extract relevant information from analysis
        return this.generateChatResponse(question, analysisData, displayName);
    }
}

// Generate Chat Response (fallback)
generateChatResponse(question, analysisData, displayName) {
    const lowerQuestion = question.toLowerCase();
    
    // Field-related questions
    if (lowerQuestion.includes('field') || lowerQuestion.includes('important')) {
        if (analysisData.fieldAnalysis && analysisData.fieldAnalysis.fields) {
            const topFields = analysisData.fieldAnalysis.fields.slice(0, 5);
            return `For the component "${displayName}", here are the key fields analyzed:

${topFields.map(f => `‚Ä¢ **${f.name}** (Level ${f.level}): ${this.generateFieldPurpose(f.name)}`).join('\n')}

Total fields analyzed: ${analysisData.totalFields}
Input fields: ${analysisData.fieldAnalysis.inputFields.length}
Output fields: ${analysisData.fieldAnalysis.outputFields.length}
Unused fields: ${analysisData.fieldAnalysis.unusedFields.length}`;
        }
    }
    
    // Dependency questions
    if (lowerQuestion.includes('depend') || lowerQuestion.includes('missing')) {
        const deps = analysisData.dependencyAnalysis;
        if (deps) {
            return `Dependency analysis for "${displayName}":

**Found Dependencies (${deps.summary.foundCount}):**
‚Ä¢ Copybooks: ${deps.found.copybooks?.join(', ') || 'None'}
‚Ä¢ Programs: ${deps.found.programs?.join(', ') || 'None'}

**Missing Dependencies (${deps.summary.missingCount}):**
‚Ä¢ Copybooks: ${deps.missing.copybooks?.join(', ') || 'None'}
‚Ä¢ Programs: ${deps.missing.programs?.join(', ') || 'None'}

These missing dependencies should be uploaded for complete analysis.`;
        }
    }
    
    // Usage pattern questions
    if (lowerQuestion.includes('usage') || lowerQuestion.includes('pattern') || lowerQuestion.includes('lifecycle')) {
        const flow = analysisData.lifecycleFlow;
        if (flow) {
            return `Lifecycle analysis for "${displayName}":

**Usage Pattern:** ${flow.usagePattern || 'Unknown'}

**Programs Involved:**
‚Ä¢ Creation: ${flow.creationSources?.length || 0} programs
‚Ä¢ Reading: ${flow.readPrograms?.length || 0} programs
‚Ä¢ Updates: ${flow.updatePrograms?.length || 0} programs

This indicates that the component is primarily used for ${flow.usagePattern?.toLowerCase().replace(/_/g, ' ') || 'data processing'}.`;
        }
    }
    
    // Default response
    return `For the component "${displayName}":
    
‚Ä¢ Type: ${analysisData.componentType}
‚Ä¢ Total Fields: ${analysisData.totalFields || 0}
‚Ä¢ Quality Score: ${analysisData.qualityScore}/10
‚Ä¢ Files Analyzed: ${analysisData.filesAnalyzed.length}

Please ask a more specific question about fields, dependencies, usage patterns, or recommendations.`;
}

// Add Chat Message
addChatMessage(sender, content) {
    const messagesContainer = document.getElementById('chatMessages');
    if (!messagesContainer) return;
    
    const messageDiv = document.createElement('div');
    messageDiv.className = `chat-message ${sender}`;
    
    const bubbleContent = this.formatChatContent(content);
    
    messageDiv.innerHTML = `
        <div class="chat-bubble">
            <div class="chat-message-header">${sender === 'user' ? 'You' : 'LLM Assistant'}</div>
            <div class="chat-message-content">${bubbleContent}</div>
            <div class="chat-message-time">${new Date().toLocaleTimeString()}</div>
        </div>
    `;
    
    messagesContainer.appendChild(messageDiv);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
    
    // Add to chat history
    this.chatHistory.push({
        sender: sender,
        content: content,
        timestamp: new Date().toISOString()
    });
    
    this.saveToStorage();
}

// Format Chat Content
formatChatContent(content) {
    return content
        .replace(/\n/g, '<br>')
        .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
        .replace(/‚Ä¢/g, '&bull;')
        .replace(/`([^`]+)`/g, '<code style="background: var(--grey-100); padding: 2px 4px; border-radius: 3px;">$1</code>');
}

// Show Chat Typing Indicator
showChatTyping() {
    const messagesContainer = document.getElementById('chatMessages');
    if (!messagesContainer) return;
    
    this.hideChatTyping();
    
    const typingDiv = document.createElement('div');
    typingDiv.id = 'typingIndicator';
    typingDiv.className = 'chat-message assistant';
    
    typingDiv.innerHTML = `
        <div class="chat-bubble">
            <div class="chat-message-header">LLM Assistant</div>
            <div class="chat-message-content">
                <span style="opacity: 0.7;">Processing your question...</span>
                <span class="typing-dots">
                    <span>.</span><span>.</span><span>.</span>
                </span>
            </div>
        </div>
    `;
    
    messagesContainer.appendChild(typingDiv);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

// Hide Chat Typing Indicator
hideChatTyping() {
    const typingIndicator = document.getElementById('typingIndicator');
    if (typingIndicator && typingIndicator.parentNode) {
        typingIndicator.parentNode.removeChild(typingIndicator);
    }
}

// Bulk Analyze
async bulkAnalyze() {
    if (this.uploadedFiles.length === 0) {
        this.showError('No files uploaded for bulk analysis');
        return;
    }

    this.showLoading();
    this.updateLoadingStatus('üîÑ Starting bulk analysis...');

    const components = this.componentSuggestions
        .filter(c => c.type === 'RECORD_LAYOUT' || c.type === 'PROGRAM')
        .slice(0, 5); // Limit to 5 components
    
    let completed = 0;

    try {
        for (const component of components) {
            this.updateLoadingStatus(`Analyzing ${component.name} (${completed + 1}/${components.length})...`);
            this.updateProgress((completed / components.length) * 100);
            
            try {
                this.currentAnalyzedComponent = component.name;
                this.currentFriendlyName = component.name;
                
                const relevantFiles = this.findRelevantFiles(component.name);
                const results = await this.runComprehensiveAnalysis(component.name, relevantFiles);
                
                this.analysisResults[component.name] = results;
                completed++;
                
                await this.sleep(2000); // Brief pause between analyses
            } catch (error) {
                console.warn(`Failed to analyze ${component.name}:`, error);
            }
        }

        this.hideLoading();
        this.saveToStorage();
        this.showSuccess(`‚ú® Bulk analysis complete! ${completed}/${components.length} components analyzed`);

        // Display results of first component
        if (completed > 0 && components[0]) {
            this.displayAnalysisResults(components[0].name, this.analysisResults[components[0].name]);
        }

    } catch (error) {
        this.hideLoading();
        this.showError(`Bulk analysis failed: ${error.message}`);
    }
}

// Export Results
async exportResults(format) {
    if (Object.keys(this.analysisResults).length === 0) {
        this.showError('No analysis results to export');
        return;
    }

    try {
        if (format === 'json') {
            this.exportAsJSON();
        } else if (format === 'markdown') {
            this.exportAsMarkdown();
        }
    } catch (error) {
        this.showError(`Export failed: ${error.message}`);
    }
}

// Export as JSON
exportAsJSON() {
    const exportData = {
        metadata: {
            timestamp: new Date().toISOString(),
            totalComponents: Object.keys(this.analysisResults).length,
            totalFiles: this.uploadedFiles.length,
            analysisMethod: 'LLM-Enhanced-Field-Focused',
            version: '2.0.0'
        },
        analysisResults: this.analysisResults,
        chatHistory: this.chatHistory
    };

    const dataStr = JSON.stringify(exportData, null, 2);
    const filename = `mainframe-analysis-${new Date().toISOString().split('T')[0]}.json`;
    
    this.downloadTextFile(dataStr, filename, 'application/json');
    this.showSuccess(`üìã Analysis results exported as ${filename}`);
}

// Export as Markdown
exportAsMarkdown() {
    let markdown = `# Mainframe Component Analysis Report\n\n`;
    markdown += `**Generated:** ${new Date().toLocaleString()}\n`;
    markdown += `**Analysis Method:** LLM-Enhanced Field-Focused Analysis\n\n`;
    markdown += `---\n\n`;

    for (const [componentName, results] of Object.entries(this.analysisResults)) {
        const displayName = results.friendlyName || componentName;
        
        markdown += `## ${displayName}\n\n`;
        markdown += `**Component Name:** ${componentName}\n`;
        markdown += `**Type:** ${results.componentType}\n`;
        markdown += `**Quality Score:** ${results.qualityScore}/10\n`;
        markdown += `**Completeness:** ${results.completeness?.score || 0}%\n`;
        markdown += `**Files Analyzed:** ${results.filesAnalyzed.length}\n\n`;
        
        // Field Analysis
        if (results.fieldAnalysis && results.fieldAnalysis.fields) {
            markdown += `### Field Analysis\n\n`;
            markdown += `- **Total Fields:** ${results.fieldAnalysis.fields.length}\n`;
            markdown += `- **Input Fields:** ${results.fieldAnalysis.inputFields.length}\n`;
            markdown += `- **Output Fields:** ${results.fieldAnalysis.outputFields.length}\n`;
            markdown += `- **Reference Fields:** ${results.fieldAnalysis.referenceFields.length}\n`;
            markdown += `- **Unused Fields:** ${results.fieldAnalysis.unusedFields.length}\n\n`;
            
            if (results.fieldAnalysis.fields.length > 0) {
                markdown += `#### Top Fields\n\n`;
                markdown += `| Field Name | Level | Picture | Usage |\n`;
                markdown += `|------------|-------|---------|-------|\n`;
                
                results.fieldAnalysis.fields.slice(0, 10).forEach(field => {
                    const usage = this.determineFieldUsage(field, results.fieldAnalysis);
                    markdown += `| ${field.name} | ${field.level} | ${field.picture || '-'} | ${usage} |\n`;
                });
                markdown += `\n`;
            }
        }
        
        // Lifecycle Flow
        if (results.lifecycleFlow) {
            markdown += `### Lifecycle Analysis\n\n`;
            markdown += `**Usage Pattern:** ${results.lifecycleFlow.usagePattern || 'Unknown'}\n\n`;
            markdown += `- Creation Sources: ${results.lifecycleFlow.creationSources?.length || 0} programs\n`;
            markdown += `- Read Programs: ${results.lifecycleFlow.readPrograms?.length || 0} programs\n`;
            markdown += `- Update Programs: ${results.lifecycleFlow.updatePrograms?.length || 0} programs\n`;
            markdown += `- CICS Screens: ${results.lifecycleFlow.cicsScreens?.length || 0}\n`;
            markdown += `- Batch Jobs: ${results.lifecycleFlow.batchJobs?.length || 0}\n\n`;
        }
        
        // Dependencies
        if (results.dependencyAnalysis) {
            markdown += `### Dependencies\n\n`;
            markdown += `**Found:** ${results.dependencyAnalysis.summary?.foundCount || 0} | `;
            markdown += `**Missing:** ${results.dependencyAnalysis.summary?.missingCount || 0}\n\n`;
            
            if (results.dependencyAnalysis.found?.copybooks?.length > 0) {
                markdown += `**Found Copybooks:** ${results.dependencyAnalysis.found.copybooks.join(', ')}\n\n`;
            }
            if (results.dependencyAnalysis.missing?.copybooks?.length > 0) {
                markdown += `**Missing Copybooks:** ${results.dependencyAnalysis.missing.copybooks.join(', ')}\n\n`;
            }
        }
        
        // Recommendations
        if (results.llmAnalysis?.recommendations && results.llmAnalysis.recommendations.length > 0) {
            markdown += `### Recommendations\n\n`;
            results.llmAnalysis.recommendations.forEach((rec, index) => {
                markdown += `${index + 1}. ${rec}\n`;
            });
            markdown += '\n';
        }
        
        markdown += `---\n\n`;
    }
    // Dependencies
if (results.dependencyAnalysis) {
    markdown += `### Dependencies\n\n`;
    markdown += `**Found:** ${results.dependencyAnalysis.summary?.foundCount || 0} | `;
    markdown += `**Missing:** ${results.dependencyAnalysis.summary?.missingCount || 0}\n\n`;
    
    if (results.dependencyAnalysis.found?.copybooks?.length > 0) {
        markdown += `**Found Copybooks:** ${results.dependencyAnalysis.found.copybooks.join(', ')}\n\n`;
    }
    if (results.dependencyAnalysis.missing?.copybooks?.length > 0) {
        markdown += `**Missing Copybooks:** ${results.dependencyAnalysis.missing.copybooks.join(', ')}\n\n`;
    }
}

// Dependency Flow Analysis
if (results.dependencyFlow) {
    markdown += `### Dependency Flow Analysis\n\n`;
    markdown += `**Flow Type:** ${results.dependencyFlow.flowType}\n`;
    markdown += `**Complexity:** ${results.dependencyFlow.complexity}\n\n`;
    
    const upstreamTotal = Object.values(results.dependencyFlow.upstream).reduce((sum, arr) => sum + arr.length, 0);
    const downstreamTotal = Object.values(results.dependencyFlow.downstream).reduce((sum, arr) => sum + arr.length, 0);
    
    markdown += `**Upstream Dependencies:** ${upstreamTotal}\n`;
    markdown += `**Downstream Dependents:** ${downstreamTotal}\n\n`;
    
    // Impact Analysis
    if (results.dependencyFlow.impactAnalysis) {
        const impact = results.dependencyFlow.impactAnalysis;
        if (impact.high.length > 0) {
            markdown += `**High Impact Issues:**\n`;
            impact.high.forEach(item => {
                markdown += `- ${item.description}\n`;
            });
            markdown += `\n`;
        }
    }
}
    
    // Add chat history if available
    if (this.chatHistory.length > 0) {
        markdown += `## Chat History\n\n`;
        this.chatHistory.forEach(msg => {
            const time = new Date(msg.timestamp).toLocaleString();
            markdown += `**[${time}] ${msg.sender === 'user' ? 'User' : 'Assistant'}:**\n`;
            markdown += `${msg.content}\n\n`;
        });
    }
    
    const filename = `mainframe-analysis-report-${new Date().toISOString().split('T')[0]}.md`;
    this.downloadTextFile(markdown, filename, 'text/markdown');
    this.showSuccess(`üìù Analysis report exported as ${filename}`);
}

// Download Text File
downloadTextFile(content, filename, mimeType = 'text/plain') {
    const blob = new Blob([content], { type: `${mimeType};charset=utf-8` });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(link.href);
}

// Clear All Data
// Clear All Data
clearAllData() {
    if (confirm('Are you sure you want to clear all analysis data? This cannot be undone.')) {
        // Clear in-memory data
        this.uploadedFiles = [];
        this.analysisResults = {};
        this.componentSuggestions = [];
        this.currentAnalyzedComponent = null;
        this.currentFriendlyName = null;
        this.chatHistory = [];
        
        // Clear SQLite database
        if (this.dbInitialized && this.db) {
            try {
                this.db.run("DELETE FROM uploaded_files");
                this.db.run("DELETE FROM analysis_results");
                this.db.run("DELETE FROM chat_history");
                this.db.run("DELETE FROM settings");
                
                // Update localStorage backup
                const data = this.db.export();
                localStorage.setItem('mainframe_analyzer_db', JSON.stringify(Array.from(data)));
            } catch (error) {
                console.error('Failed to clear database:', error);
            }
        }
        
        // Clear localStorage fallback
        localStorage.removeItem('enhanced_mainframe_analysis');
        localStorage.removeItem('mainframe_analyzer_db');
        
        // Reset UI (existing code...)
        this.displayUploadedFiles();
        this.validateForm();
        // ... rest of UI reset code ...
        
     
        
        // Clear display areas
        document.getElementById('lifecycleDetails').innerHTML = '<p>No analysis results yet.</p>';
        document.getElementById('llmResults').innerHTML = '<p>LLM analysis results will appear here.</p>';
        document.getElementById('recommendations').innerHTML = '<p>Analysis recommendations will appear here.</p>';
        document.getElementById('fieldMatrixContent').innerHTML = '<p>Field matrix analysis will appear here after component analysis.</p>';
        document.getElementById('fieldStatistics').innerHTML = '<p>Field usage statistics will appear here.</p>';
        document.getElementById('usageContent').innerHTML = '<p>Usage pattern analysis will appear here after component analysis.</p>';
        document.getElementById('foundDependencies').innerHTML = '<p>Found dependencies will appear here.</p>';
        document.getElementById('missingDependencies').innerHTML = '<p>Missing dependencies will appear here.</p>';
        document.getElementById('fileflowContent').innerHTML = '<p>File lifecycle flow analysis will appear here after component analysis.</p>';
        
        // Reset summaries
        document.getElementById('summaryComponent').textContent = '-';
        document.getElementById('summaryQuality').textContent = '-';
        document.getElementById('summaryFiles').textContent = '0';
        document.getElementById('summaryDeps').textContent = '0';
        
        // Reset chat
        const chatMessages = document.getElementById('chatMessages');
        if (chatMessages) {
            chatMessages.innerHTML = `
                <div class="chat-message assistant">
                    <div class="chat-bubble">
                        <div class="chat-message-header">LLM Analysis Assistant</div>
                        <div class="chat-message-content">
                            üëã <strong>Welcome to LLM-Enhanced Mainframe Analysis!</strong>
                            <br><br>
                            I can provide detailed analysis using advanced language models including:
                            <br><br>
                            üß† <strong>Smart Field Analysis:</strong> Context-aware field lifecycle tracking<br>
                            ‚öñÔ∏è <strong>Business Logic Extraction:</strong> Intelligent rule and validation discovery<br>
                            üîó <strong>Dependency Mapping:</strong> Comprehensive relationship analysis<br>
                            üåä <strong>File Lifecycle Flow:</strong> Creation to purge tracking with program mapping<br>
                            üí° <strong>Modernization Guidance:</strong> AI-powered optimization recommendations
                            <br><br>
                            <em>Upload files and analyze a component to unlock the full power of LLM analysis!</em>
                        </div>
                        <div class="chat-message-time">${new Date().toLocaleTimeString()}</div>
                    </div>
                </div>
            `;
        }
        
        // Disable chat
        const chatInput = document.getElementById('chatInput');
        const chatSendBtn = document.getElementById('chatSendBtn');
        const chatSuggestions = document.getElementById('chatSuggestions');
        
        if (chatInput) chatInput.disabled = true;
        if (chatSendBtn) chatSendBtn.disabled = true;
        if (chatSuggestions) chatSuggestions.style.display = 'none';
        
        this.showSuccess('üóëÔ∏è All analysis data cleared successfully');
    }
}

// Add typing animation styles
addTypingAnimationStyles() {
    if (!document.getElementById('typing-animation-styles')) {
        const style = document.createElement('style');
        style.id = 'typing-animation-styles';
        style.textContent = `
            .typing-dots {
                display: inline-block;
                margin-left: 5px;
            }
            .typing-dots span {
                display: inline-block;
                animation: typing 1.4s infinite;
            }
            .typing-dots span:nth-child(2) {
                animation-delay: 0.2s;
            }
            .typing-dots span:nth-child(3) {
                animation-delay: 0.4s;
            }
            @keyframes typing {
                0%, 60%, 100% {
                    opacity: 0.3;
                }
                30% {
                    opacity: 1;
                }
            }
        `;
        document.head.appendChild(style);
    }
}


            
        }

        // Initialize analyzer on page load
        let analyzer;
        document.addEventListener('DOMContentLoaded', function() {
            analyzer = new EnhancedMainframeAnalyzer();
            console.log('‚úÖ Enhanced Mainframe Analyzer Ready!');
        });
    </script>
</body>
</html>