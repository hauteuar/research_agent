<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Code Analyzer - Powered by Opulence</title>
    <style>
        /* ============================================
           ENHANCED CODE ANALYZER - POWERED BY OPULENCE
           Complete CSS Styles and Layout System
           ============================================ */
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Enhanced Color Palette */
            --primary-blue: #2563eb;
            --primary-blue-dark: #1e40af;
            --primary-blue-light: #3b82f6;
            --secondary-blue: #60a5fa;
            --accent-blue: #93c5fd;
            
            --grey-50: #f9fafb;
            --grey-100: #f3f4f6;
            --grey-200: #e5e7eb;
            --grey-300: #d1d5db;
            --grey-400: #9ca3af;
            --grey-500: #6b7280;
            --grey-600: #4b5563;
            --grey-700: #374151;
            --grey-800: #1f2937;
            --grey-900: #111827;
            
            --success-green: #10b981;
            --warning-yellow: #f59e0b;
            --error-red: #ef4444;
            --info-blue: #3b82f6;
            --purple: #8b5cf6;
            --indigo: #6366f1;
            
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
            
            --transition-fast: 150ms cubic-bezier(0.4, 0, 0.2, 1);
            --transition-normal: 300ms cubic-bezier(0.4, 0, 0.2, 1);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Inter', Roboto, sans-serif;
            background: #ffffff;
            color: var(--grey-800);
            line-height: 1.6;
            min-height: 100vh;
        }

        /* Main Container */
        .main-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            background: var(--grey-50);
        }

        /* Enhanced Header */
        .header {
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--indigo) 100%);
            color: white;
            padding: 1.5rem 2rem;
            box-shadow: var(--shadow-lg);
            position: relative;
            z-index: 100;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 100%;
        }

        .header h1 {
            font-size: 1.75rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .header-icon {
            width: 36px;
            height: 36px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.5rem;
        }

        .header-subtitle {
            font-size: 0.9rem;
            opacity: 0.9;
            margin-left: 3rem;
            font-weight: 400;
        }

        .header-stats {
            display: flex;
            gap: 2rem;
            font-size: 0.85rem;
        }

        .header-stat {
            text-align: center;
        }

        .header-stat-value {
            font-size: 1.25rem;
            font-weight: 700;
            display: block;
        }

        .header-stat-label {
            opacity: 0.8;
            font-size: 0.75rem;
        }

        /* Content Layout */
        .content-wrapper {
            flex: 1;
            display: flex;
            overflow: hidden;
            position: relative;
        }

        /* Enhanced Collapsible Panels */
        .panel {
            background: white;
            position: relative;
            transition: all var(--transition-normal);
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--grey-200);
            box-shadow: var(--shadow-sm);
        }

        .panel.left {
            width: 420px;
            min-width: 60px;
        }

        .panel.left.collapsed {
            width: 60px;
        }

        .panel.right {
            width: 500px;
            min-width: 60px;
            border-left: 1px solid var(--grey-200);
            border-right: none;
        }

        .panel.right.collapsed {
            width: 60px;
        }

        .panel-header {
            padding: 1rem;
            background: linear-gradient(135deg, var(--grey-50) 0%, var(--grey-100) 100%);
            border-bottom: 1px solid var(--grey-200);
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-height: 60px;
        }

        .panel-title {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
            color: var(--grey-700);
            font-size: 0.95rem;
        }

        .panel-icon {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--primary-blue);
        }

        .collapse-btn {
            width: 32px;
            height: 32px;
            border: none;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--grey-600);
            transition: all var(--transition-fast);
            box-shadow: var(--shadow-sm);
        }

        .collapse-btn:hover {
            background: var(--primary-blue);
            color: white;
            transform: scale(1.05);
            box-shadow: var(--shadow-md);
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            transition: opacity var(--transition-normal);
        }

        .panel.collapsed .panel-content {
            opacity: 0;
            pointer-events: none;
            padding: 0;
        }

        .panel.collapsed .panel-title span {
            display: none;
        }

        /* Enhanced Component Cards */
        .component-card {
            background: white;
            border: 1px solid var(--grey-200);
            border-radius: 12px;
            padding: 1.25rem;
            margin-bottom: 1rem;
            cursor: pointer;
            transition: all var(--transition-fast);
            position: relative;
            overflow: hidden;
        }

        .component-card:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
            border-color: var(--primary-blue);
        }

        .component-card.selected {
            border-color: var(--primary-blue);
            background: linear-gradient(135deg, rgba(37, 99, 235, 0.05) 0%, rgba(99, 102, 241, 0.05) 100%);
            box-shadow: var(--shadow-md);
        }

        .component-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 0.75rem;
        }

        .component-card-icon {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            margin-right: 0.75rem;
            flex-shrink: 0;
        }

        .component-card-icon.program {
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--indigo) 100%);
            color: white;
        }

        .component-card-icon.copybook {
            background: linear-gradient(135deg, var(--success-green) 0%, #059669 100%);
            color: white;
        }

        .component-card-icon.file {
            background: linear-gradient(135deg, var(--warning-yellow) 0%, #d97706 100%);
            color: white;
        }

        .component-card-info {
            flex: 1;
            min-width: 0;
        }

        .component-card-name {
            font-weight: 600;
            color: var(--grey-800);
            font-size: 0.95rem;
            margin-bottom: 0.25rem;
            word-break: break-word;
        }

        .component-card-friendly {
            font-size: 0.8rem;
            color: var(--primary-blue);
            margin-bottom: 0.5rem;
            font-weight: 500;
        }

        .component-card-description {
            font-size: 0.8rem;
            color: var(--grey-600);
            line-height: 1.4;
            margin-bottom: 0.75rem;
        }

        .component-card-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            font-size: 0.75rem;
        }

        .component-metric {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            color: var(--grey-600);
        }

        .component-metric-icon {
            width: 14px;
            height: 14px;
            color: var(--grey-500);
        }

        /* Enhanced Collapsible Sections */
        .collapsible-section {
            background: white;
            border-radius: 12px;
            margin-bottom: 1rem;
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--grey-200);
            overflow: hidden;
            transition: all var(--transition-normal);
        }

        .collapsible-header {
            padding: 1rem 1.5rem;
            background: linear-gradient(135deg, var(--grey-50) 0%, var(--grey-100) 100%);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all var(--transition-fast);
            user-select: none;
            border-bottom: 1px solid var(--grey-200);
        }

        .collapsible-header:hover {
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--indigo) 100%);
            color: white;
        }

        .collapsible-title {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-weight: 600;
            color: var(--grey-700);
        }

        .collapsible-header:hover .collapsible-title {
            color: white;
        }

        .collapsible-icon {
            width: 20px;
            height: 20px;
        }

        .expand-icon {
            width: 20px;
            height: 20px;
            color: var(--grey-400);
            transition: transform var(--transition-fast);
        }

        .collapsible-header:hover .expand-icon {
            color: white;
        }

        .collapsible-section.expanded .expand-icon {
            transform: rotate(180deg);
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height var(--transition-normal);
            background: white;
        }

        .collapsible-section.expanded .collapsible-content {
            max-height: 3000px;
        }

        .collapsible-body {
            padding: 1.5rem;
        }

        /* Main Content Area */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: white;
            overflow: hidden;
        }

        /* Enhanced Tabs */
        .tabs-container {
            background: linear-gradient(135deg, white 0%, var(--grey-50) 100%);
            border-bottom: 1px solid var(--grey-200);
            padding: 0 1.5rem;
            display: flex;
            align-items: center;
            min-height: 60px;
            box-shadow: var(--shadow-sm);
        }

        .tab {
            padding: 0.75rem 1.5rem;
            background: transparent;
            border: none;
            color: var(--grey-600);
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            position: relative;
            transition: all var(--transition-fast);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            border-radius: 8px;
            margin-right: 0.5rem;
        }

        .tab:hover {
            color: var(--primary-blue);
            background: rgba(37, 99, 235, 0.1);
        }

        .tab.active {
            color: white;
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--indigo) 100%);
            box-shadow: var(--shadow-md);
        }

        .tab-icon {
            width: 18px;
            height: 18px;
        }

        /* Tab Content */
        .tab-content-container {
            flex: 1;
            overflow-y: auto;
            background: var(--grey-50);
        }

        .tab-content {
            display: none;
            padding: 1.5rem;
            min-height: 100%;
        }

        .tab-content.active {
            display: block;
        }

        /* Enhanced Buttons */
        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all var(--transition-fast);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            box-shadow: var(--shadow-sm);
            text-decoration: none;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--indigo) 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .btn-success {
            background: linear-gradient(135deg, var(--success-green) 0%, #059669 100%);
            color: white;
        }

        .btn-success:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .btn-danger {
            background: linear-gradient(135deg, var(--error-red) 0%, #dc2626 100%);
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .btn-block {
            width: 100%;
        }

        /* Badge Styles */
        .badge {
            display: inline-flex;
            align-items: center;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .badge-primary {
            background: rgba(37, 99, 235, 0.1);
            color: var(--primary-blue);
        }

        .badge-success {
            background: rgba(16, 185, 129, 0.1);
            color: var(--success-green);
        }

        .badge-warning {
            background: rgba(245, 158, 11, 0.1);
            color: var(--warning-yellow);
        }

        .badge-danger {
            background: rgba(239, 68, 68, 0.1);
            color: var(--error-red);
        }

        .badge-info {
            background: rgba(59, 130, 246, 0.1);
            color: var(--info-blue);
        }

        .badge-grey {
            background: var(--grey-100);
            color: var(--grey-600);
        }

        /* Form Elements */
        .form-section {
            margin-bottom: 1.5rem;
            padding: 1.25rem;
            background: white;
            border-radius: 12px;
            border: 1px solid var(--grey-200);
            box-shadow: var(--shadow-sm);
        }

        .form-section-title {
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--grey-700);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-label {
            display: block;
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--grey-700);
            margin-bottom: 0.5rem;
        }

        .form-input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--grey-300);
            border-radius: 8px;
            font-size: 0.9rem;
            transition: all var(--transition-fast);
            background: white;
            color: var(--grey-800);
        }

        .form-input:focus {
            outline: none;
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        /* Upload Area */
        .upload-area {
            border: 2px dashed var(--grey-300);
            border-radius: 12px;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: all var(--transition-fast);
            background: var(--grey-50);
            margin-bottom: 1rem;
        }

        .upload-area:hover {
            border-color: var(--primary-blue);
            background: rgba(37, 99, 235, 0.05);
        }

        .upload-area.drag-over {
            border-color: var(--primary-blue);
            background: rgba(37, 99, 235, 0.1);
            transform: scale(0.98);
        }

        .upload-icon {
            font-size: 2.5rem;
            margin-bottom: 0.75rem;
            color: var(--primary-blue);
        }

        .upload-text {
            color: var(--grey-700);
            font-weight: 600;
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }

        .upload-subtext {
            color: var(--grey-500);
            font-size: 0.9rem;
        }

        /* Status Indicators */
        .status-indicator {
            padding: 0.75rem;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
            margin-bottom: 1rem;
        }

        .status-indicator.connected {
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.3);
            color: var(--success-green);
        }

        .status-indicator.connecting {
            background: rgba(245, 158, 11, 0.1);
            border: 1px solid rgba(245, 158, 11, 0.3);
            color: var(--warning-yellow);
        }

        .status-indicator.disconnected {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: var(--error-red);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.95);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            backdrop-filter: blur(5px);
        }

        .loading-overlay.show {
            display: flex;
        }

        .loading-content {
            text-align: center;
            background: white;
            padding: 2rem;
            border-radius: 16px;
            box-shadow: var(--shadow-xl);
            border: 1px solid var(--grey-200);
        }

        .loading-spinner {
            width: 48px;
            height: 48px;
            border: 4px solid var(--grey-200);
            border-top-color: var(--primary-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--grey-800);
            margin-bottom: 0.5rem;
        }

        .loading-status {
            font-size: 0.9rem;
            color: var(--grey-600);
            margin-bottom: 1rem;
        }

        .loading-progress {
            width: 250px;
            height: 6px;
            background: var(--grey-200);
            border-radius: 3px;
            overflow: hidden;
            margin: 0 auto;
        }

        .loading-progress-fill {
            height: 100%;
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--indigo) 100%);
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        /* Alert Messages */
        .alert {
            position: fixed;
            top: 80px;
            right: 20px;
            padding: 1rem 1.5rem;
            border-radius: 12px;
            box-shadow: var(--shadow-xl);
            display: flex;
            align-items: center;
            gap: 0.75rem;
            max-width: 400px;
            animation: slideInRight 0.3s ease;
            z-index: 10000;
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .alert-success {
            background: var(--success-green);
            color: white;
        }

        .alert-error {
            background: var(--error-red);
            color: white;
        }

        .alert-warning {
            background: var(--warning-yellow);
            color: white;
        }

        .alert-info {
            background: var(--info-blue);
            color: white;
        }

        .alert-icon {
            font-size: 1.25rem;
        }

        .alert-message {
            flex: 1;
            font-size: 0.9rem;
            font-weight: 500;
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .panel.left {
                width: 350px;
            }
            .panel.right {
                width: 400px;
            }
        }

        @media (max-width: 768px) {
            .content-wrapper {
                flex-direction: column;
            }
            
            .panel {
                width: 100% !important;
                min-height: 200px;
            }
            
            .panel.left.collapsed,
            .panel.right.collapsed {
                min-height: 60px;
            }
            
            .header-stats {
                display: none;
            }

            .header h1 {
                font-size: 1.5rem;
            }

            .header-subtitle {
                margin-left: 0;
                margin-top: 0.5rem;
            }
        }

        /* Data Tables */
        .data-table {
            width: 100%;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid var(--grey-200);
            margin-bottom: 1rem;
        }

        .data-table table {
            width: 100%;
            border-collapse: collapse;
        }

        .data-table thead {
            background: var(--grey-50);
        }

        .data-table th {
            padding: 0.75rem;
            text-align: left;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--grey-700);
            border-bottom: 1px solid var(--grey-200);
        }

        .data-table td {
            padding: 0.75rem;
            font-size: 0.9rem;
            color: var(--grey-800);
            border-bottom: 1px solid var(--grey-100);
        }

        .data-table tbody tr:hover {
            background: var(--grey-50);
        }

        .data-table tbody tr:last-child td {
            border-bottom: none;
        }

        /* Scrollbar Styles */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--grey-100);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--grey-400);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--grey-500);
        }

        /* Utility Classes */
        .text-center { text-align: center; }
        .text-left { text-align: left; }
        .text-right { text-align: right; }
        .font-mono { font-family: 'Courier New', monospace; }
        .font-bold { font-weight: bold; }
        .opacity-50 { opacity: 0.5; }
        .opacity-75 { opacity: 0.75; }
            </style>

        <!-- Load all JavaScript parts -->
        <script>
            // ============================================
            // ENHANCED CODE ANALYZER - COMPLETE INTEGRATION
            // Loading all parts and initializing the system
            // ============================================
            
            // This will load all the JavaScript parts from the artifacts
            // Part 2: Core Classes and Database
            // Part 3: File Processing and Component Discovery  
            // Part 4: LLM Integration and Analysis
            // Part 5: Chat System and Final Integration
            
            console.log('🚀 Enhanced Code Analyzer - Starting initialization...');
        </script>
        
        <!-- Load SQL.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.js"></script>
        
        <!-- JavaScript will be injected here by copying from the parts -->
        <script>
            // Copy the complete JavaScript from Parts 2-5 here
            // This ensures all functionality is available in a single file
            
            // Note: In implementation, you would copy the complete JavaScript code 
            // from all the parts (2-5) into this script tag to have a working system
            
            // The system includes:
            // - Database management with SQLite stored in Downloads folder
            // - File upload and processing for COBOL/JCL/Copybook files
            // - Component auto-discovery and analysis
            // - LLM integration with 6000 token limit and fallback handling
            // - Business intelligence chat system
            // - Dependency mapping and field matrix analysis
            // - Export functionality for JSON and Markdown reports
            
            console.log('📝 JavaScript loading complete - copy Parts 2-5 code here');
        </script>
    </head>
<body>
    <div class="main-container">
        <!-- Enhanced Header -->
        <div class="header">
            <div class="header-content">
                <div>
                    <h1>
                        <div class="header-icon">🔍</div>
                        Enhanced Code Analyzer
                    </h1>
                    <div class="header-subtitle">Powered by Opulence - Intelligent Mainframe Analysis & Business Intelligence</div>
                </div>
                <div class="header-stats">
                    <div class="header-stat">
                        <span class="header-stat-value" id="headerComponents">0</span>
                        <span class="header-stat-label">Components</span>
                    </div>
                    <div class="header-stat">
                        <span class="header-stat-value" id="headerPrograms">0</span>
                        <span class="header-stat-label">Programs</span>
                    </div>
                    <div class="header-stat">
                        <span class="header-stat-value" id="headerCopybooks">0</span>
                        <span class="header-stat-label">Copybooks</span>
                    </div>
                    <div class="header-stat">
                        <span class="header-stat-value" id="headerFields">0</span>
                        <span class="header-stat-label">Fields</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Content Wrapper -->
        <div class="content-wrapper" id="contentWrapper">
            <!-- Left Panel - Component Dashboard -->
            <div class="panel left" id="leftPanel">
                <div class="panel-header">
                    <div class="panel-title">
                        <div class="panel-icon">📊</div>
                        <span>Component Dashboard</span>
                    </div>
                    <button class="collapse-btn" onclick="togglePanel('left')">
                        ◀
                    </button>
                </div>
                <div class="panel-content" id="leftPanelContent">
                    <!-- LLM Server Setup -->
                    <div class="form-section">
                        <div class="form-section-title">
                            <span style="color: var(--success-green);">🚀</span>
                            LLM Server Setup
                        </div>

                        <div class="form-group">
                            <label class="form-label">Server Endpoint</label>
                            <input type="text" 
                                   id="vllmEndpoint" 
                                   class="form-input" 
                                   placeholder="http://localhost:8000" 
                                   value="http://localhost:8000">
                        </div>

                        <div class="form-group">
                            <label class="form-label">Max Tokens</label>
                            <input type="number" 
                                   id="maxTokens" 
                                   class="form-input" 
                                   value="6000" 
                                   min="1000" 
                                   max="8000">
                        </div>

                        <button id="validateApiBtn" class="btn btn-success btn-block">
                            <span>🔐</span>
                            Test Connection
                        </button>

                        <div id="apiStatus" class="status-indicator disconnected">
                            <span class="status-dot"></span>
                            <span>Enter server details and test connection</span>
                        </div>
                    </div>

                    <!-- File Upload Section -->
                    <div class="form-section">
                        <div class="form-section-title">
                            <span style="color: var(--info-blue);">📁</span>
                            Upload & Auto-Analyze
                        </div>

                        <div class="upload-area" id="uploadArea">
                            <div class="upload-icon">📤</div>
                            <div class="upload-text">Drop files here or click to browse</div>
                            <div class="upload-subtext">COBOL (.cbl), Copybooks (.cpy), JCL (.jcl) - Auto-analysis starts immediately</div>
                            <input type="file" 
                                   id="fileInput" 
                                   multiple 
                                   accept=".cbl,.cob,.cpy,.copybook,.jcl,.txt,.proc" 
                                   style="display: none;">
                        </div>

                        <button id="autoAnalyzeBtn" class="btn btn-primary btn-block" disabled>
                            <span>🤖</span>
                            Start Auto-Analysis
                        </button>
                    </div>

                    <!-- Discovered Components -->
                    <div class="collapsible-section expanded" id="discoveredComponents">
                        <div class="collapsible-header" onclick="toggleCollapsible(this)">
                            <div class="collapsible-title">
                                <span class="collapsible-icon">🎯</span>
                                Discovered Components (<span id="componentCount">0</span>)
                            </div>
                            <span class="expand-icon">▼</span>
                        </div>
                        <div class="collapsible-content">
                            <div class="collapsible-body" id="componentsList">
                                <p style="color: var(--grey-500); text-align: center; padding: 2rem;">
                                    Upload files to auto-discover components
                                </p>
                            </div>
                        </div>
                    </div>

                    <!-- Database Management -->
                    <div class="form-section">
                        <div class="form-section-title">
                            <span style="color: var(--info-blue);">💾</span>
                            Database Management
                        </div>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-bottom: 0.75rem;">
                            <button class="btn btn-primary" onclick="analyzer.saveToDownloadsWithName()">
                                <span>💾</span>
                                Manual Save
                            </button>
                            <button class="btn btn-primary" onclick="analyzer.loadFromDownloadsFolder()">
                                <span>📁</span>
                                Load Database
                            </button>
                        </div>
                        
                        <div class="storage-info" style="font-size: 0.75rem; color: var(--grey-500); padding: 0.5rem; background: var(--grey-50); border-radius: 6px; text-align: center;">
                            📁 Data auto-saved to Downloads folder every 30 seconds
                            <br>
                            💡 Look for "enhanced_code_analyzer_data.db" file
                        </div>
                    </div>

                    <!-- Quick Actions -->
                    <div class="form-section">
                        <div class="form-section-title">
                            <span style="color: var(--warning-yellow);">⚡</span>
                            Actions
                        </div>

                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-bottom: 0.75rem;">
                            <button id="exportJsonBtn" class="btn btn-primary" disabled>
                                <span>📋</span>
                                Export JSON
                            </button>
                            <button id="exportMdBtn" class="btn btn-primary" disabled>
                                <span>📝</span>
                                Export MD
                            </button>
                        </div>

                        <button id="clearBtn" class="btn btn-danger btn-block">
                            <span>🗑️</span>
                            Clear All Data
                        </button>
                    </div>
                </div>
            </div>

            <!-- Main Content Area -->
            <div class="main-content">
                <!-- Enhanced Tabs -->
                <div class="tabs-container">
                    <button class="tab active" data-tab="dashboard">
                        <span class="tab-icon">📊</span>
                        Dashboard Overview
                    </button>
                    <button class="tab" data-tab="dependencies">
                        <span class="tab-icon">🔗</span>
                        Dependencies Flow
                    </button>
                    <button class="tab" data-tab="fieldmatrix">
                        <span class="tab-icon">📋</span>
                        Field Matrix
                    </button>
                </div>

                <!-- Tab Content -->
                <div class="tab-content-container">
                    <!-- Dashboard Overview Tab -->
                    <div id="dashboard" class="tab-content active">
                        <div id="dashboardContent">
                            <p style="color: var(--grey-500); text-align: center; padding: 2rem;">
                                Upload your mainframe files to start analysis
                            </p>
                        </div>
                    </div>

                    <!-- Dependencies Flow Tab -->
                    <div id="dependencies" class="tab-content">
                        <div id="dependenciesContent">
                            <p style="color: var(--grey-500); text-align: center; padding: 2rem;">
                                Dependencies will appear after analysis
                            </p>
                        </div>
                    </div>

                    <!-- Field Matrix Tab -->
                    <div id="fieldmatrix" class="tab-content">
                        <div id="fieldMatrixContent">
                            <p style="color: var(--grey-500); text-align: center; padding: 2rem;">
                                Select a component to view field matrix
                            </p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Panel - Enhanced Chat -->
            <div class="panel right" id="rightPanel">
                <div class="panel-header">
                    <div class="panel-title">
                        <div class="panel-icon">💬</div>
                        <span>Business Intelligence Chat</span>
                    </div>
                    <button class="collapse-btn" onclick="togglePanel('right')">
                        ▶
                    </button>
                </div>
                <div class="panel-content" id="rightPanelContent">
                    <!-- Chat will be loaded in Part 3 -->
                    <div id="chatContainer">
                        <p style="color: var(--grey-500); text-align: center; padding: 2rem;">
                            Chat system loading...
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Loading Overlay -->
        <div class="loading-overlay" id="loadingIndicator">
            <div class="loading-content">
                <div class="loading-spinner"></div>
                <div class="loading-title">🤖 Processing Analysis</div>
                <div class="loading-status" id="loadingStatus">Initializing system...</div>
                <div class="loading-progress">
                    <div class="loading-progress-fill" id="progressFill" style="width: 0%"></div>
                </div>
            </div>
        </div>

        <!-- Chat Styles -->
        <style>
            /* Chat Container */
            .chat-container {
                display: flex;
                flex-direction: column;
                height: 100%;
            }

            /* Chat Messages Area */
            .chat-messages {
                flex: 1;
                overflow-y: auto;
                padding: 1rem;
                background: var(--grey-50);
                border-radius: 8px;
                margin-bottom: 1rem;
                min-height: 400px;
                max-height: calc(100vh - 400px);
                border: 1px solid var(--grey-200);
            }

            .chat-message {
                margin-bottom: 1rem;
                animation: fadeInUp 0.3s ease;
            }

            @keyframes fadeInUp {
                from {
                    opacity: 0;
                    transform: translateY(10px);
                }
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }

            .chat-message.user {
                display: flex;
                justify-content: flex-end;
            }

            .chat-message.assistant {
                display: flex;
                justify-content: flex-start;
            }

            /* Chat Bubbles */
            .chat-bubble {
                max-width: 95%;
                padding: 1rem;
                border-radius: 12px;
                position: relative;
                word-wrap: break-word;
                overflow-wrap: break-word;
                line-height: 1.6;
            }

            .user .chat-bubble {
                background: linear-gradient(135deg, var(--primary-blue) 0%, var(--indigo) 100%);
                color: white;
                border-bottom-right-radius: 4px;
            }

            .assistant .chat-bubble {
                background: white;
                color: var(--grey-800);
                border: 1px solid var(--grey-200);
                border-bottom-left-radius: 4px;
                box-shadow: var(--shadow-sm);
            }

            .chat-message-header {
                font-size: 0.7rem;
                font-weight: 600;
                margin-bottom: 0.25rem;
                opacity: 0.7;
            }

            .chat-message-content {
                font-size: 0.9rem;
                line-height: 1.6;
                white-space: pre-wrap;
            }

            .chat-message-time {
                font-size: 0.65rem;
                opacity: 0.5;
                margin-top: 0.25rem;
            }

            /* Chat Input Section */
            .chat-input-section {
                padding: 1rem;
                background: white;
                border-radius: 8px;
                border: 1px solid var(--grey-200);
                box-shadow: var(--shadow-sm);
            }

            .chat-input-group {
                display: flex;
                gap: 0.75rem;
                align-items: flex-end;
            }

            .chat-input {
                flex: 1;
                padding: 1rem;
                border: 1px solid var(--grey-300);
                border-radius: 8px;
                resize: none;
                min-height: 80px;
                max-height: 160px;
                font-size: 0.95rem;
                transition: all var(--transition-fast);
                font-family: inherit;
                line-height: 1.4;
            }

            .chat-input:focus {
                outline: none;
                border-color: var(--primary-blue);
                box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
            }

            .chat-send-btn {
                padding: 1rem 1.5rem;
                background: linear-gradient(135deg, var(--primary-blue) 0%, var(--indigo) 100%);
                color: white;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                transition: all var(--transition-fast);
                display: flex;
                align-items: center;
                gap: 0.5rem;
                font-weight: 600;
                font-size: 0.9rem;
                min-height: 80px;
            }

            .chat-send-btn:hover:not(:disabled) {
                transform: translateY(-2px);
                box-shadow: var(--shadow-lg);
            }

            .chat-send-btn:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }

            /* Typing Indicator */
            .typing-indicator {
                display: flex;
                align-items: center;
                gap: 0.5rem;
                padding: 1rem;
                background: var(--grey-100);
                border-radius: 12px;
                margin-bottom: 1rem;
                opacity: 0.8;
            }

            .typing-dots {
                display: flex;
                gap: 0.25rem;
            }

            .typing-dot {
                width: 8px;
                height: 8px;
                background: var(--grey-500);
                border-radius: 50%;
                animation: typingBounce 1.4s infinite ease-in-out;
            }

            .typing-dot:nth-child(1) { animation-delay: -0.32s; }
            .typing-dot:nth-child(2) { animation-delay: -0.16s; }
            .typing-dot:nth-child(3) { animation-delay: 0s; }

            @keyframes typingBounce {
                0%, 80%, 100% {
                    transform: scale(0.8);
                    opacity: 0.5;
                }
                40% {
                    transform: scale(1);
                    opacity: 1;
                }
            }

            /* Chat Suggestions */
            .chat-suggestions {
                padding: 0.75rem;
                background: var(--grey-50);
                border-radius: 8px;
                margin-bottom: 0.75rem;
                border: 1px solid var(--grey-200);
            }

            .chat-suggestions-title {
                font-size: 0.75rem;
                font-weight: 600;
                color: var(--grey-700);
                margin-bottom: 0.5rem;
            }

            .chat-suggestion-chips {
                display: flex;
                flex-wrap: wrap;
                gap: 0.25rem;
            }

            .chat-suggestion-btn {
                padding: 0.375rem 0.75rem;
                background: white;
                border: 1px solid var(--grey-300);
                border-radius: 20px;
                font-size: 0.7rem;
                color: var(--grey-700);
                cursor: pointer;
                transition: all var(--transition-fast);
            }

            .chat-suggestion-btn:hover {
                background: var(--primary-blue);
                color: white;
                border-color: var(--primary-blue);
                transform: translateY(-1px);
            }
        </style>
        <script>

        // ============================================
// ENHANCED CODE ANALYZER - PART 2
// Core JavaScript Classes and Database Management
// ============================================

class EnhancedCodeAnalyzer {
    constructor() {
        // Core properties
        this.uploadedFiles = [];
        this.analysisResults = {};
        this.discoveredComponents = new Map();
        this.serverValidated = false;
        this.vllmEndpoint = 'http://localhost:8000';
        this.maxTokens = 6000;
        this.currentSelectedComponent = null;
        this.chatHistory = [];
        this.chatContext = 'general';
        
        // Business intelligence properties
        this.friendlyNameCache = new Map();
        this.businessContextCache = new Map();
        this.componentMetrics = new Map();
        
        // SQLite Database (stored in Downloads folder)
        this.db = null;
        this.dbInitialized = false;
        this.dbPath = null;
        
        // Auto-analysis state
        this.autoAnalysisInProgress = false;
        this.analysisQueue = [];
        
        // Initialize
        this.initializeDatabase();
        this.initializeEventListeners();
        this.setupDownloadsFolderStorage();
        
        console.log('🚀 Enhanced Code Analyzer - Powered by Opulence - Initialized');
    }

    // ============================================
    // DATABASE INITIALIZATION AND MANAGEMENT
    // ============================================

    async initializeDatabase() {
        try {
            const SQL = await initSqlJs({
                locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${file}`
            });
            
            // Initialize new database in memory
            this.db = new SQL.Database();
            this.dbInitialized = true;
            
            // Create tables
            this.createTables();
            
            console.log('✅ SQLite database initialized');
            this.updateDbStatus('initialized', '✅ Database ready (Downloads folder storage)');
            
            // Check for existing database and prompt user
            this.promptForExistingDatabase();
            
        } catch (error) {
            console.error('Failed to initialize SQLite database:', error);
            this.dbInitialized = false;
            this.updateDbStatus('error', '❌ Database initialization failed');
        }
    }

    createTables() {
        if (!this.db) return;
        
        try {
            // Uploaded Files table
            this.db.run(`
                CREATE TABLE IF NOT EXISTS uploaded_files (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    file_id TEXT UNIQUE,
                    name TEXT,
                    content TEXT,
                    size INTEGER,
                    type TEXT,
                    upload_date TEXT,
                    components TEXT,
                    metrics TEXT,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            `);
            
            // Discovered Components table
            this.db.run(`
                CREATE TABLE IF NOT EXISTS discovered_components (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    component_name TEXT UNIQUE,
                    friendly_name TEXT,
                    component_type TEXT,
                    business_purpose TEXT,
                    file_source TEXT,
                    line_count INTEGER,
                    complexity_score INTEGER,
                    input_files TEXT,
                    output_files TEXT,
                    field_count INTEGER,
                    analyzed BOOLEAN DEFAULT 0,
                    quality_score INTEGER,
                    selected BOOLEAN DEFAULT 0,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            `);
            
            // Analysis Results table
            this.db.run(`
                CREATE TABLE IF NOT EXISTS analysis_results (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    component_name TEXT UNIQUE,
                    friendly_name TEXT,
                    component_type TEXT,
                    results_data TEXT,
                    quality_score INTEGER,
                    business_context TEXT,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            `);
            
            // Chat History table
            this.db.run(`
                CREATE TABLE IF NOT EXISTS chat_history (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    component_name TEXT,
                    context_type TEXT,
                    sender TEXT,
                    content TEXT,
                    timestamp TEXT,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            `);

            // System Settings table
            this.db.run(`
                CREATE TABLE IF NOT EXISTS system_settings (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    setting_key TEXT UNIQUE,
                    setting_value TEXT,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            `);

            console.log('✅ Database tables created successfully');
        } catch (error) {
            console.error('Failed to create database tables:', error);
        }
    }

    setupDownloadsFolderStorage() {
        // Save database every 30 seconds
        this.saveInterval = setInterval(() => {
            this.saveToDownloadsFolder();
        }, 30000);

        // Save on page unload
        window.addEventListener('beforeunload', () => {
            this.saveToDownloadsFolder();
        });

        // Save on visibility change (when user switches tabs)
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'hidden') {
                this.saveToDownloadsFolder();
            }
        });
    }

    async saveToDownloadsFolder() {
        if (!this.db || !this.dbInitialized) return;

        try {
            const data = this.db.export();
            const blob = new Blob([data], { type: 'application/octet-stream' });
            
            // Use consistent filename for automatic loading
            const filename = 'enhanced_code_analyzer_data.db';
            
            // Create download link
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            
            // Hide the download from user (automatic save)
            link.style.display = 'none';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
            
            // Update status indicator
            const now = new Date().toLocaleTimeString();
            this.updateDbStatus('initialized', `✅ Auto-saved to Downloads (${now})`);
            
            console.log(`💾 Database auto-saved to Downloads folder at ${now}`);
            
        } catch (error) {
            console.error('Failed to save database to Downloads folder:', error);
            this.updateDbStatus('error', '❌ Failed to save to Downloads');
        }
    }

    // Manual Save with Custom Name
    async saveToDownloadsWithName(customName = null) {
        if (!this.db || !this.dbInitialized) {
            this.showError('Database not initialized');
            return;
        }

        try {
            const data = this.db.export();
            const blob = new Blob([data], { type: 'application/octet-stream' });
            
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 16);
            const filename = customName || `enhanced_code_analyzer_backup_${timestamp}.db`;
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
            
            this.showSuccess(`📁 Database saved: ${filename}`);
            
        } catch (error) {
            console.error('Failed to save database:', error);
            this.showError('Failed to save database');
        }
    }

    // Prompt User to Load Existing Database
    promptForExistingDatabase() {
        // Create a subtle notification asking if user wants to load existing data
        const notification = document.createElement('div');
        notification.className = 'load-existing-notification';
        notification.innerHTML = `
            <div style="
                position: fixed; 
                top: 80px; 
                right: 20px; 
                background: linear-gradient(135deg, var(--primary-blue) 0%, var(--indigo) 100%); 
                color: white; 
                padding: 1rem 1.5rem; 
                border-radius: 12px; 
                box-shadow: var(--shadow-xl); 
                max-width: 400px; 
                z-index: 10000;
                animation: slideInRight 0.3s ease;
            ">
                <div style="font-weight: 600; margin-bottom: 0.5rem;">📂 Load Previous Data?</div>
                <div style="font-size: 0.9rem; margin-bottom: 1rem; opacity: 0.9;">
                    Do you have a previous database file in your Downloads folder to load?
                </div>
                <div style="display: flex; gap: 0.75rem;">
                    <button onclick="analyzer.loadFromDownloadsFolder()" style="
                        flex: 1; 
                        padding: 0.5rem 1rem; 
                        background: white; 
                        color: var(--primary-blue); 
                        border: none; 
                        border-radius: 6px; 
                        font-weight: 600; 
                        cursor: pointer;
                    ">
                        📁 Load File
                    </button>
                    <button onclick="this.parentElement.parentElement.parentElement.remove()" style="
                        flex: 1; 
                        padding: 0.5rem 1rem; 
                        background: rgba(255,255,255,0.2); 
                        color: white; 
                        border: 1px solid rgba(255,255,255,0.3); 
                        border-radius: 6px; 
                        font-weight: 600; 
                        cursor: pointer;
                    ">
                        Start Fresh
                    </button>
                </div>
            </div>
        `;
        
        document.body.appendChild(notification);
        
        // Auto-remove after 10 seconds
        setTimeout(() => {
            if (notification.parentNode) {
                notification.remove();
            }
        }, 10000);
    }

    // Load Database from Downloads Folder
    loadFromDownloadsFolder() {
        // Create file input for user to select database file
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = '.db';
        fileInput.style.display = 'none';
        
        fileInput.addEventListener('change', async (e) => {
            if (e.target.files[0]) {
                await this.loadDatabaseFromFile(e.target.files[0]);
            }
        });
        
        document.body.appendChild(fileInput);
        fileInput.click();
        document.body.removeChild(fileInput);
        
        // Remove the notification
        const notification = document.querySelector('.load-existing-notification');
        if (notification) {
            notification.remove();
        }
    }

    // Load Database from File
    async loadDatabaseFromFile(file) {
        try {
            this.showLoading();
            this.updateLoadingStatus('📂 Loading database from file...');
            
            const arrayBuffer = await file.arrayBuffer();
            const uInt8Array = new Uint8Array(arrayBuffer);
            
            const SQL = await initSqlJs({
                locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${file}`
            });
            
            // Close existing database
            if (this.db) {
                this.db.close();
            }
            
            this.db = new SQL.Database(uInt8Array);
            this.dbInitialized = true;
            
            // Load data from imported database
            this.updateLoadingStatus('📊 Loading components and analysis data...');
            await this.loadDataFromDatabase();
            
            this.hideLoading();
            
            this.showSuccess(`📁 Database loaded from: ${file.name}`);
            this.updateDbStatus('initialized', '✅ Database loaded from Downloads folder');
            
            // Update UI with loaded data
            this.updateDashboardStats();
            this.displayDiscoveredComponents();
            this.updateDashboardWithResults();
            
            // Enable chat if we have analysis results
            if (Object.keys(this.analysisResults).length > 0) {
                this.enableChat();
            }
            
        } catch (error) {
            this.hideLoading();
            console.error('Failed to load database:', error);
            this.showError(`Failed to load database: ${error.message}`);
        }
    }

    // Save to Database with Auto-save
    saveToDatabase() {
        if (!this.db || !this.dbInitialized) return;

        try {
            // Save uploaded files
            this.uploadedFiles.forEach(file => {
                this.db.run(`
                    INSERT OR REPLACE INTO uploaded_files 
                    (file_id, name, content, size, type, upload_date, components, metrics)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                `, [
                    file.id,
                    file.name,
                    file.content,
                    file.size,
                    file.type,
                    file.uploadDate,
                    JSON.stringify(file.components || []),
                    JSON.stringify(file.metrics || {})
                ]);
            });

            // Save discovered components
            this.discoveredComponents.forEach((component, name) => {
                this.db.run(`
                    INSERT OR REPLACE INTO discovered_components 
                    (component_name, friendly_name, component_type, business_purpose, 
                     file_source, line_count, complexity_score, input_files, output_files, 
                     field_count, analyzed, quality_score, selected)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                `, [
                    name,
                    component.friendlyName,
                    component.type,
                    component.businessPurpose,
                    component.fileSource,
                    component.lineCount,
                    component.complexityScore,
                    JSON.stringify(component.inputFiles || []),
                    JSON.stringify(component.outputFiles || []),
                    component.fieldCount,
                    component.analyzed ? 1 : 0,
                    component.qualityScore,
                    component.selected ? 1 : 0
                ]);
            });

            // Save analysis results
            Object.entries(this.analysisResults).forEach(([name, result]) => {
                this.db.run(`
                    INSERT OR REPLACE INTO analysis_results 
                    (component_name, friendly_name, component_type, results_data, 
                     quality_score, business_context, updated_at)
                    VALUES (?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
                `, [
                    name,
                    result.friendlyName,
                    result.componentType,
                    JSON.stringify(result),
                    result.qualityScore,
                    result.llmAnalysis?.businessPurpose || ''
                ]);
            });

            // Save system settings
            this.db.run(`
                INSERT OR REPLACE INTO system_settings (setting_key, setting_value, updated_at)
                VALUES ('vllm_endpoint', ?, CURRENT_TIMESTAMP)
            `, [this.vllmEndpoint]);

            this.db.run(`
                INSERT OR REPLACE INTO system_settings (setting_key, setting_value, updated_at)
                VALUES ('max_tokens', ?, CURRENT_TIMESTAMP)
            `, [this.maxTokens.toString()]);

            console.log('💾 Data saved to database');

        } catch (error) {
            console.error('Failed to save to database:', error);
        }
    }

    // Load Data from Database
    async loadDataFromDatabase() {
        if (!this.db || !this.dbInitialized) return;

        try {
            // Clear existing data
            this.uploadedFiles = [];
            this.discoveredComponents.clear();
            this.analysisResults = {};

            // Load uploaded files
            const filesStmt = this.db.prepare('SELECT * FROM uploaded_files ORDER BY created_at DESC');
            while (filesStmt.step()) {
                const row = filesStmt.getAsObject();
                const file = {
                    id: row.file_id,
                    name: row.name,
                    content: row.content,
                    size: row.size,
                    type: row.type,
                    uploadDate: row.upload_date,
                    components: JSON.parse(row.components || '[]'),
                    metrics: JSON.parse(row.metrics || '{}')
                };
                this.uploadedFiles.push(file);
            }
            filesStmt.free();

            // Load discovered components
            const componentsStmt = this.db.prepare('SELECT * FROM discovered_components ORDER BY created_at DESC');
            while (componentsStmt.step()) {
                const row = componentsStmt.getAsObject();
                const component = {
                    name: row.component_name,
                    friendlyName: row.friendly_name,
                    type: row.component_type,
                    businessPurpose: row.business_purpose,
                    fileSource: row.file_source,
                    lineCount: row.line_count,
                    complexityScore: row.complexity_score,
                    inputFiles: JSON.parse(row.input_files || '[]'),
                    outputFiles: JSON.parse(row.output_files || '[]'),
                    fieldCount: row.field_count,
                    analyzed: row.analyzed === 1,
                    qualityScore: row.quality_score,
                    selected: row.selected === 1,
                    timestamp: row.created_at
                };
                this.discoveredComponents.set(row.component_name, component);
            }
            componentsStmt.free();

            // Load analysis results
            const resultsStmt = this.db.prepare('SELECT * FROM analysis_results ORDER BY updated_at DESC');
            while (resultsStmt.step()) {
                const row = resultsStmt.getAsObject();
                try {
                    this.analysisResults[row.component_name] = JSON.parse(row.results_data);
                } catch (error) {
                    console.warn(`Failed to parse analysis result for ${row.component_name}:`, error);
                }
            }
            resultsStmt.free();

            // Load system settings
            const settingsStmt = this.db.prepare('SELECT * FROM system_settings');
            while (settingsStmt.step()) {
                const row = settingsStmt.getAsObject();
                if (row.setting_key === 'vllm_endpoint') {
                    this.vllmEndpoint = row.setting_value;
                    const endpointInput = document.getElementById('vllmEndpoint');
                    if (endpointInput) endpointInput.value = row.setting_value;
                } else if (row.setting_key === 'max_tokens') {
                    this.maxTokens = parseInt(row.setting_value);
                    const maxTokensInput = document.getElementById('maxTokens');
                    if (maxTokensInput) maxTokensInput.value = row.setting_value;
                }
            }
            settingsStmt.free();

            console.log(`📊 Data loaded: ${this.uploadedFiles.length} files, ${this.discoveredComponents.size} components, ${Object.keys(this.analysisResults).length} analyses`);

        } catch (error) {
            console.error('Failed to load from database:', error);
        }
    }

    // Update Database Status Indicator
    updateDbStatus(status, message) {
        // Create status indicator if it doesn't exist
        let indicator = document.getElementById('dbStatusIndicator');
        if (!indicator) {
            indicator = document.createElement('div');
            indicator.id = 'dbStatusIndicator';
            indicator.className = `status-indicator ${status}`;
            indicator.innerHTML = `
                <span class="status-dot"></span>
                <span>${message}</span>
            `;
            
            // Find a good place to insert it
            const leftPanel = document.getElementById('leftPanelContent');
            if (leftPanel) {
                leftPanel.insertBefore(indicator, leftPanel.firstChild);
            }
        } else {
            indicator.className = `status-indicator ${status}`;
            indicator.innerHTML = `
                <span class="status-dot"></span>
                <span>${message}</span>
            `;
        }
    }

    // ============================================
    // EVENT LISTENERS AND UI INTERACTIONS
    // ============================================

    initializeEventListeners() {
        // API Validation
        const validateBtn = document.getElementById('validateApiBtn');
        if (validateBtn) {
            validateBtn.addEventListener('click', () => this.validateConnection());
        }
        
        // File Upload
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        
        if (uploadArea && fileInput) {
            uploadArea.addEventListener('click', () => {
                if (this.serverValidated) fileInput.click();
            });
            uploadArea.addEventListener('drop', (e) => this.handleFileDrop(e));
            uploadArea.addEventListener('dragover', (e) => this.handleDragOver(e));
            uploadArea.addEventListener('dragleave', (e) => this.handleDragLeave(e));
            fileInput.addEventListener('change', (e) => this.handleFileSelect(e));
        }
        
        // Auto Analysis
        const autoAnalyzeBtn = document.getElementById('autoAnalyzeBtn');
        if (autoAnalyzeBtn) {
            autoAnalyzeBtn.addEventListener('click', () => this.startAutoAnalysis());
        }
        
        // Export buttons
        const exportJsonBtn = document.getElementById('exportJsonBtn');
        const exportMdBtn = document.getElementById('exportMdBtn');
        const clearBtn = document.getElementById('clearBtn');
        
        if (exportJsonBtn) exportJsonBtn.addEventListener('click', () => this.exportResults('json'));
        if (exportMdBtn) exportMdBtn.addEventListener('click', () => this.exportResults('markdown'));
        if (clearBtn) clearBtn.addEventListener('click', () => this.clearAllData());
        
        // Settings
        const endpointInput = document.getElementById('vllmEndpoint');
        const maxTokensInput = document.getElementById('maxTokens');
        
        if (endpointInput) {
            endpointInput.addEventListener('input', () => this.onEndpointChange());
        }
        
        if (maxTokensInput) {
            maxTokensInput.addEventListener('input', () => this.onSettingsChange());
        }

        // Initialize tabs
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', function() {
                // Remove active from all tabs
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                // Add active to clicked tab
                this.classList.add('active');
                const tabId = this.getAttribute('data-tab');
                const tabContent = document.getElementById(tabId);
                if (tabContent) {
                    tabContent.classList.add('active');
                }
            });
        });
    }

    // ============================================
    // UI HELPER FUNCTIONS
    // ============================================

    // Basic UI Functions
    togglePanel(side) {
        const panel = document.getElementById(side + 'Panel');
        if (!panel) return;
        
        panel.classList.toggle('collapsed');
        
        // Update button icon
        const btn = panel.querySelector('.collapse-btn');
        if (btn) {
            if (side === 'left') {
                btn.textContent = panel.classList.contains('collapsed') ? '▶' : '◀';
            } else {
                btn.textContent = panel.classList.contains('collapsed') ? '◀' : '▶';
            }
        }
        
        // Save state to database
        if (this.db && this.dbInitialized) {
            try {
                this.db.run(`
                    INSERT OR REPLACE INTO system_settings (setting_key, setting_value, updated_at)
                    VALUES (?, ?, CURRENT_TIMESTAMP)
                `, [`${side}_panel_collapsed`, panel.classList.contains('collapsed') ? '1' : '0']);
            } catch (error) {
                console.warn('Could not save panel state:', error);
            }
        }
    }

    toggleCollapsible(header) {
        if (!header || !header.parentElement) return;
        
        const section = header.parentElement;
        section.classList.toggle('expanded');
        
        // Update expand icon rotation
        const expandIcon = header.querySelector('.expand-icon');
        if (expandIcon) {
            if (section.classList.contains('expanded')) {
                expandIcon.style.transform = 'rotate(180deg)';
            } else {
                expandIcon.style.transform = 'rotate(0deg)';
            }
        }
    }

    // Show/Hide Loading
    showLoading() {
        const loading = document.getElementById('loadingIndicator');
        if (loading) loading.classList.add('show');
    }

    hideLoading() {
        const loading = document.getElementById('loadingIndicator');
        if (loading) loading.classList.remove('show');
    }

    updateLoadingStatus(status) {
        const statusEl = document.getElementById('loadingStatus');
        if (statusEl) statusEl.textContent = status;
    }

    updateProgress(percentage) {
        const progressFill = document.getElementById('progressFill');
        if (progressFill) progressFill.style.width = `${percentage}%`;
    }

    // Alert Messages
    showMessage(type, message, duration = 3000) {
        const alert = document.createElement('div');
        alert.className = `alert alert-${type}`;
        alert.innerHTML = `
            <span class="alert-icon">${type === 'success' ? '✅' : type === 'error' ? '❌' : type === 'warning' ? '⚠️' : 'ℹ️'}</span>
            <span class="alert-message">${message}</span>
        `;
        document.body.appendChild(alert);
        
        setTimeout(() => {
            if (alert.parentNode) {
                alert.style.animation = 'slideInRight 0.3s ease reverse';
                setTimeout(() => alert.remove(), 300);
            }
        }, duration);
    }

    showSuccess(message) { this.showMessage('success', message); }
    showError(message) { this.showMessage('error', message, 5000); }
    showWarning(message) { this.showMessage('warning', message, 4000); }
    showInfo(message) { this.showMessage('info', message); }

    // ============================================
    // LLM CONNECTION AND VALIDATION
    // ============================================

    // Validate LLM Connection
    async validateConnection() {
        const endpoint = document.getElementById('vllmEndpoint').value.trim();
        if (!endpoint) {
            this.showError('Please enter vLLM endpoint');
            return;
        }

        this.updateConnectionStatus('connecting', 'Testing LLM connection...');

        try {
            const response = await fetch(`${endpoint}/generate`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    prompt: "Test connection. Respond with 'Connected'",
                    max_tokens: 10,
                    temperature: 0.1
                }),
                signal: AbortSignal.timeout(10000)
            });

            if (response.ok) {
                this.serverValidated = true;
                this.vllmEndpoint = endpoint;
                this.updateConnectionStatus('connected', `✅ LLM connection verified`);
                this.showSuccess('🚀 vLLM server connected successfully!');
                
                // Enable file upload and auto-analysis
                this.enableFileUpload();
                
                // Save to database
                this.saveToDatabase();
            } else {
                throw new Error(`HTTP ${response.status}`);
            }
        } catch (error) {
            this.serverValidated = false;
            this.updateConnectionStatus('disconnected', `❌ Connection failed: ${error.message}`);
            this.showError(`LLM connection failed: ${error.message}`);
        }
    }

    // Enable File Upload
    enableFileUpload() {
        const uploadArea = document.getElementById('uploadArea');
        const autoAnalyzeBtn = document.getElementById('autoAnalyzeBtn');
        
        if (uploadArea) {
            uploadArea.style.opacity = '1';
            uploadArea.style.cursor = 'pointer';
        }
        
        // Enable auto-analysis if files are already uploaded
        if (this.uploadedFiles.length > 0 && autoAnalyzeBtn) {
            autoAnalyzeBtn.disabled = false;
        }
    }

    // Update Connection Status
    updateConnectionStatus(status, message) {
        const statusEl = document.getElementById('apiStatus');
        if (statusEl) {
            statusEl.className = `status-indicator ${status}`;
            statusEl.innerHTML = `
                <span class="status-dot"></span>
                <span>${message}</span>
            `;
        }
    }

    // Settings Change Handlers
    onEndpointChange() {
        this.serverValidated = false;
        this.updateConnectionStatus('disconnected', 'Connection not validated');
    }

    onSettingsChange() {
        const maxTokensInput = document.getElementById('maxTokens');
        if (maxTokensInput) {
            this.maxTokens = parseInt(maxTokensInput.value) || 6000;
            this.saveToDatabase();
        }
    }

    // ============================================
    // UTILITY FUNCTIONS
    // ============================================

    // Utility function
    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    // Clear All Data
    clearAllData() {
        if (!confirm('Are you sure you want to clear all data? This action cannot be undone.')) {
            return;
        }
        
        // Clear in-memory data
        this.uploadedFiles = [];
        this.analysisResults = {};
        this.discoveredComponents.clear();
        this.currentSelectedComponent = null;
        this.chatHistory = [];
        
        // Clear database
        if (this.db && this.dbInitialized) {
            try {
                this.db.run('DELETE FROM uploaded_files');
                this.db.run('DELETE FROM discovered_components');
                this.db.run('DELETE FROM analysis_results');
                this.db.run('DELETE FROM chat_history');
            } catch (error) {
                console.error('Failed to clear database:', error);
            }
        }
        
        // Reset UI
        this.updateDashboardStats();
        this.displayDiscoveredComponents();
        
        // Disable features
        const chatInput = document.getElementById('chatInput');
        const chatSendBtn = document.getElementById('chatSendBtn');
        const exportJsonBtn = document.getElementById('exportJsonBtn');
        const exportMdBtn = document.getElementById('exportMdBtn');
        
        if (chatInput) chatInput.disabled = true;
        if (chatSendBtn) chatSendBtn.disabled = true;
        if (exportJsonBtn) exportJsonBtn.disabled = true;
        if (exportMdBtn) exportMdBtn.disabled = true;
        
        this.showSuccess('🗑️ All data cleared successfully');
    }

    // Cleanup on page unload
    cleanup() {
        if (this.saveInterval) {
            clearInterval(this.saveInterval);
        }
        
        if (this.db) {
            // Save one final time before closing
            this.saveToDownloadsFolder();
            this.db.close();
        }
    }
}

// ============================================
// GLOBAL FUNCTIONS FOR HTML ONCLICK HANDLERS
// ============================================

// Global functions for HTML onclick handlers
function togglePanel(side) {
    if (window.analyzer) {
        window.analyzer.togglePanel(side);
    }
}

function toggleCollapsible(header) {
    if (window.analyzer) {
        window.analyzer.toggleCollapsible(header);
    }
}

// Make sure these global functions are available immediately
window.togglePanel = togglePanel;
window.toggleCollapsible = toggleCollapsible;
// ============================================
// ENHANCED CODE ANALYZER - PART 3
// File Processing and Component Discovery
// ============================================

// Extend the EnhancedCodeAnalyzer class with file processing methods
Object.assign(EnhancedCodeAnalyzer.prototype, {

    // ============================================
    // FILE HANDLING AND PROCESSING
    // ============================================

    // File Upload Handling
    async handleFileDrop(e) {
        e.preventDefault();
        e.stopPropagation();
        
        const uploadArea = document.getElementById('uploadArea');
        uploadArea.classList.remove('drag-over');
        
        if (!this.serverValidated) {
            this.showError('Please validate LLM API connection first');
            return;
        }
        
        const files = Array.from(e.dataTransfer.files);
        await this.processFiles(files);
    },

    async handleFileSelect(e) {
        if (!this.serverValidated) {
            this.showError('Please validate LLM API connection first');
            return;
        }
        
        const files = Array.from(e.target.files);
        await this.processFiles(files);
    },

    handleDragOver(e) {
        e.preventDefault();
        const uploadArea = document.getElementById('uploadArea');
        if (uploadArea) uploadArea.classList.add('drag-over');
    },

    handleDragLeave(e) {
        e.preventDefault();
        const uploadArea = document.getElementById('uploadArea');
        if (uploadArea) uploadArea.classList.remove('drag-over');
    },

    // Process Files with Auto-Discovery
    async processFiles(files) {
        this.showLoading();
        this.updateLoadingStatus('📁 Processing uploaded files...');
        
        for (let i = 0; i < files.length; i++) {
            const file = files[i];
            this.updateProgress((i / files.length) * 50); // First 50% for file processing
            
            try {
                const content = await this.readFile(file);
                const fileType = this.detectFileType(file.name, content);
                
                const fileObj = {
                    name: file.name,
                    content: content,
                    size: file.size,
                    type: fileType,
                    uploadDate: new Date().toISOString(),
                    id: Date.now() + Math.random(),
                    components: this.extractComponentsFromFile(content, fileType),
                    metrics: this.calculateFileMetrics(content, fileType)
                };
                
                this.uploadedFiles.push(fileObj);
                
                // Auto-discover components
                this.updateLoadingStatus(`🔍 Auto-discovering components in ${file.name}...`);
                await this.autoDiscoverComponents(fileObj);
                
            } catch (error) {
                this.showError(`Failed to read ${file.name}: ${error.message}`);
            }
        }
        
        this.updateProgress(100);
        this.hideLoading();
        
        this.updateDashboardStats();
        this.displayDiscoveredComponents();
        this.enableAutoAnalysis();
        this.saveToDatabase();
        
        this.showSuccess(`📁 ${files.length} files uploaded and ${this.discoveredComponents.size} components auto-discovered!`);
    },

    // Read File
    readFile(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = e => resolve(e.target.result);
            reader.onerror = e => reject(new Error('File read failed'));
            reader.readAsText(file);
        });
    },

    // Detect File Type
    detectFileType(fileName, content) {
        const name = fileName.toLowerCase();
        const upperContent = content.toUpperCase();
        
        if (name.includes('.cpy') || name.includes('copybook')) {
            return 'Copybook';
        } else if (name.includes('.jcl') || upperContent.includes('//JOB ')) {
            return 'JCL Job';
        } else if (name.includes('.cbl') || name.includes('.cob') || 
                  upperContent.includes('IDENTIFICATION DIVISION') ||
                  upperContent.includes('PROGRAM-ID')) {
            return 'COBOL Program';
        } else if (name.includes('.proc')) {
            return 'JCL Procedure';
        } else {
            return 'Text File';
        }
    },

    // Calculate File Metrics
    calculateFileMetrics(content, fileType) {
        const lines = content.split('\n');
        const totalLines = lines.length;
        const codeLines = lines.filter(line => {
            const trimmed = line.trim();
            return trimmed.length > 0 && !trimmed.startsWith('*') && !trimmed.startsWith('//');
        }).length;
        
        const complexity = this.calculateComplexity(content, fileType);
        
        return {
            totalLines,
            codeLines,
            commentLines: totalLines - codeLines,
            complexity,
            fileSize: content.length
        };
    },

    // Calculate Complexity Score
    calculateComplexity(content, fileType) {
        const upperContent = content.toUpperCase();
        let complexity = 1;
        
        if (fileType === 'COBOL Program') {
            // Count decision points
            const ifCount = (upperContent.match(/\bIF\b/g) || []).length;
            const performCount = (upperContent.match(/\bPERFORM\b/g) || []).length;
            const evaluateCount = (upperContent.match(/\bEVALUATE\b/g) || []).length;
            
            complexity = 1 + ifCount + performCount + evaluateCount;
        } else if (fileType === 'Copybook') {
            // Count field definitions
            const fieldCount = (upperContent.match(/^\s*\d{2}\s+/gm) || []).length;
            complexity = Math.ceil(fieldCount / 10);
        }
        
        return Math.min(complexity, 10);
    },

    // ============================================
    // COMPONENT EXTRACTION AND DISCOVERY
    // ============================================

    // Extract Components from Files
    extractComponentsFromFile(content, fileType) {
        const components = [];
        const lines = content.split('\n');

        lines.forEach((line, index) => {
            const trimmed = line.trim().toUpperCase();
            
            // Extract COBOL 01-level fields (main focus for copybooks)
            const field01Match = trimmed.match(/^\s*01\s+([A-Z][A-Z0-9\-_]{2,})/);
            if (field01Match) {
                components.push({
                    name: field01Match[1],
                    type: 'RECORD_LAYOUT',
                    level: '01',
                    lineNumber: index + 1,
                    fileType: fileType,
                    isMainComponent: true,
                    businessPurpose: this.generateBusinessPurpose(field01Match[1])
                });
            }
            
            // Extract ALL field levels for complete analysis
            const fieldMatch = trimmed.match(/^\s*(\d{2})\s+([A-Z][A-Z0-9\-_]*)/);
            if (fieldMatch) {
                const level = parseInt(fieldMatch[1]);
                const fieldName = fieldMatch[2];
                
                if (level !== 88 && fieldName && level <= 49) {
                    components.push({
                        name: fieldName,
                        type: level === 1 ? 'RECORD_LAYOUT' : 'FIELD',
                        level: level,
                        lineNumber: index + 1,
                        fileType: fileType,
                        isMainComponent: level === 1,
                        businessPurpose: this.generateBusinessPurpose(fieldName)
                    });
                }
            }
            
            // Extract copybook names
            const copyMatch = trimmed.match(/COPY\s+([A-Z][A-Z0-9\-_]{2,})/);
            if (copyMatch) {
                components.push({
                    name: copyMatch[1],
                    type: 'COPYBOOK',
                    lineNumber: index + 1,
                    fileType: fileType,
                    isMainComponent: false,
                    businessPurpose: this.generateBusinessPurpose(copyMatch[1])
                });
            }
            
            // Extract program names
            const programMatch = trimmed.match(/PROGRAM-ID\.?\s+([A-Z][A-Z0-9\-_]{2,})/);
            if (programMatch) {
                components.push({
                    name: programMatch[1],
                    type: 'PROGRAM',
                    lineNumber: index + 1,
                    fileType: fileType,
                    isMainComponent: true,
                    businessPurpose: this.generateBusinessPurpose(programMatch[1])
                });
            }

            // Extract file names from FD statements
            const fileMatch = trimmed.match(/FD\s+([A-Z][A-Z0-9\-_]{2,})/);
            if (fileMatch) {
                components.push({
                    name: fileMatch[1],
                    type: 'FILE',
                    lineNumber: index + 1,
                    fileType: fileType,
                    isMainComponent: false,
                    businessPurpose: this.generateBusinessPurpose(fileMatch[1])
                });
            }
        });
        
        return components;
    },

    // Generate Business Purpose based on naming patterns
    generateBusinessPurpose(componentName) {
        const name = componentName.toUpperCase();
        
        // Customer-related
        if (name.includes('CUST') || name.includes('CUSTOMER')) {
            if (name.includes('MASTER') || name.includes('MAST')) {
                return 'Customer Master Data Management';
            } else if (name.includes('TRANS') || name.includes('TXN')) {
                return 'Customer Transaction Processing';
            } else if (name.includes('VALID') || name.includes('CHECK')) {
                return 'Customer Data Validation';
            } else {
                return 'Customer Information Processing';
            }
        }
        
        // Account-related
        else if (name.includes('ACCT') || name.includes('ACCOUNT')) {
            if (name.includes('BAL') || name.includes('BALANCE')) {
                return 'Account Balance Management';
            } else if (name.includes('TRANS') || name.includes('TXN')) {
                return 'Account Transaction Processing';
            } else if (name.includes('MAINT') || name.includes('UPD')) {
                return 'Account Maintenance Operations';
            } else {
                return 'Account Management System';
            }
        }
        
        // Financial/Payment
        else if (name.includes('PAY') || name.includes('PAYMENT')) {
            return 'Payment Processing System';
        } else if (name.includes('INVOICE') || name.includes('INV')) {
            return 'Invoice Management System';
        } else if (name.includes('BILLING') || name.includes('BILL')) {
            return 'Billing Operations System';
        }
        
        // Transaction-related
        else if (name.includes('TRANS') || name.includes('TXN')) {
            if (name.includes('LOG') || name.includes('HIST')) {
                return 'Transaction History & Logging';
            } else if (name.includes('PROC') || name.includes('PROCESS')) {
                return 'Transaction Processing Engine';
            } else {
                return 'Transaction Management System';
            }
        }
        
        // Data management
        else if (name.includes('MASTER') || name.includes('MAST')) {
            return 'Master Data Management';
        } else if (name.includes('COPY') || name.includes('CPY')) {
            return 'Data Structure Definition';
        } else if (name.includes('VALID') || name.includes('CHECK')) {
            return 'Data Validation & Quality Control';
        }
        
        // Reports
        else if (name.includes('REPORT') || name.includes('RPT')) {
            return 'Report Generation System';
        } else if (name.includes('EXTRACT') || name.includes('EXT')) {
            return 'Data Extraction & ETL';
        }
        
        // Maintenance
        else if (name.includes('MAINT') || name.includes('UPD')) {
            return 'Data Maintenance Operations';
        } else if (name.includes('DELETE') || name.includes('DEL')) {
            return 'Data Deletion & Cleanup';
        }
        
        // Generic based on type indicators
        else if (name.includes('PROC') || name.includes('PROCESS')) {
            return 'Business Process Automation';
        } else if (name.includes('UTIL') || name.includes('UTILITY')) {
            return 'System Utility Functions';
        } else if (name.includes('BATCH') || name.includes('JOB')) {
            return 'Batch Processing System';
        } else if (name.includes('ONLINE') || name.includes('CICS')) {
            return 'Online Transaction Processing';
        }
        
        // Fallback based on common patterns
        else if (name.endsWith('-RECORD') || name.endsWith('-REC')) {
            return 'Data Record Structure';
        } else if (name.endsWith('-FILE') || name.endsWith('-FL')) {
            return 'File Management System';
        } else if (name.endsWith('-PROG') || name.endsWith('-PGM')) {
            return 'Business Logic Program';
        } else {
            return 'Mainframe Business Component';
        }
    },

    // ============================================
    // AUTO-DISCOVERY AND COMPONENT ANALYSIS
    // ============================================

    // Auto-Discover Components
    async autoDiscoverComponents(fileObj) {
        for (const component of fileObj.components) {
            if (component.isMainComponent) {
                const discoveredComponent = {
                    name: component.name,
                    friendlyName: await this.generateFriendlyName(component.name),
                    type: component.type,
                    businessPurpose: component.businessPurpose,
                    fileSource: fileObj.name,
                    lineCount: fileObj.metrics.codeLines,
                    complexityScore: fileObj.metrics.complexity,
                    inputFiles: this.extractInputFiles(fileObj.content),
                    outputFiles: this.extractOutputFiles(fileObj.content),
                    fieldCount: fileObj.components.filter(c => c.type === 'FIELD' || c.type === 'RECORD_LAYOUT').length,
                    analyzed: false,
                    selected: false,
                    timestamp: new Date().toISOString()
                };
                
                this.discoveredComponents.set(component.name, discoveredComponent);
            }
        }
    },

    // Extract Input/Output Files
    extractInputFiles(content) {
        const files = [];
        const lines = content.split('\n');
        
        lines.forEach(line => {
            const trimmed = line.trim().toUpperCase();
            
            // Look for INPUT file patterns
            const inputPatterns = [
                /SELECT\s+([A-Z][A-Z0-9\-_]+)\s+ASSIGN/,
                /OPEN\s+INPUT\s+([A-Z][A-Z0-9\-_]+)/,
                /READ\s+([A-Z][A-Z0-9\-_]+)/
            ];
            
            for (const pattern of inputPatterns) {
                const match = trimmed.match(pattern);
                if (match && !files.includes(match[1])) {
                    files.push(match[1]);
                }
            }
        });
        
        return files.slice(0, 10); // Limit to top 10
    },

    extractOutputFiles(content) {
        const files = [];
        const lines = content.split('\n');
        
        lines.forEach(line => {
            const trimmed = line.trim().toUpperCase();
            
            // Look for OUTPUT file patterns
            const outputPatterns = [
                /OPEN\s+OUTPUT\s+([A-Z][A-Z0-9\-_]+)/,
                /WRITE\s+([A-Z][A-Z0-9\-_]+)/,
                /DISPLAY\s+.*\s+UPON\s+([A-Z][A-Z0-9\-_]+)/
            ];
            
            for (const pattern of outputPatterns) {
                const match = trimmed.match(pattern);
                if (match && !files.includes(match[1])) {
                    files.push(match[1]);
                }
            }
        });
        
        return files.slice(0, 10); // Limit to top 10
    },

    // Generate Friendly Name using patterns
    async generateFriendlyName(componentName) {
        // Check cache first
        if (this.friendlyNameCache.has(componentName.toUpperCase())) {
            return this.friendlyNameCache.get(componentName.toUpperCase());
        }
        
        // Use pattern-based generation for speed and reliability
        const friendlyName = this.generateFriendlyNameFromPattern(componentName);
        
        // Cache the result
        this.friendlyNameCache.set(componentName.toUpperCase(), friendlyName);
        
        return friendlyName;
    },

    // Pattern-based friendly name generation
    generateFriendlyNameFromPattern(componentName) {
        const name = componentName.toUpperCase();
        
        // Common mainframe patterns to friendly names
        const patterns = [
            { pattern: /CUST.*MASTER/, replacement: 'Customer Master File' },
            { pattern: /CUST.*MAINT/, replacement: 'Customer Maintenance Program' },
            { pattern: /CUST.*VALID/, replacement: 'Customer Validation Program' },
            { pattern: /ACCT.*MASTER/, replacement: 'Account Master File' },
            { pattern: /ACCT.*TRANS/, replacement: 'Account Transaction Program' },
            { pattern: /ACCT.*BAL/, replacement: 'Account Balance Program' },
            { pattern: /PAY.*PROC/, replacement: 'Payment Processing System' },
            { pattern: /TRANS.*LOG/, replacement: 'Transaction Log Handler' },
            { pattern: /INVOICE.*PROC/, replacement: 'Invoice Processing System' },
            { pattern: /REPORT.*GEN/, replacement: 'Report Generation Program' },
            { pattern: /.*MASTER.*/, replacement: `${name.split('-')[0]} Master Data` },
            { pattern: /.*COPY.*/, replacement: `${name.split('-')[0]} Data Structure` },
            { pattern: /.*VALID.*/, replacement: `${name.split('-')[0]} Validation Program` },
            { pattern: /.*PROC.*/, replacement: `${name.split('-')[0]} Processing System` }
        ];
        
        for (const { pattern, replacement } of patterns) {
            if (pattern.test(name)) {
                return replacement;
            }
        }
        
        // Final fallback
        const parts = name.split('-');
        if (parts.length > 1) {
            return `${parts[0]} ${parts[1]} System`;
        } else {
            return `${name} Component`;
        }
    },

    // Enable Auto Analysis
    enableAutoAnalysis() {
        const autoAnalyzeBtn = document.getElementById('autoAnalyzeBtn');
        if (autoAnalyzeBtn && this.discoveredComponents.size > 0 && this.serverValidated) {
            autoAnalyzeBtn.disabled = false;
        }
    },

    // ============================================
    // DISPLAY AND UI UPDATE METHODS
    // ============================================

    // Display Discovered Components
    displayDiscoveredComponents() {
        const container = document.getElementById('componentsList');
        if (!container) return;

        const components = Array.from(this.discoveredComponents.values());
        
        if (components.length === 0) {
            container.innerHTML = `
                <p style="color: var(--grey-500); text-align: center; padding: 2rem;">
                    Upload files to auto-discover components
                </p>
            `;
            return;
        }

        // Sort components by type and name
        components.sort((a, b) => {
            if (a.type !== b.type) {
                const typeOrder = { 'PROGRAM': 1, 'RECORD_LAYOUT': 2, 'COPYBOOK': 3, 'FILE': 4 };
                return (typeOrder[a.type] || 5) - (typeOrder[b.type] || 5);
            }
            return a.friendlyName.localeCompare(b.friendlyName);
        });

        let html = '';
        
        components.forEach(component => {
            const iconClass = this.getComponentIconClass(component.type);
            const analysisStatus = component.analyzed ? 
                '<span class="badge badge-success">Analyzed</span>' : 
                '<span class="badge badge-warning">Pending</span>';
            
            const selectedClass = component.selected ? 'selected' : '';
            
            html += `
                <div class="component-card ${selectedClass}" onclick="analyzer.selectComponent('${component.name}')" data-component="${component.name}">
                    <div class="component-card-header">
                        <div class="component-card-icon ${iconClass}">
                            ${this.getComponentIcon(component.type)}
                        </div>
                        <div class="component-card-info">
                            <div class="component-card-name">${component.name}</div>
                            <div class="component-card-friendly">${component.friendlyName}</div>
                            <div class="component-card-description">${component.businessPurpose}</div>
                        </div>
                    </div>
                    <div class="component-card-metrics">
                        <div class="component-metric">
                            <span class="component-metric-icon">📁</span>
                            <span>${component.fileSource}</span>
                        </div>
                        <div class="component-metric">
                            <span class="component-metric-icon">📋</span>
                            <span>${component.fieldCount} fields</span>
                        </div>
                        <div class="component-metric">
                            <span class="component-metric-icon">📊</span>
                            <span>Complexity: ${component.complexityScore}</span>
                        </div>
                        <div class="component-metric">
                            ${analysisStatus}
                        </div>
                    </div>
                </div>
            `;
        });

        container.innerHTML = html;
        
        // Update count
        const countElement = document.getElementById('componentCount');
        if (countElement) {
            countElement.textContent = components.length;
        }
    },

    // Get Component Icon Class
    getComponentIconClass(type) {
        switch(type) {
            case 'PROGRAM': return 'program';
            case 'COPYBOOK': 
            case 'RECORD_LAYOUT': return 'copybook';
            case 'FILE': return 'file';
            default: return 'file';
        }
    },

    // Get Component Icon
    getComponentIcon(type) {
        switch(type) {
            case 'PROGRAM': return '💼';
            case 'COPYBOOK': 
            case 'RECORD_LAYOUT': return '📚';
            case 'FILE': return '📄';
            default: return '📋';
        }
    },

    // Update Dashboard Stats
    updateDashboardStats() {
        // Counts
        const totalComponents = this.discoveredComponents.size;
        const totalFiles = this.uploadedFiles.length;
        const totalFields = Array.from(this.discoveredComponents.values())
            .reduce((sum, c) => sum + (c.fieldCount || 0), 0);

        const programs = Array.from(this.discoveredComponents.values())
            .filter(c => (c.type || '').toUpperCase().includes('PROGRAM')).length;
        const copybooks = Array.from(this.discoveredComponents.values())
            .filter(c => (c.type || '').toUpperCase().includes('COPY') || (c.type || '').toUpperCase().includes('RECORD')).length;

        // Quality average (only analyzed comps with numeric score)
        const scored = Array.from(this.discoveredComponents.values())
            .map(c => Number(c.qualityScore))
            .filter(v => Number.isFinite(v));
        const avgQuality = scored.length ? (scored.reduce((a,b)=>a+b,0) / scored.length).toFixed(1) : '-';

        // Header stats
        const setText = (id, val) => { 
            const el = document.getElementById(id); 
            if (el) el.textContent = String(val); 
        };
        
        setText('headerComponents', totalComponents);
        setText('headerPrograms', programs);
        setText('headerCopybooks', copybooks);
        setText('headerFields', totalFields);

        // Component count in left panel
        setText('componentCount', totalComponents);
    },

    // Select Component
    selectComponent(componentName) {
        // Clear previous selections
        Array.from(this.discoveredComponents.values()).forEach(comp => {
            comp.selected = false;
        });
        
        // Set new selection
        const component = this.discoveredComponents.get(componentName);
        if (component) {
            component.selected = true;
            this.currentSelectedComponent = componentName;
        }
        
        // Update UI
        this.displayDiscoveredComponents();
        this.persistSelection(componentName);
        this.updateDashboardStats();
        
        // Show analysis if available
        if (this.analysisResults[componentName]) {
            this.displayComponentAnalysis(componentName);
            // Switch to appropriate tab
            const analysisTab = document.querySelector('.tab[data-tab="dependencies"]');
            if (analysisTab) analysisTab.click();
        }
        
        this.showInfo(`Selected component: ${component ? component.friendlyName : componentName}`);
    },

    // Persist Selection in Database
    persistSelection(selectedName) {
        if (!this.db || !this.dbInitialized) return;
        try {
            // Clear previous selection flags
            this.db.run(`UPDATE discovered_components SET selected = 0`);
            // Set current
            this.db.run(`UPDATE discovered_components SET selected = 1 WHERE component_name = ?`, [selectedName]);
        } catch (e) {
            console.error('Failed to persist selection:', e);
        }
    },

    // Get Display Name (friendly name if available)
    getDisplayName(componentName) {
        const component = this.discoveredComponents.get(componentName);
        return component?.friendlyName || componentName;
    },

    // Export Results
    exportResults(format) {
        const data = {
            timestamp: new Date().toISOString(),
            summary: {
                totalComponents: this.discoveredComponents.size,
                totalFiles: this.uploadedFiles.length,
                analyzedComponents: Object.keys(this.analysisResults).length
            },
            components: Array.from(this.discoveredComponents.entries()).map(([name, comp]) => ({
                name,
                friendlyName: comp.friendlyName,
                type: comp.type,
                businessPurpose: comp.businessPurpose,
                analyzed: comp.analyzed,
                analysis: this.analysisResults[name] || null
            }))
        };

        if (format === 'json') {
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            this.downloadFile(blob, 'mainframe_analysis_results.json');
        } else if (format === 'markdown') {
            const markdown = this.generateMarkdownReport(data);
            const blob = new Blob([markdown], { type: 'text/markdown' });
            this.downloadFile(blob, 'mainframe_analysis_report.md');
        }
        
        this.showSuccess(`📄 Results exported as ${format.toUpperCase()}`);
    },

    // Generate Markdown Report
    generateMarkdownReport(data) {
        let markdown = `# Mainframe Analysis Report

Generated: ${new Date(data.timestamp).toLocaleString()}

## Summary

- **Total Components:** ${data.summary.totalComponents}
- **Total Files:** ${data.summary.totalFiles}
- **Analyzed Components:** ${data.summary.analyzedComponents}

## Components

`;

        data.components.forEach(comp => {
            markdown += `### ${comp.friendlyName} (${comp.name})

- **Type:** ${comp.type}
- **Business Purpose:** ${comp.businessPurpose}
- **Status:** ${comp.analyzed ? '✅ Analyzed' : '⏳ Pending Analysis'}

`;
            
            if (comp.analysis && comp.analysis.llmAnalysis) {
                markdown += `**Analysis:**
${comp.analysis.llmAnalysis.businessPurpose || 'No detailed analysis available'}

`;
            }
        });

        return markdown;
    },

    // Download File Helper
    downloadFile(blob, filename) {
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);
    }
});

// ============================================
// ENHANCED CODE ANALYZER - PART 4
// LLM Integration and Analysis Engine
// ============================================

// Extend the EnhancedCodeAnalyzer class with analysis methods
Object.assign(EnhancedCodeAnalyzer.prototype, {

    // ============================================
    // AUTO-ANALYSIS ORCHESTRATION
    // ============================================

    // Start Auto Analysis
    async startAutoAnalysis() {
        if (this.autoAnalysisInProgress) {
            this.showWarning('Auto-analysis already in progress');
            return;
        }
        
        if (this.discoveredComponents.size === 0) {
            this.showError('No components discovered for analysis');
            return;
        }
        
        this.autoAnalysisInProgress = true;
        this.showLoading();
        this.updateLoadingStatus('🚀 Starting auto-analysis of discovered components...');
        
        try {
            const components = Array.from(this.discoveredComponents.values())
                .filter(comp => !comp.analyzed)
                .slice(0, 10); // Limit to 10 components for performance
            
            let completed = 0;
            
            for (const component of components) {
                try {
                    this.updateLoadingStatus(`Analyzing ${component.friendlyName || component.name} (${completed + 1}/${components.length})...`);
                    this.updateProgress((completed / components.length) * 100);
                    
                    const relevantFiles = this.findRelevantFiles(component.name);
                    const analysisResult = await this.runComponentAnalysis(component.name, relevantFiles);
                    
                    this.analysisResults[component.name] = analysisResult;
                    component.analyzed = true;
                    component.qualityScore = analysisResult.qualityScore;
                    
                    completed++;
                    
                    // Brief pause between analyses
                    await this.sleep(1000);
                    
                } catch (error) {
                    console.warn(`Failed to analyze ${component.name}:`, error);
                    component.analyzed = false;
                }
            }
            
            this.hideLoading();
            this.updateDashboardWithResults();
            this.enableExportButtons();
            this.enableChat();
            this.saveToDatabase();
            
            this.showSuccess(`✨ Auto-analysis complete! ${completed}/${components.length} components analyzed`);
            
            // Switch to dashboard to show results
            document.querySelector('.tab[data-tab="dashboard"]').click();
            
        } catch (error) {
            this.hideLoading();
            this.showError(`Auto-analysis failed: ${error.message}`);
        } finally {
            this.autoAnalysisInProgress = false;
        }
    },

    // Find Relevant Files for Component
    findRelevantFiles(componentName) {
        const componentUpper = componentName.toUpperCase();
        const componentBase = componentUpper.replace(/\.(CPY|COPYBOOK|COP)$/, '');
        
        return this.uploadedFiles.filter(file => {
            const fileNameUpper = file.name.toUpperCase();
            const fileNameBase = fileNameUpper.replace(/\.(CPY|COPYBOOK|COP)$/, '');
            
            // Direct name match
            if (fileNameUpper.includes(componentUpper) || 
                fileNameBase === componentBase ||
                componentBase === fileNameBase) {
                return true;
            }
            
            // Content-based matching
            const contentUpper = file.content.toUpperCase();
            if (contentUpper.includes(componentUpper) ||
                contentUpper.includes(componentBase) ||
                contentUpper.includes(`COPY ${componentBase}`) ||
                contentUpper.includes(`"${componentBase}"`) ||
                contentUpper.includes(`'${componentBase}'`)) {
                return true;
            }
            
            // Component-based matching
            if (file.components) {
                return file.components.some(comp => {
                    const compNameUpper = comp.name.toUpperCase();
                    const compNameBase = compNameUpper.replace(/\.(CPY|COPYBOOK|COP)$/, '');
                    return compNameUpper === componentUpper || 
                           compNameBase === componentBase ||
                           componentBase === compNameBase;
                });
            }
            
            return false;
        });
    },

    // Run Component Analysis
    async runComponentAnalysis(componentName, relevantFiles) {
        console.log(`Running analysis for: ${componentName}`);
        
        const component = this.discoveredComponents.get(componentName);
        const friendlyName = component?.friendlyName || componentName;
        
        try {
            // Stage 1: Basic component analysis
            const componentType = this.detectComponentType(componentName, relevantFiles);
            
            // Stage 2: Extract dependencies
            const dependencyAnalysis = await this.extractDependencies(relevantFiles);
            
            // Stage 3: Field analysis (for copybooks)
            let fieldAnalysis = null;
            if (componentType === 'Copybook' || componentType === 'RECORD_LAYOUT') {
                fieldAnalysis = await this.analyzeFieldsInComponent(componentName, relevantFiles);
            }
            
            // Stage 4: LLM-enhanced analysis
            let llmAnalysis = null;
            try {
                llmAnalysis = await this.getBusinessIntelligenceFromLLM(
                    componentName, friendlyName, componentType, relevantFiles, dependencyAnalysis, fieldAnalysis
                );
            } catch (llmError) {
                console.warn('LLM analysis failed:', llmError);
                llmAnalysis = {
                    error: true,
                    message: llmError.message,
                    businessPurpose: component?.businessPurpose || 'Business purpose analysis failed',
                    recommendations: ['Check LLM server connection', 'Verify component data', 'Try manual analysis'],
                    fallbackUsed: true
                };
            }
            
            const results = {
                componentName: componentName,
                friendlyName: friendlyName,
                timestamp: new Date().toISOString(),
                filesAnalyzed: relevantFiles.map(f => f.name),
                componentType: componentType,
                dependencyAnalysis: dependencyAnalysis,
                fieldAnalysis: fieldAnalysis,
                llmAnalysis: llmAnalysis,
                totalFields: fieldAnalysis?.fields?.length || 0,
                qualityScore: this.calculateQualityScore(llmAnalysis, fieldAnalysis),
                analysisMethod: 'Auto-Discovery-Enhanced'
            };
            
            return results;
            
        } catch (error) {
            console.error(`Analysis failed for ${componentName}:`, error);
            throw new Error(`Analysis failed: ${error.message}`);
        }
    },

    // Detect Component Type
    detectComponentType(componentName, relevantFiles) {
        const component = this.discoveredComponents.get(componentName);
        if (component?.type) {
            return component.type;
        }
        
        // Analyze files to determine type
        for (const file of relevantFiles) {
            if (file.type === 'Copybook') return 'Copybook';
            if (file.type === 'COBOL Program') return 'Program';
            if (file.type === 'JCL Job') return 'Job';
        }
        
        return 'Unknown';
    },

    // Extract Dependencies
    async extractDependencies(relevantFiles) {
        const dependencies = {
            found: { copybooks: [], programs: [], files: [] },
            missing: { copybooks: [], programs: [], files: [] },
            summary: { foundCount: 0, missingCount: 0 }
        };
        
        for (const file of relevantFiles) {
            const content = file.content.toUpperCase();
            const lines = content.split('\n');
            
            lines.forEach(line => {
                const trimmed = line.trim();
                
                // Extract COPY statements
                const copyMatch = trimmed.match(/COPY\s+([A-Z][A-Z0-9\-_]+)/);
                if (copyMatch) {
                    const copybook = copyMatch[1];
                    if (this.discoveredComponents.has(copybook)) {
                        if (!dependencies.found.copybooks.includes(copybook)) {
                            dependencies.found.copybooks.push(copybook);
                        }
                    } else {
                        if (!dependencies.missing.copybooks.includes(copybook)) {
                            dependencies.missing.copybooks.push(copybook);
                        }
                    }
                }
                
                // Extract CALL statements
                const callMatch = trimmed.match(/CALL\s+['"]([A-Z][A-Z0-9\-_]+)['"]/);
                if (callMatch) {
                    const program = callMatch[1];
                    if (this.discoveredComponents.has(program)) {
                        if (!dependencies.found.programs.includes(program)) {
                            dependencies.found.programs.push(program);
                        }
                    } else {
                        if (!dependencies.missing.programs.includes(program)) {
                            dependencies.missing.programs.push(program);
                        }
                    }
                }
                
                // Extract file references
                const fileMatch = trimmed.match(/SELECT\s+([A-Z][A-Z0-9\-_]+)/);
                if (fileMatch) {
                    const fileName = fileMatch[1];
                    if (this.discoveredComponents.has(fileName)) {
                        if (!dependencies.found.files.includes(fileName)) {
                            dependencies.found.files.push(fileName);
                        }
                    } else {
                        if (!dependencies.missing.files.includes(fileName)) {
                            dependencies.missing.files.push(fileName);
                        }
                    }
                }
            });
        }
        
        // Calculate summary
        dependencies.summary.foundCount = 
            dependencies.found.copybooks.length + 
            dependencies.found.programs.length + 
            dependencies.found.files.length;
            
        dependencies.summary.missingCount = 
            dependencies.missing.copybooks.length + 
            dependencies.missing.programs.length + 
            dependencies.missing.files.length;
        
        return dependencies;
    },

    // Analyze Fields in Component
    async analyzeFieldsInComponent(componentName, relevantFiles) {
        const fieldAnalysis = {
            fields: [],
            inputFields: [],
            outputFields: [],
            referenceFields: [],
            unusedFields: [],
            businessLogicSummary: {
                totalValidationRules: 0,
                totalCalculations: 0,
                fieldsWithBusinessLogic: 0
            }
        };
        
        for (const file of relevantFiles) {
            const content = file.content;
            const lines = content.split('\n');
            
            lines.forEach((line, index) => {
                const trimmed = line.trim().toUpperCase();
                
                // Extract field definitions
                const fieldMatch = trimmed.match(/^\s*(\d{2})\s+([A-Z][A-Z0-9\-_]+)(?:\s+PIC\s+([X9VS\(\)]+))?/);
                if (fieldMatch) {
                    const level = parseInt(fieldMatch[1]);
                    const fieldName = fieldMatch[2];
                    const picture = fieldMatch[3] || '';
                    
                    if (level !== 88 && fieldName && level <= 49) {
                        const field = {
                            name: fieldName,
                            level: level,
                            picture: picture,
                            lineNumber: index + 1,
                            fileName: file.name,
                            businessLogic: {
                                businessMeaning: this.generateFieldPurpose(fieldName),
                                validationRules: [],
                                calculations: []
                            }
                        };
                        
                        fieldAnalysis.fields.push(field);
                        
                        // Determine usage pattern
                        if (this.isInputField(fieldName, content)) {
                            fieldAnalysis.inputFields.push(fieldName);
                        } else if (this.isOutputField(fieldName, content)) {
                            fieldAnalysis.outputFields.push(fieldName);
                        } else if (this.isReferenceField(fieldName, content)) {
                            fieldAnalysis.referenceFields.push(fieldName);
                        } else {
                            fieldAnalysis.unusedFields.push(fieldName);
                        }
                    }
                }
            });
        }
        
        return fieldAnalysis;
    },

    // Field Usage Detection Methods
    isInputField(fieldName, content) {
        const patterns = [
            new RegExp(`MOVE\\s+\\w+\\s+TO\\s+${fieldName}`, 'i'),
            new RegExp(`ACCEPT\\s+${fieldName}`, 'i'),
            new RegExp(`READ\\s+\\w+\\s+INTO\\s+${fieldName}`, 'i')
        ];
        
        return patterns.some(pattern => pattern.test(content));
    },

    isOutputField(fieldName, content) {
        const patterns = [
            new RegExp(`DISPLAY\\s+${fieldName}`, 'i'),
            new RegExp(`WRITE\\s+${fieldName}`, 'i'),
            new RegExp(`MOVE\\s+${fieldName}\\s+TO`, 'i')
        ];
        
        return patterns.some(pattern => pattern.test(content));
    },

    isReferenceField(fieldName, content) {
        const patterns = [
            new RegExp(`IF\\s+${fieldName}`, 'i'),
            new RegExp(`WHEN\\s+${fieldName}`, 'i'),
            new RegExp(`COMPUTE\\s+\\w+\\s*=.*${fieldName}`, 'i')
        ];
        
        return patterns.some(pattern => pattern.test(content));
    },

    // Generate Field Purpose
    generateFieldPurpose(fieldName) {
        const name = fieldName.toUpperCase();
        
        if (name.includes('RECORD') || name.includes('REC')) {
            return `Main record structure for ${fieldName.toLowerCase().replace(/-/g, ' ')} data`;
        } else if (name.includes('ID') || name.includes('KEY')) {
            return `Unique identifier for ${fieldName.toLowerCase().replace(/-/g, ' ')}`;
        } else if (name.includes('DATE') || name.includes('TIME')) {
            return `Date/time field for ${fieldName.toLowerCase().replace(/-/g, ' ')} tracking`;
        } else if (name.includes('AMT') || name.includes('AMOUNT')) {
            return `Monetary amount for ${fieldName.toLowerCase().replace(/-/g, ' ')}`;
        } else if (name.includes('DESC') || name.includes('NAME')) {
            return `Descriptive text for ${fieldName.toLowerCase().replace(/-/g, ' ')}`;
        } else if (name.includes('FLAG') || name.includes('IND')) {
            return `Status indicator for ${fieldName.toLowerCase().replace(/-/g, ' ')}`;
        } else if (name.includes('CODE') || name.includes('CD')) {
            return `Coded value for ${fieldName.toLowerCase().replace(/-/g, ' ')}`;
        } else if (name.includes('COUNT') || name.includes('CNT')) {
            return `Counter/number field for ${fieldName.toLowerCase().replace(/-/g, ' ')}`;
        } else {
            return `Business data field for ${fieldName.toLowerCase().replace(/-/g, ' ')} processing`;
        }
    },

    // Calculate Quality Score
    calculateQualityScore(llmAnalysis, fieldAnalysis) {
        let score = 5; // Base score
        
        // LLM analysis quality factors
        if (llmAnalysis && !llmAnalysis.error) {
            score += 2;
            
            if (llmAnalysis.businessPurpose && llmAnalysis.businessPurpose.length > 50) {
                score += 1;
            }
            
            if (llmAnalysis.recommendations && llmAnalysis.recommendations.length > 0) {
                score += 1;
            }
        }
        
        // Field analysis quality factors
        if (fieldAnalysis) {
            if (fieldAnalysis.fields && fieldAnalysis.fields.length > 0) {
                score += 1;
            }
            
            if (fieldAnalysis.inputFields && fieldAnalysis.inputFields.length > 0) {
                score += 0.5;
            }
            
            if (fieldAnalysis.outputFields && fieldAnalysis.outputFields.length > 0) {
                score += 0.5;
            }
        }
        
        return Math.min(Math.round(score), 10);
    },

    // ============================================
    // LLM API INTEGRATION WITH FALLBACK
    // ============================================

    // Enhanced LLM API Call with 6000 token limit
    async callLLMAPI(prompt, retries = 2) {
        console.log('🤖 Enhanced LLM API call initiated');
        
        try {
            // Validate token limits (6000 max)
            const promptTokens = this.estimateTokens(prompt);
            const maxPromptTokens = this.maxTokens - 1500; // Reserve 1500 for response
            
            if (promptTokens > maxPromptTokens) {
                console.warn(`Prompt too large (${promptTokens} tokens), truncating...`);
                prompt = this.truncatePrompt(prompt, maxPromptTokens);
            }
            
            return await this.makeSingleLLMRequest(prompt, 1500, retries);
            
        } catch (error) {
            console.error('Enhanced LLM call failed:', error);
            
            // Return structured fallback response instead of throwing
            return {
                error: true,
                message: error.message,
                businessPurpose: 'LLM analysis failed - manual review recommended',
                recommendations: ['Check LLM connection', 'Verify component data', 'Try manual analysis'],
                qualityScore: 3,
                fallbackUsed: true
            };
        }
    },

    // Estimate Tokens
    estimateTokens(text) {
        if (!text || typeof text !== 'string') return 0;
        
        // More accurate token estimation for mainframe content
        // COBOL and technical content tends to have more tokens per character
        const baseEstimate = Math.ceil(text.length / 3.2);
        
        // Adjust for technical content density
        const technicalWords = (text.match(/\b[A-Z][A-Z0-9\-_]{3,}\b/g) || []).length;
        const codeLines = (text.match(/^\s*\d{2}\s+/gm) || []).length;
        
        // Technical content adjustment
        const adjustment = Math.floor((technicalWords + codeLines) * 0.1);
        
        return baseEstimate + adjustment;
    },

    // Truncate Prompt to Fit Token Limit
    truncatePrompt(prompt, maxTokens) {
        const lines = prompt.split('\n');
        let truncated = '';
        let tokenCount = 0;
        
        // Keep the header and instructions
        const headerEndIndex = lines.findIndex(line => line.includes('FILE CONTENTS:'));
        if (headerEndIndex !== -1) {
            const header = lines.slice(0, headerEndIndex + 1).join('\n');
            truncated = header + '\n';
            tokenCount = this.estimateTokens(truncated);
        }
        
        // Add content until we reach the limit
        for (let i = headerEndIndex + 1; i < lines.length; i++) {
            const line = lines[i] + '\n';
            const lineTokens = this.estimateTokens(line);
            
            if (tokenCount + lineTokens > maxTokens - 100) { // Leave buffer
                truncated += '\n[Content truncated to fit token limit]';
                break;
            }
            
            truncated += line;
            tokenCount += lineTokens;
        }
        
        return truncated;
    },

    // Single LLM Request
    async makeSingleLLMRequest(prompt, maxResponseTokens, retries = 2) {
        for (let attempt = 0; attempt <= retries; attempt++) {
            try {
                console.log(`LLM API call attempt ${attempt + 1}/${retries + 1}`);
                
                const response = await fetch(`${this.vllmEndpoint}/generate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: prompt,
                        max_tokens: maxResponseTokens,
                        temperature: 0.1,
                        top_p: 0.9,
                        stop: [],
                        stream: false,
                        frequency_penalty: 0.1,
                        presence_penalty: 0.0
                    }),
                    signal: AbortSignal.timeout(90000) // 90 second timeout
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                const resultText = this.extractTextFromResponse(data);
                
                if (!resultText) {
                    throw new Error('No valid text content in LLM response');
                }

                // Try to parse as JSON, fallback to plain text
                const parseResult = this.parseJSONResponse(resultText);
                
                if (parseResult.success) {
                    console.log('✅ LLM request successful with JSON response');
                    return parseResult.data;
                } else {
                    console.log('⚠️ JSON parsing failed, using fallback structure');
                    return {
                        businessPurpose: resultText.substring(0, 500),
                        recommendations: ['Manual review recommended'],
                        qualityScore: 5,
                        rawResponse: resultText,
                        fallbackUsed: true
                    };
                }

            } catch (error) {
                console.error(`LLM attempt ${attempt + 1} failed:`, error);
                
                if (attempt < retries) {
                    const delay = 2000 * (attempt + 1); // Exponential backoff
                    console.log(`Retrying in ${delay}ms...`);
                    await this.sleep(delay);
                } else {
                    throw error;
                }
            }
        }
    },

    // Extract Text from LLM Response
    extractTextFromResponse(data) {
        if (typeof data === 'string') return data.trim();
        if (data.text) return data.text.trim();
        if (data.choices && data.choices[0]) {
            if (data.choices[0].text) return data.choices[0].text.trim();
            if (data.choices[0].message?.content) return data.choices[0].message.content.trim();
        }
        if (data.generated_text) return data.generated_text.trim();
        if (data.response) return data.response.trim();
        
        return null;
    },

    // Parse JSON Response with Fallback
    parseJSONResponse(text) {
        try {
            // Try to extract JSON from response
            const jsonMatch = text.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                const parsed = JSON.parse(jsonMatch[0]);
                return { success: true, data: parsed };
            }
            
            // If no JSON found, create structured fallback
            return {
                success: false,
                error: 'No JSON found in response',
                fallbackData: {
                    businessPurpose: text.substring(0, 300),
                    recommendations: ['Manual review recommended'],
                    qualityScore: 5,
                    rawResponse: text
                }
            };
            
        } catch (error) {
            return {
                success: false,
                error: error.message,
                fallbackData: {
                    businessPurpose: 'Analysis failed - LLM response could not be parsed',
                    recommendations: ['Check LLM connection', 'Verify component data'],
                    qualityScore: 3,
                    rawResponse: text
                }
            };
        }
    },

    // Get Business Intelligence from LLM
    async getBusinessIntelligenceFromLLM(componentName, friendlyName, componentType, relevantFiles, dependencyAnalysis, fieldAnalysis) {
        const fileContents = relevantFiles.map(f => `=== ${f.name} (${f.type}) ===\n${f.content}`).join('\n\n');
        
        // Truncate file contents if too long
        const maxFileContentLength = 4000;
        const truncatedContents = fileContents.length > maxFileContentLength ? 
            fileContents.substring(0, maxFileContentLength) + '\n[Content truncated...]' : 
            fileContents;
        
        const prompt = `MAINFRAME COMPONENT BUSINESS INTELLIGENCE ANALYSIS

Component: ${componentName}
Friendly Name: ${friendlyName}
Type: ${componentType}

FILE CONTENTS:
${truncatedContents}

DEPENDENCY ANALYSIS:
Found Dependencies: ${JSON.stringify(dependencyAnalysis.found)}
Missing Dependencies: ${JSON.stringify(dependencyAnalysis.missing)}

${fieldAnalysis ? `FIELD ANALYSIS:
Total Fields: ${fieldAnalysis.fields.length}
Input Fields: ${fieldAnalysis.inputFields.length}
Output Fields: ${fieldAnalysis.outputFields.length}
Unused Fields: ${fieldAnalysis.unusedFields.length}` : ''}

TASK: Provide comprehensive business intelligence analysis for this mainframe component.

Return ONLY a JSON object with this exact structure:
{
  "componentName": "${componentName}",
  "friendlyName": "${friendlyName}",
  "businessPurpose": "detailed business purpose and role in the system",
  "businessLogic": {
    "validationRules": ["rule1", "rule2"],
    "businessRules": ["rule1", "rule2"],
    "dataProcessing": "description of data processing logic"
  },
  "qualityScore": 8,
  "recommendations": ["rec1", "rec2", "rec3"],
  "modernizationSuggestions": ["suggestion1", "suggestion2"],
  "riskAssessment": "low/medium/high risk assessment with reasoning"
}`;

        return await this.callLLMAPI(prompt);
    },

    // ============================================
    // DASHBOARD AND RESULTS DISPLAY
    // ============================================

    // Update Dashboard with Results
    updateDashboardWithResults() {
        const dashboardContent = document.getElementById('dashboardContent');
        if (!dashboardContent) return;

        const analyzedComponents = Object.keys(this.analysisResults);
        
        if (analyzedComponents.length === 0) {
            dashboardContent.innerHTML = `
                <p style="color: var(--grey-500); text-align: center; padding: 2rem;">
                    Run auto-analysis to see detailed component insights
                </p>
            `;
            return;
        }

        let html = `
            <!-- System Overview Card -->
            <div class="collapsible-section expanded">
                <div class="collapsible-header" onclick="toggleCollapsible(this)">
                    <div class="collapsible-title">
                        <span class="collapsible-icon">📊</span>
                        System Overview (${analyzedComponents.length} components analyzed)
                    </div>
                    <span class="expand-icon">▼</span>
                </div>
                <div class="collapsible-content">
                    <div class="collapsible-body">
                        ${this.generateSystemOverview()}
                    </div>
                </div>
            </div>

            <!-- Component Analysis Results -->
            <div class="collapsible-section expanded">
                <div class="collapsible-header" onclick="toggleCollapsible(this)">
                    <div class="collapsible-title">
                        <span class="collapsible-icon">🎯</span>
                        Component Analysis Results
                    </div>
                    <span class="expand-icon">▼</span>
                </div>
                <div class="collapsible-content">
                    <div class="collapsible-body">
                        ${this.generateComponentResults()}
                    </div>
                </div>
            </div>

            <!-- Dependencies Summary -->
            <div class="collapsible-section">
                <div class="collapsible-header" onclick="toggleCollapsible(this)">
                    <div class="collapsible-title">
                        <span class="collapsible-icon">🔗</span>
                        Dependencies Summary
                    </div>
                    <span class="expand-icon">▼</span>
                </div>
                <div class="collapsible-content">
                    <div class="collapsible-body">
                        ${this.generateDependenciesSummary()}
                    </div>
                </div>
            </div>
        `;

        dashboardContent.innerHTML = html;
    },

    // Generate System Overview
    generateSystemOverview() {
        const analyzedComponents = Object.values(this.analysisResults);
        const avgQuality = analyzedComponents.length > 0 ? 
            (analyzedComponents.reduce((sum, comp) => sum + (comp.qualityScore || 0), 0) / analyzedComponents.length).toFixed(1) : 
            0;

        const riskLevels = analyzedComponents.reduce((acc, comp) => {
            const risk = comp.llmAnalysis?.riskAssessment || 'unknown';
            acc[risk.toLowerCase()] = (acc[risk.toLowerCase()] || 0) + 1;
            return acc;
        }, {});

        return `
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1.5rem;">
                <div style="background: var(--grey-50); padding: 1rem; border-radius: 8px; text-align: center;">
                    <div style="font-size: 1.5rem; font-weight: bold; color: var(--primary-blue);">${analyzedComponents.length}</div>
                    <div style="font-size: 0.8rem; color: var(--grey-600);">Components Analyzed</div>
                </div>
                <div style="background: var(--grey-50); padding: 1rem; border-radius: 8px; text-align: center;">
                    <div style="font-size: 1.5rem; font-weight: bold; color: var(--success-green);">${avgQuality}</div>
                    <div style="font-size: 0.8rem; color: var(--grey-600);">Average Quality Score</div>
                </div>
                <div style="background: var(--grey-50); padding: 1rem; border-radius: 8px; text-align: center;">
                    <div style="font-size: 1.5rem; font-weight: bold; color: var(--warning-yellow);">${riskLevels.high || 0}</div>
                    <div style="font-size: 0.8rem; color: var(--grey-600);">High Risk Components</div>
                </div>
                <div style="background: var(--grey-50); padding: 1rem; border-radius: 8px; text-align: center;">
                    <div style="font-size: 1.5rem; font-weight: bold; color: var(--info-blue);">${this.discoveredComponents.size}</div>
                    <div style="font-size: 0.8rem; color: var(--grey-600);">Total Components</div>
                </div>
            </div>
            <p style="color: var(--grey-600); font-size: 0.9rem;">
                📈 <strong>Business Intelligence:</strong> Your mainframe system has been analyzed for business purpose, dependencies, and modernization opportunities. 
                Click on any component below to drill down into detailed analysis.
            </p>
        `;
    },

    // Generate Component Results
    generateComponentResults() {
        const analyzedComponents = Object.entries(this.analysisResults);
        
        let html = '<div style="display: grid; gap: 1rem;">';
        
        analyzedComponents.forEach(([name, result]) => {
            const component = this.discoveredComponents.get(name);
            const displayName = component?.friendlyName || name;
            const qualityColor = this.getQualityColor(result.qualityScore);
            const riskColor = this.getRiskColor(result.llmAnalysis?.riskAssessment);
            
            html += `
                <div style="background: white; border: 1px solid var(--grey-200); border-radius: 8px; padding: 1rem; cursor: pointer;" 
                     onclick="analyzer.selectComponent('${name}')">
                    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 0.75rem;">
                        <div>
                            <h4 style="margin: 0; color: var(--grey-800);">${displayName}</h4>
                            <div style="font-size: 0.8rem; color: var(--grey-500); font-family: monospace;">${name}</div>
                        </div>
                        <div style="text-align: right;">
                            <span class="badge" style="background: ${qualityColor}; color: white; margin-bottom: 0.25rem;">
                                Quality: ${result.qualityScore}/10
                            </span>
                            <br>
                            <span class="badge" style="background: ${riskColor}; color: white;">
                                ${result.llmAnalysis?.riskAssessment || 'Unknown'} Risk
                            </span>
                        </div>
                    </div>
                    <p style="color: var(--grey-600); font-size: 0.85rem; margin: 0; line-height: 1.4;">
                        ${result.llmAnalysis?.businessPurpose?.substring(0, 200) || 'No business purpose available'}...
                    </p>
                </div>
            `;
        });
        
        html += '</div>';
        return html;
    },

    // Generate Dependencies Summary
    generateDependenciesSummary() {
        const allDependencies = Object.values(this.analysisResults).reduce((acc, result) => {
            if (result.dependencyAnalysis) {
                acc.foundCount += result.dependencyAnalysis.summary.foundCount;
                acc.missingCount += result.dependencyAnalysis.summary.missingCount;
                
                // Collect missing items
                result.dependencyAnalysis.missing.copybooks.forEach(cb => {
                    if (!acc.missingItems.includes(cb)) acc.missingItems.push(cb);
                });
                result.dependencyAnalysis.missing.programs.forEach(pg => {
                    if (!acc.missingItems.includes(pg)) acc.missingItems.push(pg);
                });
                result.dependencyAnalysis.missing.files.forEach(fl => {
                    if (!acc.missingItems.includes(fl)) acc.missingItems.push(fl);
                });
            }
            return acc;
        }, { foundCount: 0, missingCount: 0, missingItems: [] });

        return `
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                <div style="background: rgba(16, 185, 129, 0.1); padding: 1rem; border-radius: 8px; text-align: center;">
                    <div style="font-size: 1.5rem; font-weight: bold; color: var(--success-green);">${allDependencies.foundCount}</div>
                    <div style="font-size: 0.8rem; color: var(--grey-600);">Dependencies Found</div>
                </div>
                <div style="background: rgba(239, 68, 68, 0.1); padding: 1rem; border-radius: 8px; text-align: center;">
                    <div style="font-size: 1.5rem; font-weight: bold; color: var(--error-red);">${allDependencies.missingCount}</div>
                    <div style="font-size: 0.8rem; color: var(--grey-600);">Dependencies Missing</div>
                </div>
            </div>
            ${allDependencies.missingItems.length > 0 ? `
                <div style="background: var(--grey-50); padding: 1rem; border-radius: 8px;">
                    <h5 style="margin: 0 0 0.5rem 0; color: var(--error-red);">⚠️ Missing Dependencies</h5>
                    <div style="display: flex; flex-wrap: wrap; gap: 0.25rem;">
                        ${allDependencies.missingItems.slice(0, 10).map(item => 
                            `<span class="badge badge-danger">${item}</span>`
                        ).join('')}
                        ${allDependencies.missingItems.length > 10 ? `<span class="badge badge-grey">+${allDependencies.missingItems.length - 10} more</span>` : ''}
                    </div>
                </div>
            ` : ''}
        `;
    },

    // Helper methods for colors
    getQualityColor(score) {
        if (score >= 8) return 'var(--success-green)';
        if (score >= 6) return 'var(--warning-yellow)';
        return 'var(--error-red)';
    },

    getRiskColor(risk) {
        const riskLevel = (risk || '').toLowerCase();
        if (riskLevel.includes('high')) return 'var(--error-red)';
        if (riskLevel.includes('medium')) return 'var(--warning-yellow)';
        return 'var(--success-green)';
    },

    // Enable Export Buttons
    enableExportButtons() {
        const exportJsonBtn = document.getElementById('exportJsonBtn');
        const exportMdBtn = document.getElementById('exportMdBtn');
        
        if (exportJsonBtn) exportJsonBtn.disabled = false;
        if (exportMdBtn) exportMdBtn.disabled = false;
    },

    // Enable Chat
    enableChat() {
        // This will be implemented in Part 5
        console.log('✅ Chat system ready for activation');
    },

    
// Attach Chat Event Listeners
    attachChatEventListeners() {
        const chatInput = document.getElementById('chatInput');
        const chatSendBtn = document.getElementById('chatSendBtn');
        const chatContext = document.getElementById('chatContext');
        
        if (chatInput && chatSendBtn) {
            // Chat input event handlers
            chatInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    this.sendChatMessage();
                }
            });
            
            chatSendBtn.addEventListener('click', () => this.sendChatMessage());
            
            // Auto-resize chat input
            chatInput.addEventListener('input', () => {
                chatInput.style.height = 'auto';
                chatInput.style.height = Math.min(chatInput.scrollHeight, 160) + 'px';
            });
        }

        // Chat context change
        if (chatContext) {
            chatContext.addEventListener('change', () => this.onChatContextChange());
        }

        // Chat suggestion buttons - use event delegation
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('chat-suggestion-btn')) {
                const question = e.target.getAttribute('data-question');
                if (question && chatInput) {
                    chatInput.value = question;
                    this.sendChatMessage();
                }
            }
        });
    },

    // Display Welcome Message
    displayWelcomeMessage() {
        this.addChatMessage('assistant', `👋 **Welcome to Business Intelligence Chat!**

I provide contextual analysis and can drill down into:

🎯 **Business Purpose:** What each component does in business terms
📊 **Program Analysis:** Detailed program structure and logic  
📋 **Field Analysis:** Field lifecycle, usage, and business meaning
📁 **File Analysis:** Data flow and file relationships
🔗 **Dependency Impact:** How changes affect the system
⚖️ **Business Rules:** Logic validation and business constraints
🚀 **Modernization:** Optimization and migration recommendations

*Upload files and start auto-analysis to unlock intelligent conversations!*`);
    },

    // Enable Chat
    enableChat() {
        const chatInput = document.getElementById('chatInput');
        const chatSendBtn = document.getElementById('chatSendBtn');
        const chatContextSection = document.getElementById('chatContextSection');
        const chatSuggestions = document.getElementById('chatSuggestions');
        
        if (chatInput) chatInput.disabled = false;
        if (chatSendBtn) chatSendBtn.disabled = false;
        if (chatContextSection) chatContextSection.style.display = 'block';
        if (chatSuggestions) chatSuggestions.style.display = 'block';
        
        // Show analysis ready message
        this.addChatMessage('assistant', `🎉 **Analysis Complete!**

I can now provide intelligent insights about your ${this.discoveredComponents.size} discovered components.

**Available Analysis:**
• ${Object.keys(this.analysisResults).length} components fully analyzed
• Business purpose and logic understanding
• Dependency mapping and impact analysis
• Field-level insights and relationships
• Modernization recommendations

**Try asking:**
"What's the business purpose of [component name]?"
"Show me missing dependencies"
"Which components are most critical?"
"How can we optimize this system?"

Select any component from the dashboard to get contextual suggestions!`);
    },

    // ============================================
    // CHAT MESSAGE HANDLING
    // ============================================

    // Send Chat Message
    async sendChatMessage() {
        const chatInput = document.getElementById('chatInput');
        const message = chatInput.value.trim();
        
        if (!message) return;
        
        // Clear input and add user message
        chatInput.value = '';
        chatInput.style.height = 'auto';
        this.addChatMessage('user', message);
        
        // Show typing indicator
        this.showTypingIndicator();
        
        try {
            // Get contextual response
            const response = await this.getChatResponse(message);
            
            // Remove typing indicator and add response
            this.hideTypingIndicator();
            this.addChatMessage('assistant', response);
            
            // Save chat to database
            this.saveChatToDatabase(message, response);
            
        } catch (error) {
            this.hideTypingIndicator();
            this.addChatMessage('assistant', `❌ **Error:** ${error.message}\n\nPlease check your LLM connection and try again.`);
        }
    },

    // Add Chat Message to UI
    addChatMessage(sender, content) {
        const chatMessages = document.getElementById('chatMessages');
        if (!chatMessages) return;
        
        const messageDiv = document.createElement('div');
        messageDiv.className = `chat-message ${sender}`;
        
        const bubble = document.createElement('div');
        bubble.className = 'chat-bubble';
        
        if (sender === 'assistant') {
            bubble.innerHTML = `
                <div class="chat-message-header">Business Intelligence Assistant</div>
                <div class="chat-message-content">${content}</div>
                <div class="chat-message-time">${new Date().toLocaleTimeString()}</div>
            `;
        } else {
            bubble.innerHTML = `
                <div class="chat-message-content">${content}</div>
                <div class="chat-message-time">${new Date().toLocaleTimeString()}</div>
            `;
        }
        
        messageDiv.appendChild(bubble);
        chatMessages.appendChild(messageDiv);
        
        // Scroll to bottom
        chatMessages.scrollTop = chatMessages.scrollHeight;
    },

    // Show/Hide Typing Indicator
    showTypingIndicator() {
        const chatMessages = document.getElementById('chatMessages');
        if (!chatMessages) return;
        
        const typingDiv = document.createElement('div');
        typingDiv.className = 'typing-indicator';
        typingDiv.id = 'typingIndicator';
        typingDiv.innerHTML = `
            <span>🤖 Assistant is thinking...</span>
            <div class="typing-dots">
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
            </div>
        `;
        
        chatMessages.appendChild(typingDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
    },

    hideTypingIndicator() {
        const typingIndicator = document.getElementById('typingIndicator');
        if (typingIndicator) {
            typingIndicator.remove();
        }
    },

    // Get Chat Response
    async getChatResponse(message) {
        const context = this.buildChatContext(message);
        
        const prompt = `BUSINESS INTELLIGENCE CHAT ASSISTANT

CONTEXT:
${context}

USER QUESTION: "${message}"

INSTRUCTIONS:
- Provide intelligent, business-focused insights based on the analysis data
- Use specific component names, statistics, and recommendations from the context
- Format response in markdown for readability with **bold** text for emphasis
- Be conversational but professional
- If asked about specific components, reference their analysis data
- For dependency questions, highlight critical missing items
- For optimization questions, provide concrete modernization suggestions
- If information is not available in the context, say so clearly

RESPONSE:`;

        try {
            const response = await this.callLLMAPI(prompt);
            
            // Handle different response types
            if (typeof response === 'string') {
                return response;
            } else if (response && response.businessPurpose) {
                return response.businessPurpose;
            } else if (response && response.rawResponse) {
                return response.rawResponse;
            } else {
                return this.generateFallbackResponse(message);
            }
            
        } catch (error) {
            console.error('Chat response failed:', error);
            return this.generateFallbackResponse(message);
        }
    },

    // Build Chat Context
    buildChatContext(message) {
        let context = `SYSTEM OVERVIEW:
- Total Components: ${this.discoveredComponents.size}
- Analyzed Components: ${Object.keys(this.analysisResults).length}
- Files Uploaded: ${this.uploadedFiles.length}
- Current Selection: ${this.currentSelectedComponent || 'None'}

`;

        // Add component summaries
        if (Object.keys(this.analysisResults).length > 0) {
            context += `ANALYZED COMPONENTS:\n`;
            Object.entries(this.analysisResults).slice(0, 5).forEach(([name, result]) => {
                const comp = this.discoveredComponents.get(name);
                context += `- ${name} (${comp?.friendlyName || name}): ${result.componentType}\n`;
                context += `  Purpose: ${result.llmAnalysis?.businessPurpose?.substring(0, 150) || 'Not available'}...\n`;
                if (result.qualityScore) {
                    context += `  Quality Score: ${result.qualityScore}/10\n`;
                }
                if (result.llmAnalysis?.riskAssessment) {
                    context += `  Risk Level: ${result.llmAnalysis.riskAssessment}\n`;
                }
            });
            context += '\n';
        }

        // Add dependency summary
        const totalMissing = Object.values(this.analysisResults).reduce((sum, result) => 
            sum + (result.dependencyAnalysis?.summary?.missingCount || 0), 0);
        if (totalMissing > 0) {
            context += `DEPENDENCIES:\n- Total Missing Dependencies: ${totalMissing}\n\n`;
        }

        // Add specific component context if selected
        if (this.currentSelectedComponent && this.analysisResults[this.currentSelectedComponent]) {
            const selectedResult = this.analysisResults[this.currentSelectedComponent];
            context += `CURRENT COMPONENT FOCUS: ${this.currentSelectedComponent}\n`;
            context += `Analysis: ${JSON.stringify(selectedResult, null, 2).substring(0, 1500)}\n\n`;
        }

        return context;
    },

    // Generate Fallback Response
    generateFallbackResponse(message) {
        const lowerMessage = message.toLowerCase();
        
        if (lowerMessage.includes('business purpose') || lowerMessage.includes('what does')) {
            return `📊 **Business Purpose Analysis**

Based on the analyzed components:

${Object.entries(this.analysisResults).slice(0, 3).map(([name, result]) => {
    const comp = this.discoveredComponents.get(name);
    return `• **${comp?.friendlyName || name}**: ${result.llmAnalysis?.businessPurpose?.substring(0, 100) || result.componentType + ' component'}...`;
}).join('\n')}

*Select a specific component from the dashboard for detailed analysis.*`;
        }
        
        if (lowerMessage.includes('dependencies') || lowerMessage.includes('missing')) {
            const totalMissing = Object.values(this.analysisResults).reduce((sum, result) => 
                sum + (result.dependencyAnalysis?.summary?.missingCount || 0), 0);
            
            return `🔗 **Dependency Analysis**

**System Health:**
• Total Missing Dependencies: ${totalMissing}
• Critical Impact Assessment: ${totalMissing > 10 ? 'HIGH' : totalMissing > 5 ? 'MEDIUM' : 'LOW'}

**Recommendations:**
• Review missing copybooks and programs
• Validate file references
• Consider impact on system functionality

*Ask about specific components for detailed dependency maps.*`;
        }
        
        if (lowerMessage.includes('risk') || lowerMessage.includes('critical')) {
            const highRiskComponents = Object.entries(this.analysisResults)
                .filter(([_, result]) => (result.llmAnalysis?.riskAssessment || '').toLowerCase().includes('high'))
                .map(([name, _]) => this.discoveredComponents.get(name)?.friendlyName || name);
            
            return `📊 **Risk Analysis**

**High Risk Components:** ${highRiskComponents.length}
${highRiskComponents.length > 0 ? highRiskComponents.slice(0, 5).map(name => `• ${name}`).join('\n') : '• No high-risk components identified'}

**Quality Assessment:**
• Components analyzed: ${Object.keys(this.analysisResults).length}
• Average quality score: ${Object.values(this.analysisResults).reduce((sum, r) => sum + (r.qualityScore || 0), 0) / Object.keys(this.analysisResults).length || 0}

*Select components to view detailed risk assessments.*`;
        }
        
        if (lowerMessage.includes('optimize') || lowerMessage.includes('modernize')) {
            return `🚀 **Modernization Recommendations**

**System Optimization Opportunities:**
• Legacy code refactoring candidates identified
• Dependency simplification possibilities  
• Data structure optimization potential

**Next Steps:**
• Review high-complexity components first
• Address missing dependencies
• Consider microservices decomposition
• Implement automated testing coverage

*Ask about specific components for targeted modernization strategies.*`;
        }
        
        return `🤖 **I'm here to help with your mainframe analysis!**

**What I can assist with:**
• Business purpose explanations
• Dependency analysis and impact assessment
• Risk assessment and quality evaluation
• Modernization recommendations
• Component-specific insights

**Try asking:**
• "What's the purpose of [component name]?"
• "Show me missing dependencies"
• "Which components need attention?"
• "How can we optimize this system?"

*Select any component from the dashboard for focused analysis.*`;
    },

    // Update Chat Context
    updateChatContext(contextType, selectedItem) {
        const chatContext = document.getElementById('chatContext');
        const chatSelectedItem = document.getElementById('chatSelectedItem');
        
        if (chatContext) chatContext.value = contextType;
        if (chatSelectedItem) chatSelectedItem.value = selectedItem || '';
        
        this.chatContext = contextType;
        this.currentSelectedComponent = contextType === 'component' ? selectedItem : null;
    },

    // Save Chat to Database
    saveChatToDatabase(userMessage, assistantResponse) {
        if (!this.db || !this.dbInitialized) return;
        
        try {
            const timestamp = new Date().toISOString();
            
            // Save user message
            this.db.run(`
                INSERT INTO chat_history 
                (component_name, context_type, sender, content, timestamp)
                VALUES (?, ?, ?, ?, ?)
            `, [
                this.currentSelectedComponent || '',
                this.chatContext,
                'user',
                userMessage,
                timestamp
            ]);
            
            // Save assistant response
            this.db.run(`
                INSERT INTO chat_history 
                (component_name, context_type, sender, content, timestamp)
                VALUES (?, ?, ?, ?, ?)
            `, [
                this.currentSelectedComponent || '',
                this.chatContext,
                'assistant',
                assistantResponse,
                timestamp
            ]);
            
        } catch (error) {
            console.error('Failed to save chat to database:', error);
        }
    },

    // Chat context change handler
    onChatContextChange() {
        const chatContext = document.getElementById('chatContext');
        if (chatContext) {
            this.chatContext = chatContext.value;
        }
    },

    // ============================================
    // DEPENDENCY AND FIELD MATRIX DISPLAY
    // ============================================

    // Display Component Analysis
    displayComponentAnalysis(componentName) {
        const result = this.analysisResults[componentName];
        if (!result) return;

        // Update dependencies tab
        this.displayDependencyFlow(componentName, result);
        
        // Update field matrix tab if applicable
        if (result.fieldAnalysis) {
            this.displayFieldMatrix(componentName, result);
        }
    },

    // Display Dependency Flow
    displayDependencyFlow(componentName, result) {
        const container = document.getElementById('dependenciesContent');
        if (!container) return;

        const component = this.discoveredComponents.get(componentName);
        const displayName = component?.friendlyName || componentName;

        let html = `
            <div class="collapsible-section expanded">
                <div class="collapsible-header" onclick="toggleCollapsible(this)">
                    <div class="collapsible-title">
                        <span class="collapsible-icon">🎯</span>
                        ${displayName} - Dependency Analysis
                    </div>
                    <span class="expand-icon">▼</span>
                </div>
                <div class="collapsible-content">
                    <div class="collapsible-body">
                        ${this.generateDependencyFlowChart(result.dependencyAnalysis)}
                    </div>
                </div>
            </div>

            <div class="collapsible-section expanded">
                <div class="collapsible-header" onclick="toggleCollapsible(this)">
                    <div class="collapsible-title">
                        <span class="collapsible-icon">📋</span>
                        Detailed Dependency Breakdown
                    </div>
                    <span class="expand-icon">▼</span>
                </div>
                <div class="collapsible-content">
                    <div class="collapsible-body">
                        ${this.generateDependencyTable(result.dependencyAnalysis)}
                    </div>
                </div>
            </div>
        `;

        container.innerHTML = html;
    },

    // Generate Dependency Flow Chart
    generateDependencyFlowChart(dependencyAnalysis) {
        if (!dependencyAnalysis) return '<p>No dependency analysis available</p>';

        return `
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem; margin-bottom: 1.5rem;">
                <div style="background: rgba(16, 185, 129, 0.1); padding: 1rem; border-radius: 8px; text-align: center;">
                    <div style="font-size: 1.5rem; font-weight: bold; color: var(--success-green);">${dependencyAnalysis.summary.foundCount}</div>
                    <div style="font-size: 0.8rem; color: var(--grey-600);">Dependencies Found</div>
                </div>
                <div style="background: rgba(239, 68, 68, 0.1); padding: 1rem; border-radius: 8px; text-align: center;">
                    <div style="font-size: 1.5rem; font-weight: bold; color: var(--error-red);">${dependencyAnalysis.summary.missingCount}</div>
                    <div style="font-size: 0.8rem; color: var(--grey-600);">Dependencies Missing</div>
                </div>
            </div>

            <div style="background: var(--grey-50); padding: 1.5rem; border-radius: 8px;">
                <h4 style="margin: 0 0 1rem 0; color: var(--grey-800);">📊 Dependency Health Status</h4>
                <div style="background: white; padding: 1rem; border-radius: 6px; margin-bottom: 1rem;">
                    <div style="display: flex; justify-content: between; align-items: center; margin-bottom: 0.5rem;">
                        <span>Dependency Completion</span>
                        <span style="font-weight: bold;">${Math.round((dependencyAnalysis.summary.foundCount / (dependencyAnalysis.summary.foundCount + dependencyAnalysis.summary.missingCount)) * 100) || 0}%</span>
                    </div>
                    <div style="background: var(--grey-200); height: 8px; border-radius: 4px; overflow: hidden;">
                        <div style="background: var(--success-green); height: 100%; width: ${Math.round((dependencyAnalysis.summary.foundCount / (dependencyAnalysis.summary.foundCount + dependencyAnalysis.summary.missingCount)) * 100) || 0}%; border-radius: 4px;"></div>
                    </div>
                </div>
                <p style="color: var(--grey-600); font-size: 0.9rem; margin: 0;">
                    ${dependencyAnalysis.summary.missingCount > 5 ? '⚠️ High impact: Many missing dependencies may affect system functionality' : 
                      dependencyAnalysis.summary.missingCount > 0 ? '⚡ Medium impact: Some dependencies missing' : 
                      '✅ Low impact: All major dependencies found'}
                </p>
            </div>
        `;
    },

    // Generate Dependency Table
    generateDependencyTable(dependencyAnalysis) {
        if (!dependencyAnalysis) return '<p>No dependency analysis available</p>';

        let html = '';

        // Found Dependencies
        if (dependencyAnalysis.found.copybooks.length > 0 || dependencyAnalysis.found.programs.length > 0 || dependencyAnalysis.found.files.length > 0) {
            html += `
                <h5 style="color: var(--success-green); margin-bottom: 0.75rem;">✅ Found Dependencies</h5>
                <div class="data-table" style="margin-bottom: 1.5rem;">
                    <table>
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th>Status</th>
                                <th>Business Name</th>
                            </tr>
                        </thead>
                        <tbody>
            `;

            ['copybooks', 'programs', 'files'].forEach(type => {
                dependencyAnalysis.found[type].forEach(name => {
                    const comp = this.discoveredComponents.get(name);
                    html += `
                        <tr onclick="analyzer.selectComponent('${name}')" style="cursor: pointer;">
                            <td style="font-family: monospace;">${name}</td>
                            <td><span class="badge badge-success">${type.slice(0, -1)}</span></td>
                            <td><span class="badge badge-success">Found</span></td>
                            <td>${comp?.friendlyName || 'Not analyzed'}</td>
                        </tr>
                    `;
                });
            });

            html += `
                        </tbody>
                    </table>
                </div>
            `;
        }

        // Missing Dependencies
        if (dependencyAnalysis.missing.copybooks.length > 0 || dependencyAnalysis.missing.programs.length > 0 || dependencyAnalysis.missing.files.length > 0) {
            html += `
                <h5 style="color: var(--error-red); margin-bottom: 0.75rem;">⚠️ Missing Dependencies</h5>
                <div class="data-table">
                    <table>
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th>Status</th>
                                <th>Impact</th>
                            </tr>
                        </thead>
                        <tbody>
            `;

            ['copybooks', 'programs', 'files'].forEach(type => {
                dependencyAnalysis.missing[type].forEach(name => {
                    html += `
                        <tr>
                            <td style="font-family: monospace;">${name}</td>
                            <td><span class="badge badge-warning">${type.slice(0, -1)}</span></td>
                            <td><span class="badge badge-danger">Missing</span></td>
                            <td style="color: var(--error-red);">Potential compilation/runtime issues</td>
                        </tr>
                    `;
                });
            });

            html += `
                        </tbody>
                    </table>
                </div>
            `;
        }

        return html || '<p style="text-align: center; color: var(--grey-500);">No dependency information available</p>';
    },

    // Display Field Matrix
    displayFieldMatrix(componentName, result) {
        const container = document.getElementById('fieldMatrixContent');
        if (!container) return;

        const component = this.discoveredComponents.get(componentName);
        const displayName = component?.friendlyName || componentName;
        const fieldAnalysis = result.fieldAnalysis;

        if (!fieldAnalysis || !fieldAnalysis.fields || fieldAnalysis.fields.length === 0) {
            container.innerHTML = `
                <div style="text-align: center; padding: 2rem; color: var(--grey-500);">
                    <h4>No Field Analysis Available</h4>
                    <p>Component "${displayName}" doesn't contain field data or hasn't been analyzed for fields.</p>
                </div>
            `;
            return;
        }

        let html = `
            <h4 style="margin-bottom: 1rem;">Field Matrix Analysis for ${displayName}</h4>
            
            <!-- Field Overview Metrics -->
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1.5rem;">
                <div style="background: var(--grey-50); padding: 1rem; border-radius: 8px; text-align: center;">
                    <div style="font-size: 1.5rem; font-weight: bold; color: var(--primary-blue);">${fieldAnalysis.fields.length}</div>
                    <div style="font-size: 0.8rem; color: var(--grey-600);">Total Fields</div>
                </div>
                <div style="background: var(--grey-50); padding: 1rem; border-radius: 8px; text-align: center;">
                    <div style="font-size: 1.5rem; font-weight: bold; color: var(--success-green);">${fieldAnalysis.inputFields.length}</div>
                    <div style="font-size: 0.8rem; color: var(--grey-600);">Input Fields</div>
                </div>
                <div style="background: var(--grey-50); padding: 1rem; border-radius: 8px; text-align: center;">
                    <div style="font-size: 1.5rem; font-weight: bold; color: var(--info-blue);">${fieldAnalysis.outputFields.length}</div>
                    <div style="font-size: 0.8rem; color: var(--grey-600);">Output Fields</div>
                </div>
                <div style="background: var(--grey-50); padding: 1rem; border-radius: 8px; text-align: center;">
                    <div style="font-size: 1.5rem; font-weight: bold; color: var(--error-red);">${fieldAnalysis.unusedFields.length}</div>
                    <div style="font-size: 0.8rem; color: var(--grey-600);">Unused Fields</div>
                </div>
            </div>

            <div class="data-table">
                <table>
                    <thead>
                        <tr>
                            <th>Field Name</th>
                            <th>Level</th>
                            <th>Picture</th>
                            <th>Usage Pattern</th>
                            <th>Business Purpose</th>
                        </tr>
                    </thead>
                    <tbody>
        `;
        
        fieldAnalysis.fields.slice(0, 50).forEach(field => {
            const usage = this.determineFieldUsage(field, fieldAnalysis);
            const badgeClass = this.getUsageBadgeClass(usage);
            const businessPurpose = field.businessLogic?.businessMeaning || this.generateFieldPurpose(field.name);
            
            html += `
                <tr onclick="analyzer.updateChatContext('field', '${field.name}')" style="cursor: pointer;">
                    <td style="font-family: monospace; font-weight: 600;">${field.name}</td>
                    <td><span class="badge badge-grey">${field.level}</span></td>
                    <td style="font-family: monospace;">${field.picture || '-'}</td>
                    <td><span class="badge ${badgeClass}">${usage}</span></td>
                    <td style="font-size: 0.85rem; max-width: 200px;">${businessPurpose}</td>
                </tr>
            `;
        });
        
        html += `
                    </tbody>
                </table>
            </div>
        `;
        
        if (fieldAnalysis.fields.length > 50) {
            html += `<p style="margin-top: 1rem; color: var(--grey-500);">Showing 50 of ${fieldAnalysis.fields.length} fields</p>`;
        }

        container.innerHTML = html;
    },

    // Determine Field Usage
    determineFieldUsage(field, fieldAnalysis) {
        const fieldName = field.name;
        
        if (fieldAnalysis.inputFields && fieldAnalysis.inputFields.includes(fieldName)) return 'INPUT';
        if (fieldAnalysis.outputFields && fieldAnalysis.outputFields.includes(fieldName)) return 'OUTPUT';
        if (fieldAnalysis.referenceFields && fieldAnalysis.referenceFields.includes(fieldName)) return 'REFERENCE';
        if (fieldAnalysis.unusedFields && fieldAnalysis.unusedFields.includes(fieldName)) return 'UNUSED';
        
        return 'UNKNOWN';
    },

    // Get Usage Badge Class
    getUsageBadgeClass(usage) {
        switch(usage) {
            case 'INPUT': return 'badge-success';
            case 'OUTPUT': return 'badge-primary';
            case 'REFERENCE': return 'badge-warning';
            case 'UNUSED': return 'badge-danger';
            default: return 'badge-grey';
        }
    }
});

// ============================================
// GLOBAL INITIALIZATION AND SETUP
// ============================================

// Initialize analyzer on page load with proper error handling
let analyzer;
document.addEventListener('DOMContentLoaded', function() {
    try {
        analyzer = new EnhancedCodeAnalyzer();
        window.analyzer = analyzer; // Make globally accessible
        
        // Initialize chat system
        analyzer.initializeChat();
        
        console.log('✅ Enhanced Code Analyzer - Powered by Opulence Ready!');
    } catch (error) {
        console.error('Failed to initialize Enhanced Code Analyzer:', error);
        // Show error message to user
        document.body.innerHTML = `
            <div style="display: flex; align-items: center; justify-content: center; height: 100vh; background: #f9fafb;">
                <div style="text-align: center; padding: 2rem; background: white; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                    <h2 style="color: #ef4444; margin-bottom: 1rem;">❌ Initialization Failed</h2>
                    <p style="color: #6b7280; margin-bottom: 1rem;">Enhanced Code Analyzer failed to initialize properly.</p>
                    <p style="color: #374151; font-size: 0.9rem;">Error: ${error.message}</p>
                    <button onclick="location.reload()" style="margin-top: 1rem; padding: 0.5rem 1rem; background: #3b82f6; color: white; border: none; border-radius: 6px; cursor: pointer;">
                        Reload Page
                    </button>
                </div>
            </div>
        `;
    }
});

// Add cleanup on page unload
window.addEventListener('beforeunload', function() {
    if (analyzer && analyzer.cleanup) {
        analyzer.cleanup();
    }
});

// Export the analyzer for external use
if (typeof module !== 'undefined' && module.exports) {
    module.exports = EnhancedCodeAnalyzer;
}

console.log('🚀 Enhanced Code Analyzer - All Parts Loaded Successfully!');// ============================================
// ENHANCED CODE ANALYZER - PART 5
// Chat System and Final Integration
// ============================================

// Extend the EnhancedCodeAnalyzer class with chat and display methods
Object.assign(EnhancedCodeAnalyzer.prototype, {

    // ============================================
    // CHAT SYSTEM INITIALIZATION
    // ============================================

    // Initialize Chat System
    initializeChat() {
        this.setupChatUI();
        this.attachChatEventListeners();
        this.displayWelcomeMessage();
    },

    // Setup Chat UI
    setupChatUI() {
        const chatContainer = document.getElementById('chatContainer');
        if (!chatContainer) return;

        chatContainer.innerHTML = `
            <!-- Chat Header Info -->
            <div style="padding: 1rem; background: linear-gradient(135deg, var(--primary-blue) 0%, var(--indigo) 100%); color: white; border-radius: 12px; margin-bottom: 1rem;">
                <h3 style="font-size: 1rem; margin-bottom: 0.5rem;">🧠 Business Intelligence Chat</h3>
                <p style="font-size: 0.8rem; opacity: 0.9;">Drill down into programs, fields, files, and business logic</p>
            </div>

            <!-- Chat Context Selector -->
            <div class="form-section" id="chatContextSection" style="display: none;">
                <div class="form-section-title">
                    <span style="color: var(--info-blue);">🎯</span>
                    Chat Context
                </div>
                <div class="form-group">
                    <label class="form-label">Current Focus</label>
                    <select id="chatContext" class="form-input">
                        <option value="general">General Analysis</option>
                        <option value="component">Specific Component</option>
                        <option value="dependencies">Dependencies</option>
                        <option value="modernization">Modernization</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Selected Item</label>
                    <input type="text" id="chatSelectedItem" class="form-input" placeholder="Auto-selected based on dashboard" readonly>
                </div>
            </div>

            <!-- Chat Suggestions -->
            <div id="chatSuggestions" class="chat-suggestions" style="display: none;">
                <div class="chat-suggestions-title">💡 Suggested Questions:</div>
                <div class="chat-suggestion-chips">
                    <button class="chat-suggestion-btn" data-question="What is the business purpose of this system?">
                        🎯 Business Purpose
                    </button>
                    <button class="chat-suggestion-btn" data-question="Show me the complete dependency flow">
                        🌊 Dependency Flow
                    </button>
                    <button class="chat-suggestion-btn" data-question="What are the missing dependencies and their impact?">
                        ⚠️ Missing Dependencies
                    </button>
                    <button class="chat-suggestion-btn" data-question="How can we optimize this system for modernization?">
                        🚀 Optimization
                    </button>
                    <button class="chat-suggestion-btn" data-question="What business rules are implemented?">
                        ⚖️ Business Rules
                    </button>
                    <button class="chat-suggestion-btn" data-question="What components have the highest risk?">
                        📊 Risk Analysis
                    </button>
                </div>
            </div>

            <!-- Chat Messages Area -->
            <div class="chat-messages" id="chatMessages">
                <!-- Messages will be inserted here -->
            </div>

            <!-- Chat Input Section -->
            <div class="chat-input-section">
                <div class="chat-input-group">
                    <textarea id="chatInput" 
                              class="chat-input" 
                              placeholder="Ask about business purpose, dependencies, optimization..." 
                              disabled 
                              rows="1"></textarea>
                    <button id="chatSendBtn" class="chat-send-btn" disabled>
                        <span>Send</span>
                    </button>
                </div>
            </div>
        `;
    }
});
    
</script>
</body>
</html>