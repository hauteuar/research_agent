<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Mainframe Analyzer - Redesigned</title>
    <style>
        /* ===================================================================
        PART 1: RESET AND BASE STYLES
        ================================================================== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
        font-family: 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif;
        background: #ffffff;
        color: #1f2937;
        min-height: 100vh;
        overflow-x: hidden;
    }

    /* ===================================================================
    PART 2: MAIN LAYOUT STRUCTURE
    ================================================================== */
    .main-container {
        display: flex;
        height: 100vh;
        position: relative;
    }

    /* Left Panel - Collapsible */
    .left-panel {
        width: 400px;
        background: #f8fafc;
        border-right: 2px solid #e2e8f0;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        z-index: 10;
        overflow-y: auto;
        max-height: 100vh;
    }

    .left-panel.collapsed {
        width: 0;
        border-right: none;
        overflow: hidden;
    }

    .left-panel-content {
        padding: 20px;
        min-width: 400px;
    }

    /* Center Panel - Analysis Workspace */
    .center-panel {
        flex: 1;
        background: #ffffff;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        overflow-y: auto;
        max-height: 100vh;
    }

    /* Right Panel - Chat */
    .right-panel {
        width: 350px;
        background: #f1f5f9;
        border-left: 2px solid #e2e8f0;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        z-index: 10;
        display: flex;
        flex-direction: column;
        max-height: 100vh;
    }

    .right-panel.collapsed {
        width: 0;
        border-left: none;
        overflow: hidden;
    }

    .right-panel-content {
        padding: 20px;
        min-width: 350px;
        display: flex;
        flex-direction: column;
        height: 100%;
    }

    /* ===================================================================
PART 3: COLLAPSE TOGGLES - ENHANCED FIX
================================================================== */
.panel-toggle {
    position: absolute;
    top: 10px;
    width: 35px;
    height: 35px;
    background: #3b82f6;
    border: none;
    border-radius: 6px;
    color: white;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    z-index: 25;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    font-size: 14px;
    font-weight: bold;
}

.panel-toggle:hover {
    background: #2563eb;
    transform: scale(1.05);
}

/* LEFT TOGGLE - Position INSIDE the left panel */
.left-toggle {
    right: 10px; /* Changed from right: -50px to right: 10px */
}

/* RIGHT TOGGLE - Position INSIDE the right panel */  
.right-toggle {
    left: 10px; /* Changed from left: -50px to left: 10px */
}

/* Ensure panels have relative positioning for absolute toggle buttons */
.left-panel {
    position: relative;
}

.right-panel {
    position: relative;
}

/* Make sure toggle buttons stay visible */
.left-panel .panel-toggle,
.right-panel .panel-toggle {
    opacity: 1;
    visibility: visible;
}
/* Restore buttons - shown when panels are collapsed */
.restore-btn {
    position: fixed;
    top: 90px;
    width: 45px;
    height: 45px;
    background: #059669;
    border: none;
    border-radius: 50%;
    color: white;
    cursor: pointer;
    display: none;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    z-index: 30;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    font-size: 16px;
}

.restore-btn:hover {
    background: #047857;
    transform: scale(1.1);
}

.restore-btn.show {
    display: flex;
}

.left-restore {
    left: 15px;
}

.right-restore {
    right: 15px;
}
/* Panel collapsed state adjustments */
.left-panel.collapsed {
    width: 0;
    border-right: none;
    overflow: hidden;
}

.right-panel.collapsed {
    width: 0;
    border-left: none;
    overflow: hidden;
}

/* Toggle icons */
.toggle-icon {
    font-size: 16px;
    transition: transform 0.3s ease;
}

    /* ===================================================================
    PART 4: HEADER
    ================================================================== */
    .header {
        background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
        color: white;
        padding: 20px;
        text-align: center;
        position: sticky;
        top: 0;
        z-index: 15;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .header h1 {
        font-size: 2rem;
        margin-bottom: 8px;
        font-weight: 700;
    }

    .header p {
        opacity: 0.9;
        font-size: 0.9rem;
    }

    /* ===================================================================
    PART 5: LEFT PANEL COMPONENTS
    ================================================================== */
    .section {
        background: white;
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 20px;
        border: 1px solid #e2e8f0;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .section-title {
        color: #1e40af;
        font-size: 1.1rem;
        margin-bottom: 15px;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .section-title .icon {
        font-size: 1.2rem;
    }

    /* Form Elements */
    .form-group {
        margin-bottom: 16px;
    }

    .form-group label {
        display: block;
        margin-bottom: 6px;
        font-weight: 500;
        color: #374151;
        font-size: 0.9rem;
    }

    .form-input {
        width: 100%;
        padding: 12px 16px;
        border: 2px solid #d1d5db;
        border-radius: 8px;
        background: #ffffff;
        color: #1f2937;
        font-size: 14px;
        transition: all 0.2s ease;
    }

    .form-input:focus {
        outline: none;
        border-color: #3b82f6;
        box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }

    .form-input::placeholder {
        color: #9ca3af;
    }

    /* Buttons */
    .btn {
        width: 100%;
        padding: 12px 20px;
        border: none;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        text-transform: none;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
    }

    .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    .btn-primary {
        background: #3b82f6;
        color: white;
    }

    .btn-primary:hover:not(:disabled) {
        background: #2563eb;
        transform: translateY(-1px);
    }

    .btn-success {
        background: #10b981;
        color: white;
    }

    .btn-success:hover:not(:disabled) {
        background: #059669;
        transform: translateY(-1px);
    }

    .btn-secondary {
        background: #6b7280;
        color: white;
    }

    .btn-secondary:hover:not(:disabled) {
        background: #4b5563;
        transform: translateY(-1px);
    }

    .btn-danger {
        background: #ef4444;
        color: white;
    }

    .btn-danger:hover:not(:disabled) {
        background: #dc2626;
        transform: translateY(-1px);
    }

    /* Component Suggestions */
    .component-suggestions {
        background: white;
        border: 1px solid #d1d5db;
        border-radius: 8px;
        max-height: 150px;
        overflow-y: auto;
        display: none;
        position: absolute;
        width: calc(100% - 40px);
        z-index: 100;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
    }

    .suggestion-item {
        padding: 12px 16px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-size: 13px;
        border-bottom: 1px solid #f3f4f6;
    }

    .suggestion-item:hover {
        background: #f3f4f6;
        padding-left: 20px;
    }

    .suggestion-item:last-child {
        border-bottom: none;
    }

    /* Status Indicators */
    .status-indicator {
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 6px;
        margin-top: 8px;
    }

    .status-connected {
        background: #d1fae5;
        color: #065f46;
        border: 1px solid #a7f3d0;
    }

    .status-connecting {
        background: #fef3c7;
        color: #92400e;
        border: 1px solid #fcd34d;
    }

    .status-disconnected {
        background: #fee2e2;
        color: #991b1b;
        border: 1px solid #fca5a5;
    }

    /* File Upload */
    .upload-area {
        border: 2px dashed #d1d5db;
        border-radius: 12px;
        padding: 32px;
        text-align: center;
        cursor: pointer;
        transition: all 0.3s ease;
        background: #f9fafb;
    }

    .upload-area:hover {
        border-color: #3b82f6;
        background: #eff6ff;
    }

    .upload-area.drag-over {
        border-color: #10b981;
        background: #ecfdf5;
    }

    .file-list {
        max-height: 200px;
        overflow-y: auto;
        margin-top: 16px;
    }

    .file-item {
        background: #f9fafb;
        border: 1px solid #e5e7eb;
        border-radius: 6px;
        padding: 12px;
        margin-bottom: 8px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .file-info {
        flex: 1;
    }

    .file-name {
        font-weight: 600;
        color: #1f2937;
        margin-bottom: 4px;
    }

    .file-details {
        font-size: 11px;
        color: #6b7280;
    }

    .file-remove {
        background: #ef4444;
        color: white;
        border: none;
        border-radius: 4px;
        padding: 4px 8px;
        font-size: 10px;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .file-remove:hover {
        background: #dc2626;
    }

    /* Token Management */
    .token-info {
        background: #fef3c7;
        border: 1px solid #fcd34d;
        border-radius: 8px;
        padding: 12px;
        margin: 12px 0;
        font-size: 12px;
    }

    .token-bar {
        background: #f3f4f6;
        height: 6px;
        border-radius: 3px;
        margin: 8px 0;
        overflow: hidden;
    }

    .token-fill {
        height: 100%;
        transition: all 0.3s ease;
        border-radius: 3px;
    }

    .token-fill.safe { background: #10b981; }
    .token-fill.warning { background: #f59e0b; }
    .token-fill.danger { background: #ef4444; }

    /* ===================================================================
    PART 6: CENTER PANEL COMPONENTS
    ================================================================== */
    .center-content {
        padding: 20px;
    }

    /* Tabs */
    .tabs {
        display: flex;
        background: #f8fafc;
        border-radius: 8px;
        padding: 4px;
        margin-bottom: 20px;
        border: 1px solid #e2e8f0;
    }

    .tab {
        flex: 1;
        background: transparent;
        color: #6b7280;
        border: none;
        padding: 12px 16px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 13px;
        font-weight: 500;
        transition: all 0.2s ease;
    }

    .tab.active {
        background: #3b82f6;
        color: white;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .tab:hover:not(.active) {
        background: #e2e8f0;
        color: #374151;
    }

    .tab-content {
        display: none;
        background: white;
        border-radius: 12px;
        padding: 24px;
        border: 1px solid #e2e8f0;
        min-height: calc(100vh - 200px);
    }

    .tab-content.active {
        display: block;
    }

    /* Analysis Results */
    .analysis-header {
        margin-bottom: 24px;
        padding-bottom: 16px;
        border-bottom: 2px solid #e2e8f0;
    }

    .analysis-title {
        color: #1e40af;
        font-size: 1.5rem;
        margin-bottom: 8px;
        font-weight: 700;
    }

    .analysis-meta {
        color: #6b7280;
        font-size: 0.9rem;
    }

    .metrics-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 16px;
        margin-bottom: 24px;
    }

    .metric-card {
        background: #f8fafc;
        padding: 16px;
        border-radius: 8px;
        text-align: center;
        border: 1px solid #e2e8f0;
    }

    .metric-value {
        font-size: 1.5rem;
        font-weight: 700;
        color: #1e40af;
        margin-bottom: 4px;
    }

    .metric-label {
        font-size: 0.8rem;
        color: #6b7280;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    /* Results Cards */
    .result-card {
        background: #f9fafb;
        border: 1px solid #e5e7eb;
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 20px;
    }

    .result-card h4 {
        color: #1e40af;
        margin-bottom: 12px;
        font-size: 1.1rem;
        font-weight: 600;
    }

    /* Flow Diagram */
    .flow-diagram {
        background: white;
        border: 1px solid #e2e8f0;
        border-radius: 12px;
        padding: 20px;
        margin: 20px 0;
        overflow-x: auto;
    }

    .flow-container {
        min-width: 800px;
        position: relative;
    }

    .flow-stage {
        display: inline-block;
        background: #f8fafc;
        border: 2px solid #3b82f6;
        border-radius: 8px;
        padding: 12px 16px;
        margin: 0 20px;
        position: relative;
        min-width: 120px;
        text-align: center;
    }

    .flow-stage.creation { border-color: #10b981; background: #ecfdf5; }
    .flow-stage.processing { border-color: #f59e0b; background: #fffbeb; }
    .flow-stage.output { border-color: #ef4444; background: #fef2f2; }

    .flow-arrow {
        position: absolute;
        right: -30px;
        top: 50%;
        transform: translateY(-50%);
        width: 0;
        height: 0;
        border-left: 10px solid #6b7280;
        border-top: 6px solid transparent;
        border-bottom: 6px solid transparent;
    }

    .flow-programs {
        font-size: 10px;
        color: #6b7280;
        margin-top: 4px;
    }

    /* ===================================================================
    PART 7: RIGHT PANEL - CHAT
    ================================================================== */
    .chat-header {
        background: #3b82f6;
        color: white;
        padding: 16px;
        border-radius: 8px;
        margin-bottom: 16px;
        text-align: center;
    }

    .chat-header h3 {
        margin-bottom: 4px;
        font-size: 1.1rem;
    }

    .chat-header p {
        font-size: 0.8rem;
        opacity: 0.9;
    }

    .chat-suggestions {
        margin-bottom: 16px;
        padding: 12px;
        background: white;
        border-radius: 8px;
        border: 1px solid #e2e8f0;
    }

    .chat-suggestion-btn {
        background: #f3f4f6;
        border: 1px solid #d1d5db;
        color: #374151;
        padding: 6px 12px;
        border-radius: 16px;
        font-size: 11px;
        cursor: pointer;
        margin: 3px;
        transition: all 0.2s ease;
        display: inline-block;
    }

    .chat-suggestion-btn:hover {
        background: #3b82f6;
        color: white;
        border-color: #3b82f6;
    }

    .chat-messages {
        flex: 1;
        overflow-y: auto;
        padding: 16px;
        background: white;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        margin-bottom: 16px;
        max-height: calc(100vh - 400px);
    }

    .chat-message {
        margin-bottom: 16px;
        padding: 12px 16px;
        border-radius: 12px;
        max-width: 90%;
        word-wrap: break-word;
        line-height: 1.5;
    }

    .chat-message.user {
        background: #eff6ff;
        border: 1px solid #bfdbfe;
        margin-left: auto;
        text-align: right;
    }

    .chat-message.assistant {
        background: #f0fdf4;
        border: 1px solid #bbf7d0;
    }

    .chat-sender {
        font-weight: 600;
        font-size: 11px;
        margin-bottom: 6px;
        color: #374151;
    }

    .chat-content {
        font-size: 13px;
        line-height: 1.5;
    }

    .chat-timestamp {
        font-size: 10px;
        color: #9ca3af;
        margin-top: 6px;
    }

    .chat-input-section {
        display: flex;
        gap: 8px;
        padding: 12px;
        background: white;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
    }

    .chat-input {
        flex: 1;
        padding: 8px 12px;
        border: 1px solid #d1d5db;
        border-radius: 6px;
        resize: none;
        min-height: 36px;
        max-height: 100px;
        font-size: 13px;
    }

    .chat-send-btn {
        background: #3b82f6;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 13px;
        font-weight: 500;
        transition: all 0.2s ease;
    }

    .chat-send-btn:hover:not(:disabled) {
        background: #2563eb;
    }

    .chat-send-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    /* ===================================================================
    PART 8: LOADING AND NOTIFICATIONS  
    ================================================================== */
    .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.95);
        display: none;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        z-index: 1000;
    }

    .loading-overlay.show {
        display: flex;
    }

    .spinner {
        width: 50px;
        height: 50px;
        border: 4px solid #e5e7eb;
        border-top: 4px solid #3b82f6;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-bottom: 16px;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .loading-text {
        color: #1f2937;
        font-weight: 500;
        margin-bottom: 8px;
    }

    .loading-status {
        color: #6b7280;
        font-size: 0.9rem;
    }

    .progress-bar {
        width: 300px;
        height: 4px;
        background: #e5e7eb;
        border-radius: 2px;
        margin-top: 16px;
        overflow: hidden;
    }

    .progress-fill {
        height: 100%;
        background: #3b82f6;
        width: 0%;
        transition: width 0.3s ease;
    }

    /* Notifications */
    .notification {
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 12px 20px;
        border-radius: 8px;
        font-weight: 500;
        z-index: 2000;
        animation: slideIn 0.3s ease;
        max-width: 400px;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
    }

    .notification.success {
        background: #d1fae5;
        color: #065f46;
        border: 1px solid #a7f3d0;
    }

    .notification.error {
        background: #fee2e2;
        color: #991b1b;
        border: 1px solid #fca5a5;
    }

    .notification.warning {
        background: #fef3c7;
        color: #92400e;
        border: 1px solid #fcd34d;
    }

    @keyframes slideIn {
        from { 
            transform: translateX(100%); 
            opacity: 0;
        }
        to { 
            transform: translateX(0); 
            opacity: 1;
        }
    }

    /* ===================================================================
    PART 9: RESPONSIVE DESIGN
    ================================================================== */
    @media (max-width: 1200px) {
        .left-panel {
            width: 320px;
        }
        
        .left-panel-content {
            min-width: 320px;
        }
        
        .right-panel {
            width: 300px;
        }
        
        .right-panel-content {
            min-width: 300px;
        }
    }

    @media (max-width: 768px) {
        .main-container {
            flex-direction: column;
            height: auto;
        }
        
        .left-panel,
        .right-panel {
            width: 100%;
            max-height: 400px;
        }
        
        .left-panel.collapsed,
        .right-panel.collapsed {
            width: 100%;
            max-height: 0;
            padding: 0;
        }
        
        .center-panel {
            min-height: 600px;
        }
        
        .panel-toggle {
            position: static;
            width: 100%;
            height: 40px;
            border-radius: 0;
        }
    }
        @media (max-width: 768px) {
    .panel-toggle {
        position: static;
        width: 100%;
        height: 40px;
        border-radius: 0;
        margin-bottom: 10px;
    }
    
    .restore-btn {
        position: fixed;
        top: 120px;
        width: 45px;
        height: 45px;
    }
    
    .left-restore {
        left: 10px;
    }
    
    .right-restore {
        right: 10px;
    }
}
    

    /* ===================================================================
    PART 10: UTILITIES
    ================================================================== */
    .hidden { display: none !important; }
    .text-center { text-align: center; }
    .text-primary { color: #3b82f6; }
    .text-success { color: #10b981; }
    .text-danger { color: #ef4444; }
    .text-muted { color: #6b7280; }
    .font-mono { font-family: 'Monaco', 'Menlo', monospace; }
    .font-bold { font-weight: 700; }
    .mb-4 { margin-bottom: 1rem; }
    .mt-4 { margin-top: 1rem; }
    .p-4 { padding: 1rem; }

    /* Scrollbar Styling */
    ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
    }

    ::-webkit-scrollbar-track {
        background: #f1f5f9;
    }

    ::-webkit-scrollbar-thumb {
        background: #cbd5e1;
        border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
        background: #94a3b8;
    }
</style>
</head>
<body>
    <!-- Header -->
    <!-- Header -->
<div class="header">
    <h1>🔬 Enhanced Mainframe Analyzer</h1>
    <p>Advanced mainframe analysis with LLM-powered field flow tracking and lifecycle mapping</p>
</div>

<!-- Restore Buttons -->
<button class="restore-btn left-restore" id="leftRestore" title="Restore Left Panel">
    <span>📁</span>
</button>
<button class="restore-btn right-restore" id="rightRestore" title="Restore Chat Panel">
    <span>💬</span>
</button>
    <!-- Main Container -->
<!-- Main Container -->
<div class="main-container">
    <!-- Left Panel - Controls -->
    <div class="left-panel" id="leftPanel">
    <button class="panel-toggle left-toggle" id="leftToggle" title="Collapse Left Panel">
        ←
    </button>

    
    <div class="left-panel-content">
            <!-- Component Analysis Section -->
            <div class="section">
                <h2 class="section-title">
                    <span class="icon">🎯</span>
                    Component Analysis
                </h2>
                
                <div class="form-group">
                    <label for="friendlyName">Friendly Name (Display Name):</label>
                    <input type="text" id="friendlyName" class="form-input" 
                           placeholder="e.g., Customer Master Record, Payment Processing">
                </div>
                
                <div class="form-group" style="position: relative;">
                    <label for="componentName">Component Name:</label>
                    <input type="text" id="componentName" class="form-input" 
                           placeholder="e.g., CUSTOMER-RECORD, ACCOUNT-COPY, PAYROLL-PROC">
                           <div id="componentSuggestions" class="component-suggestions"></div>
                    </div>
                    <!-- Token Usage Display -->
                <div id="tokenInfo" class="token-info" style="display: none;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                        <span style="font-weight: 600;">Token Management</span>
                        <span id="tokenCount">0 / 4000</span>
                    </div>
                    <div class="token-bar">
                        <div id="tokenFill" class="token-fill safe" style="width: 0%"></div>
                    </div>
                    <div id="tokenWarning" style="font-size: 11px; margin-top: 4px;"></div>
                </div>
                
                <button class="btn btn-primary" id="analyzeComponentBtn" disabled>
                    <span>🔍</span> Analyze Component
                </button>
            </div>

            <!-- vLLM API Setup -->
            <div class="section">
                <h2 class="section-title">
                    <span class="icon">🚀</span>
                    vLLM Server Setup
                </h2>
                
                <div class="form-group">
                    <label for="vllmEndpoint">Server Endpoint:</label>
                    <input type="text" id="vllmEndpoint" class="form-input" 
                           placeholder="http://localhost:8000" value="http://localhost:8000">
                </div>
                
                <div class="form-group">
                    <label for="maxTokens">Max Tokens:</label>
                    <input type="number" id="maxTokens" class="form-input" 
                           value="4000" min="1000" max="8000">
                </div>
                
                <button class="btn btn-success" id="validateApiBtn">
                    <span>🔐</span> Test Connection
                </button>
                
                <div class="status-indicator status-disconnected" id="apiStatus">
                    <span>🔴</span> Enter server details and test connection
                </div>
            </div>

            <!-- File Upload Section -->
            <div class="section">
                <h2 class="section-title">
                    <span class="icon">📁</span>
                    Upload Files
                </h2>
                
                <div class="upload-area" id="uploadArea">
                    <div>
                        <h3 style="margin-bottom: 8px; color: #374151;">📤 Drop files here</h3>
                        <p style="font-size: 14px; color: #6b7280;">COBOL (.cbl), Copybooks (.cpy), JCL (.jcl)</p>
                    </div>
                    <input type="file" id="fileInput" multiple accept=".cbl,.cob,.cpy,.copybook,.jcl,.txt,.proc" style="display: none;">
                </div>
                <div id="uploadedFiles" class="file-list"></div>
            </div>

            <!-- Quick Actions -->
            <div class="section">
                <h2 class="section-title">
                    <span class="icon">⚡</span>
                    Actions
                </h2>
                
                <button class="btn btn-secondary" id="bulkAnalyzeBtn" disabled style="margin-bottom: 12px;">
                    <span>📊</span> Bulk Analyze
                </button>
                
                <!-- Export Section -->
                <div class="export-section">
                    <h4>📤 Export Options</h4>
                    <div class="export-btn-group">
                        <button class="export-btn" id="exportJsonBtn" disabled>
                            <span>📋</span> JSON
                        </button>
                        <button class="export-btn" id="exportMdBtn" disabled>
                            <span>📝</span> Markdown
                        </button>
                    </div>
                </div>
                
                <button class="btn btn-danger" id="clearBtn" style="margin-top: 12px;">
                    <span>🗑️</span> Clear All Data
                </button>
            </div>
        </div>
    </div>

    <!-- Center Panel - Analysis Workspace -->
    <div class="center-panel">
        <div class="center-content">
            <div class="tabs">
                <button class="tab active" data-tab="lifecycle">
                    <span>🔄</span> Analysis Results
                </button>
                <button class="tab" data-tab="fieldmatrix">
                    <span>📋</span> Field Matrix
                </button>
                <button class="tab" data-tab="usage">
                    <span>📈</span> Usage Patterns
                </button>
                <button class="tab" data-tab="dependencies">
                    <span>🔗</span> Dependencies
                </button>
                <button class="tab" data-tab="fileflow">
                    <span>🌊</span> File Lifecycle
                </button>
            </div>

            <!-- Tab Contents -->
            <div id="lifecycle" class="tab-content active">
                <div id="lifecycleContent">
                    <div class="analysis-header">
                        <h3 class="analysis-title">🎯 LLM-Powered Component Analysis</h3>
                        <p class="analysis-meta">
                            Upload files, test your connection, and analyze components for detailed LLM-powered field flows and business rules.
                        </p>
                    </div>
                    
                    <div class="result-card">
                        <h4>🤖 LLM-Enhanced Features:</h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 16px; margin-top: 16px;">
                            <div>
                                <strong style="color: #10b981;">🧠 LLM Field Analysis:</strong>
                                <ul style="list-style: none; margin-left: 10px; line-height: 1.8; margin-top: 8px;">
                                    <li>• Smart field lifecycle tracking</li>
                                    <li>• Context-aware usage patterns</li>
                                    <li>• Intelligent field categorization</li>
                                    <li>• Cross-program flow analysis</li>
                                </ul>
                            </div>
                            <div>
                                <strong style="color: #3b82f6;">⚖️ Smart Business Rules:</strong>
                                <ul style="list-style: none; margin-left: 10px; line-height: 1.8; margin-top: 8px;">
                                    <li>• LLM-extracted validation logic</li>
                                    <li>• Context-aware decision mapping</li>
                                    <li>• Business calculation analysis</li>
                                    <li>• Rule complexity assessment</li>
                                </ul>
                            </div>
                            <div>
                                <strong style="color: #f59e0b;">🔗 Smart Dependencies:</strong>
                                <ul style="list-style: none; margin-left: 10px; line-height: 1.8; margin-top: 8px;">
                                    <li>• Regex + LLM validation</li>
                                    <li>• Smart call chain analysis</li>
                                    <li>• Contextual file references</li>
                                    <li>• Impact assessment</li>
                                </ul>
                            </div>
                            <div>
                                <strong style="color: #8b5cf6;">🌊 File Lifecycle:</strong>
                                <ul style="list-style: none; margin-left: 10px; line-height: 1.8; margin-top: 8px;">
                                    <li>• Creation to purge tracking</li>
                                    <li>• Program usage mapping</li>
                                    <li>• Field update patterns</li>
                                    <li>• CICS screen integration</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="fieldmatrix" class="tab-content">
                <div id="fieldMatrixContent">
                    <div class="analysis-header">
                        <h3 class="analysis-title">📋 LLM Field Matrix Analysis</h3>
                        <p class="analysis-meta">Enhanced field-level analysis with LLM-powered categorization will appear here after component analysis.</p>
                    </div>
                    <div class="result-card text-center">
                        <p style="opacity: 0.8;">LLM-enhanced field matrix will appear here after analysis.</p>
                    </div>
                </div>
            </div>

            <div id="usage" class="tab-content">
                <div id="usageContent">
                    <div class="analysis-header">
                        <h3 class="analysis-title">📈 Smart Usage Patterns</h3>
                        <p class="analysis-meta">LLM-powered usage pattern analysis with field lifecycle flows will appear here after component analysis.</p>
                    </div>
                    <div class="result-card text-center">
                        <p style="opacity: 0.8;">Smart usage patterns will appear here after analysis.</p>
                    </div>
                </div>
            </div>

            <div id="dependencies" class="tab-content">
                <div id="dependenciesContent">
                    <div class="analysis-header">
                        <h3 class="analysis-title">🔗 Hybrid Dependency Analysis</h3>
                        <p class="analysis-meta">Regex + LLM dependency mapping will appear here after component analysis.</p>
                    </div>
                    <div class="result-card text-center">
                        <p style="opacity: 0.8;">Hybrid dependency graph will appear here after analysis.</p>
                    </div>
                </div>
            </div>

            <div id="fileflow" class="tab-content">
                <div id="fileflowContent">
                    <div class="analysis-header">
                        <h3 class="analysis-title">🌊 File Lifecycle Flow Analysis</h3>
                        <p class="analysis-meta">Complete file lifecycle from creation through purge, including program usage patterns and field update tracking.</p>
                    </div>
                    
                    <!-- Flow Diagram Placeholder -->
                    <div class="flow-diagram">
                        <h4 style="color: #1e40af; margin-bottom: 16px; text-center;">📊 Dynamic Lifecycle Flow</h4>
                        <div class="flow-container" id="flowContainer">
                            <div class="flow-stage creation">
                                <div class="flow-stage-title">🌱 Creation</div>
                                <div class="flow-count" id="creationCount">0</div>
                                <div class="flow-programs" id="creationPrograms">Programs</div>
                                <div class="flow-arrow"></div>
                            </div>
                            
                            <div class="flow-stage processing">
                                <div class="flow-stage-title">⚙️ Processing</div>
                                <div class="flow-count" id="processingCount">0</div>
                                <div class="flow-programs" id="processingPrograms">Programs</div>
                                <div class="flow-arrow"></div>
                            </div>
                            
                            <div class="flow-stage output">
                                <div class="flow-stage-title">📤 Output</div>
                                <div class="flow-count" id="outputCount">0</div>
                                <div class="flow-programs" id="outputPrograms">Programs</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="result-card text-center">
                        <p style="opacity: 0.8;">Detailed file lifecycle flow analysis will appear here after component analysis.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Right Panel - Chat -->
    <div class="right-panel" id="rightPanel">
    <button class="panel-toggle right-toggle" id="rightToggle" title="Collapse Chat Panel">
        →
    </button>
    
    <div class="right-panel-content">
            <div class="chat-header">
                <h3>💬 LLM Analysis Chat</h3>
                <p>Enhanced interactive chat with rich formatting and export</p>
            </div>
            
            <!-- Chat Suggestions -->
            <div class="chat-suggestions" id="chatSuggestions">
                <h4>💡 Suggested Questions:</h4>
                <button class="chat-suggestion-btn" data-question="Explain the file lifecycle flow for this component">📊 File Lifecycle</button>
                <button class="chat-suggestion-btn" data-question="What fields are updated by which programs?">🔄 Field Updates</button>
                <button class="chat-suggestion-btn" data-question="Show me the creation and purge process">🌊 Creation/Purge</button>
                <button class="chat-suggestion-btn" data-question="Which programs only read vs modify data?">📖 Read/Write Patterns</button>
            </div>
            
            <!-- Chat Messages Area -->
            <div class="chat-messages" id="chatMessages">
                <div class="chat-message assistant">
                    <div class="chat-sender">LLM Analysis Assistant</div>
                    <div class="chat-content">
                        👋 <strong>Welcome to LLM-Enhanced Mainframe Analysis!</strong>
                        <br><br>
                        I can provide detailed analysis using advanced language models including:
                        <br><br>
                        🧠 <strong>Smart Field Analysis:</strong> Context-aware field lifecycle tracking
                        <br>⚖️ <strong>Business Logic Extraction:</strong> Intelligent rule and validation discovery  
                        <br>🔗 <strong>Dependency Mapping:</strong> Comprehensive relationship analysis
                        <br>🌊 <strong>File Lifecycle Flow:</strong> Creation to purge tracking with program mapping
                        <br>💡 <strong>Modernization Guidance:</strong> AI-powered optimization recommendations
                        <br><br>
                        <em>Upload files and analyze a component to unlock the full power of LLM analysis!</em>
                    </div>
                    <div class="chat-timestamp">${new Date().toLocaleTimeString()}</div>
                </div>
            </div>
            
            <!-- Chat Input -->
            <div class="chat-input-section">
                <textarea class="chat-input" id="chatInput" placeholder="Ask about field flows, program dependencies, lifecycle patterns..." disabled rows="2"></textarea>
                <button class="chat-send-btn" id="chatSendBtn" disabled>Send</button>
            </div>
        </div>
    </div>
</div>

<!-- Loading Overlay -->
<div class="loading-overlay" id="loadingIndicator">
    <div class="spinner"></div>
    <div class="loading-text">🤖 LLM Analyzing Component</div>
    <div class="loading-status" id="loadingStatus">Processing component analysis with LLM...</div>
    <div class="progress-bar">
        <div class="progress-fill" id="progressFill" style="width: 0%;"></div>
    </div>
</div>

<script>
    /* ===================================================================
    ENHANCED MAINFRAME ANALYZER - REDESIGNED JAVASCRIPT
    All original functionality preserved with new UI interactions
    ================================================================== */

    class EnhancedMainframeAnalyzer {
        constructor() {
            // Core properties - preserved from original
            this.uploadedFiles = [];
            this.analysisResults = {};
            this.componentSuggestions = [];
            this.serverValidated = false;
            this.vllmEndpoint = 'http://localhost:8000';
            this.maxTokens = 4000;
            this.storageKey = 'enhanced_mainframe_analysis';
            this.currentAnalyzedComponent = null;
            this.chatHistory = [];
            
            // Token management
            this.averageCharsPerToken = 3;
            this.tokenSafetyMargin = 0.7;
            
            // LLM Analysis configuration
            this.llmConfig = {
                temperature: 0.1,
                maxRetries: 2,
                chunkSize: 2000,
                analysisTimeout: 90000
            };
            
            // File lifecycle patterns
            this.lifecyclePatterns = {
                creation: ['CREATE', 'WRITE', 'OUTPUT', 'OPEN OUTPUT', 'FD ', 'FILE-CONTROL'],
                reading: ['READ', 'INPUT', 'OPEN INPUT', 'SELECT'],
                updating: ['WRITE', 'REWRITE', 'UPDATE', 'MODIFY', 'OPEN I-O'],
                deletion: ['DELETE', 'PURGE', 'REMOVE'],
                cicsOperations: ['EXEC CICS', 'SEND MAP', 'RECEIVE MAP', 'READ TD', 'WRITE TD'],
                batchOperations: ['SORT', 'MERGE', 'COPY', '//EXEC PGM=']
            };
            
            // Initialize all components
            this.initializeUI();
            this.initializeEventListeners();
            this.loadStoredData();
            this.initializeTokenManagement();
            this.initializeChat();
            
            console.log('🚀 Enhanced Mainframe Analyzer with Redesigned UI Initialized');
        }

        /* ===================================================================
        UI INITIALIZATION AND PANEL MANAGEMENT
        ================================================================== */
        initializeUI() {
            // Initialize panel toggles
            this.initializePanelToggles();
            
            // Initialize tabs
            this.initializeTabs();
            
            // Set initial friendly name timestamp
            const friendlyInput = document.getElementById('friendlyName');
            if (friendlyInput && !friendlyInput.value) {
                friendlyInput.placeholder = `Analysis Session ${new Date().toLocaleDateString()}`;
            }
        }

initializePanelToggles() {
    const leftToggle = document.getElementById('leftToggle');
    const rightToggle = document.getElementById('rightToggle');
    const leftPanel = document.getElementById('leftPanel');
    const rightPanel = document.getElementById('rightPanel');
    const leftRestore = document.getElementById('leftRestore');
    const rightRestore = document.getElementById('rightRestore');

    console.log('Initializing panel toggles...', { leftToggle, rightToggle, leftPanel, rightPanel });

    // Left panel toggle
    if (leftToggle && leftPanel && leftRestore) {
        leftToggle.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('Left toggle clicked');
            
            leftPanel.classList.add('collapsed');
            leftRestore.classList.add('show');
            leftToggle.style.display = 'none';
        });

        // Left restore button
        leftRestore.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('Left restore clicked');
            
            leftPanel.classList.remove('collapsed');
            leftRestore.classList.remove('show');
            leftToggle.style.display = 'flex';
        });
    }

    // Right panel toggle  
    if (rightToggle && rightPanel && rightRestore) {
        rightToggle.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('Right toggle clicked');
            
            rightPanel.classList.add('collapsed');
            rightRestore.classList.add('show');
            rightToggle.style.display = 'none';
        });

        // Right restore button
        rightRestore.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('Right restore clicked');
            
            rightPanel.classList.remove('collapsed');
            rightRestore.classList.remove('show');
            rightToggle.style.display = 'flex';
        });
    }
}

        updateToggleIcon(toggle, isCollapsed) {
            const icon = toggle.querySelector('.toggle-icon');
            if (icon) {
                if (toggle.classList.contains('left-toggle')) {
                    icon.textContent = isCollapsed ? '▶' : '◀';
                } else {
                    icon.textContent = isCollapsed ? '◀' : '▶';
                }
            }
        }

        initializeTabs() {
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', (e) => this.switchTab(e));
            });
        }

        switchTab(e) {
            const targetTab = e.target?.dataset?.tab || e.currentTarget?.dataset?.tab;
            if (!targetTab) return;
            
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            e.target.classList.add('active') || e.currentTarget.classList.add('active');
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            const targetContent = document.getElementById(targetTab);
            if (targetContent) {
                targetContent.classList.add('active');
            }
        }

        /* ===================================================================
        EVENT LISTENERS - PRESERVED FROM ORIGINAL
        ================================================================== */
        initializeEventListeners() {
            // API validation
            document.getElementById('validateApiBtn')?.addEventListener('click', () => this.validateConnection());
            document.getElementById('vllmEndpoint')?.addEventListener('input', () => this.onEndpointChange());
            document.getElementById('maxTokens')?.addEventListener('input', () => this.onSettingsChange());
            
            // File upload handlers
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');
            
            uploadArea?.addEventListener('click', () => {
                if (this.serverValidated) fileInput.click();
            });
            uploadArea?.addEventListener('drop', (e) => this.handleFileDrop(e));
            uploadArea?.addEventListener('dragover', (e) => this.handleDragOver(e));
            uploadArea?.addEventListener('dragleave', (e) => this.handleDragLeave(e));
            fileInput?.addEventListener('change', (e) => this.handleFileSelect(e));

            // Component analysis
            document.getElementById('componentName')?.addEventListener('input', () => this.onComponentInput());
            document.getElementById('analyzeComponentBtn')?.addEventListener('click', () => this.analyzeComponent());
            
            // Quick actions
            document.getElementById('bulkAnalyzeBtn')?.addEventListener('click', () => this.bulkAnalyze());
            document.getElementById('exportJsonBtn')?.addEventListener('click', () => this.exportResults('json'));
            document.getElementById('exportMdBtn')?.addEventListener('click', () => this.exportResults('markdown'));
            document.getElementById('clearBtn')?.addEventListener('click', () => this.clearAllData());

            // Hide suggestions when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.section')) {
                    const suggestions = document.getElementById('componentSuggestions');
                    if (suggestions) suggestions.style.display = 'none';
                }
            });
        }

        /* ===================================================================
        STORAGE MANAGEMENT - ENHANCED FOR BETTER PERSISTENCE
        ================================================================== */
        saveToStorage() {
            try {
                const data = {
                    uploadedFiles: this.uploadedFiles,
                    analysisResults: this.analysisResults,
                    chatHistory: this.chatHistory,
                    vllmEndpoint: this.vllmEndpoint,
                    maxTokens: this.maxTokens,
                    timestamp: new Date().toISOString(),
                    version: '2.0.0-redesigned'
                };

                // Try localStorage first
                try {
                    localStorage.setItem(this.storageKey, JSON.stringify(data));
                    console.log('💾 Data saved to localStorage');
                } catch (localStorageError) {
                    console.warn('localStorage failed, trying sessionStorage:', localStorageError);
                    // Fallback to sessionStorage
                    try {
                        sessionStorage.setItem(this.storageKey, JSON.stringify(data));
                        console.log('💾 Data saved to sessionStorage');
                    } catch (sessionStorageError) {
                        console.warn('All storage methods failed:', sessionStorageError);
                        // Could implement IndexedDB fallback here
                        this.showWarning('Storage unavailable - data will be lost on page refresh');
                    }
                }
            } catch (error) {
                console.error('Failed to save data:', error);
                this.showWarning('Failed to save data - progress may be lost');
            }
        }

        loadStoredData() {
            try {
                let stored = null;
                
                // Try localStorage first
                try {
                    stored = localStorage.getItem(this.storageKey);
                } catch (e) {
                    console.warn('localStorage access failed, trying sessionStorage');
                }
                
                // Fallback to sessionStorage
                if (!stored) {
                    try {
                        stored = sessionStorage.getItem(this.storageKey);
                    } catch (e) {
                        console.warn('sessionStorage access failed');
                    }
                }
                
                if (stored) {
                    const data = JSON.parse(stored);
                    this.uploadedFiles = data.uploadedFiles || [];
                    this.analysisResults = data.analysisResults || {};
                    this.chatHistory = data.chatHistory || [];
                    
                    // Restore UI state
                    const endpointInput = document.getElementById('vllmEndpoint');
                    const maxTokensInput = document.getElementById('maxTokens');
                    
                    if (data.vllmEndpoint && endpointInput) {
                        endpointInput.value = data.vllmEndpoint;
                        this.vllmEndpoint = data.vllmEndpoint;
                    }
                    
                    if (data.maxTokens && maxTokensInput) {
                        maxTokensInput.value = data.maxTokens;
                        this.maxTokens = data.maxTokens;
                    }
                    
                    this.displayUploadedFiles();
                    this.updateComponentSuggestions();
                    this.validateForm();
                    
                    console.log('📁 Stored analysis data loaded successfully');
                    this.showSuccess('Previous session data restored');
                }
            } catch (error) {
                console.warn('Failed to load stored data:', error);
            }
        }

        /* ===================================================================
        TOKEN MANAGEMENT
        ================================================================== */
        initializeTokenManagement() {
            this.updateTokenDisplay(0);
            this.showSuccess('🚀 Enhanced Mainframe Analyzer Ready with New UI!');
        }

        estimateTokenCount(text) {
            if (!text) return 0;
            return Math.ceil(text.length / this.averageCharsPerToken);
        }

        updateTokenDisplay(currentTokens) {
            const tokenInfo = document.getElementById('tokenInfo');
            const tokenCount = document.getElementById('tokenCount');
            const tokenFill = document.getElementById('tokenFill');
            const tokenWarning = document.getElementById('tokenWarning');

            if (!tokenInfo) return;

            tokenInfo.style.display = 'block';
            tokenCount.textContent = `${currentTokens} / ${this.maxTokens}`;
            
            const percentage = (currentTokens / this.maxTokens) * 100;
            tokenFill.style.width = `${Math.min(percentage, 100)}%`;
            
            tokenFill.className = 'token-fill';
            if (percentage <= 50) {
                tokenFill.classList.add('safe');
                tokenWarning.textContent = '🟢 Optimal token usage - full analysis available';
            } else if (percentage <= 70) {
                tokenFill.classList.add('warning');
                tokenWarning.textContent = '🟡 Moderate usage - focused analysis active';
            } else {
                tokenFill.classList.add('danger');
                tokenWarning.textContent = '🔴 High usage - scope optimization required';
            }
        }

        /* ===================================================================
        NOTIFICATION SYSTEM - ENHANCED FOR NEW UI
        ================================================================== */
        showNotification(type, message, duration = 3000) {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, duration);
        }
        
        showError(message) { this.showNotification('error', message, 5000); }
        showSuccess(message) { this.showNotification('success', message, 3000); }
        showWarning(message) { this.showNotification('warning', message, 4000); }

        /* ===================================================================
        LOADING MANAGEMENT
        ================================================================== */
        showLoading() { 
            const loading = document.getElementById('loadingIndicator');
            if (loading) loading.classList.add('show'); 
        }
        
        hideLoading() { 
            const loading = document.getElementById('loadingIndicator');
            if (loading) loading.classList.remove('show'); 
        }
        
        updateLoadingStatus(status) { 
            const statusElement = document.getElementById('loadingStatus');
            if (statusElement) statusElement.textContent = status; 
        }

        updateProgress(percentage) {
            const progressFill = document.getElementById('progressFill');
            if (progressFill) {
                progressFill.style.width = `${percentage}%`;
            }
        }

        /* ===================================================================
        FLOW DIAGRAM UPDATES
        ================================================================== */
        updateFlowDiagram(lifecycleFlow) {
            if (!lifecycleFlow) return;

            const creationCount = document.getElementById('creationCount');
            const processingCount = document.getElementById('processingCount');
            const outputCount = document.getElementById('outputCount');
            
            const creationPrograms = document.getElementById('creationPrograms');
            const processingPrograms = document.getElementById('processingPrograms');
            const outputPrograms = document.getElementById('outputPrograms');

            if (creationCount) {
                const count = (lifecycleFlow.creationSources || []).length;
                creationCount.textContent = count;
                if (creationPrograms) {
                    const programs = (lifecycleFlow.creationSources || []).slice(0, 2).map(s => s.program).join(', ');
                    creationPrograms.textContent = programs || 'No programs';
                }
            }

            if (processingCount) {
                const count = (lifecycleFlow.inputPrograms || []).length + (lifecycleFlow.updatePrograms || []).length;
                processingCount.textContent = count;
                if (processingPrograms) {
                    const inputProgs = (lifecycleFlow.inputPrograms || []).slice(0, 1).map(p => p.program);
                    const updateProgs = (lifecycleFlow.updatePrograms || []).slice(0, 1).map(u => u.program);
                    const programs = [...inputProgs, ...updateProgs].join(', ');
                    processingPrograms.textContent = programs || 'No programs';
                }
            }

            if (outputCount) {
                const count = (lifecycleFlow.cicsScreens || []).length + (lifecycleFlow.batchJobs || []).length;
                outputCount.textContent = count;
                if (outputPrograms) {
                    const cicsProgs = (lifecycleFlow.cicsScreens || []).slice(0, 1).map(c => c.program);
                    const batchProgs = (lifecycleFlow.batchJobs || []).slice(0, 1).map(b => b.program);
                    const programs = [...cicsProgs, ...batchProgs].join(', ');
                    outputPrograms.textContent = programs || 'No programs';
                }
            }
        }

        /* ===================================================================
        PRESERVED CORE FUNCTIONALITY - FILE UPLOAD
        ================================================================== */
        handleFileDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const uploadArea = document.getElementById('uploadArea');
                  uploadArea.classList.remove('drag-over');   
                  if (!this.serverValidated) {
                this.showError('Please validate LLM API connection first');
                return;
            }
            
            const files = Array.from(e.dataTransfer.files);
            this.processFiles(files);
        }

        handleDragOver(e) {
            e.preventDefault();
            e.stopPropagation();
            const uploadArea = document.getElementById('uploadArea');
            if (uploadArea) uploadArea.classList.add('drag-over');
        }

        handleDragLeave(e) {
            e.preventDefault();
            e.stopPropagation();
            const uploadArea = document.getElementById('uploadArea');
            if (uploadArea) uploadArea.classList.remove('drag-over');
        }

        handleFileSelect(e) {
            if (!this.serverValidated) {
                this.showError('Please validate LLM API connection first');
                return;
            }
            
            const files = Array.from(e.target.files);
            this.processFiles(files);
        }

        async processFiles(files) {
            for (const file of files) {
                try {
                    const content = await this.readFile(file);
                    const fileType = this.detectFileType(file.name, content);
                    
                    const fileObj = {
                        name: file.name,
                        content: content,
                        size: file.size,
                        type: fileType,
                        uploadDate: new Date().toISOString(),
                        id: Date.now() + Math.random(),
                        components: this.extractComponentsFromFile(content, fileType)
                    };
                    
                    this.uploadedFiles.push(fileObj);
                    this.updateComponentSuggestions();
                    
                } catch (error) {
                    this.showError(`Failed to read ${file.name}: ${error.message}`);
                }
            }
            
            this.displayUploadedFiles();
            this.validateForm();
            this.saveToStorage();
            this.showSuccess(`📁 ${files.length} files uploaded successfully!`);
        }

        readFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.onerror = e => reject(new Error('File read failed'));
                reader.readAsText(file);
            });
        }

        detectFileType(fileName, content) {
            const name = fileName.toLowerCase();
            const upperContent = content.toUpperCase();
            
            if (name.includes('.cpy') || name.includes('copybook')) {
                return 'Copybook';
            } else if (name.includes('.jcl') || upperContent.includes('//JOB ')) {
                return 'JCL Job';
            } else if (name.includes('.cbl') || name.includes('.cob') || 
                      upperContent.includes('IDENTIFICATION DIVISION') ||
                      upperContent.includes('PROGRAM-ID')) {
                return 'COBOL Program';
            } else if (name.includes('.proc')) {
                return 'JCL Procedure';
            } else {
                return 'Text File';
            }
        }
        extractDependenciesFromFile(file) {
    const dependencies = {
        copyStatements: [],
        callStatements: [],
        execStatements: [],
        jclDatasets: [],
        programIds: [],
        sqlTables: [],
        fileReferences: []
    };

    const lines = file.content.split('\n');
    const fileName = file.name.toUpperCase();
    
    lines.forEach((line, lineNum) => {
        const trimmed = line.trim().toUpperCase();
        
        // Enhanced COPY statements - handles both .cpy and without extension
        const copyPatterns = [
            /COPY\s+(['"]*[A-Z][A-Z0-9\-_]{1,}['"]*)/,           // COPY COPYBOOK-NAME
            /COPY\s+(['"]*[A-Z][A-Z0-9\-_]{1,}\.CPY['"]*)/,      // COPY COPYBOOK-NAME.CPY  
            /COPY\s+(['"]*[A-Z][A-Z0-9\-_]{1,}\.COPYBOOK['"]*)/,  // COPY COPYBOOK-NAME.COPYBOOK
            /INCLUDE\s+(['"]*[A-Z][A-Z0-9\-_]{1,}['"]*)/,        // INCLUDE COPYBOOK-NAME
            /-INC\s+([A-Z][A-Z0-9\-_]{1,})/                      // -INC COPYBOOK-NAME (JCL style)
        ];
        
        copyPatterns.forEach(pattern => {
            const copyMatch = trimmed.match(pattern);
            if (copyMatch) {
                let copyName = copyMatch[1].replace(/['"]/g, '');
                
                // Normalize copybook names - remove extensions for comparison
                const baseName = copyName.replace(/\.(CPY|COPYBOOK)$/i, '');
                
                // Store both with and without extension for flexible matching
                if (!dependencies.copyStatements.includes(baseName)) {
                    dependencies.copyStatements.push(baseName);
                }
                if (copyName !== baseName && !dependencies.copyStatements.includes(copyName)) {
                    dependencies.copyStatements.push(copyName);
                }
                
                console.log(`Found COPY statement: ${copyName} (normalized: ${baseName}) at line ${lineNum + 1}`);
            }
        });

        // Enhanced CALL statements
        const callPatterns = [
            /CALL\s+['"]*([A-Z][A-Z0-9\-_]{1,})['"]*/,           // CALL 'PROGRAM-NAME'
            /LINK\s+['"]*([A-Z][A-Z0-9\-_]{1,})['"]*/,           // LINK PROGRAM-NAME
            /XCTL\s+['"]*([A-Z][A-Z0-9\-_]{1,})['"]*/,           // XCTL PROGRAM-NAME
            /EXEC\s+CICS\s+LINK\s+PROGRAM\(['"]*([A-Z][A-Z0-9\-_]{1,})['"]*\)/, // EXEC CICS LINK
            /EXEC\s+CICS\s+XCTL\s+PROGRAM\(['"]*([A-Z][A-Z0-9\-_]{1,})['"]*\)/, // EXEC CICS XCTL
        ];
        
        callPatterns.forEach(pattern => {
            const callMatch = trimmed.match(pattern);
            if (callMatch && !dependencies.callStatements.includes(callMatch[1])) {
                dependencies.callStatements.push(callMatch[1]);
                console.log(`Found CALL statement: ${callMatch[1]} at line ${lineNum + 1}`);
            }
        });

        // Enhanced JCL EXEC statements
        const execPatterns = [
            /\/\/\w+\s+EXEC\s+PGM=([A-Z][A-Z0-9\-_]{1,})/,      // //STEP EXEC PGM=PROGRAM
            /\/\/\w+\s+EXEC\s+([A-Z][A-Z0-9\-_]{1,})/,          // //STEP EXEC PROGRAM
            /EXEC\s+PGM=([A-Z][A-Z0-9\-_]{1,})/,                // EXEC PGM=PROGRAM
            /EXEC\s+PROC=([A-Z][A-Z0-9\-_]{1,})/                // EXEC PROC=PROCEDURE
        ];
        
        execPatterns.forEach(pattern => {
            const execMatch = trimmed.match(pattern);
            if (execMatch && !dependencies.execStatements.includes(execMatch[1])) {
                dependencies.execStatements.push(execMatch[1]);
                console.log(`Found EXEC statement: ${execMatch[1]} at line ${lineNum + 1}`);
            }
        });

        // PROGRAM-ID extraction
        const programMatch = trimmed.match(/PROGRAM-ID\.?\s+([A-Z][A-Z0-9\-_]{1,})/);
        if (programMatch && !dependencies.programIds.includes(programMatch[1])) {
            dependencies.programIds.push(programMatch[1]);
            console.log(`Found PROGRAM-ID: ${programMatch[1]} at line ${lineNum + 1}`);
        }

        // Enhanced file references
        const filePatterns = [
            /FD\s+([A-Z][A-Z0-9\-_]{1,})/,                      // FD FILE-NAME
            /SELECT\s+([A-Z][A-Z0-9\-_]{1,})\s+ASSIGN/,         // SELECT FILE-NAME ASSIGN
            /OPEN\s+(?:INPUT|OUTPUT|I-O)\s+([A-Z][A-Z0-9\-_]{1,})/, // OPEN INPUT FILE-NAME
            /READ\s+([A-Z][A-Z0-9\-_]{1,})/,                    // READ FILE-NAME
            /WRITE\s+([A-Z][A-Z0-9\-_]{1,})/,                   // WRITE FILE-NAME
            /\/\/([A-Z][A-Z0-9\-_]{1,})\s+DD\s+/                // //FILENAME DD
        ];
        
        filePatterns.forEach(pattern => {
            const fileMatch = trimmed.match(pattern);
            if (fileMatch && !dependencies.fileReferences.includes(fileMatch[1])) {
                dependencies.fileReferences.push(fileMatch[1]);
                console.log(`Found file reference: ${fileMatch[1]} at line ${lineNum + 1}`);
            }
        });

        // SQL table references (if applicable)
        const sqlPatterns = [
            /FROM\s+([A-Z][A-Z0-9\-_\.]{1,})/,                  // FROM TABLE-NAME
            /INSERT\s+INTO\s+([A-Z][A-Z0-9\-_\.]{1,})/,         // INSERT INTO TABLE-NAME
            /UPDATE\s+([A-Z][A-Z0-9\-_\.]{1,})/,                // UPDATE TABLE-NAME
            /DELETE\s+FROM\s+([A-Z][A-Z0-9\-_\.]{1,})/          // DELETE FROM TABLE-NAME
        ];
        
        sqlPatterns.forEach(pattern => {
            const sqlMatch = trimmed.match(pattern);
            if (sqlMatch && !dependencies.sqlTables.includes(sqlMatch[1])) {
                dependencies.sqlTables.push(sqlMatch[1]);
                console.log(`Found SQL table: ${sqlMatch[1]} at line ${lineNum + 1}`);
            }
        });
    });

    console.log(`Dependency extraction complete for ${fileName}:`, {
        copyStatements: dependencies.copyStatements.length,
        callStatements: dependencies.callStatements.length,
        execStatements: dependencies.execStatements.length,
        fileReferences: dependencies.fileReferences.length
    });

    return dependencies;
}

        extractComponentsFromFile(content, fileType) {
            const components = [];
            const lines = content.split('\n');

            lines.forEach((line, index) => {
                const trimmed = line.trim().toUpperCase();
                
                // Extract COBOL 01-level fields
                const field01Match = trimmed.match(/^\s*01\s+([A-Z][A-Z0-9\-_]{2,})/);
                if (field01Match) {
                    components.push({
                        name: field01Match[1],
                        type: 'RECORD_LAYOUT',
                        level: '01',
                        lineNumber: index + 1,
                        fileType: fileType,
                        isMainComponent: true
                    });
                }
                
                // Extract copybook names
                const copyMatch = trimmed.match(/COPY\s+([A-Z][A-Z0-9\-_]{2,})/);
                if (copyMatch) {
                    components.push({
                        name: copyMatch[1],
                        type: 'COPYBOOK',
                        lineNumber: index + 1,
                        fileType: fileType,
                        isMainComponent: false
                    });
                }
                
                // Extract program names
                const programMatch = trimmed.match(/PROGRAM-ID\.?\s+([A-Z][A-Z0-9\-_]{2,})/);
                if (programMatch) {
                    components.push({
                        name: programMatch[1],
                        type: 'PROGRAM',
                        lineNumber: index + 1,
                        fileType: fileType,
                        isMainComponent: true
                    });
                }

                // Extract file names from FD statements
                const fileMatch = trimmed.match(/FD\s+([A-Z][A-Z0-9\-_]{2,})/);
                if (fileMatch) {
                    components.push({
                        name: fileMatch[1],
                        type: 'FILE',
                        lineNumber: index + 1,
                        fileType: fileType,
                        isMainComponent: false
                    });
                }
            });
            
            return components;
        }

        displayUploadedFiles() {
            const container = document.getElementById('uploadedFiles');
            if (!container) return;
            
            if (this.uploadedFiles.length === 0) {
                container.innerHTML = '';
                return;
            }
            
            let html = '';
            this.uploadedFiles.forEach(file => {
                const mainComponents = file.components ? 
                    file.components.filter(c => c.isMainComponent).length : 0;
                const totalComponents = file.components ? file.components.length : 0;
                
                html += `
                    <div class="file-item">
                        <div class="file-info">
                            <div class="file-name">${file.name}</div>
                            <div class="file-details">
                                ${file.type} • ${Math.round(file.size/1024)}KB
                                ${mainComponents > 0 ? ` • 🎯 ${mainComponents} main components` : ''}
                                ${totalComponents > mainComponents ? ` • 📁 ${totalComponents - mainComponents} references` : ''}
                            </div>
                        </div>
                        <button class="file-remove" onclick="analyzer.removeFile('${file.id}')">🗑️</button>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        removeFile(fileId) {
            this.uploadedFiles = this.uploadedFiles.filter(f => f.id != fileId);
            this.displayUploadedFiles();
            this.updateComponentSuggestions();
            this.validateForm();
            this.saveToStorage();
        }

        /* ===================================================================
        COMPONENT SUGGESTIONS
        ================================================================== */
        updateComponentSuggestions() {
            this.componentSuggestions = [];
            
            this.uploadedFiles.forEach(file => {
                if (file.components) {
                    file.components.forEach(component => {
                        if (component.isMainComponent) {
                            this.componentSuggestions.push({
                                name: component.name,
                                type: component.type,
                                level: component.level,
                                file: file.name,
                                fileType: file.type,
                                lineNumber: component.lineNumber
                            });
                        }
                    });
                }
            });
            
            // Remove duplicates and sort
            this.componentSuggestions = this.componentSuggestions
                .filter((item, index, self) => 
                    index === self.findIndex(t => t.name === item.name && t.type === item.type)
                )
                .sort((a, b) => {
                    if (a.type === 'RECORD_LAYOUT' && b.type !== 'RECORD_LAYOUT') return -1;
                    if (b.type === 'RECORD_LAYOUT' && a.type !== 'RECORD_LAYOUT') return 1;
                    if (a.type === 'PROGRAM' && b.type !== 'PROGRAM') return -1;
                    if (b.type === 'PROGRAM' && a.type !== 'PROGRAM') return 1;
                    return a.name.localeCompare(b.name);
                });
        }

        onComponentInput() {
            const input = document.getElementById('componentName');
            const suggestions = document.getElementById('componentSuggestions');
            
            if (!input || !suggestions) {
                this.validateForm();
                return;
            }
            
            const value = input.value.trim().toUpperCase();
            
            if (value.length < 2) {
                suggestions.style.display = 'none';
                this.validateForm();
                return;
            }
            
            const filtered = this.componentSuggestions.filter(item => 
                item.name.includes(value)
            ).slice(0, 8);
            
            if (filtered.length > 0) {
                let html = '';
                filtered.forEach(item => {
                    const priority = item.type === 'RECORD_LAYOUT' ? '🎯' : 
                                   item.type === 'PROGRAM' ? '💼' : '📁';
                    
                    html += `
                        <div class="suggestion-item" onclick="analyzer.selectSuggestion('${item.name}')">
                            <strong>${priority} ${item.name}</strong> 
                            <span style="opacity: 0.7;">(${item.type} in ${item.file})</span>
                            ${item.level ? `<span style="margin-left: 8px; background: #fcd34d; color: #92400e; padding: 1px 4px; border-radius: 2px; font-size: 9px;">L${item.level}</span>` : ''}
                        </div>
                    `;
                });
                suggestions.innerHTML = html;
                suggestions.style.display = 'block';
            } else {
                suggestions.style.display = 'none';
            }
            
            this.validateForm();
        }

        selectSuggestion(componentName) {
            const input = document.getElementById('componentName');
            const suggestions = document.getElementById('componentSuggestions');
            
            if (input) input.value = componentName;
            if (suggestions) suggestions.style.display = 'none';
            
            // Auto-populate friendly name if empty
            const friendlyInput = document.getElementById('friendlyName');
            if (friendlyInput && !friendlyInput.value.trim()) {
                const friendlyName = this.generateFriendlyName(componentName);
                friendlyInput.value = friendlyName;
            }
            
            this.validateForm();
        }

        generateFriendlyName(componentName) {
            // Convert component name to friendly format
            return componentName
                .toLowerCase()
                .replace(/-/g, ' ')
                .replace(/\b\w/g, l => l.toUpperCase())
                .replace(/Record/g, 'Record')
                .replace(/Copy/g, 'Copy')
                .replace(/Proc/g, 'Process');
        }

        /* ===================================================================
        API CONNECTION MANAGEMENT
        ================================================================== */
        async validateConnection() {
            const endpoint = document.getElementById('vllmEndpoint').value.trim();
            if (!endpoint) {
                this.showError('Please enter vLLM endpoint');
                return;
            }

            this.updateConnectionStatus('connecting', 'Testing LLM connection...');

            try {
                const response = await fetch(`${endpoint}/generate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: "Test connection. Respond with 'Connected'",
                        max_tokens: 10,
                        temperature: 0.1
                    }),
                    signal: AbortSignal.timeout(10000)
                });

                if (response.ok) {
                    const data = await response.json();
                    this.serverValidated = true;
                    this.vllmEndpoint = endpoint;
                    this.updateConnectionStatus('connected', `✅ LLM connection verified`);
                    this.showSuccess('🚀 vLLM server connected successfully!');
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
            } catch (error) {
                this.serverValidated = false;
                this.updateConnectionStatus('disconnected', `❌ Connection failed: ${error.message}`);
                this.showError(`LLM connection failed: ${error.message}`);
            }
            
            this.validateForm();
        }

        updateConnectionStatus(status, message) {
            const statusElement = document.getElementById('apiStatus');
            if (statusElement) {
                statusElement.className = `status-indicator status-${status}`;
                statusElement.innerHTML = message;
            }
        }

        onEndpointChange() {
            this.serverValidated = false;
            this.updateConnectionStatus('disconnected', '🔴 Connection not validated');
            this.validateForm();
        }

        onSettingsChange() {
            const maxTokensInput = document.getElementById('maxTokens');
            if (maxTokensInput) {
                this.maxTokens = parseInt(maxTokensInput.value) || 4000;
                this.saveToStorage();
            }
        }

        /* ===================================================================
        FORM VALIDATION
        ================================================================== */
        validateForm() {
            const hasFiles = this.uploadedFiles.length > 0;
            const hasComponent = document.getElementById('componentName') && 
                               document.getElementById('componentName').value.trim().length > 0;
            const hasConnection = this.serverValidated;
            
            const analyzeBtn = document.getElementById('analyzeComponentBtn');
            const bulkBtn = document.getElementById('bulkAnalyzeBtn');
            
            if (analyzeBtn) analyzeBtn.disabled = !(hasFiles && hasComponent && hasConnection);
            if (bulkBtn) bulkBtn.disabled = !(hasFiles && hasConnection);
            
            const hasResults = Object.keys(this.analysisResults).length > 0;
            const exportJsonBtn = document.getElementById('exportJsonBtn');
            const exportMdBtn = document.getElementById('exportMdBtn');
            
            if (exportJsonBtn) exportJsonBtn.disabled = !hasResults;
            if (exportMdBtn) exportMdBtn.disabled = !hasResults;
        }

        /* ===================================================================
        CHAT FUNCTIONALITY - ENHANCED
        ================================================================== */
        initializeChat() {
            this.initializeChatEventListeners();
        }

        initializeChatEventListeners() {
            const chatSendBtn = document.getElementById('chatSendBtn');
            const chatInput = document.getElementById('chatInput');
            
            if (chatSendBtn && chatInput) {
                chatSendBtn.addEventListener('click', () => this.sendChatMessage());
                
                chatInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.sendChatMessage();
                    }
                });
            }

            // Chat suggestions
            document.querySelectorAll('.chat-suggestion-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const question = e.target.dataset.question;
                    if (chatInput && question) {
                        chatInput.value = question;
                        this.sendChatMessage();
                    }
                });
            });
        }

        enableChat() {
            const chatInput = document.getElementById('chatInput');
            const chatSendBtn = document.getElementById('chatSendBtn');
            const chatSuggestions = document.getElementById('chatSuggestions');
            
            if (chatInput && chatSendBtn) {
                chatInput.disabled = false;
                chatSendBtn.disabled = false;
                
                if (chatSuggestions) {
                    chatSuggestions.style.display = 'block';
                }
                
                const friendlyName = document.getElementById('friendlyName')?.value || this.currentAnalyzedComponent;
                
                this.addChatMessage('assistant', 
                    `🎯 **Analysis complete for ${friendlyName}!**
                    I can now provide detailed insights about this component:
🧠 Field Analysis: Context-aware categorization with lifecycle tracking
⚖️ Business Logic: Extracted rules and validation patterns
🔗 Dependency Analysis: Found vs missing dependencies
🌊 Lifecycle Flow: Complete usage pattern mapping
Ask me about:

"Which fields are most important in this component?"
"What programs create vs update this data?"
"What dependencies are missing and why?"
"How can we optimize this component?"`
);
}
}
async sendChatMessage() {
          const input = document.getElementById('chatInput');
          const sendBtn = document.getElementById('chatSendBtn');
          const message = input.value.trim();
          
          if (!message) {
              this.showError('Please enter a message');
              return;
          }
          
          if (!this.currentAnalyzedComponent) {
              this.showError('Please analyze a component first');
              return;
          }
          
          input.disabled = true;
          sendBtn.disabled = true;
          sendBtn.textContent = 'Processing...';
          
          this.addChatMessage('user', message);
          input.value = '';
          
          this.showChatTyping();
          
          try {
              const response = await this.processEnhancedChatQuery(message);
              this.hideChatTyping();
              this.addChatMessage('assistant', response);
          } catch (error) {
              console.error('Chat error:', error);
              this.hideChatTyping();
              this.addChatMessage('assistant', `I apologize, but I encountered an error: ${error.message}. Please try rephrasing your question.`);
          } finally {
              input.disabled = false;
              sendBtn.disabled = false;
              sendBtn.textContent = 'Send';
              input.focus();
          }
      }
      isDependencyFound(dependency, type, uploadedFiles) {
    const depUpper = dependency.toUpperCase();
    
    // For copybooks, create multiple search variants
    if (type === 'copyStatements') {
        const searchVariants = [
            depUpper,                           // COPYBOOK-NAME
            depUpper + '.CPY',                  // COPYBOOK-NAME.CPY
            depUpper + '.COPYBOOK',             // COPYBOOK-NAME.COPYBOOK
            depUpper.replace('.CPY', ''),       // Remove .CPY if present
            depUpper.replace('.COPYBOOK', '')   // Remove .COPYBOOK if present
        ];
        
        return uploadedFiles.some(file => {
            // Check filename variants
            const fileNameUpper = file.name.toUpperCase();
            const fileBaseName = fileNameUpper.replace(/\.(CPY|COPYBOOK|TXT)$/i, '');
            
            const filenameMatches = searchVariants.some(variant => {
                return fileNameUpper === variant || 
                       fileNameUpper === variant + '.CPY' || 
                       fileNameUpper === variant + '.COPYBOOK' ||
                       fileBaseName === variant.replace(/\.(CPY|COPYBOOK)$/i, '');
            });
            
            if (filenameMatches) {
                console.log(`✅ Found copybook dependency: ${dependency} -> ${file.name}`);
                return true;
            }
            
            // Check components within files
            if (file.components) {
                const componentMatch = file.components.some(comp => 
                    searchVariants.some(variant => comp.name.toUpperCase() === variant)
                );
                if (componentMatch) {
                    console.log(`✅ Found copybook component: ${dependency} in ${file.name}`);
                    return true;
                }
            }
            
            return false;
        });
    }

    // For programs
    if (type === 'callStatements' || type === 'programIds' || type === 'execStatements') {
        return uploadedFiles.some(file => {
            // Check filename
            const fileBaseName = file.name.replace(/\.(CBL|COB|TXT)$/i, '').toUpperCase();
            if (fileBaseName === depUpper) {
                console.log(`✅ Found program dependency: ${dependency} -> ${file.name}`);
                return true;
            }
            
            // Check PROGRAM-ID in components
            if (file.components) {
                const programMatch = file.components.some(comp => 
                    comp.type === 'PROGRAM' && comp.name.toUpperCase() === depUpper
                );
                if (programMatch) {
                    console.log(`✅ Found program component: ${dependency} in ${file.name}`);
                    return true;
                }
            }
            
            return false;
        });
    }

    // For file references
    if (type === 'fileReferences') {
        return uploadedFiles.some(file => {
            const fileBaseName = file.name.replace(/\.[^/.]+$/, "").toUpperCase();
            if (fileBaseName === depUpper || file.name.toUpperCase().includes(depUpper)) {
                console.log(`✅ Found file dependency: ${dependency} -> ${file.name}`);
                return true;
            }
            
            if (file.components) {
                const fileMatch = file.components.some(comp => 
                    comp.type === 'FILE' && comp.name.toUpperCase() === depUpper
                );
                if (fileMatch) {
                    console.log(`✅ Found file component: ${dependency} in ${file.name}`);
                    return true;
                }
            }
            
            return false;
        });
    }

    return false;
}

updateTokenDisplay(currentTokens) {
    const tokenInfo = document.getElementById('tokenInfo');
    const tokenCount = document.getElementById('tokenCount');
    const tokenFill = document.getElementById('tokenFill');
    const tokenWarning = document.getElementById('tokenWarning');

    if (!tokenInfo) return;

    tokenInfo.style.display = 'block';
    tokenCount.textContent = `${currentTokens} / ${this.maxTokens}`;
    
    const percentage = (currentTokens / this.maxTokens) * 100;
    tokenFill.style.width = `${Math.min(percentage, 100)}%`;
    
    tokenFill.className = 'token-fill';
    if (percentage <= 50) {
        tokenFill.classList.add('safe');
        tokenWarning.innerHTML = '🟢 Optimal token usage - full analysis available<br><small>Intelligent chunking: OFF</small>';
    } else if (percentage <= 70) {
        tokenFill.classList.add('warning');
        tokenWarning.innerHTML = '🟡 Moderate usage - smart chunking active<br><small>Intelligent chunking: ACTIVE</small>';
    } else {
        tokenFill.classList.add('danger');
        tokenWarning.innerHTML = '🔴 High usage - aggressive optimization active<br><small>Intelligent chunking: AGGRESSIVE</small>';
    }
}

      async processEnhancedChatQuery(question) {
          const analysisData = this.analysisResults[this.currentAnalyzedComponent];
          const friendlyName = document.getElementById('friendlyName')?.value || this.currentAnalyzedComponent;
          
          let context = `MAINFRAME COMPONENT ANALYSIS CHATCOMPONENT: ${this.currentAnalyzedComponent}
FRIENDLY NAME: ${friendlyName}
COMPONENT TYPE: ${analysisData.componentType}
ANALYSIS METHOD: ${analysisData.analysisMethod}
FILES ANALYZED: ${analysisData.filesAnalyzed.join(', ')}
ANALYSIS RESULTS:
${JSON.stringify(analysisData.llmAnalysis, null, 2)}
LIFECYCLE FLOW:
${JSON.stringify(analysisData.lifecycleFlow, null, 2)}
DEPENDENCY ANALYSIS:
${JSON.stringify(analysisData.dependencyAnalysis, null, 2)}
USER QUESTION: "${question}"
Provide a detailed, helpful response based on the analysis data above. Use the friendly name "${friendlyName}" when referring to the component. Use specific examples and data from the analysis.`;
try {
                const response = await this.callLLMAPI(context);
                
                if (typeof response === 'string') {
                    return response;
                } else if (response.rawResponse) {
                    return response.rawResponse;
                } else if (response.error) {
                    return `Based on the available analysis data for ${friendlyName}: ${response.fallbackData?.recommendations?.join('. ') || 'Please check the analysis results for more details.'}`;
                }
            } catch (error) {
                console.error('Chat LLM call failed:', error);
            }
            
            return `I can provide information based on the ${friendlyName} analysis. What specific aspect would you like to know more about?`;
        }

        addChatMessage(sender, content) {
            const messagesContainer = document.getElementById('chatMessages');
            if (!messagesContainer) return;
            
            const messageId = 'msg_' + Date.now();
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${sender}`;
            messageDiv.id = messageId;
            
            messageDiv.innerHTML = `
                <div class="chat-sender">${sender === 'user' ? 'You' : 'Analysis Assistant'}</div>
                <div class="chat-content">${this.formatChatMessage(content)}</div>
                <div class="chat-timestamp">${new Date().toLocaleTimeString()}</div>
            `;
            
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            this.chatHistory.push({
                id: messageId,
                sender: sender,
                content: content,
                timestamp: new Date().toISOString()
            });
            
            this.saveToStorage();
        }

        formatChatMessage(content) {
            return content
                .replace(/\n/g, '<br>')
                .replace(/\*\*([^*]+)\*\*/g, '<strong style="color: #1e40af;">$1</strong>')
                .replace(/`([^`]+)`/g, '<code style="background: #f3f4f6; padding: 2px 4px; border-radius: 3px; color: #10b981; font-family: monospace;">$1</code>')
                .replace(/^- /gm, '• ')
                .replace(/^• /gm, '<span style="color: #10b981;">•</span> ')
                .replace(/🧠|⚖️|🔗|💡|🎯|📊|🔍|🚀|🌊|⚙️|🖥️|📤/g, '<span style="font-size: 1.2em;">$&</span>');
        }

        showChatTyping() {
            const messagesContainer = document.getElementById('chatMessages');
            if (!messagesContainer) return;
            
            this.hideChatTyping();
            
            const typingDiv = document.createElement('div');
            typingDiv.id = 'typingIndicator';
            typingDiv.className = 'chat-message assistant';
            
            typingDiv.innerHTML = `
                <div class="chat-sender">Analysis Assistant</div>
                <div class="chat-content">
                    <span style="opacity: 0.7;">🤖 Processing your question...</span>
                    <span style="animation: blink 1s infinite; margin-left: 5px;">●●●</span>
                </div>
            `;
            
            messagesContainer.appendChild(typingDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        hideChatTyping() {
            const typingIndicator = document.getElementById('typingIndicator');
            if (typingIndicator && typingIndicator.parentNode) {
                typingIndicator.parentNode.removeChild(typingIndicator);
            }
        }

        /* ===================================================================
        MAIN ANALYSIS METHODS - PRESERVED WITH UI UPDATES
        ================================================================== */
        async analyzeComponent() {
            const componentName = document.getElementById('componentName').value.trim();
            const friendlyName = document.getElementById('friendlyName').value.trim() || componentName;
            
            if (!componentName) {
                this.showError('Please enter a component name');
                return;
            }

            if (!this.serverValidated) {
                this.showError('Please validate LLM server connection first');
                return;
            }

            this.showLoading();
            this.updateProgress(0);

            try {
                console.log(`=== Starting Analysis for Component: ${componentName} (${friendlyName}) ===`);
                this.updateLoadingStatus(`🚀 Initializing analysis for ${friendlyName}...`);
                
                // Check if component exists in uploaded files
                const relevantFiles = this.findRelevantFiles(componentName);
                if (relevantFiles.length === 0) {
                    throw new Error(`Component "${componentName}" not found in uploaded files. Please check the component name and ensure related files are uploaded.`);
                }

                console.log(`Found ${relevantFiles.length} relevant files:`, relevantFiles.map(f => f.name));

                const results = await this.runLLMEnhancedAnalysisWithLifecycle(componentName, friendlyName);
                
                // Store results
                this.analysisResults[componentName] = results;
                this.currentAnalyzedComponent = componentName;
                
                // Update UI
                this.displayAnalysisResults(componentName, results, friendlyName);
                this.updateFlowDiagram(results.lifecycleFlow);
                this.enableChat();
                this.saveToStorage();
                
                this.hideLoading();
                
                // Show success with details
                const successMessage = `✅ Analysis complete for ${friendlyName}! 
                Quality: ${results.qualityScore}/10 | 
                Files: ${results.filesAnalyzed.length} | 
                Dependencies: ${results.dependencyAnalysis?.summary?.foundCount || 0} found, ${results.dependencyAnalysis?.summary?.missingCount || 0} missing`;
                
                this.showSuccess(successMessage);
                
                console.log(`=== Analysis Complete for ${componentName} (${friendlyName}) ===`);
                
            } catch (error) {
                this.hideLoading();
                console.error('Component analysis failed:', error);
                this.showError(`Analysis failed: ${error.message}`);
            }
        }

        // This is a simplified placeholder for the core analysis functionality
        // In a real implementation, you would include all the analysis methods from the original code
        async runLLMEnhancedAnalysisWithLifecycle(componentName, friendlyName) {
    console.log(`=== Starting Full LLM Analysis for ${componentName} ===`);
    
    this.updateLoadingStatus('🔍 Stage 1: Extracting dependencies...');
    this.updateProgress(10);
    
    const relevantFiles = this.findRelevantFiles(componentName);
    const componentType = this.detectComponentType(componentName, relevantFiles);
    
    // STEP 1: Extract comprehensive dependencies
    const allDependencies = this.extractComprehensiveDependencies(relevantFiles, componentName);
    console.log('Extracted dependencies:', allDependencies);
    
    this.updateLoadingStatus('🔗 Stage 2: Analyzing dependency relationships...');
    this.updateProgress(25);
    
    // STEP 2: Analyze found vs missing dependencies
    const dependencyAnalysis = this.analyzeDependencyStatus(allDependencies);
    console.log('Dependency analysis:', dependencyAnalysis);
    
    this.updateLoadingStatus('🌊 Stage 3: Building lifecycle context...');
    this.updateProgress(40);
    
    // STEP 3: Build comprehensive context for LLM
    const analysisContext = this.buildLLMAnalysisContext(
        componentName, 
        friendlyName, 
        relevantFiles, 
        allDependencies, 
        dependencyAnalysis
    );
    
    this.updateLoadingStatus('🤖 Stage 4: Calling LLM for component analysis...');
    this.updateProgress(60);
    
    // STEP 4: Call LLM with intelligent chunking
    const llmAnalysis = await this.callLLMForComponentAnalysis(analysisContext);
    
    this.updateLoadingStatus('🌊 Stage 5: Analyzing lifecycle flow...');
    this.updateProgress(80);
    
    // STEP 5: Generate lifecycle flow
    const lifecycleFlow = this.generateLifecycleFlow(componentName, friendlyName, relevantFiles, llmAnalysis);
    
    this.updateLoadingStatus('📊 Stage 6: Finalizing analysis...');
    this.updateProgress(95);
    
    const results = {
        componentName: componentName,
        friendlyName: friendlyName,
        timestamp: new Date().toISOString(),
        filesAnalyzed: relevantFiles.map(f => f.name),
        componentType: componentType,
        dependencyAnalysis: dependencyAnalysis,
        lifecycleFlow: lifecycleFlow,
        llmAnalysis: llmAnalysis,
        qualityScore: this.calculateQualityScore(llmAnalysis, dependencyAnalysis, relevantFiles),
        completeness: this.calculateCompleteness(llmAnalysis, dependencyAnalysis),
        analysisMethod: 'LLM-Enhanced-Full-Integration'
    };

    this.updateProgress(100);
    console.log('=== LLM Analysis Complete ===', results);
    return results;
}

/* ===================================================================
ENHANCED MAINFRAME ANALYZER - LIFECYCLE AND QUALITY ASSESSMENT
Part 4: Lifecycle Flow Generation and Quality Scoring
================================================================== */

// Generate comprehensive lifecycle flow from analysis
generateLifecycleFlow(componentName, friendlyName, relevantFiles, llmAnalysis) {
    console.log('🌊 Generating lifecycle flow for:', componentName);
    
    const lifecycleFlow = {
        componentName: componentName,
        friendlyName: friendlyName,
        timestamp: new Date().toISOString(),
        usagePattern: this.determineUsagePattern(relevantFiles, llmAnalysis),
        creationSources: this.identifyCreationSources(relevantFiles),
        inputPrograms: this.identifyInputPrograms(relevantFiles),
        updatePrograms: this.identifyUpdatePrograms(relevantFiles),
        cicsScreens: this.identifyCicsScreens(relevantFiles),
        batchJobs: this.identifyBatchJobs(relevantFiles),
        dataFlow: this.analyzeDataFlow(relevantFiles, componentName),
        businessFlow: this.extractBusinessFlow(llmAnalysis),
        riskAssessment: this.assessLifecycleRisks(relevantFiles, llmAnalysis)
    };
    
    console.log('✅ Lifecycle flow generated:', lifecycleFlow);
    return lifecycleFlow;
}

// Determine the primary usage pattern of the component
determineUsagePattern(files, llmAnalysis) {
    const patterns = {
        'BATCH_PROCESSING': 0,
        'ONLINE_TRANSACTION': 0,
        'DATA_STORAGE': 0,
        'INTERFACE_PROCESSING': 0,
        'REPORTING': 0,
        'HYBRID': 0
    };
    
    files.forEach(file => {
        const content = file.content.toUpperCase();
        
        // Check for batch indicators
        if (content.includes('//JOB') || content.includes('//EXEC') || content.includes('SORT')) {
            patterns.BATCH_PROCESSING += 3;
        }
        
        // Check for CICS indicators
        if (content.includes('EXEC CICS') || content.includes('SEND MAP') || content.includes('RECEIVE MAP')) {
            patterns.ONLINE_TRANSACTION += 3;
        }
        
        // Check for data storage indicators
        if (content.includes('01 ') || content.includes('COPY ') || file.type === 'Copybook') {
            patterns.DATA_STORAGE += 2;
        }
        
        // Check for interface indicators
        if (content.includes('CALL ') || content.includes('INVOKE') || content.includes('WS-')) {
            patterns.INTERFACE_PROCESSING += 2;
        }
        
        // Check for reporting indicators
        if (content.includes('DISPLAY') || content.includes('WRITE') || content.includes('REPORT')) {
            patterns.REPORTING += 1;
        }
    });
    
    // Determine primary pattern
    const maxScore = Math.max(...Object.values(patterns));
    if (maxScore === 0) return 'UNKNOWN';
    
    const primaryPattern = Object.keys(patterns).find(key => patterns[key] === maxScore);
    
    // Check for hybrid patterns
    const significantPatterns = Object.keys(patterns).filter(key => patterns[key] >= maxScore * 0.7);
    if (significantPatterns.length > 1) {
        return 'HYBRID';
    }
    
    return primaryPattern;
}

// Identify programs/processes that create the component
identifyCreationSources(files) {
    const creationSources = [];
    
    files.forEach(file => {
        const lines = file.content.split('\n');
        lines.forEach((line, index) => {
            const upperLine = line.trim().toUpperCase();
            
            // Check for creation patterns
            const creationPatterns = [
                /OPEN\s+OUTPUT\s+([A-Z][A-Z0-9\-_]+)/,
                /WRITE\s+([A-Z][A-Z0-9\-_]+)/,
                /CREATE\s+([A-Z][A-Z0-9\-_]+)/,
                /\/\/([A-Z][A-Z0-9\-_]+)\s+DD\s+DISP=NEW/,
                /FD\s+([A-Z][A-Z0-9\-_]+).*OUTPUT/
            ];
            
            creationPatterns.forEach(pattern => {
                const match = upperLine.match(pattern);
                if (match) {
                    creationSources.push({
                        program: this.extractProgramName(file),
                        file: file.name,
                        lineNumber: index + 1,
                        operation: 'CREATE',
                        target: match[1],
                        confidence: this.calculateConfidence(line, 'creation')
                    });
                }
            });
        });
    });
    
    return this.deduplicateAndRank(creationSources);
}

// Identify programs that read/input the component
identifyInputPrograms(files) {
    const inputPrograms = [];
    
    files.forEach(file => {
        const lines = file.content.split('\n');
        lines.forEach((line, index) => {
            const upperLine = line.trim().toUpperCase();
            
            // Check for input patterns
            const inputPatterns = [
                /OPEN\s+INPUT\s+([A-Z][A-Z0-9\-_]+)/,
                /READ\s+([A-Z][A-Z0-9\-_]+)/,
                /SELECT\s+([A-Z][A-Z0-9\-_]+)\s+ASSIGN/,
                /EXEC\s+CICS\s+READ/,
                /\/\/([A-Z][A-Z0-9\-_]+)\s+DD\s+DISP=SHR/
            ];
            
            inputPatterns.forEach(pattern => {
                const match = upperLine.match(pattern);
                if (match) {
                    inputPrograms.push({
                        program: this.extractProgramName(file),
                        file: file.name,
                        lineNumber: index + 1,
                        operation: 'READ',
                        target: match[1],
                        confidence: this.calculateConfidence(line, 'input')
                    });
                }
            });
        });
    });
    
    return this.deduplicateAndRank(inputPrograms);
}

// Identify programs that update/modify the component
identifyUpdatePrograms(files) {
    const updatePrograms = [];
    
    files.forEach(file => {
        const lines = file.content.split('\n');
        lines.forEach((line, index) => {
            const upperLine = line.trim().toUpperCase();
            
            // Check for update patterns
            const updatePatterns = [
                /OPEN\s+I-O\s+([A-Z][A-Z0-9\-_]+)/,
                /REWRITE\s+([A-Z][A-Z0-9\-_]+)/,
                /UPDATE\s+([A-Z][A-Z0-9\-_]+)/,
                /EXEC\s+CICS\s+REWRITE/,
                /EXEC\s+CICS\s+WRITE/,
                /MOVE\s+.*TO\s+([A-Z][A-Z0-9\-_]+)/
            ];
            
            updatePatterns.forEach(pattern => {
                const match = upperLine.match(pattern);
                if (match) {
                    updatePrograms.push({
                        program: this.extractProgramName(file),
                        file: file.name,
                        lineNumber: index + 1,
                        operation: 'UPDATE',
                        target: match[1],
                        confidence: this.calculateConfidence(line, 'update')
                    });
                }
            });
        });
    });
    
    return this.deduplicateAndRank(updatePrograms);
}

// Identify CICS screens and transactions
identifyCicsScreens(files) {
    const cicsScreens = [];
    
    files.forEach(file => {
        const lines = file.content.split('\n');
        lines.forEach((line, index) => {
            const upperLine = line.trim().toUpperCase();
            
            // Check for CICS patterns
            const cicsPatterns = [
                /EXEC\s+CICS\s+SEND\s+MAP\s*\(\s*['"]*([A-Z][A-Z0-9\-_]+)/,
                /EXEC\s+CICS\s+RECEIVE\s+MAP\s*\(\s*['"]*([A-Z][A-Z0-9\-_]+)/,
                /EXEC\s+CICS\s+START\s+TRANSID\s*\(\s*['"]*([A-Z][A-Z0-9\-_]+)/,
                /DFHCOMMAREA/
            ];
            
            cicsPatterns.forEach(pattern => {
                const match = upperLine.match(pattern);
                if (match) {
                    cicsScreens.push({
                        program: this.extractProgramName(file),
                        file: file.name,
                        lineNumber: index + 1,
                        operation: 'CICS_INTERACTION',
                        screen: match[1] || 'UNKNOWN',
                        confidence: this.calculateConfidence(line, 'cics')
                    });
                }
            });
        });
    });
    
    return this.deduplicateAndRank(cicsScreens);
}

// Identify batch jobs and procedures
identifyBatchJobs(files) {
    const batchJobs = [];
    
    files.forEach(file => {
        if (file.type === 'JCL Job' || file.content.includes('//JOB ')) {
            const lines = file.content.split('\n');
            lines.forEach((line, index) => {
                const upperLine = line.trim().toUpperCase();
                
                // Check for batch patterns
                const batchPatterns = [
                    /\/\/JOB\s+([A-Z][A-Z0-9\-_]+)/,
                    /\/\/([A-Z][A-Z0-9\-_]+)\s+EXEC\s+PGM=([A-Z][A-Z0-9\-_]+)/,
                    /\/\/([A-Z][A-Z0-9\-_]+)\s+EXEC\s+([A-Z][A-Z0-9\-_]+)/
                ];
                
                batchPatterns.forEach(pattern => {
                    const match = upperLine.match(pattern);
                    if (match) {
                        batchJobs.push({
                            job: match[1],
                            program: match[2] || match[1],
                            file: file.name,
                            lineNumber: index + 1,
                            operation: 'BATCH_EXECUTION',
                            confidence: this.calculateConfidence(line, 'batch')
                        });
                    }
                });
            });
        }
    });
    
    return this.deduplicateAndRank(batchJobs);
}

// Analyze data flow patterns
analyzeDataFlow(files, componentName) {
    const dataFlow = {
        inputs: [],
        outputs: [],
        transformations: [],
        validations: []
    };
    
    files.forEach(file => {
        const content = file.content.toUpperCase();
        
        // Identify input sources
        const inputMatches = content.match(/READ\s+([A-Z][A-Z0-9\-_]+)/g) || [];
        inputMatches.forEach(match => {
            const source = match.replace('READ ', '').trim();
            if (!dataFlow.inputs.includes(source)) {
                dataFlow.inputs.push(source);
            }
        });
        
        // Identify output destinations
        const outputMatches = content.match(/WRITE\s+([A-Z][A-Z0-9\-_]+)/g) || [];
        outputMatches.forEach(match => {
            const dest = match.replace('WRITE ', '').trim();
            if (!dataFlow.outputs.includes(dest)) {
                dataFlow.outputs.push(dest);
            }
        });
        
        // Identify transformations
        const computeMatches = content.match(/COMPUTE\s+([A-Z][A-Z0-9\-_]+)/g) || [];
        computeMatches.forEach(match => {
            const field = match.replace('COMPUTE ', '').trim();
            if (!dataFlow.transformations.includes(field)) {
                dataFlow.transformations.push(field);
            }
        });
        
        // Identify validations
        const ifMatches = content.match(/IF\s+([A-Z][A-Z0-9\-_]+)/g) || [];
        ifMatches.forEach(match => {
            const field = match.replace('IF ', '').trim();
            if (!dataFlow.validations.includes(field)) {
                dataFlow.validations.push(field);
            }
        });
    });
    
    return dataFlow;
}

// Extract business flow from LLM analysis
extractBusinessFlow(llmAnalysis) {
    if (!llmAnalysis || llmAnalysis.error) {
        return {
            businessSteps: [],
            decisionPoints: [],
            businessRules: []
        };
    }
    
    return {
        businessSteps: llmAnalysis.lifecyclePhases || {},
        decisionPoints: (llmAnalysis.businessRules || [])
            .filter(rule => rule.type === 'CONTROL')
            .map(rule => rule.description),
        businessRules: llmAnalysis.businessRules || []
    };
}

// Assess lifecycle risks
assessLifecycleRisks(files, llmAnalysis) {
    const risks = [];
    
    // Check for missing dependencies
    const totalFiles = files.length;
    if (totalFiles < 2) {
        risks.push({
            type: 'INCOMPLETE_ANALYSIS',
            severity: 'HIGH',
            description: 'Limited files available for comprehensive analysis',
            impact: 'May miss critical dependencies and relationships'
        });
    }
    
    // Check for LLM analysis issues
    if (llmAnalysis.error || llmAnalysis.fallbackGenerated) {
        risks.push({
            type: 'LLM_ANALYSIS_INCOMPLETE',
            severity: 'MEDIUM',
            description: 'LLM analysis failed or incomplete',
            impact: 'Business logic and advanced patterns may not be identified'
        });
    }
    
    // Check for missing dependencies
    if (llmAnalysis.dependencies && llmAnalysis.dependencies.missing.length > 0) {
        risks.push({
            type: 'MISSING_DEPENDENCIES',
            severity: 'HIGH',
            description: `${llmAnalysis.dependencies.missing.length} dependencies not found`,
            impact: 'Component may not function correctly without missing dependencies'
        });
    }
    
    // Check for outdated patterns
    files.forEach(file => {
        const content = file.content.toUpperCase();
        if (content.includes('GOTO') || content.includes('ALTER')) {
            risks.push({
                type: 'LEGACY_PATTERNS',
                severity: 'MEDIUM',
                description: 'Legacy programming patterns detected',
                impact: 'May be difficult to maintain and modernize'
            });
        }
    });
    
    return risks;
}

// Helper methods for lifecycle generation
extractProgramName(file) {
    // Try to extract program name from content
    const content = file.content.toUpperCase();
    const programMatch = content.match(/PROGRAM-ID\.?\s+([A-Z][A-Z0-9\-_]+)/);
    if (programMatch) {
        return programMatch[1];
    }
    
    // Fallback to filename
    return file.name.replace(/\.(cbl|cob|cpy|jcl|txt)$/i, '').toUpperCase();
}

calculateConfidence(line, operationType) {
    let confidence = 0.5; // Base confidence
    
    // Adjust confidence based on context
    const upperLine = line.toUpperCase();
    
    if (operationType === 'creation') {
        if (upperLine.includes('OPEN OUTPUT')) confidence = 0.9;
        else if (upperLine.includes('WRITE')) confidence = 0.8;
        else if (upperLine.includes('CREATE')) confidence = 0.9;
    } else if (operationType === 'input') {
        if (upperLine.includes('OPEN INPUT')) confidence = 0.9;
        else if (upperLine.includes('READ')) confidence = 0.8;
    } else if (operationType === 'update') {
        if (upperLine.includes('OPEN I-O')) confidence = 0.9;
        else if (upperLine.includes('REWRITE')) confidence = 0.8;
    } else if (operationType === 'cics') {
        if (upperLine.includes('EXEC CICS')) confidence = 0.9;
    } else if (operationType === 'batch') {
        if (upperLine.includes('//JOB')) confidence = 0.9;
        else if (upperLine.includes('//EXEC')) confidence = 0.8;
    }
    
    return confidence;
}

deduplicateAndRank(items) {
    // Remove duplicates based on program and target
    const unique = items.filter((item, index, self) => 
        index === self.findIndex(t => 
            t.program === item.program && 
            t.target === item.target &&
            t.operation === item.operation
        )
    );
    
    // Sort by confidence (highest first)
    return unique.sort((a, b) => (b.confidence || 0) - (a.confidence || 0));
}

// Calculate overall quality score for the analysis
calculateQualityScore(llmAnalysis, dependencyAnalysis, relevantFiles) {
    let score = 5; // Base score
    
    // LLM Analysis Quality (40% weight)
    if (!llmAnalysis.error && !llmAnalysis.fallbackGenerated) {
        score += 2; // +2 for successful LLM analysis
        
        if (llmAnalysis.businessPurpose && llmAnalysis.businessPurpose.length > 50) {
            score += 0.5; // +0.5 for detailed business purpose
        }
        
        if (llmAnalysis.recommendations && llmAnalysis.recommendations.length >= 3) {
            score += 0.5; // +0.5 for comprehensive recommendations
        }
        
        if (llmAnalysis.fieldAnalysis && llmAnalysis.fieldAnalysis.totalFields > 0) {
            score += 0.5; // +0.5 for field analysis
        }
    } else {
        score -= 1; // -1 for failed LLM analysis
    }
    
    // Dependency Analysis Quality (30% weight)
    const totalDeps = dependencyAnalysis.summary.foundCount + dependencyAnalysis.summary.missingCount;
    if (totalDeps > 0) {
        const foundRatio = dependencyAnalysis.summary.foundCount / totalDeps;
        score += foundRatio * 2; // +0 to +2 based on found dependency ratio
    }
    
    // File Coverage Quality (20% weight)
    if (relevantFiles.length >= 3) {
        score += 1; // +1 for good file coverage
    } else if (relevantFiles.length >= 2) {
        score += 0.5; // +0.5 for adequate file coverage
    }
    
    // Completeness Quality (10% weight)
    if (llmAnalysis.businessRules && llmAnalysis.businessRules.length > 0) {
        score += 0.5; // +0.5 for business rules identification
    }
    
    if (llmAnalysis.lifecyclePhases && Object.keys(llmAnalysis.lifecyclePhases).length > 0) {
        score += 0.5; // +0.5 for lifecycle phases
    }
    
    // Ensure score is between 1 and 10
    return Math.max(1, Math.min(10, Math.round(score * 10) / 10));
}

// Calculate completeness metrics
calculateCompleteness(llmAnalysis, dependencyAnalysis) {
    const checkpoints = {
        llmAnalysisComplete: !llmAnalysis.error && !llmAnalysis.fallbackGenerated,
        businessPurposeIdentified: !!(llmAnalysis.businessPurpose && llmAnalysis.businessPurpose.length > 20),
        fieldAnalysisComplete: !!(llmAnalysis.fieldAnalysis && llmAnalysis.fieldAnalysis.totalFields > 0),
        businessRulesIdentified: !!(llmAnalysis.businessRules && llmAnalysis.businessRules.length > 0),
        dependenciesAnalyzed: !!(dependencyAnalysis.summary.foundCount > 0 || dependencyAnalysis.summary.missingCount > 0),
        recommendationsProvided: !!(llmAnalysis.recommendations && llmAnalysis.recommendations.length > 0)
    };
    
    const completed = Object.values(checkpoints).filter(Boolean).length;
    const total = Object.keys(checkpoints).length;
    const score = Math.round((completed / total) * 100);
    
    return {
        score: score,
        checkpoints: checkpoints,
        completed: completed,
        total: total
    };
}

// Enhanced dependency found check with better matching
isDependencyFound(dependency, type, uploadedFiles) {
    const depUpper = dependency.toUpperCase();
    
    // For copybooks, create multiple search variants
    if (type === 'copyStatements') {
        const searchVariants = [
            depUpper,                           // COPYBOOK-NAME
            depUpper + '.CPY',                  // COPYBOOK-NAME.CPY
            depUpper + '.COPYBOOK',             // COPYBOOK-NAME.COPYBOOK
            depUpper.replace('.CPY', ''),       // Remove .CPY if present
            depUpper.replace('.COPYBOOK', '')   // Remove .COPYBOOK if present
        ];
        
        return uploadedFiles.some(file => {
            // Check filename variants
            const fileNameUpper = file.name.toUpperCase();
            const fileBaseName = fileNameUpper.replace(/\.(CPY|COPYBOOK|TXT)$/i, '');
            
            const filenameMatches = searchVariants.some(variant => {
                return fileNameUpper === variant || 
                       fileNameUpper === variant + '.CPY' || 
                       fileNameUpper === variant + '.COPYBOOK' ||
                       fileBaseName === variant.replace(/\.(CPY|COPYBOOK)$/i, '');
            });
            
            if (filenameMatches) {
                console.log(`✅ Found copybook dependency: ${dependency} -> ${file.name}`);
                return true;
            }
            
            // Check components within files
            if (file.components) {
                const componentMatch = file.components.some(comp => 
                    searchVariants.some(variant => comp.name.toUpperCase() === variant)
                );
                if (componentMatch) {
                    console.log(`✅ Found copybook component: ${dependency} in ${file.name}`);
                    return true;
                }
            }
            
            return false;
        });
    }

    // For programs
    if (type === 'callStatements' || type === 'programIds' || type === 'execStatements') {
        return uploadedFiles.some(file => {
            // Check filename
            const fileBaseName = file.name.replace(/\.(CBL|COB|TXT)$/i, '').toUpperCase();
            if (fileBaseName === depUpper) {
                console.log(`✅ Found program dependency: ${dependency} -> ${file.name}`);
                return true;
            }
            
            // Check PROGRAM-ID in components
            if (file.components) {
                const programMatch = file.components.some(comp => 
                    comp.type === 'PROGRAM' && comp.name.toUpperCase() === depUpper
                );
                if (programMatch) {
                    console.log(`✅ Found program component: ${dependency} in ${file.name}`);
                    return true;
                }
            }
            
            return false;
        });
    }

    // For file references
    if (type === 'fileReferences') {
        return uploadedFiles.some(file => {
            const fileBaseName = file.name.replace(/\.[^/.]+$/, "").toUpperCase();
            if (fileBaseName === depUpper || file.name.toUpperCase().includes(depUpper)) {
                console.log(`✅ Found file dependency: ${dependency} -> ${file.name}`);
                return true;
            }
            
            if (file.components) {
                const fileMatch = file.components.some(comp => 
                    comp.type === 'FILE' && comp.name.toUpperCase() === depUpper
                );
                if (fileMatch) {
                    console.log(`✅ Found file component: ${dependency} in ${file.name}`);
                    return true;
                }
            }
            
            return false;
        });
    }

    return false;
}

// Create basic fallback for complete failure scenarios
createBasicFallback() {
    return {
        componentName: 'Unknown',
        friendlyName: 'Unknown Component',
        componentType: 'Unknown',
        analysisScope: 'FAILED',
        businessPurpose: 'Analysis failed - unable to determine business purpose',
        technicalSummary: 'Technical analysis failed',
        qualityScore: 1,
        recommendations: [
            'Check LLM server configuration',
            'Verify file content and format',
            'Consider manual analysis',
            'Review token limits and chunking settings'
        ],
        fieldAnalysis: {
            totalFields: 0,
            keyFields: [],
            fieldCategories: { input: [], output: [], calculated: [], control: [] }
        },
        businessRules: [],
        dependencies: {
            required: [],
            optional: [],
            missing: [],
            riskAssessment: 'UNKNOWN'
        },
        lifecyclePhases: {
            creation: [],
            processing: [],
            output: [],
            archival: []
        },
        modernizationOpportunities: [],
        riskFactors: ['Complete analysis failure'],
        error: true,
        timestamp: new Date().toISOString()
    };
}
// Analyze which dependencies are found vs missing
analyzeDependencyStatus(allDependencies) {
    const analysis = {
        found: {},
        missing: {},
        summary: { foundCount: 0, missingCount: 0 },
        details: {}
    };

    const dependencyTypes = ['copyStatements', 'callStatements', 'execStatements', 'fileReferences'];
    
    dependencyTypes.forEach(depType => {
        const dependencies = allDependencies[depType] || [];
        analysis.found[depType] = [];
        analysis.missing[depType] = [];
        analysis.details[depType] = [];

        dependencies.forEach(dependency => {
            const isFound = this.isDependencyFound(dependency, depType, this.uploadedFiles);
            
            const depInfo = {
                name: dependency,
                found: isFound,
                type: depType,
                searchVariants: this.generateSearchVariants(dependency, depType)
            };

            if (isFound) {
                analysis.found[depType].push(dependency);
                analysis.summary.foundCount++;
            } else {
                analysis.missing[depType].push(dependency);
                analysis.summary.missingCount++;
            }
            
            analysis.details[depType].push(depInfo);
        });
    });

    console.log('Dependency analysis complete:', analysis);
    return analysis;
}
// Generate search variants for dependency matching
generateSearchVariants(dependency, type) {
    const variants = [dependency.toUpperCase()];
    
    if (type === 'copyStatements') {
        const base = dependency.toUpperCase().replace(/\.(CPY|COPYBOOK)$/i, '');
        variants.push(
            base,
            base + '.CPY',
            base + '.COPYBOOK',
            dependency.toUpperCase() + '.CPY',
            dependency.toUpperCase() + '.COPYBOOK'
        );
    }
    
    return [...new Set(variants)];
}

// Build comprehensive context for LLM analysis
buildLLMAnalysisContext(componentName, friendlyName, relevantFiles, dependencies, dependencyAnalysis) {
    const fileContents = relevantFiles.map(file => ({
        name: file.name,
        type: file.type,
        content: file.content.substring(0, 2000), // Limit content for token management
        lines: file.content.split('\n').length
    }));

    const context = {
        component: {
            name: componentName,
            friendlyName: friendlyName,
            type: this.detectComponentType(componentName, relevantFiles)
        },
        files: fileContents,
        dependencies: dependencies,
        dependencyStatus: {
            found: dependencyAnalysis.found,
            missing: dependencyAnalysis.missing,
            summary: dependencyAnalysis.summary
        },
        analysisRequest: {
            timestamp: new Date().toISOString(),
            maxTokens: this.maxTokens,
            analysisScope: 'COMPREHENSIVE'
        }
    };

    return context;
}

async callLLMForComponentAnalysis(context) {
    const prompt = this.buildComponentAnalysisPrompt(context);
    console.log('Built analysis prompt, estimated tokens:', this.estimateTokenCount(prompt));
    
    try {
        const response = await this.callLLMAPI(prompt);
        
        if (response.error) {
            console.warn('LLM call failed, using fallback:', response.message);
            return this.createComponentFallback(
                context.component.name,
                context.component.friendlyName,
                context
            );
        }
        
        return response;
    } catch (error) {
        console.error('LLM analysis failed:', error);
        return this.createComponentFallback(
            context.component.name,
            context.component.friendlyName,
            context
        );
    }
}

// Build the detailed prompt for LLM component analysis
buildComponentAnalysisPrompt(context) {
    const { component, files, dependencies, dependencyStatus } = context;
    
    const prompt = `MAINFRAME COMPONENT ANALYSIS REQUEST

CRITICAL: Respond with valid JSON format only. No markdown, no explanations outside JSON.

COMPONENT DETAILS:
- Name: ${component.name}
- Friendly Name: ${component.friendlyName}
- Type: ${component.type}
- Files Analyzed: ${files.length}

DEPENDENCIES SUMMARY:
- Found: ${dependencyStatus.summary.foundCount}
- Missing: ${dependencyStatus.summary.missingCount}
- Copy Statements: ${(dependencies.copyStatements || []).join(', ')}
- Call Statements: ${(dependencies.callStatements || []).join(', ')}
- File References: ${(dependencies.fileReferences || []).join(', ')}

MISSING DEPENDENCIES:
${Object.entries(dependencyStatus.missing).map(([type, deps]) => 
    `${type}: ${deps.join(', ')}`
).join('\n')}

FILE CONTENTS:
${files.map(file => `
=== ${file.name} (${file.type}) ===
${file.content}
`).join('\n')}

REQUIRED JSON RESPONSE FORMAT:
{
  "componentName": "${component.name}",
  "friendlyName": "${component.friendlyName}",
  "componentType": "${component.type}",
  "analysisScope": "COMPREHENSIVE",
  "businessPurpose": "string - what this component does in business terms",
  "technicalSummary": "string - technical overview of the component",
  "fieldAnalysis": {
    "totalFields": number,
    "keyFields": ["field1", "field2"],
    "calculatedFields": ["field1", "field2"],
    "fieldCategories": {
      "input": ["fields that are input"],
      "output": ["fields that are output"],
      "calculated": ["fields that are calculated"],
      "control": ["fields used for control/validation"]
    }
  },
  "businessRules": [
    {
      "type": "VALIDATION|CALCULATION|CONTROL",
      "description": "string",
      "fields": ["affected fields"],
      "complexity": "LOW|MEDIUM|HIGH"
    }
  ],
  "dependencies": {
    "required": ["critical dependencies"],
    "optional": ["optional dependencies"],
    "missing": ["missing dependencies that impact functionality"],
    "riskAssessment": "LOW|MEDIUM|HIGH"
  },
  "lifecyclePhases": {
    "creation": ["programs/processes that create this data"],
    "processing": ["programs that read/update this data"],
    "output": ["programs that output/report this data"],
    "archival": ["programs that archive/purge this data"]
  },
  "qualityScore": number between 1-10,
  "recommendations": [
    "string - specific actionable recommendations"
  ],
  "modernizationOpportunities": [
    "string - opportunities for modernization"
  ],
  "riskFactors": [
    "string - potential risks or issues identified"
  ]
}

INSTRUCTIONS:
1. Analyze the component thoroughly based on the provided file contents
2. Focus on business value and technical accuracy
3. Identify patterns in field usage and data flow
4. Assess the impact of missing dependencies
5. Provide actionable recommendations
6. Respond with valid JSON only - no additional text`;

    return prompt;
}

// Extract comprehensive dependencies from all relevant files
extractComprehensiveDependencies(relevantFiles, componentName) {
    console.log(`Extracting dependencies for component: ${componentName}`);
    
    const allDependencies = {
        copyStatements: new Set(),
        callStatements: new Set(),
        execStatements: new Set(),
        jclDatasets: new Set(),
        programIds: new Set(),
        sqlTables: new Set(),
        fileReferences: new Set(),
        sourceFiles: []
    };

    relevantFiles.forEach(file => {
        console.log(`Processing file: ${file.name}`);
        const fileDeps = this.extractDependenciesFromFile(file);
        
        // Merge dependencies
        Object.keys(fileDeps).forEach(depType => {
            if (Array.isArray(fileDeps[depType])) {
                fileDeps[depType].forEach(dep => {
                    if (allDependencies[depType]) {
                        allDependencies[depType].add(dep);
                    }
                });
            }
        });
        
        allDependencies.sourceFiles.push({
            name: file.name,
            type: file.type,
            dependencies: fileDeps
        });
    });

    // Convert Sets back to Arrays for easier processing
    Object.keys(allDependencies).forEach(key => {
        if (allDependencies[key] instanceof Set) {
            allDependencies[key] = Array.from(allDependencies[key]);
        }
    });

    console.log('Comprehensive dependencies extracted:', allDependencies);
    return allDependencies;
}

        findRelevantFiles(componentName) {
            return this.uploadedFiles.filter(file => {
                if (file.content.toUpperCase().includes(componentName.toUpperCase()) ||
                    file.name.toUpperCase().includes(componentName.toUpperCase())) {
                    return true;
                }
                
                if (file.components) {
                    return file.components.some(comp => 
                        comp.name.toUpperCase() === componentName.toUpperCase()
                    );
                }
                
                return false;
            });
        }

        detectComponentType(componentName, files) {
            for (const file of files) {
                if (file.components) {
                    const component = file.components.find(c => 
                        c.name.toUpperCase() === componentName.toUpperCase()
                    );
                    if (component) {
                        if (component.type === 'RECORD_LAYOUT') return 'Copybook';
                        if (component.type === 'PROGRAM') return 'COBOL Program';
                        if (component.type === 'FILE') return 'File Definition';
                    }
                }
            }
            
            const copybookFile = files.find(f => f.type === 'Copybook');
            if (copybookFile) return 'Copybook';
            
            const programFile = files.find(f => f.type === 'COBOL Program');
            if (programFile) return 'COBOL Program';
            
            return 'Component';
        }

        displayAnalysisResults(componentName, results, friendlyName) {
            console.log('Displaying analysis results for:', friendlyName || componentName);
            
            // Update the main analysis tab
            const container = document.getElementById('lifecycleContent');
            if (!container) return;
            
            let html = `
                <div class="analysis-header">
                    <h3 class="analysis-title">🤖 Analysis: ${friendlyName || componentName}</h3>
                    <p class="analysis-meta">
                        Component: <strong>${results.componentType}</strong> • 
                        Method: <strong>${results.analysisMethod}</strong> • 
                        Files: <strong>${results.filesAnalyzed.length}</strong> • 
                        Completed: <strong>${new Date(results.timestamp).toLocaleString()}</strong>
                        </p>
                    </div>
                    <!-- Quality Metrics -->
                <div class="metrics-grid">
                    <div class="metric-card">
                        <div class="metric-value">${results.qualityScore}/10</div>
                        <div class="metric-label">Analysis Quality</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${results.completeness.score}%</div>
                        <div class="metric-label">Completeness</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${results.filesAnalyzed.length}</div>
                        <div class="metric-label">Files Analyzed</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${results.dependencyAnalysis.summary.foundCount}</div>
                        <div class="metric-label">Dependencies Found</div>
                    </div>
                </div>
            `;

            // Display dependency analysis
            if (results.dependencyAnalysis) {
                html += this.displayDependencyAnalysis(results.dependencyAnalysis);
            }

            // Display LLM analysis results
            if (results.llmAnalysis) {
                html += this.displayLLMResults(results.llmAnalysis, friendlyName);
            }

            // Display lifecycle flow summary
            if (results.lifecycleFlow) {
                html += this.displayLifecycleFlowSummary(results.lifecycleFlow, friendlyName);
            }
            
            container.innerHTML = html;

            // Update other tabs
            this.displayFieldMatrix(componentName, results, friendlyName);
            this.displayUsagePatterns(componentName, results, friendlyName);
            this.displayDependencies(componentName, results, friendlyName);
            this.displayFileLifecycle(componentName, results, friendlyName);
        }

        displayDependencyAnalysis(dependencyAnalysis) {
            const found = dependencyAnalysis.found || {};
            const missing = dependencyAnalysis.missing || {};
            const summary = dependencyAnalysis.summary || { foundCount: 0, missingCount: 0 };

            return `
                <div class="result-card">
                    <h4>🔗 Dependency Analysis</h4>
                    
                    <!-- Summary -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 20px;">
                        <div style="text-align: center; background: #d1fae5; padding: 12px; border-radius: 6px; border: 1px solid #a7f3d0;">
                            <div style="font-size: 1.5rem; font-weight: bold; color: #065f46;">${summary.foundCount}</div>
                            <div style="font-size: 11px; color: #065f46;">✅ Dependencies Found</div>
                        </div>
                        <div style="text-align: center; background: #fee2e2; padding: 12px; border-radius: 6px; border: 1px solid #fca5a5;">
                            <div style="font-size: 1.5rem; font-weight: bold; color: #991b1b;">${summary.missingCount}</div>
                            <div style="font-size: 11px; color: #991b1b;">❌ Dependencies Missing</div>
                        </div>
                    </div>

                    ${Object.keys(found).length > 0 ? `
                        <div style="margin-bottom: 15px;">
                            <h5 style="color: #065f46; margin-bottom: 10px;">✅ Found Dependencies:</h5>
                            <div style="background: #f0fdf4; padding: 12px; border-radius: 6px; border: 1px solid #bbf7d0;">
                                <div style="font-size: 12px; color: #166534;">
                                    Dependencies are available in uploaded files and can be analyzed.
                                </div>
                            </div>
                        </div>
                    ` : ''}

                    ${Object.keys(missing).length > 0 && Object.values(missing).some(arr => arr && arr.length > 0) ? `
                        <div>
                            <h5 style="color: #991b1b; margin-bottom: 10px;">❌ Missing Dependencies:</h5>
                            <div style="background: #fef2f2; padding: 12px; border-radius: 6px; border: 1px solid #fecaca;">
                                <div style="font-size: 12px; color: #991b1b;">
                                    Some dependencies are referenced but not found in uploaded files.
                                </div>
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        displayLLMResults(llmAnalysis, friendlyName) {
            return `
                <div class="result-card">
                    <h4>🤖 LLM Analysis Results for ${friendlyName}</h4>
                    
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 12px; margin-bottom: 16px;">
                        <div style="background: #eff6ff; padding: 12px; border-radius: 6px; text-align: center; border: 1px solid #bfdbfe;">
                            <div style="font-weight: bold; color: #1d4ed8;">${llmAnalysis.componentType}</div>
                            <div style="font-size: 10px; color: #1e40af;">Component Type</div>
                        </div>
                        <div style="background: #f0f9ff; padding: 12px; border-radius: 6px; text-align: center; border: 1px solid #bae6fd;">
                            <div style="font-weight: bold; color: #0284c7;">${llmAnalysis.analysisScope}</div>
                            <div style="font-size: 10px; color: #0ea5e9;">Analysis Scope</div>
                        </div>
                        <div style="background: #fefce8; padding: 12px; border-radius: 6px; text-align: center; border: 1px solid #fde047;">
                            <div style="font-weight: bold; color: #ca8a04;">${llmAnalysis.qualityScore}/10</div>
                            <div style="font-size: 10px; color: #eab308;">Quality Score</div>
                        </div>
                    </div>

                    ${llmAnalysis.recommendations && llmAnalysis.recommendations.length > 0 ? `
                        <div style="margin-top: 16px;">
                            <h5 style="color: #1e40af; margin-bottom: 10px;">💡 Recommendations:</h5>
                            <div style="background: #fef3c7; padding: 12px; border-radius: 6px; border: 1px solid #fcd34d;">
                                ${llmAnalysis.recommendations.map((rec, index) => `
                                    <div style="margin-bottom: 6px; font-size: 13px; color: #92400e;">
                                        <strong>💡 ${index + 1}.</strong> ${rec}
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        displayLifecycleFlowSummary(lifecycleFlow, friendlyName) {
            return `
                <div class="result-card">
                    <h4>🌊 Lifecycle Summary for ${friendlyName}</h4>
                    
                    <!-- Usage Pattern -->
                    <div style="margin-bottom: 16px; text-align: center;">
                        <span style="background: #3b82f6; color: white; padding: 8px 16px; border-radius: 8px; font-weight: bold;">
                            ${(lifecycleFlow.usagePattern || 'ANALYZED').replace(/_/g, ' ')}
                        </span>
                    </div>

                    <!-- Lifecycle Metrics -->
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 12px;">
                        <div style="text-align: center; background: #ecfdf5; padding: 12px; border-radius: 6px; border: 1px solid #a7f3d0;">
                            <div style="font-size: 1.2rem; font-weight: bold; color: #059669;">${(lifecycleFlow.creationSources || []).length}</div>
                            <div style="font-size: 10px; color: #065f46;">🌱 Creation</div>
                        </div>
                        <div style="text-align: center; background: #eff6ff; padding: 12px; border-radius: 6px; border: 1px solid #bfdbfe;">
                            <div style="font-size: 1.2rem; font-weight: bold; color: #2563eb;">${(lifecycleFlow.inputPrograms || []).length}</div>
                            <div style="font-size: 10px; color: #1d4ed8;">📖 Reading</div>
                        </div>
                        <div style="text-align: center; background: #fffbeb; padding: 12px; border-radius: 6px; border: 1px solid #fcd34d;">
                            <div style="font-size: 1.2rem; font-weight: bold; color: #d97706;">${(lifecycleFlow.updatePrograms || []).length}</div>
                            <div style="font-size: 10px; color: #92400e;">⚙️ Updating</div>
                        </div>
                        <div style="text-align: center; background: #fdf4ff; padding: 12px; border-radius: 6px; border: 1px solid #e9d5ff;">
                            <div style="font-size: 1.2rem; font-weight: bold; color: #7c3aed;">${(lifecycleFlow.cicsScreens || []).length + (lifecycleFlow.batchJobs || []).length}</div>
                            <div style="font-size: 10px; color: #6b21a8;">📤 Output</div>
                        </div>
                    </div>
                </div>
            `;
        }

        displayFieldMatrix(componentName, results, friendlyName) {
            const container = document.getElementById('fieldMatrixContent');
            if (!container) return;
            
            let html = `
                <div class="analysis-header">
                    <h3 class="analysis-title">📋 Field Matrix: ${friendlyName}</h3>
                    <p class="analysis-meta">Field-level analysis with lifecycle context for ${friendlyName}.</p>
                </div>
                
                <div class="result-card text-center">
                    <h4>🔬 Enhanced Field Analysis</h4>
                    <p>Field matrix analysis for ${friendlyName} will be displayed here with:</p>
                    <ul style="text-align: left; margin: 16px 0; color: #6b7280;">
                        <li>• Field-level lifecycle tracking</li>
                        <li>• Usage pattern categorization</li>
                        <li>• Business purpose mapping</li>
                        <li>• Cross-program field flow</li>
                    </ul>
                    <p style="font-size: 12px; color: #9ca3af;">Detailed field matrix will appear after enhanced analysis.</p>
                </div>
            `;
            
            container.innerHTML = html;
        }

        displayUsagePatterns(componentName, results, friendlyName) {
            const container = document.getElementById('usageContent');
            if (!container) return;
            
            let html = `
                <div class="analysis-header">
                    <h3 class="analysis-title">📈 Usage Patterns: ${friendlyName}</h3>
                    <p class="analysis-meta">Component usage pattern analysis for ${friendlyName}.</p>
                </div>
                
                <div class="result-card">
                    <h4>📊 Pattern Analysis for ${friendlyName}</h4>
                    
                    <div style="background: #f8fafc; padding: 16px; border-radius: 8px; border: 1px solid #e2e8f0;">
                        <div style="text-align: center; margin-bottom: 16px;">
                            <span style="background: #3b82f6; color: white; padding: 8px 16px; border-radius: 6px; font-weight: bold;">
                                ${results.lifecycleFlow?.usagePattern || 'ANALYZED'}
                            </span>
                        </div>
                        
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px;">
                            <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #d1d5db;">
                                <h6 style="color: #059669; margin-bottom: 8px;">🌱 Creation Patterns</h6>
                                <p style="font-size: 12px; color: #6b7280;">Programs that create or initialize ${friendlyName}</p>
                            </div>
                            
                            <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #d1d5db;">
                                <h6 style="color: #2563eb; margin-bottom: 8px;">📖 Access Patterns</h6>
                                <p style="font-size: 12px; color: #6b7280;">How programs read and access ${friendlyName}</p>
                            </div>
                            
                            <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #d1d5db;">
                                <h6 style="color: #d97706; margin-bottom: 8px;">⚙️ Update Patterns</h6>
                                <p style="font-size: 12px; color: #6b7280;">Modification and update operations on ${friendlyName}</p>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            container.innerHTML = html;
        }

        displayDependencies(componentName, results, friendlyName) {
            const container = document.getElementById('dependenciesContent');
            if (!container) return;
            
            let html = `
                <div class="analysis-header">
                    <h3 class="analysis-title">🔗 Dependencies: ${friendlyName}</h3>
                    <p class="analysis-meta">Found vs missing dependencies for ${friendlyName}.</p>
                </div>
            `;
            
            if (results.dependencyAnalysis) {
                html += this.displayDependencyAnalysis(results.dependencyAnalysis);
            } else {
                html += `
                    <div class="result-card text-center">
                        <p style="opacity: 0.8;">Dependency analysis for ${friendlyName} will appear here after component analysis.</p>
                    </div>
                `;
            }
            
            container.innerHTML = html;
        }

        displayFileLifecycle(componentName, results, friendlyName) {
            const container = document.getElementById('fileflowContent');
            if (!container) return;
            
            let html = `
                <div class="analysis-header">
                    <h3 class="analysis-title">🌊 File Lifecycle: ${friendlyName}</h3>
                    <p class="analysis-meta">Complete lifecycle from creation through usage patterns for ${friendlyName}.</p>
                </div>
                
                <!-- Dynamic Flow Diagram -->
                <div class="flow-diagram">
                    <h4 style="color: #1e40af; margin-bottom: 16px; text-center;">📊 Dynamic Lifecycle Flow for ${friendlyName}</h4>
                    <div class="flow-container">
                        <div class="flow-stage creation">
                            <div class="flow-stage-title">🌱 Creation</div>
                            <div class="flow-count">${(results.lifecycleFlow?.creationSources || []).length}</div>
                            <div class="flow-programs">${(results.lifecycleFlow?.creationSources || []).slice(0, 2).map(s => s.program || 'Unknown').join(', ') || 'No programs'}</div>
                            <div class="flow-arrow"></div>
                        </div>
                        
                        <div class="flow-stage processing">
                            <div class="flow-stage-title">⚙️ Processing</div>
                            <div class="flow-count">${((results.lifecycleFlow?.inputPrograms || []).length + (results.lifecycleFlow?.updatePrograms || []).length)}</div>
                            <div class="flow-programs">Read & Update</div>
                            <div class="flow-arrow"></div>
                        </div>
                        
                        <div class="flow-stage output">
                            <div class="flow-stage-title">📤 Output</div>
                            <div class="flow-count">${((results.lifecycleFlow?.cicsScreens || []).length + (results.lifecycleFlow?.batchJobs || []).length)}</div>
                            <div class="flow-programs">CICS & Batch</div>
                        </div>
                    </div>
                </div>
                
                <div class="result-card">
                    <h4>🌊 Detailed Lifecycle Flow for ${friendlyName}</h4>
                    <p>Complete file lifecycle analysis showing how ${friendlyName} moves through the system:</p>
                    
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 16px; margin-top: 16px;">
                        <div style="background: #ecfdf5; padding: 16px; border-radius: 8px; border-left: 4px solid #059669;">
                            <h6 style="color: #059669; margin-bottom: 8px;">🌱 Creation Phase</h6>
                            <p style="font-size: 12px; color: #065f46;">
                                Programs and processes that create or initialize ${friendlyName} data.
                            </p>
                        </div>
                        
                        <div style="background: #eff6ff; padding: 16px; border-radius: 8px; border-left: 4px solid #2563eb;">
                            <h6 style="color: #2563eb; margin-bottom: 8px;">⚙️ Processing Phase</h6>
                            <p style="font-size: 12px; color: #1d4ed8;">
                                Programs that read, validate, and update ${friendlyName} throughout its lifecycle.
                            </p>
                        </div>
                        
                        <div style="background: #fef2f2; padding: 16px; border-radius: 8px; border-left: 4px solid #dc2626;">
                            <h6 style="color: #dc2626; margin-bottom: 8px;">📤 Output Phase</h6>
                            <p style="font-size: 12px; color: #991b1b;">
                                Final processing, reporting, and archival of ${friendlyName} data.
                            </p>
                            <!-- Quality Metrics -->
                <div class="metrics-grid">
                    <div class="metric-card">
                        <div class="metric-value">${results.qualityScore}/10</div>
                        <div class="metric-label">Analysis Quality</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${results.completeness.score}%</div>
                        <div class="metric-label">Completeness</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${results.filesAnalyzed.length}</div>
                        <div class="metric-label">Files Analyzed</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${results.dependencyAnalysis.summary.foundCount}</div>
                        <div class="metric-label">Dependencies Found</div>
                    </div>
                </div>
            `;

            // Display dependency analysis
            if (results.dependencyAnalysis) {
                html += this.displayDependencyAnalysis(results.dependencyAnalysis);
            }

            // Display LLM analysis results
            if (results.llmAnalysis) {
                html += this.displayLLMResults(results.llmAnalysis, friendlyName);
            }

            // Display lifecycle flow summary
            if (results.lifecycleFlow) {
                html += this.displayLifecycleFlowSummary(results.lifecycleFlow, friendlyName);
            }
            
            container.innerHTML = html;

            // Update other tabs
            this.displayFieldMatrix(componentName, results, friendlyName);
            this.displayUsagePatterns(componentName, results, friendlyName);
            this.displayDependencies(componentName, results, friendlyName);
            this.displayFileLifecycle(componentName, results, friendlyName);
        }

        displayDependencyAnalysis(dependencyAnalysis) {
            const found = dependencyAnalysis.found || {};
            const missing = dependencyAnalysis.missing || {};
            const summary = dependencyAnalysis.summary || { foundCount: 0, missingCount: 0 };

            return `
                <div class="result-card">
                    <h4>🔗 Dependency Analysis</h4>
                    
                    <!-- Summary -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 20px;">
                        <div style="text-align: center; background: #d1fae5; padding: 12px; border-radius: 6px; border: 1px solid #a7f3d0;">
                            <div style="font-size: 1.5rem; font-weight: bold; color: #065f46;">${summary.foundCount}</div>
                            <div style="font-size: 11px; color: #065f46;">✅ Dependencies Found</div>
                        </div>
                        <div style="text-align: center; background: #fee2e2; padding: 12px; border-radius: 6px; border: 1px solid #fca5a5;">
                            <div style="font-size: 1.5rem; font-weight: bold; color: #991b1b;">${summary.missingCount}</div>
                            <div style="font-size: 11px; color: #991b1b;">❌ Dependencies Missing</div>
                        </div>
                    </div>

                    ${Object.keys(found).length > 0 ? `
                        <div style="margin-bottom: 15px;">
                            <h5 style="color: #065f46; margin-bottom: 10px;">✅ Found Dependencies:</h5>
                            <div style="background: #f0fdf4; padding: 12px; border-radius: 6px; border: 1px solid #bbf7d0;">
                                <div style="font-size: 12px; color: #166534;">
                                    Dependencies are available in uploaded files and can be analyzed.
                                </div>
                            </div>
                        </div>
                    ` : ''}

                    ${Object.keys(missing).length > 0 && Object.values(missing).some(arr => arr && arr.length > 0) ? `
                        <div>
                            <h5 style="color: #991b1b; margin-bottom: 10px;">❌ Missing Dependencies:</h5>
                            <div style="background: #fef2f2; padding: 12px; border-radius: 6px; border: 1px solid #fecaca;">
                                <div style="font-size: 12px; color: #991b1b;">
                                    Some dependencies are referenced but not found in uploaded files.
                                </div>
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        displayLLMResults(llmAnalysis, friendlyName) {
            return `
                <div class="result-card">
                    <h4>🤖 LLM Analysis Results for ${friendlyName}</h4>
                    
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 12px; margin-bottom: 16px;">
                        <div style="background: #eff6ff; padding: 12px; border-radius: 6px; text-align: center; border: 1px solid #bfdbfe;">
                            <div style="font-weight: bold; color: #1d4ed8;">${llmAnalysis.componentType}</div>
                            <div style="font-size: 10px; color: #1e40af;">Component Type</div>
                        </div>
                        <div style="background: #f0f9ff; padding: 12px; border-radius: 6px; text-align: center; border: 1px solid #bae6fd;">
                            <div style="font-weight: bold; color: #0284c7;">${llmAnalysis.analysisScope}</div>
                            <div style="font-size: 10px; color: #0ea5e9;">Analysis Scope</div>
                        </div>
                        <div style="background: #fefce8; padding: 12px; border-radius: 6px; text-align: center; border: 1px solid #fde047;">
                            <div style="font-weight: bold; color: #ca8a04;">${llmAnalysis.qualityScore}/10</div>
                            <div style="font-size: 10px; color: #eab308;">Quality Score</div>
                        </div>
                    </div>

                    ${llmAnalysis.recommendations && llmAnalysis.recommendations.length > 0 ? `
                        <div style="margin-top: 16px;">
                            <h5 style="color: #1e40af; margin-bottom: 10px;">💡 Recommendations:</h5>
                            <div style="background: #fef3c7; padding: 12px; border-radius: 6px; border: 1px solid #fcd34d;">
                                ${llmAnalysis.recommendations.map((rec, index) => `
                                    <div style="margin-bottom: 6px; font-size: 13px; color: #92400e;">
                                        <strong>💡 ${index + 1}.</strong> ${rec}
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        displayLifecycleFlowSummary(lifecycleFlow, friendlyName) {
            return `
                <div class="result-card">
                    <h4>🌊 Lifecycle Summary for ${friendlyName}</h4>
                    
                    <!-- Usage Pattern -->
                    <div style="margin-bottom: 16px; text-align: center;">
                        <span style="background: #3b82f6; color: white; padding: 8px 16px; border-radius: 8px; font-weight: bold;">
                            ${(lifecycleFlow.usagePattern || 'ANALYZED').replace(/_/g, ' ')}
                        </span>
                    </div>

                    <!-- Lifecycle Metrics -->
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 12px;">
                        <div style="text-align: center; background: #ecfdf5; padding: 12px; border-radius: 6px; border: 1px solid #a7f3d0;">
                            <div style="font-size: 1.2rem; font-weight: bold; color: #059669;">${(lifecycleFlow.creationSources || []).length}</div>
                            <div style="font-size: 10px; color: #065f46;">🌱 Creation</div>
                        </div>
                        <div style="text-align: center; background: #eff6ff; padding: 12px; border-radius: 6px; border: 1px solid #bfdbfe;">
                            <div style="font-size: 1.2rem; font-weight: bold; color: #2563eb;">${(lifecycleFlow.inputPrograms || []).length}</div>
                            <div style="font-size: 10px; color: #1d4ed8;">📖 Reading</div>
                        </div>
                        <div style="text-align: center; background: #fffbeb; padding: 12px; border-radius: 6px; border: 1px solid #fcd34d;">
                            <div style="font-size: 1.2rem; font-weight: bold; color: #d97706;">${(lifecycleFlow.updatePrograms || []).length}</div>
                            <div style="font-size: 10px; color: #92400e;">⚙️ Updating</div>
                        </div>
                        <div style="text-align: center; background: #fdf4ff; padding: 12px; border-radius: 6px; border: 1px solid #e9d5ff;">
                            <div style="font-size: 1.2rem; font-weight: bold; color: #7c3aed;">${(lifecycleFlow.cicsScreens || []).length + (lifecycleFlow.batchJobs || []).length}</div>
                            <div style="font-size: 10px; color: #6b21a8;">📤 Output</div>
                        </div>
                    </div>
                </div>
            `;
        }

        displayFieldMatrix(componentName, results, friendlyName) {
            const container = document.getElementById('fieldMatrixContent');
            if (!container) return;
            
            let html = `
                <div class="analysis-header">
                    <h3 class="analysis-title">📋 Field Matrix: ${friendlyName}</h3>
                    <p class="analysis-meta">Field-level analysis with lifecycle context for ${friendlyName}.</p>
                </div>
                
                <div class="result-card text-center">
                    <h4>🔬 Enhanced Field Analysis</h4>
                    <p>Field matrix analysis for ${friendlyName} will be displayed here with:</p>
                    <ul style="text-align: left; margin: 16px 0; color: #6b7280;">
                        <li>• Field-level lifecycle tracking</li>
                        <li>• Usage pattern categorization</li>
                        <li>• Business purpose mapping</li>
                        <li>• Cross-program field flow</li>
                    </ul>
                    <p style="font-size: 12px; color: #9ca3af;">Detailed field matrix will appear after enhanced analysis.</p>
                </div>
            `;
            
            container.innerHTML = html;
        }

        displayUsagePatterns(componentName, results, friendlyName) {
            const container = document.getElementById('usageContent');
            if (!container) return;
            
            let html = `
                <div class="analysis-header">
                    <h3 class="analysis-title">📈 Usage Patterns: ${friendlyName}</h3>
                    <p class="analysis-meta">Component usage pattern analysis for ${friendlyName}.</p>
                </div>
                
                <div class="result-card">
                    <h4>📊 Pattern Analysis for ${friendlyName}</h4>
                    
                    <div style="background: #f8fafc; padding: 16px; border-radius: 8px; border: 1px solid #e2e8f0;">
                        <div style="text-align: center; margin-bottom: 16px;">
                            <span style="background: #3b82f6; color: white; padding: 8px 16px; border-radius: 6px; font-weight: bold;">
                                ${results.lifecycleFlow?.usagePattern || 'ANALYZED'}
                            </span>
                        </div>
                        
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px;">
                            <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #d1d5db;">
                                <h6 style="color: #059669; margin-bottom: 8px;">🌱 Creation Patterns</h6>
                                <p style="font-size: 12px; color: #6b7280;">Programs that create or initialize ${friendlyName}</p>
                            </div>
                            
                            <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #d1d5db;">
                                <h6 style="color: #2563eb; margin-bottom: 8px;">📖 Access Patterns</h6>
                                <p style="font-size: 12px; color: #6b7280;">How programs read and access ${friendlyName}</p>
                            </div>
                            
                            <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #d1d5db;">
                                <h6 style="color: #d97706; margin-bottom: 8px;">⚙️ Update Patterns</h6>
                                <p style="font-size: 12px; color: #6b7280;">Modification and update operations on ${friendlyName}</p>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            container.innerHTML = html;
        }

        displayDependencies(componentName, results, friendlyName) {
            const container = document.getElementById('dependenciesContent');
            if (!container) return;
            
            let html = `
                <div class="analysis-header">
                    <h3 class="analysis-title">🔗 Dependencies: ${friendlyName}</h3>
                    <p class="analysis-meta">Found vs missing dependencies for ${friendlyName}.</p>
                </div>
            `;
            
            if (results.dependencyAnalysis) {
                html += this.displayDependencyAnalysis(results.dependencyAnalysis);
            } else {
                html += `
                    <div class="result-card text-center">
                        <p style="opacity: 0.8;">Dependency analysis for ${friendlyName} will appear here after component analysis.</p>
                    </div>
                `;
            }
            
            container.innerHTML = html;
        }

        displayFileLifecycle(componentName, results, friendlyName) {
            const container = document.getElementById('fileflowContent');
            if (!container) return;
            
            let html = `
                <div class="analysis-header">
                    <h3 class="analysis-title">🌊 File Lifecycle: ${friendlyName}</h3>
                    <p class="analysis-meta">Complete lifecycle from creation through usage patterns for ${friendlyName}.</p>
                </div>
                
                <!-- Dynamic Flow Diagram -->
                <div class="flow-diagram">
                    <h4 style="color: #1e40af; margin-bottom: 16px; text-center;">📊 Dynamic Lifecycle Flow for ${friendlyName}</h4>
                    <div class="flow-container">
                        <div class="flow-stage creation">
                            <div class="flow-stage-title">🌱 Creation</div>
                            <div class="flow-count">${(results.lifecycleFlow?.creationSources || []).length}</div>
                            <div class="flow-programs">${(results.lifecycleFlow?.creationSources || []).slice(0, 2).map(s => s.program || 'Unknown').join(', ') || 'No programs'}</div>
                            <div class="flow-arrow"></div>
                        </div>
                        
                        <div class="flow-stage processing">
                            <div class="flow-stage-title">⚙️ Processing</div>
                            <div class="flow-count">${((results.lifecycleFlow?.inputPrograms || []).length + (results.lifecycleFlow?.updatePrograms || []).length)}</div>
                            <div class="flow-programs">Read & Update</div>
                            <div class="flow-arrow"></div>
                        </div>
                        
                        <div class="flow-stage output">
                            <div class="flow-stage-title">📤 Output</div>
                            <div class="flow-count">${((results.lifecycleFlow?.cicsScreens || []).length + (results.lifecycleFlow?.batchJobs || []).length)}</div>
                            <div class="flow-programs">CICS & Batch</div>
                        </div>
                    </div>
                </div>
                
                <div class="result-card">
                    <h4>🌊 Detailed Lifecycle Flow for ${friendlyName}</h4>
                    <p>Complete file lifecycle analysis showing how ${friendlyName} moves through the system:</p>
                    
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 16px; margin-top: 16px;">
                        <div style="background: #ecfdf5; padding: 16px; border-radius: 8px; border-left: 4px solid #059669;">
                            <h6 style="color: #059669; margin-bottom: 8px;">🌱 Creation Phase</h6>
                            <p style="font-size: 12px; color: #065f46;">
                                Programs and processes that create or initialize ${friendlyName} data.
                            </p>
                        </div>
                        
                        <div style="background: #eff6ff; padding: 16px; border-radius: 8px; border-left: 4px solid #2563eb;">
                            <h6 style="color: #2563eb; margin-bottom: 8px;">⚙️ Processing Phase</h6>
                            <p style="font-size: 12px; color: #1d4ed8;">
                                Programs that read, validate, and update ${friendlyName} throughout its lifecycle.
                            </p>
                        </div>
                        
                        <div style="background: #fef2f2; padding: 16px; border-radius: 8px; border-left: 4px solid #dc2626;">
                            <h6 style="color: #dc2626; margin-bottom: 8px;">📤 Output Phase</h6>
                            <p style="font-size: 12px; color: #991b1b;">
                                Final processing, reporting, and archival of ${friendlyName} data.
                            </p>
                        </div>
                    </div>
                </div>
            `;
            
            container.innerHTML = html;
        }

        /* ===================================================================
        EXPORT FUNCTIONALITY
        ================================================================== */
        async exportResults(format) {
            if (Object.keys(this.analysisResults).length === 0) {
                this.showError('No analysis results to export');
                return;
            }

            try {
                if (format === 'json') {
                    await this.exportAsJSON();
                } else if (format === 'markdown') {
                    await this.exportAsMarkdown();
                }
            } catch (error) {
                this.showError(`Export failed: ${error.message}`);
            }
        }

        async exportAsJSON() {
            const exportData = {
                metadata: {
                    timestamp: new Date().toISOString(),
                    totalComponents: Object.keys(this.analysisResults).length,
                    totalFiles: this.uploadedFiles.length,
                    analysisMethod: 'LLM-Enhanced-Redesigned-UI',
                    version: '2.0.0-redesigned'
                },
                analysisResults: this.analysisResults,
                chatHistory: this.chatHistory
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const filename = `mainframe-analysis-${new Date().toISOString().split('T')[0]}.json`;
            
            this.downloadTextFile(dataStr, filename);
            this.showSuccess(`📋 Analysis results exported as ${filename}`);
        }

        async exportAsMarkdown() {
            let markdown = `# Mainframe Component Analysis Report\n\n`;
            markdown += `**Generated:** ${new Date().toLocaleString()}\n`;
            markdown += `**Analysis Method:** LLM-Enhanced Redesigned UI\n\n`;

            for (const [componentName, results] of Object.entries(this.analysisResults)) {
                const friendlyName = results.friendlyName || componentName;
                markdown += `## ${friendlyName} (${componentName})\n\n`;
                markdown += `**Type:** ${results.componentType}\n`;
                markdown += `**Quality Score:** ${results.qualityScore}/10\n`;
                markdown += `**Usage Pattern:** ${results.lifecycleFlow?.usagePattern || 'N/A'}\n\n`;
                
                if (results.llmAnalysis?.recommendations) {
                    markdown += `**Recommendations:**\n`;
                    results.llmAnalysis.recommendations.forEach(rec => {
                        markdown += `- ${rec}\n`;
                    });
                }
                markdown += '\n---\n\n';
            }
            
            const filename = `mainframe-analysis-report-${new Date().toISOString().split('T')[0]}.md`;
            this.downloadTextFile(markdown, filename);
            this.showSuccess(`📝 Analysis report exported as ${filename}`);
        }

        downloadTextFile(content, filename) {
            const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        /* ===================================================================
        BULK ANALYSIS
        ================================================================== */
        async bulkAnalyze() {
            if (this.uploadedFiles.length === 0) {
                this.showError('No files uploaded for bulk analysis');
                return;
            }

            this.showLoading();
            this.updateLoadingStatus('🔄 Starting bulk analysis...');

            const components = this.componentSuggestions
                .filter(c => c.type === 'RECORD_LAYOUT' || c.type === 'PROGRAM')
                .slice(0, 5);
            let completed = 0;

            try {
                for (const component of components) {
                    this.updateLoadingStatus(`Analyzing ${component.name} (${completed + 1}/${components.length})...`);
                    this.updateProgress((completed / components.length) * 100);
                    
                    try {
                        document.getElementById('componentName').value = component.name;
                        const friendlyName = this.generateFriendlyName(component.name);
                        document.getElementById('friendlyName').value = friendlyName;
                        
                        const results = await this.runLLMEnhancedAnalysisWithLifecycle(component.name, friendlyName);
                        this.analysisResults[component.name] = results;
                        completed++;
                        
                        await this.sleep(2000); // Reduced wait time
                    } catch (error) {
                        console.warn(`Failed to analyze ${component.name}:`, error);
                    }
                }

                this.hideLoading();
                this.saveToStorage();
                this.showSuccess(`✨ Bulk analysis complete! ${completed}/${components.length} components analyzed`);

            } catch (error) {
                this.hideLoading();
                this.showError(`Bulk analysis failed: ${error.message}`);
            }
        }

        /* ===================================================================
        CLEAR DATA
        ================================================================== */
        clearAllData() {
            if (confirm('Are you sure you want to clear all analysis data? This cannot be undone.')) {
                this.uploadedFiles = [];
                this.analysisResults = {};
                this.componentSuggestions = [];
                this.currentAnalyzedComponent = null;
                this.chatHistory = [];
                
                // Clear storage
                try {
                    localStorage.removeItem(this.storageKey);
                    sessionStorage.removeItem(this.storageKey);
                } catch (e) {
                    console.warn('Failed to clear storage:', e);
                }
                
                this.displayUploadedFiles();
                this.validateForm();
                
                // Reset UI components
                const componentNameInput = document.getElementById('componentName');
                const friendlyNameInput = document.getElementById('friendlyName');
                if (componentNameInput) componentNameInput.value = '';
                if (friendlyNameInput) friendlyNameInput.value = '';
                
                // Reset chat area
                const chatMessages = document.getElementById('chatMessages');
                if (chatMessages) {
                    chatMessages.innerHTML = `
                        <div class="chat-message assistant">
                            <div class="chat-sender">Analysis Assistant</div>
                            <div class="chat-content">
                                👋 <strong>Welcome to Enhanced Mainframe Analysis!</strong>
                                <br><br>Upload files and analyze a component to get started.
                            </div>
                            <div class="chat-timestamp">${new Date().toLocaleTimeString()}</div>
                        </div>
                    `;
                }
                
                // Disable chat input
                const chatInput = document.getElementById('chatInput');
                const chatSendBtn = document.getElementById('chatSendBtn');
                const chatSuggestions = document.getElementById('chatSuggestions');
                if (chatInput) chatInput.disabled = true;
                if (chatSendBtn) chatSendBtn.disabled = true;
                if (chatSuggestions) chatSuggestions.style.display = 'none';
                
                // Reset flow diagram
                this.updateFlowDiagram({
                    creationSources: [],
                    inputPrograms: [],
                    updatePrograms: [],
                    cicsScreens: [],
                    batchJobs: []
                });
                
                this.showSuccess('🗑️ All analysis data cleared successfully');
            }
        }

        /* ===================================================================
        UTILITY METHODS
        ================================================================== */
        sleep(ms) { 
            return new Promise(resolve => setTimeout(resolve, ms)); 
        }

        // Simplified LLM API call - in real implementation, include full LLM integration
        async callLLMAPI(prompt, retries = 0) {
    let resultText = '';
    
    try {
        console.log(`Making LLM API call attempt ${retries + 1}...`);
        
        // Intelligent token estimation and chunking
        const estimatedTokens = this.estimateTokenCount(prompt);
        console.log(`Estimated tokens: ${estimatedTokens}, Max allowed: ${this.maxTokens}`);
        
        let processedPrompt = prompt;
        
        // If prompt exceeds token limit, apply intelligent chunking
        if (estimatedTokens > this.maxTokens * 0.8) {
            console.log('Applying intelligent chunking...');
            processedPrompt = await this.applyIntelligentChunking(prompt);
        }
        
        const response = await fetch(`${this.vllmEndpoint}/generate`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                prompt: processedPrompt,
                max_tokens: Math.min(this.maxTokens * 0.8, 4000),
                temperature: 0.1,
                top_p: 0.9,
                stop: [],
                stream: false,
                frequency_penalty: 0.1,
                presence_penalty: 0.0
            }),
            signal: AbortSignal.timeout(90000) // 90 second timeout
        });

        if (!response.ok) {
            throw new Error(`LLM API request failed: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();
        console.log('LLM API Response received, keys:', Object.keys(data));
        
        // Extract text from various response formats
        if (data.text) {
            resultText = data.text.trim();
        } else if (data.choices && data.choices.length > 0) {
            if (data.choices[0].text) {
                resultText = data.choices[0].text.trim();
            } else if (data.choices[0].message && data.choices[0].message.content) {
                resultText = data.choices[0].message.content.trim();
            }
        } else if (data.generated_text) {
            resultText = data.generated_text.trim();
        } else if (data.response) {
            resultText = data.response.trim();
        } else if (typeof data === 'string') {
            resultText = data.trim();
        }

        if (!resultText) {
            throw new Error('No valid text content in LLM response');
        }

        console.log(`LLM response length: ${resultText.length} chars`);
        
        // Update token display
        this.updateTokenDisplay(this.estimateTokenCount(processedPrompt + resultText));

        // Parse the response
        const parseResult = this.parseJSONResponse(resultText);
        
        if (parseResult.success) {
            console.log('LLM JSON parsing successful');
            return parseResult.data;
        } else {
            console.warn('LLM JSON parsing failed, using fallback');
            if (parseResult.fallbackData) {
                parseResult.fallbackData.rawResponse = resultText.substring(0, 1000);
                parseResult.fallbackData.parseError = parseResult.error;
                return parseResult.fallbackData;
            } else {
                throw new Error(`JSON parsing failed: ${parseResult.error}`);
            }
        }

    } catch (error) {
        console.error(`LLM API call attempt ${retries + 1} failed:`, error);
        
        if (retries < 2) {
            console.log(`Retrying LLM API call (${retries + 1}/2)...`);
            await this.sleep(2000 * (retries + 1));
            return this.callLLMAPI(prompt, retries + 1);
        }
        
        return {
            error: true,
            message: error.message,
            fallbackData: this.createComponentFallback(
                this.currentAnalyzedComponent || 'Unknown',
                'Unknown',
                null
            )
        };
    }
}

/* ===================================================================
ENHANCED MAINFRAME ANALYZER - INTELLIGENT CHUNKING AND CHAT
Part 3: Advanced Token Management and Enhanced Chat with LLM
================================================================== */

// Enhanced intelligent chunking with priority-based content selection
async applyIntelligentChunking(prompt) {
    console.log('🔄 Applying intelligent chunking to optimize token usage...');
    
    // Parse prompt into sections
    const sections = this.parsePromptSections(prompt);
    console.log('📋 Parsed sections:', Object.keys(sections));
    
    // Calculate token budgets
    const tokenBudget = this.calculateTokenBudgets();
    console.log('💰 Token budget:', tokenBudget);
    
    // Build optimized prompt
    const optimizedPrompt = this.buildOptimizedPrompt(sections, tokenBudget);
    
    const finalTokenCount = this.estimateTokenCount(optimizedPrompt);
    console.log(`✅ Chunking complete: ${finalTokenCount} tokens (target: ${this.maxTokens * 0.7})`);
    
    return optimizedPrompt;
}

// Parse prompt into manageable sections
parsePromptSections(prompt) {
    const sections = {
        instructions: '',
        component: '',
        dependencies: '',
        fileContents: '',
        jsonFormat: ''
    };
    
    const lines = prompt.split('\n');
    let currentSection = 'instructions';
    
    lines.forEach(line => {
        if (line.includes('COMPONENT DETAILS:')) {
            currentSection = 'component';
        } else if (line.includes('DEPENDENCIES SUMMARY:')) {
            currentSection = 'dependencies';
        } else if (line.includes('FILE CONTENTS:')) {
            currentSection = 'fileContents';
        } else if (line.includes('REQUIRED JSON RESPONSE')) {
            currentSection = 'jsonFormat';
        }
        
        sections[currentSection] += line + '\n';
    });
    
    return sections;
}

// Calculate token budgets for different sections
calculateTokenBudgets() {
    const maxTokens = this.maxTokens * 0.7; // 70% for input, 30% for response
    
    return {
        total: maxTokens,
        instructions: Math.floor(maxTokens * 0.2), // 20% for instructions
        component: Math.floor(maxTokens * 0.1),    // 10% for component details
        dependencies: Math.floor(maxTokens * 0.15), // 15% for dependencies
        fileContents: Math.floor(maxTokens * 0.45), // 45% for file contents
        jsonFormat: Math.floor(maxTokens * 0.1)     // 10% for JSON format
    };
}

// Build optimized prompt within token limits
buildOptimizedPrompt(sections, budget) {
    let optimizedPrompt = '';
    
    // Always include full instructions and JSON format
    optimizedPrompt += this.limitSectionTokens(sections.instructions, budget.instructions);
    optimizedPrompt += this.limitSectionTokens(sections.component, budget.component);
    optimizedPrompt += this.limitSectionTokens(sections.dependencies, budget.dependencies);
    
    // Smart chunking for file contents
    const chunkedFileContents = this.chunkFileContents(sections.fileContents, budget.fileContents);
    optimizedPrompt += chunkedFileContents;
    
    optimizedPrompt += this.limitSectionTokens(sections.jsonFormat, budget.jsonFormat);
    
    return optimizedPrompt;
}

// Limit section to token budget
limitSectionTokens(content, maxTokens) {
    const currentTokens = this.estimateTokenCount(content);
    
    if (currentTokens <= maxTokens) {
        return content;
    }
    
    // Truncate content to fit token budget
    const targetChars = Math.floor(maxTokens * this.averageCharsPerToken * 0.9);
    const truncated = content.substring(0, targetChars);
    
    return truncated + '\n[Content truncated for token optimization]\n';
}

// Advanced file content chunking with priority preservation
chunkFileContents(fileContents, maxTokens) {
    console.log('📁 Chunking file contents...');
    
    const lines = fileContents.split('\n');
    let chunkedContent = 'FILE CONTENTS:\n';
    let currentTokens = this.estimateTokenCount(chunkedContent);
    
    // Priority patterns for important lines
    const priorityPatterns = [
        { pattern: /01\s+[A-Z][A-Z0-9\-_]+/, priority: 10, label: 'COBOL 01-level' },
        { pattern: /PROGRAM-ID\.?\s+[A-Z][A-Z0-9\-_]+/, priority: 9, label: 'Program ID' },
        { pattern: /COPY\s+[A-Z][A-Z0-9\-_]+/, priority: 8, label: 'Copy statement' },
        { pattern: /CALL\s+['"]*[A-Z][A-Z0-9\-_]+/, priority: 7, label: 'Call statement' },
        { pattern: /FD\s+[A-Z][A-Z0-9\-_]+/, priority: 6, label: 'File definition' },
        { pattern: /EXEC\s+CICS/, priority: 5, label: 'CICS command' },
        { pattern: /WORKING-STORAGE|LINKAGE/, priority: 4, label: 'Storage section' },
        { pattern: /PROCEDURE\s+DIVISION/, priority: 3, label: 'Procedure division' }
    ];
    
    // Categorize lines by priority
    const categorizedLines = lines.map(line => {
        const trimmed = line.trim().toUpperCase();
        let priority = 0;
        let label = 'Regular code';
        
        for (const pattern of priorityPatterns) {
            if (pattern.pattern.test(trimmed)) {
                priority = pattern.priority;
                label = pattern.label;
                break;
            }
        }
        
        return {
            original: line,
            trimmed: trimmed,
            priority: priority,
            label: label,
            tokens: this.estimateTokenCount(line)
        };
    });
    
    // Sort by priority (high to low)
    const sortedLines = categorizedLines.sort((a, b) => b.priority - a.priority);
    
    // Add high-priority lines first
    const addedLines = new Set();
    
    for (const lineInfo of sortedLines) {
        if (currentTokens + lineInfo.tokens < maxTokens * 0.9) {
            if (!addedLines.has(lineInfo.original)) {
                chunkedContent += lineInfo.original + '\n';
                currentTokens += lineInfo.tokens;
                addedLines.add(lineInfo.original);
                
                if (lineInfo.priority > 0) {
                    console.log(`Added priority line (${lineInfo.label}): ${lineInfo.original.substring(0, 50)}...`);
                }
            }
        } else {
            break;
        }
    }
    
    // Add summary of excluded content
    const excludedCount = lines.length - addedLines.size;
    if (excludedCount > 0) {
        chunkedContent += `\n[${excludedCount} lines excluded for token optimization - lower priority code]\n`;
    }
    
    console.log(`📊 File content chunking: ${addedLines.size}/${lines.length} lines kept, ${this.estimateTokenCount(chunkedContent)} tokens`);
    
    return chunkedContent;
}

// Enhanced chat functionality with proper LLM integration
async processEnhancedChatQuery(question) {
    console.log('💬 Processing chat query:', question);
    
    const analysisData = this.analysisResults[this.currentAnalyzedComponent];
    const friendlyName = document.getElementById('friendlyName')?.value || this.currentAnalyzedComponent;
    
    if (!analysisData) {
        return "Please analyze a component first before asking questions about it.";
    }
    
    // Build chat context
    const chatContext = this.buildChatContext(question, analysisData, friendlyName);
    
    // Apply chunking for chat
    const optimizedContext = await this.applyChatChunking(chatContext);
    
    try {
        console.log('🤖 Calling LLM for chat response...');
        const response = await this.callLLMAPI(optimizedContext);
        
        if (response.error) {
            return this.generateFallbackChatResponse(question, analysisData, friendlyName);
        }
        
        // Extract chat response
        return this.extractChatResponse(response, question, friendlyName);
        
    } catch (error) {
        console.error('Chat LLM call failed:', error);
        return this.generateFallbackChatResponse(question, analysisData, friendlyName);
    }
}

// Build comprehensive chat context
buildChatContext(question, analysisData, friendlyName) {
    const context = `MAINFRAME ANALYSIS CHAT ASSISTANT

CONTEXT:
You are a helpful assistant analyzing mainframe components. Provide detailed, accurate responses based on the analysis data.

COMPONENT: ${analysisData.componentName} (${friendlyName})
TYPE: ${analysisData.componentType}
ANALYSIS METHOD: ${analysisData.analysisMethod}

ANALYSIS RESULTS:
${JSON.stringify(analysisData.llmAnalysis, null, 2)}

DEPENDENCY STATUS:
Found Dependencies: ${analysisData.dependencyAnalysis?.summary?.foundCount || 0}
Missing Dependencies: ${analysisData.dependencyAnalysis?.summary?.missingCount || 0}
Details: ${JSON.stringify(analysisData.dependencyAnalysis?.found, null, 2)}

LIFECYCLE FLOW:
${JSON.stringify(analysisData.lifecycleFlow, null, 2)}

CHAT HISTORY:
${this.getChatHistoryForContext()}

USER QUESTION: "${question}"

INSTRUCTIONS:
1. Provide a helpful, detailed response based on the analysis data
2. Use the friendly name "${friendlyName}" when referring to the component
3. Include specific examples and data from the analysis
4. Format response with markdown for better readability
5. If the question cannot be answered from the data, explain what's available
6. Keep responses focused and actionable

RESPONSE:`;

    return context;
}

// Apply chunking specifically for chat context
async applyChatChunking(context) {
    const maxChatTokens = this.maxTokens * 0.6; // Reserve more for response in chat
    const currentTokens = this.estimateTokenCount(context);
    
    if (currentTokens <= maxChatTokens) {
        return context;
    }
    
    console.log('🔄 Applying chat chunking...');
    
    // Split context into sections
    const sections = context.split('\n\n');
    let optimizedContext = '';
    let tokenCount = 0;
    
    // Prioritize sections for chat
    const priorityOrder = [
        'INSTRUCTIONS:',
        'USER QUESTION:',
        'COMPONENT:',
        'ANALYSIS RESULTS:',
        'DEPENDENCY STATUS:',
        'LIFECYCLE FLOW:',
        'CHAT HISTORY:'
    ];
    
    // Add sections in priority order
    for (const priority of priorityOrder) {
        const section = sections.find(s => s.includes(priority));
        if (section) {
            const sectionTokens = this.estimateTokenCount(section);
            if (tokenCount + sectionTokens < maxChatTokens) {
                optimizedContext += section + '\n\n';
                tokenCount += sectionTokens;
            }
        }
    }
    
    console.log(`📊 Chat chunking: ${tokenCount} tokens (limit: ${maxChatTokens})`);
    return optimizedContext;
}

// Get relevant chat history for context
getChatHistoryForContext() {
    const recentMessages = this.chatHistory.slice(-4); // Last 4 messages
    return recentMessages.map(msg => 
        `${msg.sender}: ${msg.content.substring(0, 200)}${msg.content.length > 200 ? '...' : ''}`
    ).join('\n');
}

// Extract response from LLM chat call
extractChatResponse(llmResponse, question, friendlyName) {
    let responseText = '';
    
    // Handle different response formats
    if (typeof llmResponse === 'string') {
        responseText = llmResponse;
    } else if (llmResponse.text) {
        responseText = llmResponse.text;
    } else if (llmResponse.response) {
        responseText = llmResponse.response;
    } else if (llmResponse.rawResponse) {
        responseText = llmResponse.rawResponse;
    } else {
        // Try to extract meaningful content from structured response
        if (llmResponse.businessPurpose) {
            responseText = `Based on the analysis of ${friendlyName}:\n\n${llmResponse.businessPurpose}`;
        } else if (llmResponse.recommendations) {
            responseText = `Here are the key recommendations for ${friendlyName}:\n\n` +
                         llmResponse.recommendations.map((rec, i) => `${i + 1}. ${rec}`).join('\n');
        } else {
            return this.generateFallbackChatResponse(question, null, friendlyName);
        }
    }
    
    // Clean and format the response
    return this.formatChatResponse(responseText, friendlyName);
}

// Format chat response for display
formatChatResponse(text, friendlyName) {
    return text
        .replace(/RESPONSE:\s*/i, '') // Remove RESPONSE: prefix
        .replace(/\n{3,}/g, '\n\n') // Limit consecutive newlines
        .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>') // Bold formatting
        .replace(/`([^`]+)`/g, '<code>$1</code>') // Code formatting
        .replace(/\n- /g, '\n• ') // Bullet points
        .trim();
}

// Generate fallback response when LLM fails
generateFallbackChatResponse(question, analysisData, friendlyName) {
    const lowerQuestion = question.toLowerCase();
    
    if (lowerQuestion.includes('field') || lowerQuestion.includes('data')) {
        return `Based on the analysis of **${friendlyName}**, I can provide information about the fields and data structures. The component contains various data elements that are used throughout the system. For detailed field-level analysis, please check the Field Matrix tab.`;
    }
    
    if (lowerQuestion.includes('dependency') || lowerQuestion.includes('call') || lowerQuestion.includes('copy')) {
        return `For **${friendlyName}** dependencies: The analysis identified both found and missing dependencies. Check the Dependencies tab for a complete breakdown of copybooks, called programs, and file references.`;
    }
    
    if (lowerQuestion.includes('lifecycle') || lowerQuestion.includes('flow') || lowerQuestion.includes('process')) {
        return `The lifecycle flow for **${friendlyName}** shows how the component moves through different processing stages. You can view the complete flow diagram in the File Lifecycle tab.`;
    }
    
    if (lowerQuestion.includes('business') || lowerQuestion.includes('purpose') || lowerQuestion.includes('function')) {
        if (analysisData?.llmAnalysis?.businessPurpose) {
            return `**Business Purpose of ${friendlyName}:**\n\n${analysisData.llmAnalysis.businessPurpose}`;
        }
        return `**${friendlyName}** serves a specific business function within the mainframe system. The analysis provides insights into its role and purpose based on the code structure and dependencies.`;
    }
    
    if (lowerQuestion.includes('recommend') || lowerQuestion.includes('improve') || lowerQuestion.includes('optimize')) {
        if (analysisData?.llmAnalysis?.recommendations) {
            return `**Recommendations for ${friendlyName}:**\n\n` +
                   analysisData.llmAnalysis.recommendations.map((rec, i) => `${i + 1}. ${rec}`).join('\n');
        }
        return `For **${friendlyName}** optimization: Consider reviewing the dependency analysis for missing components, examine the field usage patterns, and evaluate modernization opportunities based on the current structure.`;
    }
    
    // Generic fallback
    return `I can help you understand **${friendlyName}** based on the analysis results. The component has been analyzed for dependencies, field structures, and lifecycle patterns. Please check the different tabs (Analysis Results, Field Matrix, Dependencies, File Lifecycle) for detailed information, or ask more specific questions about fields, dependencies, business logic, or recommendations.`;
}

// Create comprehensive fallback data for failed LLM calls
createComponentFallback(componentName, friendlyName, context) {
    console.log('🔄 Creating fallback data for:', componentName);
    
    const fallbackData = {
        componentName: componentName,
        friendlyName: friendlyName || componentName,
        componentType: this.detectComponentTypeFromContext(context),
        analysisScope: 'FALLBACK',
        businessPurpose: `Analysis of ${friendlyName || componentName} - Component serves as part of the mainframe system architecture`,
        technicalSummary: 'Technical analysis incomplete due to LLM processing limitations',
        qualityScore: 6,
        recommendations: [
            'Consider re-analyzing with optimized token usage',
            'Review dependency status manually',
            'Check file contents for missing components',
            'Verify LLM server configuration and connectivity'
        ],
        fieldAnalysis: {
            totalFields: this.estimateFieldCount(context),
            keyFields: this.extractKeyFields(context),
            fieldCategories: {
                input: [],
                output: [],
                calculated: [],
                control: []
            }
        },
        businessRules: [],
        dependencies: {
            required: context?.dependencies?.copyStatements || [],
            optional: context?.dependencies?.callStatements || [],
            missing: [],
            riskAssessment: 'MEDIUM'
        },
        lifecyclePhases: {
            creation: [],
            processing: [],
            output: [],
            archival: []
        },
        modernizationOpportunities: [
            'LLM analysis incomplete - manual review recommended'
        ],
        riskFactors: [
            'Analysis incomplete due to processing limitations',
            'Manual validation recommended'
        ],
        fallbackGenerated: true,
        timestamp: new Date().toISOString()
    };
    
    console.log('✅ Fallback data created:', fallbackData);
    return fallbackData;
}

// Helper methods for fallback data creation
detectComponentTypeFromContext(context) {
    if (!context) return 'Unknown';
    
    if (context.component?.type) return context.component.type;
    
    const files = context.files || [];
    for (const file of files) {
        if (file.type === 'Copybook') return 'Copybook';
        if (file.type === 'COBOL Program') return 'COBOL Program';
        if (file.type === 'JCL Job') return 'JCL Job';
    }
    
    return 'Component';
}

estimateFieldCount(context) {
    if (!context?.files) return 0;
    
    let fieldCount = 0;
    context.files.forEach(file => {
        const matches = file.content?.match(/01\s+[A-Z][A-Z0-9\-_]+/gi) || [];
        fieldCount += matches.length;
    });
    
    return fieldCount;
}

extractKeyFields(context) {
    if (!context?.files) return [];
    
    const fields = [];
    context.files.forEach(file => {
        const matches = file.content?.match(/01\s+([A-Z][A-Z0-9\-_]+)/gi) || [];
        matches.forEach(match => {
            const field = match.replace(/01\s+/i, '').trim();
            if (fields.length < 10 && !fields.includes(field)) {
                fields.push(field);
            }
        });
    });
    
    return fields;
}

chunkContextData(contextData, maxTokens) {
    const lines = contextData.split('\n');
    let chunkedData = '';
    let currentTokens = 0;
    
    // Prioritize important lines
    const priorityPatterns = [
        /01\s+[A-Z][A-Z0-9\-_]+/,  // COBOL 01-level fields
        /COPY\s+[A-Z][A-Z0-9\-_]+/, // Copy statements
        /CALL\s+[A-Z][A-Z0-9\-_]+/, // Call statements
        /PROGRAM-ID/,                // Program IDs
        /FD\s+[A-Z]/,               // File definitions
        /EXEC\s+CICS/               // CICS commands
    ];
    
    // First pass: Add high-priority lines
    lines.forEach(line => {
        if (currentTokens < maxTokens * 0.8) {
            const lineTokens = this.estimateTokenCount(line);
            const isHighPriority = priorityPatterns.some(pattern => pattern.test(line));
            
            if (isHighPriority && (currentTokens + lineTokens < maxTokens)) {
                chunkedData += line + '\n';
                currentTokens += lineTokens;
            }
        }
    });
    
    // Second pass: Add remaining lines if space allows
    lines.forEach(line => {
        if (currentTokens < maxTokens * 0.9) {
            const lineTokens = this.estimateTokenCount(line);
            const alreadyIncluded = chunkedData.includes(line);
            
            if (!alreadyIncluded && (currentTokens + lineTokens < maxTokens)) {
                chunkedData += line + '\n';
                currentTokens += lineTokens;
            }
        }
    });
    
    return chunkedData + '\n[Content truncated for token optimization]';
}

// Create fallback data from text content
createFallbackFromText(text) {
    const componentName = this.currentAnalyzedComponent || 'Unknown';
    const friendlyName = document.getElementById('friendlyName')?.value || componentName;
    
    // Try to extract useful information from text
    const extractedInfo = this.extractInfoFromText(text);
    
    return {
        componentName: componentName,
        friendlyName: friendlyName,
        componentType: extractedInfo.type || 'Unknown',
        analysisScope: 'TEXT_EXTRACTION',
        businessPurpose: extractedInfo.purpose || 'Could not determine business purpose from response',
        technicalSummary: extractedInfo.summary || 'Technical analysis incomplete',
        qualityScore: 5,
        recommendations: extractedInfo.recommendations || [
            'LLM response parsing failed',
            'Consider re-analyzing with different parameters',
            'Review file content and dependencies manually'
        ],
        fieldAnalysis: {
            totalFields: extractedInfo.fieldCount || 0,
            keyFields: extractedInfo.fields || [],
            fieldCategories: { input: [], output: [], calculated: [], control: [] }
        },
        businessRules: [],
        dependencies: {
            required: [],
            optional: [],
            missing: [],
            riskAssessment: 'HIGH'
        },
        lifecyclePhases: {
            creation: [],
            processing: [],
            output: [],
            archival: []
        },
        parseError: 'Response could not be parsed as JSON',
        rawText: text.substring(0, 500)
    };
}

// Extract information from unstructured text
extractInfoFromText(text) {
    const info = {};
    
    // Extract component type
    const typePatterns = [
        /(?:component|program|copybook|file)[\s:]+(\w+)/gi,
        /type[\s:]+(\w+)/gi
    ];
    
    for (const pattern of typePatterns) {
        const match = text.match(pattern);
        if (match && match[1]) {
            info.type = match[1];
            break;
        }
    }
    
    // Extract purpose/description
    const purposePatterns = [
        /purpose[\s:]+([^.]+)/gi,
        /description[\s:]+([^.]+)/gi,
        /business[\s:]+([^.]+)/gi
    ];
    
    for (const pattern of purposePatterns) {
        const match = text.match(pattern);
        if (match && match[1]) {
            info.purpose = match[1].trim();
            break;
        }
    }
    
    // Extract field names
    const fieldMatches = text.match(/(?:01|field)[\s]+([A-Z][A-Z0-9\-_]+)/gi);
    if (fieldMatches) {
        info.fields = fieldMatches.map(match => 
            match.replace(/^(?:01|field)[\s]+/i, '').trim()
        ).slice(0, 10); // Limit to first 10
        info.fieldCount = info.fields.length;
    }
    
    // Extract recommendations
    const recMatches = text.match(/recommend[^.]+\./gi);
    if (recMatches) {
        info.recommendations = recMatches.slice(0, 5); // Limit to 5
    }
    
    return info;
}


    }

    // ===================================================================
    // INITIALIZATION
    // ===================================================================
    document.addEventListener('DOMContentLoaded', function() {
        window.analyzer = new EnhancedMainframeAnalyzer();
        
        console.log('🚀 Enhanced Mainframe Analyzer with Redesigned UI Ready!');
        console.log('✅ New Features:');
        console.log('   • Collapsible left and right panels');
        console.log('   • White background with blue/grey color scheme');
        console.log('   • Enhanced chat with full-height display');
        console.log('   • Friendly name support for better UX');
        console.log('   • Dynamic flow diagram visualization');
        console.log('   • Improved storage management');
        console.log('   • Responsive design for all screen sizes');
        console.log('🎯 Ready for enhanced mainframe component analysis!');
    });

    // Fallback initialization
    if (document.readyState === 'loading') {
        // Document still loading, wait for DOMContentLoaded
    } else {
        // Document already loaded
        window.analyzer = new EnhancedMainframeAnalyzer();
        console.log('🚀 Enhanced Mainframe Analyzer initialized (fallback)');
    }

    // Add CSS animation for blinking dots
    const style = document.createElement('style');
    style.textContent = `
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
    `;
    document.head.appendChild(style);
</script>
</body>
</html>