<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Code Analyzer - Powered by Opulence</title>
    <style>
        /* ============================================
           ENHANCED CODE ANALYZER - POWERED BY OPULENCE
           Complete CSS Styles and Layout System
           ============================================ */
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Enhanced Color Palette */
            --primary-blue: #2563eb;
            --primary-blue-dark: #1e40af;
            --primary-blue-light: #3b82f6;
            --secondary-blue: #60a5fa;
            --accent-blue: #93c5fd;
            
            --grey-50: #f9fafb;
            --grey-100: #f3f4f6;
            --grey-200: #e5e7eb;
            --grey-300: #d1d5db;
            --grey-400: #9ca3af;
            --grey-500: #6b7280;
            --grey-600: #4b5563;
            --grey-700: #374151;
            --grey-800: #1f2937;
            --grey-900: #111827;
            
            --success-green: #10b981;
            --warning-yellow: #f59e0b;
            --error-red: #ef4444;
            --info-blue: #3b82f6;
            --purple: #8b5cf6;
            --indigo: #6366f1;
            
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
            
            --transition-fast: 150ms cubic-bezier(0.4, 0, 0.2, 1);
            --transition-normal: 300ms cubic-bezier(0.4, 0, 0.2, 1);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Inter', Roboto, sans-serif;
            background: #ffffff;
            color: var(--grey-800);
            line-height: 1.6;
            min-height: 100vh;
        }

        /* Main Container */
        .main-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            background: var(--grey-50);
        }

        /* Enhanced Header */
        .header {
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--indigo) 100%);
            color: white;
            padding: 1.5rem 2rem;
            box-shadow: var(--shadow-lg);
            position: relative;
            z-index: 100;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 100%;
        }

        .header h1 {
            font-size: 1.75rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .header-icon {
            width: 36px;
            height: 36px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.5rem;
        }

        .header-subtitle {
            font-size: 0.9rem;
            opacity: 0.9;
            margin-left: 3rem;
            font-weight: 400;
        }

        .header-stats {
            display: flex;
            gap: 2rem;
            font-size: 0.85rem;
        }

        .header-stat {
            text-align: center;
        }

        .header-stat-value {
            font-size: 1.25rem;
            font-weight: 700;
            display: block;
        }

        .header-stat-label {
            opacity: 0.8;
            font-size: 0.75rem;
        }

        /* Content Layout */
        .content-wrapper {
            flex: 1;
            display: flex;
            overflow: hidden;
            position: relative;
        }

        /* Enhanced Collapsible Panels */
        .panel {
            background: white;
            position: relative;
            transition: all var(--transition-normal);
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--grey-200);
            box-shadow: var(--shadow-sm);
        }

        .panel.left {
            width: 420px;
            min-width: 60px;
        }

        .panel.left.collapsed {
            width: 60px;
        }

        .panel.right {
            width: 500px;
            min-width: 60px;
            border-left: 1px solid var(--grey-200);
            border-right: none;
        }

        .panel.right.collapsed {
            width: 60px;
        }

        .panel-header {
            padding: 1rem;
            background: linear-gradient(135deg, var(--grey-50) 0%, var(--grey-100) 100%);
            border-bottom: 1px solid var(--grey-200);
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-height: 60px;
        }

        .panel-title {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
            color: var(--grey-700);
            font-size: 0.95rem;
        }

        .panel-icon {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--primary-blue);
        }

        .collapse-btn {
            width: 32px;
            height: 32px;
            border: none;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--grey-600);
            transition: all var(--transition-fast);
            box-shadow: var(--shadow-sm);
        }

        .collapse-btn:hover {
            background: var(--primary-blue);
            color: white;
            transform: scale(1.05);
            box-shadow: var(--shadow-md);
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            transition: opacity var(--transition-normal);
        }

        .panel.collapsed .panel-content {
            opacity: 0;
            pointer-events: none;
            padding: 0;
        }

        .panel.collapsed .panel-title span {
            display: none;
        }

        /* Enhanced Component Cards */
        .component-card {
            background: white;
            border: 1px solid var(--grey-200);
            border-radius: 12px;
            padding: 1.25rem;
            margin-bottom: 1rem;
            cursor: pointer;
            transition: all var(--transition-fast);
            position: relative;
            overflow: hidden;
        }

        .component-card:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
            border-color: var(--primary-blue);
        }

        .component-card.selected {
            border-color: var(--primary-blue);
            background: linear-gradient(135deg, rgba(37, 99, 235, 0.05) 0%, rgba(99, 102, 241, 0.05) 100%);
            box-shadow: var(--shadow-md);
        }

        .component-card-header {
            display: flex;
            justify-content: between;
            align-items: flex-start;
            margin-bottom: 0.75rem;
        }

        .component-card-icon {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            margin-right: 0.75rem;
            flex-shrink: 0;
        }

        .component-card-icon.program {
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--indigo) 100%);
            color: white;
        }

        .component-card-icon.copybook {
            background: linear-gradient(135deg, var(--success-green) 0%, #059669 100%);
            color: white;
        }

        .component-card-icon.file {
            background: linear-gradient(135deg, var(--warning-yellow) 0%, #d97706 100%);
            color: white;
        }

        .component-card-info {
            flex: 1;
            min-width: 0;
        }

        .component-card-name {
            font-weight: 600;
            color: var(--grey-800);
            font-size: 0.95rem;
            margin-bottom: 0.25rem;
            word-break: break-word;
        }

        .component-card-friendly {
            font-size: 0.8rem;
            color: var(--primary-blue);
            margin-bottom: 0.5rem;
            font-weight: 500;
        }

        .component-card-description {
            font-size: 0.8rem;
            color: var(--grey-600);
            line-height: 1.4;
            margin-bottom: 0.75rem;
        }

        .component-card-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            font-size: 0.75rem;
        }

        .component-metric {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            color: var(--grey-600);
        }

        .component-metric-icon {
            width: 14px;
            height: 14px;
            color: var(--grey-500);
        }

        /* Enhanced Collapsible Sections */
        .collapsible-section {
            background: white;
            border-radius: 12px;
            margin-bottom: 1rem;
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--grey-200);
            overflow: hidden;
            transition: all var(--transition-normal);
        }

        .collapsible-header {
            padding: 1rem 1.5rem;
            background: linear-gradient(135deg, var(--grey-50) 0%, var(--grey-100) 100%);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all var(--transition-fast);
            user-select: none;
            border-bottom: 1px solid var(--grey-200);
        }

        .collapsible-header:hover {
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--indigo) 100%);
            color: white;
        }

        .collapsible-title {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-weight: 600;
            color: var(--grey-700);
        }

        .collapsible-header:hover .collapsible-title {
            color: white;
        }

        .collapsible-icon {
            width: 20px;
            height: 20px;
        }

        .expand-icon {
            width: 20px;
            height: 20px;
            color: var(--grey-400);
            transition: transform var(--transition-fast);
        }

        .collapsible-header:hover .expand-icon {
            color: white;
        }

        .collapsible-section.expanded .expand-icon {
            transform: rotate(180deg);
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height var(--transition-normal);
            background: white;
        }

        .collapsible-section.expanded .collapsible-content {
            max-height: 3000px;
        }

        .collapsible-body {
            padding: 1.5rem;
        }

        /* Main Content Area */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: white;
            overflow: hidden;
        }

        /* Enhanced Tabs */
        .tabs-container {
            background: linear-gradient(135deg, white 0%, var(--grey-50) 100%);
            border-bottom: 1px solid var(--grey-200);
            padding: 0 1.5rem;
            display: flex;
            align-items: center;
            min-height: 60px;
            box-shadow: var(--shadow-sm);
        }

        .tab {
            padding: 0.75rem 1.5rem;
            background: transparent;
            border: none;
            color: var(--grey-600);
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            position: relative;
            transition: all var(--transition-fast);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            border-radius: 8px;
            margin-right: 0.5rem;
        }

        .tab:hover {
            color: var(--primary-blue);
            background: rgba(37, 99, 235, 0.1);
        }

        .tab.active {
            color: white;
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--indigo) 100%);
            box-shadow: var(--shadow-md);
        }

        .tab-icon {
            width: 18px;
            height: 18px;
        }

        /* Tab Content */
        .tab-content-container {
            flex: 1;
            overflow-y: auto;
            background: var(--grey-50);
        }

        .tab-content {
            display: none;
            padding: 1.5rem;
            min-height: 100%;
        }

        .tab-content.active {
            display: block;
        }

        /* Dashboard Cards */
        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .dashboard-card {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--grey-200);
            cursor: pointer;
            transition: all var(--transition-fast);
            position: relative;
            overflow: hidden;
        }

        .dashboard-card:hover {
            transform: translateY(-4px);
            box-shadow: var(--shadow-xl);
            border-color: var(--primary-blue);
        }

        .dashboard-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--indigo) 100%);
        }

        .dashboard-card-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .dashboard-card-icon {
            width: 48px;
            height: 48px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            background: linear-gradient(135deg, var(--accent-blue) 0%, var(--secondary-blue) 100%);
            color: white;
        }

        .dashboard-card-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--grey-800);
        }

        .dashboard-card-subtitle {
            font-size: 0.85rem;
            color: var(--grey-600);
        }

        .dashboard-card-content {
            margin-bottom: 1rem;
        }

        .dashboard-card-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--grey-100);
        }

        .dashboard-metric {
            text-align: center;
        }

        .dashboard-metric-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary-blue);
            display: block;
        }

        .dashboard-metric-label {
            font-size: 0.7rem;
            color: var(--grey-500);
            text-transform: uppercase;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        /* Status Indicators */
        .status-indicator {
            padding: 0.75rem;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
            margin-bottom: 1rem;
        }

        .status-indicator.connected {
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.3);
            color: var(--success-green);
        }

        .status-indicator.connecting {
            background: rgba(245, 158, 11, 0.1);
            border: 1px solid rgba(245, 158, 11, 0.3);
            color: var(--warning-yellow);
        }

        .status-indicator.disconnected {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: var(--error-red);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Enhanced Buttons */
        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all var(--transition-fast);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            box-shadow: var(--shadow-sm);
            text-decoration: none;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--indigo) 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .btn-success {
            background: linear-gradient(135deg, var(--success-green) 0%, #059669 100%);
            color: white;
        }

        .btn-success:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .btn-danger {
            background: linear-gradient(135deg, var(--error-red) 0%, #dc2626 100%);
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .btn-block {
            width: 100%;
        }

        /* Badge Styles */
        .badge {
            display: inline-flex;
            align-items: center;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .badge-primary {
            background: rgba(37, 99, 235, 0.1);
            color: var(--primary-blue);
        }

        .badge-success {
            background: rgba(16, 185, 129, 0.1);
            color: var(--success-green);
        }

        .badge-warning {
            background: rgba(245, 158, 11, 0.1);
            color: var(--warning-yellow);
        }

        .badge-danger {
            background: rgba(239, 68, 68, 0.1);
            color: var(--error-red);
        }

        .badge-info {
            background: rgba(59, 130, 246, 0.1);
            color: var(--info-blue);
        }

        .badge-grey {
            background: var(--grey-100);
            color: var(--grey-600);
        }

        /* Form Elements */
        .form-section {
            margin-bottom: 1.5rem;
            padding: 1.25rem;
            background: white;
            border-radius: 12px;
            border: 1px solid var(--grey-200);
            box-shadow: var(--shadow-sm);
        }

        .form-section-title {
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--grey-700);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-label {
            display: block;
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--grey-700);
            margin-bottom: 0.5rem;
        }

        .form-input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--grey-300);
            border-radius: 8px;
            font-size: 0.9rem;
            transition: all var(--transition-fast);
            background: white;
            color: var(--grey-800);
        }

        .form-input:focus {
            outline: none;
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        /* Upload Area */
        .upload-area {
            border: 2px dashed var(--grey-300);
            border-radius: 12px;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: all var(--transition-fast);
            background: var(--grey-50);
            margin-bottom: 1rem;
        }

        .upload-area:hover {
            border-color: var(--primary-blue);
            background: rgba(37, 99, 235, 0.05);
        }

        .upload-area.drag-over {
            border-color: var(--primary-blue);
            background: rgba(37, 99, 235, 0.1);
            transform: scale(0.98);
        }

        .upload-icon {
            font-size: 2.5rem;
            margin-bottom: 0.75rem;
            color: var(--primary-blue);
        }

        .upload-text {
            color: var(--grey-700);
            font-weight: 600;
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }

        .upload-subtext {
            color: var(--grey-500);
            font-size: 0.9rem;
        }

        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.95);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            backdrop-filter: blur(5px);
        }

        .loading-overlay.show {
            display: flex;
        }

        .loading-content {
            text-align: center;
            background: white;
            padding: 2rem;
            border-radius: 16px;
            box-shadow: var(--shadow-xl);
            border: 1px solid var(--grey-200);
        }

        .loading-spinner {
            width: 48px;
            height: 48px;
            border: 4px solid var(--grey-200);
            border-top-color: var(--primary-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--grey-800);
            margin-bottom: 0.5rem;
        }

        .loading-status {
            font-size: 0.9rem;
            color: var(--grey-600);
            margin-bottom: 1rem;
        }

        .loading-progress {
            width: 250px;
            height: 6px;
            background: var(--grey-200);
            border-radius: 3px;
            overflow: hidden;
            margin: 0 auto;
        }

        .loading-progress-fill {
            height: 100%;
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--indigo) 100%);
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        /* Scrollbar Styles */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--grey-100);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--grey-400);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--grey-500);
        }

        /* Alert Messages */
        .alert {
            position: fixed;
            top: 80px;
            right: 20px;
            padding: 1rem 1.5rem;
            border-radius: 12px;
            box-shadow: var(--shadow-xl);
            display: flex;
            align-items: center;
            gap: 0.75rem;
            max-width: 400px;
            animation: slideInRight 0.3s ease;
            z-index: 10000;
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .alert-success {
            background: var(--success-green);
            color: white;
        }

        .alert-error {
            background: var(--error-red);
            color: white;
        }

        .alert-warning {
            background: var(--warning-yellow);
            color: white;
        }

        .alert-info {
            background: var(--info-blue);
            color: white;
        }

        .alert-icon {
            font-size: 1.25rem;
        }

        .alert-message {
            flex: 1;
            font-size: 0.9rem;
            font-weight: 500;
        }

        /* Continue with additional styles... */
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.js"></script>
</head>
<body>
    <div class="main-container">
        <!-- Enhanced Header -->
        <div class="header">
            <div class="header-content">
                <div>
                    <h1>
                        <div class="header-icon">üîç</div>
                        Enhanced Code Analyzer
                    </h1>
                    <div class="header-subtitle">Powered by Opulence - Intelligent Mainframe Analysis & Business Intelligence</div>
                </div>
                <div class="header-stats">
                    <div class="header-stat">
                        <span class="header-stat-value" id="headerComponents">0</span>
                        <span class="header-stat-label">Components</span>
                    </div>
                    <div class="header-stat">
                        <span class="header-stat-value" id="headerPrograms">0</span>
                        <span class="header-stat-label">Programs</span>
                    </div>
                    <div class="header-stat">
                        <span class="header-stat-value" id="headerCopybooks">0</span>
                        <span class="header-stat-label">Copybooks</span>
                    </div>
                    <div class="header-stat">
                        <span class="header-stat-value" id="headerFields">0</span>
                        <span class="header-stat-label">Fields</span>
                    </div>
                </div>
            </div>
        </div>
<!-- Main Content Wrapper -->
<div class="content-wrapper">
    <!-- Left Panel - Component Dashboard -->
    <div class="panel left" id="leftPanel">
        <div class="panel-header">
            <div class="panel-title">
                <div class="panel-icon">üìä</div>
                <span>Component Dashboard</span>
            </div>
            <button class="collapse-btn" onclick="togglePanel('left')">
                ‚óÄ
            </button>
        </div>
        <div class="panel-content" id="leftPanelContent">
            <!-- LLM Server Setup -->
            <div class="form-section">
                <div class="form-section-title">
                    <span style="color: var(--success-green);">üöÄ</span>
                    LLM Server Setup
                </div>

                <div class="form-group">
                    <label class="form-label">Server Endpoint</label>
                    <input type="text" 
                           id="vllmEndpoint" 
                           class="form-input" 
                           placeholder="http://localhost:8000" 
                           value="http://localhost:8000">
                </div>

                <div class="form-group">
                    <label class="form-label">Max Tokens</label>
                    <input type="number" 
                           id="maxTokens" 
                           class="form-input" 
                           value="4000" 
                           min="1000" 
                           max="8000">
                </div>

                <button id="validateApiBtn" class="btn btn-success btn-block">
                    <span>üîê</span>
                    Test Connection
                </button>

                <div id="apiStatus" class="status-indicator disconnected">
                    <span class="status-dot"></span>
                    <span>Enter server details and test connection</span>
                </div>
            </div>

            <!-- File Upload Section -->
            <div class="form-section">
                <div class="form-section-title">
                    <span style="color: var(--info-blue);">üìÅ</span>
                    Upload & Auto-Analyze
                </div>

                <div class="upload-area" id="uploadArea">
                    <div class="upload-icon">üì§</div>
                    <div class="upload-text">Drop files here or click to browse</div>
                    <div class="upload-subtext">COBOL (.cbl), Copybooks (.cpy), JCL (.jcl) - Auto-analysis starts immediately</div>
                    <input type="file" 
                           id="fileInput" 
                           multiple 
                           accept=".cbl,.cob,.cpy,.copybook,.jcl,.txt,.proc" 
                           style="display: none;">
                </div>

                <button id="autoAnalyzeBtn" class="btn btn-primary btn-block" disabled>
                    <span>ü§ñ</span>
                    Start Auto-Analysis
                </button>
            </div>

            <!-- Discovered Components -->
            <div class="collapsible-section expanded" id="discoveredComponents">
                <div class="collapsible-header" onclick="toggleCollapsible(this)">
                    <div class="collapsible-title">
                        <span class="collapsible-icon">üéØ</span>
                        Discovered Components (<span id="componentCount">0</span>)
                    </div>
                    <span class="expand-icon">‚ñº</span>
                </div>
                <div class="collapsible-content">
                    <div class="collapsible-body" id="componentsList">
                        <p style="color: var(--grey-500); text-align: center; padding: 2rem;">
                            Upload files to auto-discover components
                        </p>
                    </div>
                </div>
            </div>

            <!-- Programs Section -->
            <div class="collapsible-section" id="programsSection">
                <div class="collapsible-header" onclick="toggleCollapsible(this)">
                    <div class="collapsible-title">
                        <span class="collapsible-icon">üíº</span>
                        COBOL Programs (<span id="programCount">0</span>)
                    </div>
                    <span class="expand-icon">‚ñº</span>
                </div>
                <div class="collapsible-content">
                    <div class="collapsible-body" id="programsList">
                        <p style="color: var(--grey-500); text-align: center;">No programs discovered yet</p>
                    </div>
                </div>
            </div>

            <!-- Copybooks Section -->
            <div class="collapsible-section" id="copybooksSection">
                <div class="collapsible-header" onclick="toggleCollapsible(this)">
                    <div class="collapsible-title">
                        <span class="collapsible-icon">üìö</span>
                        Copybooks (<span id="copybookCount">0</span>)
                    </div>
                    <span class="expand-icon">‚ñº</span>
                </div>
                <div class="collapsible-content">
                    <div class="collapsible-body" id="copybooksList">
                        <p style="color: var(--grey-500); text-align: center;">No copybooks discovered yet</p>
                    </div>
                </div>
            </div>

            <!-- Files Section -->
            <div class="collapsible-section" id="filesSection">
                <div class="collapsible-header" onclick="toggleCollapsible(this)">
                    <div class="collapsible-title">
                        <span class="collapsible-icon">üìã</span>
                        Files & Jobs (<span id="fileCount">0</span>)
                    </div>
                    <span class="expand-icon">‚ñº</span>
                </div>
                <div class="collapsible-content">
                    <div class="collapsible-body" id="filesList">
                        <p style="color: var(--grey-500); text-align: center;">No files discovered yet</p>
                    </div>
                </div>
            </div>
            <div class="form-section">
                <div class="form-section-title">
                    <span style="color: var(--info-blue);">üíæ</span>
                    Database Management
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-bottom: 0.75rem;">
                    <button class="btn btn-primary" onclick="analyzer.saveToDownloadsWithName()">
                        <span>üíæ</span>
                        Manual Save
                    </button>
                    <button class="btn btn-primary" onclick="analyzer.loadFromDownloadsFolder()">
                        <span>üìÅ</span>
                        Load Database
                    </button>
                </div>
                
                <div class="storage-info">
                    üìÅ Data auto-saved to Downloads folder every 30 seconds
                    <br>
                    üí° Look for "enhanced_code_analyzer_data.db" file
                </div>
            </div>
            <!-- Quick Actions -->
            <div class="form-section">
                <div class="form-section-title">
                    <span style="color: var(--warning-yellow);">‚ö°</span>
                    Actions
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-bottom: 0.75rem;">
                    <button id="exportJsonBtn" class="btn btn-primary" disabled>
                        <span>üìã</span>
                        Export JSON
                    </button>
                    <button id="exportMdBtn" class="btn btn-primary" disabled>
                        <span>üìù</span>
                        Export MD
                    </button>
                </div>

                <button id="clearBtn" class="btn btn-danger btn-block">
                    <span>üóëÔ∏è</span>
                    Clear All Data
                </button>
            </div>
        </div>
    </div>

    <!-- Main Content Area -->
    <div class="main-content">
        <!-- Enhanced Tabs -->
        <div class="tabs-container">
            <button class="tab active" data-tab="dashboard">
                <span class="tab-icon">üìä</span>
                Dashboard Overview
            </button>
            <button class="tab" data-tab="fieldmatrix">
                <span class="tab-icon">üìã</span>
                Field Matrix
            </button>
            <button class="tab" data-tab="dependencies">
                <span class="tab-icon">üîó</span>
                Dependencies Flow
            </button>
        </div>

        <!-- Tab Content -->
        <div class="tab-content-container">
            <!-- Dashboard Overview Tab -->
            <div id="dashboard" class="tab-content active">
                <!-- Overview Cards -->
                <div class="dashboard-grid" id="dashboardGrid">
                    <div class="dashboard-card">
                        <div class="dashboard-card-header">
                            <div class="dashboard-card-icon">üìä</div>
                            <div>
                                <div class="dashboard-card-title">System Overview</div>
                                <div class="dashboard-card-subtitle">Complete mainframe analysis</div>
                            </div>
                        </div>
                        <div class="dashboard-card-content">
                            <p>Upload your mainframe files to automatically discover and analyze all components with business intelligence.</p>
                        </div>
                        <div class="dashboard-card-metrics">
                            <div class="dashboard-metric">
                                <span class="dashboard-metric-value" id="dashTotalComponents">0</span>
                                <span class="dashboard-metric-label">Components</span>
                            </div>
                            <div class="dashboard-metric">
                                <span class="dashboard-metric-value" id="dashTotalFiles">0</span>
                                <span class="dashboard-metric-label">Files</span>
                            </div>
                            <div class="dashboard-metric">
                                <span class="dashboard-metric-value" id="dashTotalFields">0</span>
                                <span class="dashboard-metric-label">Fields</span>
                            </div>
                            <div class="dashboard-metric">
                                <span class="dashboard-metric-value" id="dashQualityScore">-</span>
                                <span class="dashboard-metric-label">Avg Quality</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Component Analysis Results -->
                <div id="dashboardContent">
                    <!-- Programs Overview -->
                    <div class="collapsible-section expanded">
                        <div class="collapsible-header" onclick="toggleCollapsible(this)">
                            <div class="collapsible-title">
                                <span class="collapsible-icon">üíº</span>
                                Programs Overview
                            </div>
                            <span class="expand-icon">‚ñº</span>
                        </div>
                        <div class="collapsible-content">
                            <div class="collapsible-body" id="programsOverview">
                                <p style="color: var(--grey-500); text-align: center;">Upload and analyze files to see program overview</p>
                            </div>
                        </div>
                    </div>

                    <!-- Copybooks Overview -->
                    <div class="collapsible-section expanded">
                        <div class="collapsible-header" onclick="toggleCollapsible(this)">
                            <div class="collapsible-title">
                                <span class="collapsible-icon">üìö</span>
                                Copybooks Overview
                            </div>
                            <span class="expand-icon">‚ñº</span>
                        </div>
                        <div class="collapsible-content">
                            <div class="collapsible-body" id="copybooksOverview">
                                <p style="color: var(--grey-500); text-align: center;">Upload and analyze files to see copybook overview</p>
                            </div>
                        </div>
                    </div>

                    <!-- Dependencies Summary -->
                    <div class="collapsible-section">
                        <div class="collapsible-header" onclick="toggleCollapsible(this)">
                            <div class="collapsible-title">
                                <span class="collapsible-icon">üîó</span>
                                Dependencies Summary
                            </div>
                            <span class="expand-icon">‚ñº</span>
                        </div>
                        <div class="collapsible-content">
                            <div class="collapsible-body" id="dependenciesSummary">
                                <p style="color: var(--grey-500); text-align: center;">Upload and analyze files to see dependencies summary</p>
                            </div>
                        </div>
                    </div>

                    <!-- Field Statistics -->
                    <div class="collapsible-section">
                        <div class="collapsible-header" onclick="toggleCollapsible(this)">
                            <div class="collapsible-title">
                                <span class="collapsible-icon">üìã</span>
                                Field Statistics
                            </div>
                            <span class="expand-icon">‚ñº</span>
                        </div>
                        <div class="collapsible-content">
                            <div class="collapsible-body" id="fieldStatistics">
                                <p style="color: var(--grey-500); text-align: center;">Upload and analyze files to see field statistics</p>
                            </div>
                        </div>
                    </div>

                    <!-- Business Logic Summary -->
                    <div class="collapsible-section">
                        <div class="collapsible-header" onclick="toggleCollapsible(this)">
                            <div class="collapsible-title">
                                <span class="collapsible-icon">‚öñÔ∏è</span>
                                Business Logic Summary
                            </div>
                            <span class="expand-icon">‚ñº</span>
                        </div>
                        <div class="collapsible-content">
                            <div class="collapsible-body" id="businessLogicSummary">
                                <p style="color: var(--grey-500); text-align: center;">Upload and analyze files to see business logic summary</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Field Matrix Tab -->
            <div id="fieldmatrix" class="tab-content">
                <div class="collapsible-section expanded">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <div class="collapsible-title">
                            <span class="collapsible-icon">üìä</span>
                            Field Matrix Analysis
                        </div>
                        <span class="expand-icon">‚ñº</span>
                    </div>
                    <div class="collapsible-content">
                        <div class="collapsible-body" id="fieldMatrixContent">
                            <p style="color: var(--grey-500); text-align: center;">Select a component from the dashboard to view field matrix analysis.</p>
                        </div>
                    </div>
                </div>

                <div class="collapsible-section">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <div class="collapsible-title">
                            <span class="collapsible-icon">üìà</span>
                            Field Usage Patterns
                        </div>
                        <span class="expand-icon">‚ñº</span>
                    </div>
                    <div class="collapsible-content">
                        <div class="collapsible-body" id="fieldUsagePatterns">
                            <p style="color: var(--grey-500); text-align: center;">Field usage patterns will appear here.</p>
                        </div>
                    </div>
                </div>

                <div class="collapsible-section">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <div class="collapsible-title">
                            <span class="collapsible-icon">üåä</span>
                            Field Lifecycle Details
                        </div>
                        <span class="expand-icon">‚ñº</span>
                    </div>
                    <div class="collapsible-content">
                        <div class="collapsible-body" id="fieldLifecycleDetails">
                            <p style="color: var(--grey-500); text-align: center;">Field lifecycle details will appear here.</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Dependencies Flow Tab -->
            <div id="dependencies" class="tab-content">
                <div class="collapsible-section expanded">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <div class="collapsible-title">
                            <span class="collapsible-icon">üó∫Ô∏è</span>
                            High-Level Dependency Flow
                        </div>
                        <span class="expand-icon">‚ñº</span>
                    </div>
                    <div class="collapsible-content">
                        <div class="collapsible-body" id="dependencyFlowChart">
                            <p style="color: var(--grey-500); text-align: center;">Upload and analyze files to see dependency flow visualization.</p>
                        </div>
                    </div>
                </div>

                <div class="collapsible-section">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <div class="collapsible-title">
                            <span class="collapsible-icon">üîç</span>
                            Detailed Flow Analysis
                        </div>
                        <span class="expand-icon">‚ñº</span>
                    </div>
                    <div class="collapsible-content">
                        <div class="collapsible-body" id="detailedFlowAnalysis">
                            <p style="color: var(--grey-500); text-align: center;">Detailed flow analysis will appear here.</p>
                        </div>
                    </div>
                </div>

                <div class="collapsible-section">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <div class="collapsible-title">
                            <span class="collapsible-icon">‚ö°</span>
                            Impact Analysis
                        </div>
                        <span class="expand-icon">‚ñº</span>
                    </div>
                    <div class="collapsible-content">
                        <div class="collapsible-body" id="impactAnalysis">
                            <p style="color: var(--grey-500); text-align: center;">Impact analysis will appear here.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
   
    <!-- Right Panel - Enhanced Chat -->
    <div class="panel right" id="rightPanel">
        <div class="panel-header">
            <div class="panel-title">
                <div class="panel-icon">üí¨</div>
                <span>Business Intelligence Chat</span>
            </div>
            <button class="collapse-btn" onclick="togglePanel('right')">
                ‚ñ∂
            </button>
        </div>
        <div class="panel-content" id="rightPanelContent">
            <!-- Chat Container -->
            <div class="chat-container">
                <!-- Chat Header Info -->
                <div style="padding: 1rem; background: linear-gradient(135deg, var(--primary-blue) 0%, var(--indigo) 100%); color: white; border-radius: 12px; margin-bottom: 1rem;">
                    <h3 style="font-size: 1rem; margin-bottom: 0.5rem;">üß† Business Intelligence Chat</h3>
                    <p style="font-size: 0.8rem; opacity: 0.9;">Drill down into programs, fields, files, and business logic</p>
                </div>

                <!-- Context Selector -->
                <div class="form-section" id="chatContextSection" style="display: none;">
                    <div class="form-section-title">
                        <span style="color: var(--info-blue);">üéØ</span>
                        Chat Context
                    </div>
                    <div class="form-group">
                        <label class="form-label">Current Focus</label>
                        <select id="chatContext" class="form-input">
                            <option value="general">General Analysis</option>
                            <option value="component">Specific Component</option>
                            <option value="program">Program Level</option>
                            <option value="field">Field Level</option>
                            <option value="file">File Level</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Selected Item</label>
                        <input type="text" id="chatSelectedItem" class="form-input" placeholder="Auto-selected based on dashboard" readonly>
                    </div>
                </div>

                <!-- Chat Suggestions -->
                <div id="chatSuggestions" class="chat-suggestions" style="display: none;">
                    <div class="chat-suggestions-title">üí° Suggested Questions:</div>
                    <div class="chat-suggestion-chips">
                        <button class="chat-suggestion-btn" data-question="What is the business purpose of this component?">
                            üéØ Business Purpose
                        </button>
                        <button class="chat-suggestion-btn" data-question="Show me the complete field lifecycle flow">
                            üåä Field Lifecycle
                        </button>
                        <button class="chat-suggestion-btn" data-question="What programs create vs update vs read this data?">
                            üîÑ Data Operations
                        </button>
                        <button class="chat-suggestion-btn" data-question="What are the missing dependencies and their impact?">
                            ‚ö†Ô∏è Missing Dependencies
                        </button>
                        <button class="chat-suggestion-btn" data-question="What business rules and validations are implemented?">
                            ‚öñÔ∏è Business Rules
                        </button>
                        <button class="chat-suggestion-btn" data-question="How can we optimize this component for modernization?">
                            üöÄ Optimization
                        </button>
                    </div>
                </div>

                <!-- Chat Messages Area -->
                <div class="chat-messages" id="chatMessages">
                    <div class="chat-message assistant">
                        <div class="chat-bubble">
                            <div class="chat-message-header">Business Intelligence Assistant</div>
                            <div class="chat-message-content">
                                üëã <strong>Welcome to Business Intelligence Chat!</strong>
                                <br><br>
                                I provide contextual analysis and can drill down into:
                                <br><br>
                                üéØ <strong>Business Purpose:</strong> What each component does in business terms<br>
                                üìä <strong>Program Analysis:</strong> Detailed program structure and logic<br>
                                üìã <strong>Field Analysis:</strong> Field lifecycle, usage, and business meaning<br>
                                üìÅ <strong>File Analysis:</strong> Data flow and file relationships<br>
                                üîó <strong>Dependency Impact:</strong> How changes affect the system<br>
                                ‚öñÔ∏è <strong>Business Rules:</strong> Logic validation and business constraints<br>
                                üöÄ <strong>Modernization:</strong> Optimization and migration recommendations
                                <br><br>
                                <em>Upload files and start auto-analysis to unlock intelligent conversations!</em>
                            </div>
                            <div class="chat-message-time">${new Date().toLocaleTimeString()}</div>
                        </div>
                    </div>
                </div>

                <!-- Chat Input Section -->
                <div class="chat-input-section">
                    <div class="chat-input-group">
                        <textarea id="chatInput" 
                                  class="chat-input" 
                                  placeholder="Ask about business purpose, field flows, dependencies, optimization..." 
                                  disabled 
                                  rows="1"></textarea>
                        <button id="chatSendBtn" class="chat-send-btn" disabled>
                            <span>Send</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Loading Overlay -->
<div class="loading-overlay" id="loadingIndicator">
    <div class="loading-content">
        <div class="loading-spinner"></div>
        <div class="loading-title">ü§ñ Auto-Analyzing Components</div>
        <div class="loading-status" id="loadingStatus">Processing component auto-discovery...</div>
        <div class="loading-progress">
            <div class="loading-progress-fill" id="progressFill" style="width: 0%"></div>
        </div>
    </div>
</div>
        
    <!-- Enhanced Chat Styles -->
<style>
    /* Chat Styles - Enhanced Layout */
    .chat-container {
        display: flex;
        flex-direction: column;
        height: 100%;
    }

    /* Chat Suggestions */
    .chat-suggestions {
        padding: 0.75rem;
        background: var(--grey-50);
        border-radius: 8px;
        margin-bottom: 0.75rem;
        border: 1px solid var(--grey-200);
    }

    .chat-suggestions-title {
        font-size: 0.75rem;
        font-weight: 600;
        color: var(--grey-700);
        margin-bottom: 0.5rem;
    }

    .chat-suggestion-chips {
        display: flex;
        flex-wrap: wrap;
        gap: 0.25rem;
    }

    .chat-suggestion-btn {
        padding: 0.375rem 0.75rem;
        background: white;
        border: 1px solid var(--grey-300);
        border-radius: 20px;
        font-size: 0.7rem;
        color: var(--grey-700);
        cursor: pointer;
        transition: all var(--transition-fast);
    }

    .chat-suggestion-btn:hover {
        background: var(--primary-blue);
        color: white;
        border-color: var(--primary-blue);
        transform: translateY(-1px);
    }

    /* Enhanced Chat Messages Area */
    .chat-messages {
        flex: 1;
        overflow-y: auto;
        padding: 1rem;
        background: var(--grey-50);
        border-radius: 8px;
        margin-bottom: 1rem;
        min-height: 400px;
        max-height: calc(100vh - 400px);
        border: 1px solid var(--grey-200);
    }

    .chat-message {
        margin-bottom: 1rem;
        animation: fadeInUp 0.3s ease;
    }

    @keyframes fadeInUp {
        from {
            opacity: 0;
            transform: translateY(10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .chat-message.user {
        display: flex;
        justify-content: flex-end;
    }

    .chat-message.assistant {
        display: flex;
        justify-content: flex-start;
    }

    /* Enhanced Chat Bubbles */
    .chat-bubble {
        max-width: 95%;
        padding: 1rem;
        border-radius: 12px;
        position: relative;
        word-wrap: break-word;
        overflow-wrap: break-word;
        line-height: 1.6;
    }

    .user .chat-bubble {
        background: linear-gradient(135deg, var(--primary-blue) 0%, var(--indigo) 100%);
        color: white;
        border-bottom-right-radius: 4px;
    }

    .assistant .chat-bubble {
        background: white;
        color: var(--grey-800);
        border: 1px solid var(--grey-200);
        border-bottom-left-radius: 4px;
        box-shadow: var(--shadow-sm);
    }

    .chat-message-header {
        font-size: 0.7rem;
        font-weight: 600;
        margin-bottom: 0.25rem;
        opacity: 0.7;
    }

    .chat-message-content {
        font-size: 0.9rem;
        line-height: 1.6;
        white-space: pre-wrap;
    }

    .chat-message-content strong {
        font-weight: 600;
        color: var(--primary-blue);
    }

    .assistant .chat-message-content strong {
        color: var(--primary-blue);
    }

    .user .chat-message-content strong {
        color: white;
    }

    .chat-message-time {
        font-size: 0.65rem;
        opacity: 0.5;
        margin-top: 0.25rem;
    }

    /* Enhanced Chat Input Section */
    .chat-input-section {
        padding: 1rem;
        background: white;
        border-radius: 8px;
        border: 1px solid var(--grey-200);
        box-shadow: var(--shadow-sm);
    }

    .chat-input-group {
        display: flex;
        gap: 0.75rem;
        align-items: flex-end;
    }

    .chat-input {
        flex: 1;
        padding: 1rem;
        border: 1px solid var(--grey-300);
        border-radius: 8px;
        resize: none;
        min-height: 80px;
        max-height: 160px;
        font-size: 0.95rem;
        transition: all var(--transition-fast);
        font-family: inherit;
        line-height: 1.4;
    }

    .chat-input:focus {
        outline: none;
        border-color: var(--primary-blue);
        box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
    }

    .chat-input::placeholder {
        color: var(--grey-400);
        font-size: 0.9rem;
    }

    .chat-send-btn {
        padding: 1rem 1.5rem;
        background: linear-gradient(135deg, var(--primary-blue) 0%, var(--indigo) 100%);
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        transition: all var(--transition-fast);
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-weight: 600;
        font-size: 0.9rem;
        min-height: 80px;
        align-self: stretch;
    }

    .chat-send-btn:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: var(--shadow-lg);
    }

    .chat-send-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    /* Table Styles for Analysis Results */
    .data-table {
        width: 100%;
        background: white;
        border-radius: 8px;
        overflow: hidden;
        border: 1px solid var(--grey-200);
        margin-bottom: 1rem;
    }

    .data-table thead {
        background: var(--grey-50);
    }

    .data-table th {
        padding: 0.75rem;
        text-align: left;
        font-size: 0.85rem;
        font-weight: 600;
        color: var(--grey-700);
        border-bottom: 1px solid var(--grey-200);
    }

    .data-table td {
        padding: 0.75rem;
        font-size: 0.9rem;
        color: var(--grey-800);
        border-bottom: 1px solid var(--grey-100);
    }

    .data-table tbody tr:hover {
        background: var(--grey-50);
    }

    .data-table tbody tr:last-child td {
        border-bottom: none;
    }

    /* Metric Cards for Dashboard */
    .metrics-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
        gap: 1rem;
        margin-bottom: 1.5rem;
    }

    .metric-card {
        background: white;
        border: 1px solid var(--grey-200);
        border-radius: 12px;
        padding: 1.25rem;
        display: flex;
        align-items: center;
        gap: 1rem;
        transition: all var(--transition-fast);
        cursor: pointer;
    }

    .metric-card:hover {
        box-shadow: var(--shadow-md);
        transform: translateY(-2px);
        border-color: var(--primary-blue);
    }

    .metric-icon {
        width: 48px;
        height: 48px;
        background: linear-gradient(135deg, var(--primary-blue) 0%, var(--indigo) 100%);
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 1.5rem;
    }

    .metric-details {
        flex: 1;
    }

    .metric-label {
        font-size: 0.75rem;
        color: var(--grey-500);
        text-transform: uppercase;
        font-weight: 600;
        margin-bottom: 0.25rem;
    }

    .metric-value {
        font-size: 1.5rem;
        font-weight: bold;
        color: var(--grey-800);
    }

    .metric-change {
        font-size: 0.85rem;
        margin-top: 0.25rem;
        display: flex;
        align-items: center;
        gap: 0.25rem;
    }

    .metric-change.positive {
        color: var(--success-green);
    }

    .metric-change.negative {
        color: var(--error-red);
    }

    /* File List Styles */
    .file-list {
        max-height: 200px;
        overflow-y: auto;
        margin-top: 1rem;
    }

    .file-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.75rem;
        background: white;
        border: 1px solid var(--grey-200);
        border-radius: 8px;
        margin-bottom: 0.5rem;
        transition: all var(--transition-fast);
    }

    .file-item:hover {
        box-shadow: var(--shadow-sm);
        transform: translateX(2px);
    }

    .file-info {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        flex: 1;
    }

    .file-icon {
        width: 32px;
        height: 32px;
        background: var(--grey-100);
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--primary-blue);
    }

    .file-details {
        flex: 1;
    }

    .file-name {
        font-weight: 500;
        color: var(--grey-800);
        font-size: 0.9rem;
    }

    .file-meta {
        font-size: 0.75rem;
        color: var(--grey-500);
        margin-top: 0.125rem;
    }

    .file-remove {
        width: 28px;
        height: 28px;
        border: none;
        background: var(--error-red);
        color: white;
        border-radius: 6px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all var(--transition-fast);
    }

    .file-remove:hover {
        background: #dc2626;
        transform: scale(1.1);
    }

    /* Flow Visualization Styles */
    .flow-container {
        background: white;
        border-radius: 12px;
        padding: 1.5rem;
        margin-bottom: 1rem;
        overflow-x: auto;
        border: 1px solid var(--grey-200);
    }

    .flow-diagram {
        min-width: 800px;
        padding: 2rem;
        background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
        border-radius: 8px;
        position: relative;
    }

    .flow-level {
        display: flex;
        align-items: center;
        justify-content: center;
        margin-bottom: 3rem;
        position: relative;
    }

    .flow-level:last-child {
        margin-bottom: 0;
    }

    .flow-level-title {
        position: absolute;
        left: -120px;
        top: 50%;
        transform: translateY(-50%);
        font-weight: 600;
        color: var(--grey-600);
        font-size: 0.9rem;
        writing-mode: vertical-rl;
        text-orientation: mixed;
    }

    .flow-nodes {
        display: flex;
        gap: 2rem;
        flex-wrap: wrap;
        justify-content: center;
        flex: 1;
    }

    .flow-node {
        background: white;
        border: 2px solid var(--grey-300);
        border-radius: 12px;
        padding: 1rem;
        min-width: 120px;
        text-align: center;
        position: relative;
        transition: all var(--transition-fast);
        cursor: pointer;
    }

    .flow-node:hover {
        transform: translateY(-2px);
        box-shadow: var(--shadow-lg);
        border-color: var(--primary-blue);
    }

    .flow-node.current {
        border-color: var(--primary-blue);
        background: linear-gradient(135deg, var(--primary-blue) 0%, var(--indigo) 100%);
        color: white;
        box-shadow: var(--shadow-lg);
    }

    .flow-node.upstream {
        border-color: var(--success-green);
        background: rgba(16, 185, 129, 0.1);
    }

    .flow-node.downstream {
        border-color: var(--warning-yellow);
        background: rgba(245, 158, 11, 0.1);
    }

    .flow-node.missing {
        border-color: var(--error-red);
        background: rgba(239, 68, 68, 0.1);
        border-style: dashed;
    }

    .flow-node-icon {
        font-size: 1.5rem;
        margin-bottom: 0.5rem;
    }

    .flow-node-name {
        font-weight: 600;
        font-size: 0.9rem;
        margin-bottom: 0.25rem;
    }

    .flow-node-type {
        font-size: 0.75rem;
        opacity: 0.8;
    }

    .flow-arrow {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        bottom: -2rem;
        color: var(--primary-blue);
        font-size: 1.5rem;
        opacity: 0.7;
    }

    /* Progress Bars */
    .progress-bar {
        width: 100%;
        height: 8px;
        background: var(--grey-200);
        border-radius: 4px;
        overflow: hidden;
        margin: 0.5rem 0;
    }

    .progress-fill {
        height: 100%;
        border-radius: 4px;
        transition: width 0.3s ease;
    }

    .progress-fill.primary {
        background: linear-gradient(135deg, var(--primary-blue) 0%, var(--indigo) 100%);
    }

    .progress-fill.success {
        background: linear-gradient(135deg, var(--success-green) 0%, #059669 100%);
    }

    .progress-fill.warning {
        background: linear-gradient(135deg, var(--warning-yellow) 0%, #d97706 100%);
    }

    .progress-fill.danger {
        background: linear-gradient(135deg, var(--error-red) 0%, #dc2626 100%);
    }

    /* Typing Animation for Chat */
    .typing-indicator {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 1rem;
        background: var(--grey-100);
        border-radius: 12px;
        margin-bottom: 1rem;
        opacity: 0.8;
    }

    .typing-dots {
        display: flex;
        gap: 0.25rem;
    }

    .typing-dot {
        width: 8px;
        height: 8px;
        background: var(--grey-500);
        border-radius: 50%;
        animation: typingBounce 1.4s infinite ease-in-out;
    }

    .typing-dot:nth-child(1) { animation-delay: -0.32s; }
    .typing-dot:nth-child(2) { animation-delay: -0.16s; }
    .typing-dot:nth-child(3) { animation-delay: 0s; }

    @keyframes typingBounce {
        0%, 80%, 100% {
            transform: scale(0.8);
            opacity: 0.5;
        }
        40% {
            transform: scale(1);
            opacity: 1;
        }
    }

    /* Enhanced Database Status Indicator */
    .db-status {
        padding: 0.5rem;
        border-radius: 6px;
        font-size: 0.8rem;
        font-weight: 500;
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        margin-bottom: 1rem;
    }

    .db-status.initialized {
        background: rgba(16, 185, 129, 0.1);
        color: var(--success-green);
    }

    .db-status.error {
        background: rgba(239, 68, 68, 0.1);
        color: var(--error-red);
    }

    /* Enhanced Storage Indicators */
    .storage-info {
        font-size: 0.75rem;
        color: var(--grey-500);
        padding: 0.5rem;
        background: var(--grey-50);
        border-radius: 6px;
        margin-top: 1rem;
        text-align: center;
    }

    /* Responsive Design */
    @media (max-width: 1200px) {
        .panel.left {
            width: 350px;
        }
        .panel.right {
            width: 400px;
        }
    }

    @media (max-width: 768px) {
        .content-wrapper {
            flex-direction: column;
        }
        
        .panel {
            width: 100% !important;
            min-height: 200px;
        }
        
        .panel.left.collapsed,
        .panel.right.collapsed {
            min-height: 60px;
        }
        
        .dashboard-grid {
            grid-template-columns: 1fr;
        }
        
        .metrics-grid {
            grid-template-columns: 1fr;
        }

        .header-stats {
            display: none;
        }

        .header h1 {
            font-size: 1.5rem;
        }

        .header-subtitle {
            margin-left: 0;
            margin-top: 0.5rem;
        }
    }

    /* Dark mode variables (for future enhancement) */
    @media (prefers-color-scheme: dark) {
        :root {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --text-primary: #ffffff;
            --text-secondary: #b3b3b3;
        }
    }

    /* Additional utility classes */
    .text-center { text-align: center; }
    .text-left { text-align: left; }
    .text-right { text-align: right; }
    .font-mono { font-family: 'Courier New', monospace; }
    .font-bold { font-weight: bold; }
    .opacity-50 { opacity: 0.5; }
    .opacity-75 { opacity: 0.75; }
    .mb-1 { margin-bottom: 0.25rem; }
    .mb-2 { margin-bottom: 0.5rem; }
    .mb-3 { margin-bottom: 0.75rem; }
    .mb-4 { margin-bottom: 1rem; }
    .mt-1 { margin-top: 0.25rem; }
    .mt-2 { margin-top: 0.5rem; }
    .mt-3 { margin-top: 0.75rem; }
    .mt-4 { margin-top: 1rem; }
    .p-1 { padding: 0.25rem; }
    .p-2 { padding: 0.5rem; }
    .p-3 { padding: 0.75rem; }
    .p-4 { padding: 1rem; }

    /* Component quality indicators */
    .quality-indicator {
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
        font-size: 0.75rem;
        font-weight: 600;
    }

    .quality-excellent { color: var(--success-green); }
    .quality-good { color: #10b981; }
    .quality-fair { color: var(--warning-yellow); }
    .quality-poor { color: var(--error-red); }

    /* Animation for component loading */
    .component-loading {
        background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
        background-size: 200% 100%;
        animation: loading 1.5s infinite;
    }

    @keyframes loading {
        0% { background-position: 200% 0; }
        100% { background-position: -200% 0; }
    }
</style>
<script>
    // ============================================
// ENHANCED CODE ANALYZER - POWERED BY OPULENCE
// Core JavaScript Functions and SQLite Database Integration
// ============================================

class EnhancedCodeAnalyzer {
    constructor() {
        // Core properties
        this.uploadedFiles = [];
        this.analysisResults = {};
        this.componentSuggestions = [];
        this.discoveredComponents = new Map();
        this.serverValidated = false;
        this.vllmEndpoint = 'http://localhost:8000';
        this.maxTokens = 4000;
        this.currentSelectedComponent = null;
        this.chatHistory = [];
        this.chatContext = 'general';
        
        // Business intelligence properties
        this.friendlyNameCache = new Map();
        this.businessContextCache = new Map();
        this.componentMetrics = new Map();
        
        // SQLite Database (stored in Downloads folder)
        this.db = null;
        this.dbInitialized = false;
        this.dbPath = null;
        
        // Auto-analysis state
        this.autoAnalysisInProgress = false;
        this.analysisQueue = [];
        
        // Initialize
        this.initializeDatabase();
        this.initializeEventListeners();
        this.loadStoredData();
        this.initializeChat();
        this.addTypingAnimationStyles();

        console.log('üöÄ Enhanced Code Analyzer - Powered by Opulence - Initialized');
    }

    // ============================================
    // DATABASE INITIALIZATION AND MANAGEMENT
    // ============================================

async initializeDatabase() {
    try {
        const SQL = await initSqlJs({
            locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${file}`
        });
        
        // Initialize new database in memory
        this.db = new SQL.Database();
        this.dbInitialized = true;
        
        // Create tables
        this.createTables();
        
        // Set up periodic saving to Downloads folder
        this.setupDownloadsFolderStorage();
        
        // Check for existing database file and prompt user to load it
        this.promptForExistingDatabase();
        
        console.log('‚úÖ SQLite database initialized');
        this.updateDbStatus('initialized', '‚úÖ Database ready (Downloads folder storage)');
        
    } catch (error) {
        console.error('Failed to initialize SQLite database:', error);
        this.dbInitialized = false;
        this.updateDbStatus('error', '‚ùå Database initialization failed');
    }
}
setupDownloadsFolderStorage() {
    // Save database every 30 seconds
    this.saveInterval = setInterval(() => {
        this.saveToDownloadsFolder();
    }, 3000000);

    // Save on page unload
    window.addEventListener('beforeunload', () => {
        this.saveToDownloadsFolder();
    });

    // Save on visibility change (when user switches tabs)
    document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'hidden') {
            this.saveToDownloadsFolder();
        }
    });
}

    // Create Database Tables
    createTables() {
        if (!this.db) return;
        
        // Uploaded Files table
        this.db.run(`
            CREATE TABLE IF NOT EXISTS uploaded_files (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                file_id TEXT UNIQUE,
                name TEXT,
                content TEXT,
                size INTEGER,
                type TEXT,
                upload_date TEXT,
                components TEXT,
                metrics TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);
        
        // Discovered Components table
        this.db.run(`
            CREATE TABLE IF NOT EXISTS discovered_components (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                component_name TEXT UNIQUE,
                friendly_name TEXT,
                component_type TEXT,
                business_purpose TEXT,
                file_source TEXT,
                line_count INTEGER,
                complexity_score INTEGER,
                input_files TEXT,
                output_files TEXT,
                field_count INTEGER,
                analyzed BOOLEAN DEFAULT 0,
                quality_score INTEGER,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);
        
        // Analysis Results table
        this.db.run(`
            CREATE TABLE IF NOT EXISTS analysis_results (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                component_name TEXT UNIQUE,
                friendly_name TEXT,
                component_type TEXT,
                results_data TEXT,
                quality_score INTEGER,
                business_context TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);
        
        // Business Intelligence cache
        this.db.run(`
            CREATE TABLE IF NOT EXISTS business_intelligence (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                component_name TEXT,
                friendly_name TEXT,
                business_context TEXT,
                source TEXT DEFAULT 'LLM',
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);
        
        // Chat History table
        this.db.run(`
            CREATE TABLE IF NOT EXISTS chat_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                component_name TEXT,
                context_type TEXT,
                sender TEXT,
                content TEXT,
                timestamp TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);

        // System Settings table
        this.db.run(`
            CREATE TABLE IF NOT EXISTS system_settings (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                setting_key TEXT UNIQUE,
                setting_value TEXT,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);
    }

    async saveToDownloadsFolder() {
    if (!this.db || !this.dbInitialized) return;

    try {
        const data = this.db.export();
        const blob = new Blob([data], { type: 'application/octet-stream' });
        
        // Use consistent filename for automatic loading
        const filename = 'enhanced_code_analyzer_data.db';
        
        // Create download link
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        
        // Hide the download from user (automatic save)
        link.style.display = 'none';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);
        
        // Update status indicator
        const now = new Date().toLocaleTimeString();
        this.updateDbStatus('initialized', `‚úÖ Auto-saved to Downloads (${now})`);
        
        console.log(`üíæ Database auto-saved to Downloads folder at ${now}`);
        
    } catch (error) {
        console.error('Failed to save database to Downloads folder:', error);
        this.updateDbStatus('error', '‚ùå Failed to save to Downloads');
    }
}

// Manual Save with Custom Name
async saveToDownloadsWithName(customName = null) {
    if (!this.db || !this.dbInitialized) {
        this.showError('Database not initialized');
        return;
    }

    try {
        const data = this.db.export();
        const blob = new Blob([data], { type: 'application/octet-stream' });
        
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 16);
        const filename = customName || `enhanced_code_analyzer_backup_${timestamp}.db`;
        
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);
        
        this.showSuccess(`üìÅ Database saved: ${filename}`);
        
    } catch (error) {
        console.error('Failed to save database:', error);
        this.showError('Failed to save database');
    }
}

// Prompt User to Load Existing Database
promptForExistingDatabase() {
    // Create a subtle notification asking if user wants to load existing data
    const notification = document.createElement('div');
    notification.className = 'load-existing-notification';
    notification.innerHTML = `
        <div style="
            position: fixed; 
            top: 80px; 
            right: 20px; 
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--indigo) 100%); 
            color: white; 
            padding: 1rem 1.5rem; 
            border-radius: 12px; 
            box-shadow: var(--shadow-xl); 
            max-width: 400px; 
            z-index: 10000;
            animation: slideInRight 0.3s ease;
        ">
            <div style="font-weight: 600; margin-bottom: 0.5rem;">üìÇ Load Previous Data?</div>
            <div style="font-size: 0.9rem; margin-bottom: 1rem; opacity: 0.9;">
                Do you have a previous database file in your Downloads folder to load?
            </div>
            <div style="display: flex; gap: 0.75rem;">
                <button onclick="analyzer.loadFromDownloadsFolder()" style="
                    flex: 1; 
                    padding: 0.5rem 1rem; 
                    background: white; 
                    color: var(--primary-blue); 
                    border: none; 
                    border-radius: 6px; 
                    font-weight: 600; 
                    cursor: pointer;
                ">
                    üìÅ Load File
                </button>
                <button onclick="this.parentElement.parentElement.parentElement.remove()" style="
                    flex: 1; 
                    padding: 0.5rem 1rem; 
                    background: rgba(255,255,255,0.2); 
                    color: white; 
                    border: 1px solid rgba(255,255,255,0.3); 
                    border-radius: 6px; 
                    font-weight: 600; 
                    cursor: pointer;
                ">
                    Start Fresh
                </button>
            </div>
        </div>
    `;
    
    document.body.appendChild(notification);
    
    // Auto-remove after 10 seconds
    setTimeout(() => {
        if (notification.parentNode) {
            notification.remove();
        }
    }, 10000);
}

// Load Database from Downloads Folder
loadFromDownloadsFolder() {
    // Create file input for user to select database file
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = '.db';
    fileInput.style.display = 'none';
    
    fileInput.addEventListener('change', async (e) => {
        if (e.target.files[0]) {
            await this.loadDatabaseFromFile(e.target.files[0]);
        }
    });
    
    document.body.appendChild(fileInput);
    fileInput.click();
    document.body.removeChild(fileInput);
    
    // Remove the notification
    const notification = document.querySelector('.load-existing-notification');
    if (notification) {
        notification.remove();
    }
}

// Load Database from File
async loadDatabaseFromFile(file) {
    try {
        this.showLoading();
        this.updateLoadingStatus('üìÇ Loading database from file...');
        
        const arrayBuffer = await file.arrayBuffer();
        const uInt8Array = new Uint8Array(arrayBuffer);
        
        const SQL = await initSqlJs({
            locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${file}`
        });
        
        // Close existing database
        if (this.db) {
            this.db.close();
        }
        
        this.db = new SQL.Database(uInt8Array);
        this.dbInitialized = true;
        
        // Load data from imported database
        this.updateLoadingStatus('üìä Loading components and analysis data...');
        await this.loadDataFromDatabase();
        
        this.hideLoading();
        
        this.showSuccess(`üìÅ Database loaded from: ${file.name}`);
        this.updateDbStatus('initialized', '‚úÖ Database loaded from Downloads folder');
        
        // Update UI with loaded data
        this.updateDashboardStats();
        this.displayDiscoveredComponents();
        this.updateDashboardWithResults();
        
        // Enable chat if we have analysis results
        if (Object.keys(this.analysisResults).length > 0) {
            this.enableChat();
        }
        
    } catch (error) {
        this.hideLoading();
        console.error('Failed to load database:', error);
        this.showError(`Failed to load database: ${error.message}`);
    }
}

// Enhanced Save to Database with Auto-save
saveToDatabase() {
    if (!this.db || !this.dbInitialized) return;

    try {
        // Save uploaded files
        this.uploadedFiles.forEach(file => {
            this.db.run(`
                INSERT OR REPLACE INTO uploaded_files 
                (file_id, name, content, size, type, upload_date, components, metrics)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            `, [
                file.id,
                file.name,
                file.content,
                file.size,
                file.type,
                file.uploadDate,
                JSON.stringify(file.components || []),
                JSON.stringify(file.metrics || {})
            ]);
        });

        // Save discovered components
        this.discoveredComponents.forEach((component, name) => {
            this.db.run(`
                INSERT OR REPLACE INTO discovered_components 
                (component_name, friendly_name, component_type, business_purpose, 
                 file_source, line_count, complexity_score, input_files, output_files, 
                 field_count, analyzed, quality_score)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            `, [
                name,
                component.friendlyName,
                component.type,
                component.businessPurpose,
                component.fileSource,
                component.lineCount,
                component.complexityScore,
                JSON.stringify(component.inputFiles || []),
                JSON.stringify(component.outputFiles || []),
                component.fieldCount,
                component.analyzed ? 1 : 0,
                component.qualityScore
            ]);
        });

        // Save analysis results
        Object.entries(this.analysisResults).forEach(([name, result]) => {
            this.db.run(`
                INSERT OR REPLACE INTO analysis_results 
                (component_name, friendly_name, component_type, results_data, 
                 quality_score, business_context, updated_at)
                VALUES (?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
            `, [
                name,
                result.friendlyName,
                result.componentType,
                JSON.stringify(result),
                result.qualityScore,
                result.llmAnalysis?.businessPurpose || ''
            ]);
        });

        // Save system settings
        this.db.run(`
            INSERT OR REPLACE INTO system_settings (setting_key, setting_value, updated_at)
            VALUES ('vllm_endpoint', ?, CURRENT_TIMESTAMP)
        `, [this.vllmEndpoint]);

        this.db.run(`
            INSERT OR REPLACE INTO system_settings (setting_key, setting_value, updated_at)
            VALUES ('max_tokens', ?, CURRENT_TIMESTAMP)
        `, [this.maxTokens.toString()]);

        console.log('üíæ Data saved to database');

    } catch (error) {
        console.error('Failed to save to database:', error);
    }
}

// Load Data from Database (same as before)
async loadDataFromDatabase() {
    if (!this.db || !this.dbInitialized) return;

    try {
        // Clear existing data
        this.uploadedFiles = [];
        this.discoveredComponents.clear();
        this.analysisResults = {};

        // Load uploaded files
        const filesStmt = this.db.prepare('SELECT * FROM uploaded_files ORDER BY created_at DESC');
        while (filesStmt.step()) {
            const row = filesStmt.getAsObject();
            const file = {
                id: row.file_id,
                name: row.name,
                content: row.content,
                size: row.size,
                type: row.type,
                uploadDate: row.upload_date,
                components: JSON.parse(row.components || '[]'),
                metrics: JSON.parse(row.metrics || '{}')
            };
            this.uploadedFiles.push(file);
        }
        filesStmt.free();

        // Load discovered components
        const componentsStmt = this.db.prepare('SELECT * FROM discovered_components ORDER BY created_at DESC');
        while (componentsStmt.step()) {
            const row = componentsStmt.getAsObject();
            const component = {
                name: row.component_name,
                friendlyName: row.friendly_name,
                type: row.component_type,
                businessPurpose: row.business_purpose,
                fileSource: row.file_source,
                lineCount: row.line_count,
                complexityScore: row.complexity_score,
                inputFiles: JSON.parse(row.input_files || '[]'),
                outputFiles: JSON.parse(row.output_files || '[]'),
                fieldCount: row.field_count,
                analyzed: row.analyzed === 1,
                qualityScore: row.quality_score,
                timestamp: row.created_at
            };
            this.discoveredComponents.set(row.component_name, component);
        }
        componentsStmt.free();

        // Load analysis results
        const resultsStmt = this.db.prepare('SELECT * FROM analysis_results ORDER BY updated_at DESC');
        while (resultsStmt.step()) {
            const row = resultsStmt.getAsObject();
            try {
                this.analysisResults[row.component_name] = JSON.parse(row.results_data);
            } catch (error) {
                console.warn(`Failed to parse analysis result for ${row.component_name}:`, error);
            }
        }
        resultsStmt.free();

        // Load system settings
        const settingsStmt = this.db.prepare('SELECT * FROM system_settings');
        while (settingsStmt.step()) {
            const row = settingsStmt.getAsObject();
            if (row.setting_key === 'vllm_endpoint') {
                this.vllmEndpoint = row.setting_value;
                const endpointInput = document.getElementById('vllmEndpoint');
                if (endpointInput) endpointInput.value = row.setting_value;
            } else if (row.setting_key === 'max_tokens') {
                this.maxTokens = parseInt(row.setting_value);
                const maxTokensInput = document.getElementById('maxTokens');
                if (maxTokensInput) maxTokensInput.value = row.setting_value;
            }
        }
        settingsStmt.free();

        console.log(`üìä Data loaded: ${this.uploadedFiles.length} files, ${this.discoveredComponents.size} components, ${Object.keys(this.analysisResults).length} analyses`);

    } catch (error) {
        console.error('Failed to load from database:', error);
    }
}

// Clear All Data
clearAllData() {
    if (!confirm('Are you sure you want to clear all data? This action cannot be undone.')) {
        return;
    }
    
    // Clear in-memory data
    this.uploadedFiles = [];
    this.analysisResults = {};
    this.discoveredComponents.clear();
    this.currentSelectedComponent = null;
    this.chatHistory = [];
    
    // Clear database
    if (this.db && this.dbInitialized) {
        try {
            this.db.run('DELETE FROM uploaded_files');
            this.db.run('DELETE FROM discovered_components');
            this.db.run('DELETE FROM analysis_results');
            this.db.run('DELETE FROM business_intelligence');
            this.db.run('DELETE FROM chat_history');
            this.db.run('DELETE FROM system_settings');
        } catch (error) {
            console.error('Failed to clear database:', error);
        }
    }
    
    // Reset UI
    this.updateDashboardStats();
    this.displayDiscoveredComponents();
    
    // Clear chat
    const chatMessages = document.getElementById('chatMessages');
    if (chatMessages) {
        chatMessages.innerHTML = `
            <div class="chat-message assistant">
                <div class="chat-bubble">
                    <div class="chat-message-header">Business Intelligence Assistant</div>
                    <div class="chat-message-content">
                        üëã <strong>Data cleared successfully!</strong>
                        <br><br>
                        Upload your mainframe files to start a new analysis session.
                    </div>
                    <div class="chat-message-time">${new Date().toLocaleTimeString()}</div>
                </div>
            </div>
        `;
    }
    
    // Disable features
    const chatInput = document.getElementById('chatInput');
    const chatSendBtn = document.getElementById('chatSendBtn');
    const exportJsonBtn = document.getElementById('exportJsonBtn');
    const exportMdBtn = document.getElementById('exportMdBtn');
    
    if (chatInput) chatInput.disabled = true;
    if (chatSendBtn) chatSendBtn.disabled = true;
    if (exportJsonBtn) exportJsonBtn.disabled = true;
    if (exportMdBtn) exportMdBtn.disabled = true;
    
    this.showSuccess('üóëÔ∏è All data cleared successfully');
}

// Cleanup on page unload
cleanup() {
    if (this.saveInterval) {
        clearInterval(this.saveInterval);
    }
    
    if (this.db) {
        // Save one final time before closing
        this.saveToDownloadsFolder();
        this.db.close();
    }
}



    // Setup Database Saving to Downloads Folder
    setupDatabaseSaving() {
        // Save database every 30 seconds
        setInterval(() => {
            this.saveDatabase();
        }, 30000);

        // Save on page unload
        window.addEventListener('beforeunload', () => {
            this.saveDatabase();
        });
    }

    // Save Database to Downloads Folder
    async saveDatabase() {
        if (!this.db || !this.dbInitialized) return;

        try {
            const data = this.db.export();
            const blob = new Blob([data], { type: 'application/octet-stream' });
            
            // Create download link
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const filename = `enhanced_code_analyzer_${timestamp}.db`;
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            
            // Automatically download to Downloads folder
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            console.log(`üìÅ Database saved to Downloads: ${filename}`);
            
        } catch (error) {
            console.error('Failed to save database:', error);
        }
    }

    // Load Database from File
    async loadDatabase(file) {
        try {
            const arrayBuffer = await file.arrayBuffer();
            const uInt8Array = new Uint8Array(arrayBuffer);
            
            const SQL = await initSqlJs({
                locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${file}`
            });
            
            this.db = new SQL.Database(uInt8Array);
            this.dbInitialized = true;
            
            // Reload data from database
            await this.loadDataFromDatabase();
            
            this.showSuccess(`üìÅ Database loaded from: ${file.name}`);
            this.updateDbStatus('initialized', '‚úÖ Database loaded successfully');
            
        } catch (error) {
            console.error('Failed to load database:', error);
            this.showError(`Failed to load database: ${error.message}`);
        }
    }

    // Update Database Status Indicator
    updateDbStatus(status, message) {
        const indicator = document.getElementById('dbStatusIndicator');
        if (indicator) {
            indicator.className = `db-status ${status}`;
            indicator.textContent = message;
        }
    }

    // ============================================
    // EVENT LISTENERS AND UI INTERACTIONS
    // ============================================

    initializeEventListeners() {
        // API Validation
        const validateBtn = document.getElementById('validateApiBtn');
        if (validateBtn) {
            validateBtn.addEventListener('click', () => this.validateConnection());
        }
        
        // File Upload
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        
        if (uploadArea && fileInput) {
            uploadArea.addEventListener('click', () => {
                if (this.serverValidated) fileInput.click();
            });
            uploadArea.addEventListener('drop', (e) => this.handleFileDrop(e));
            uploadArea.addEventListener('dragover', (e) => this.handleDragOver(e));
            uploadArea.addEventListener('dragleave', (e) => this.handleDragLeave(e));
            fileInput.addEventListener('change', (e) => this.handleFileSelect(e));
        }
        
        // Auto Analysis
        const autoAnalyzeBtn = document.getElementById('autoAnalyzeBtn');
        if (autoAnalyzeBtn) {
            autoAnalyzeBtn.addEventListener('click', () => this.startAutoAnalysis());
        }
        
        // Export buttons
        const exportJsonBtn = document.getElementById('exportJsonBtn');
        const exportMdBtn = document.getElementById('exportMdBtn');
        const clearBtn = document.getElementById('clearBtn');
        
        if (exportJsonBtn) exportJsonBtn.addEventListener('click', () => this.exportResults('json'));
        if (exportMdBtn) exportMdBtn.addEventListener('click', () => this.exportResults('markdown'));
        if (clearBtn) clearBtn.addEventListener('click', () => this.clearAllData());
        
        // Settings
        const endpointInput = document.getElementById('vllmEndpoint');
        const maxTokensInput = document.getElementById('maxTokens');
        
        if (endpointInput) {
            endpointInput.addEventListener('input', () => this.onEndpointChange());
        }
        
        if (maxTokensInput) {
            maxTokensInput.addEventListener('input', () => this.onSettingsChange());
        }
        
        // Chat context selector
        const chatContext = document.getElementById('chatContext');
        if (chatContext) {
            chatContext.addEventListener('change', () => this.onChatContextChange());
        }

        // Initialize tabs
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', function() {
                // Remove active from all tabs
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                // Add active to clicked tab
                this.classList.add('active');
                const tabId = this.getAttribute('data-tab');
                document.getElementById(tabId).classList.add('active');
            });
        });

        // Database file upload for loading existing database
        const dbUploadInput = document.createElement('input');
        dbUploadInput.type = 'file';
        dbUploadInput.accept = '.db';
        dbUploadInput.style.display = 'none';
        dbUploadInput.addEventListener('change', (e) => {
            if (e.target.files[0]) {
                this.loadDatabase(e.target.files[0]);
            }
        });
        document.body.appendChild(dbUploadInput);
    }

    // ============================================
    // UI HELPER FUNCTIONS
    // ============================================

    // Basic UI Functions
    togglePanel(side) {
        const panel = document.getElementById(side + 'Panel');
        panel.classList.toggle('collapsed');
        
        // Update button icon
        const btn = panel.querySelector('.collapse-btn');
        if (side === 'left') {
            btn.textContent = panel.classList.contains('collapsed') ? '‚ñ∂' : '‚óÄ';
        } else {
            btn.textContent = panel.classList.contains('collapsed') ? '‚óÄ' : '‚ñ∂';
        }
        
        // Save state to database
        this.db.run(`
            INSERT OR REPLACE INTO system_settings (setting_key, setting_value, updated_at)
            VALUES (?, ?, CURRENT_TIMESTAMP)
        `, [`${side}_panel_collapsed`, panel.classList.contains('collapsed') ? '1' : '0']);
    }

    toggleCollapsible(header) {
        const section = header.parentElement;
        section.classList.toggle('expanded');
    }

    // Show/Hide Loading
    showLoading() {
        const loading = document.getElementById('loadingIndicator');
        if (loading) loading.classList.add('show');
    }

    hideLoading() {
        const loading = document.getElementById('loadingIndicator');
        if (loading) loading.classList.remove('show');
    }

    updateLoadingStatus(status) {
        const statusEl = document.getElementById('loadingStatus');
        if (statusEl) statusEl.textContent = status;
    }

    updateProgress(percentage) {
        const progressFill = document.getElementById('progressFill');
        if (progressFill) progressFill.style.width = `${percentage}%`;
    }

    // Alert Messages
    showMessage(type, message, duration = 3000) {
        const alert = document.createElement('div');
        alert.className = `alert alert-${type}`;
        alert.innerHTML = `
            <span class="alert-icon">${type === 'success' ? '‚úÖ' : type === 'error' ? '‚ùå' : type === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è'}</span>
            <span class="alert-message">${message}</span>
        `;
        document.body.appendChild(alert);
        
        setTimeout(() => {
            if (alert.parentNode) {
                alert.style.animation = 'slideInRight 0.3s ease reverse';
                setTimeout(() => alert.remove(), 300);
            }
        }, duration);
    }

    showSuccess(message) { this.showMessage('success', message); }
    showError(message) { this.showMessage('error', message, 5000); }
    showWarning(message) { this.showMessage('warning', message, 4000); }
    showInfo(message) { this.showMessage('info', message); }

    // ============================================
    // LLM CONNECTION AND VALIDATION
    // ============================================

    // Validate LLM Connection
    async validateConnection() {
        const endpoint = document.getElementById('vllmEndpoint').value.trim();
        if (!endpoint) {
            this.showError('Please enter vLLM endpoint');
            return;
        }

        this.updateConnectionStatus('connecting', 'Testing LLM connection...');

        try {
            const response = await fetch(`${endpoint}/generate`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    prompt: "Test connection. Respond with 'Connected'",
                    max_tokens: 10,
                    temperature: 0.1
                }),
                signal: AbortSignal.timeout(10000)
            });

            if (response.ok) {
                this.serverValidated = true;
                this.vllmEndpoint = endpoint;
                this.updateConnectionStatus('connected', `‚úÖ LLM connection verified`);
                this.showSuccess('üöÄ vLLM server connected successfully!');
                
                // Enable file upload and auto-analysis
                this.enableFileUpload();
                
                // Save to database
                this.saveToDatabase();
            } else {
                throw new Error(`HTTP ${response.status}`);
            }
        } catch (error) {
            this.serverValidated = false;
            this.updateConnectionStatus('disconnected', `‚ùå Connection failed: ${error.message}`);
            this.showError(`LLM connection failed: ${error.message}`);
        }
    }

    // Enable File Upload
    enableFileUpload() {
        const uploadArea = document.getElementById('uploadArea');
        const autoAnalyzeBtn = document.getElementById('autoAnalyzeBtn');
        
        if (uploadArea) {
            uploadArea.style.opacity = '1';
            uploadArea.style.cursor = 'pointer';
        }
        
        // Enable auto-analysis if files are already uploaded
        if (this.uploadedFiles.length > 0 && autoAnalyzeBtn) {
            autoAnalyzeBtn.disabled = false;
        }
    }

    // Update Connection Status
    updateConnectionStatus(status, message) {
        const statusEl = document.getElementById('apiStatus');
        if (statusEl) {
            statusEl.className = `status-indicator ${status}`;
            statusEl.innerHTML = `
                <span class="status-dot"></span>
                <span>${message}</span>
            `;
        }
    }

    // ============================================
    // FILE HANDLING AND PROCESSING
    // ============================================

    // File Upload Handling
    async handleFileDrop(e) {
        e.preventDefault();
        e.stopPropagation();
        
        const uploadArea = document.getElementById('uploadArea');
        uploadArea.classList.remove('drag-over');
        
        if (!this.serverValidated) {
            this.showError('Please validate LLM API connection first');
            return;
        }
        
        const files = Array.from(e.dataTransfer.files);
        await this.processFiles(files);
    }

    async handleFileSelect(e) {
        if (!this.serverValidated) {
            this.showError('Please validate LLM API connection first');
            return;
        }
        
        const files = Array.from(e.target.files);
        await this.processFiles(files);
    }

    handleDragOver(e) {
        e.preventDefault();
        const uploadArea = document.getElementById('uploadArea');
        if (uploadArea) uploadArea.classList.add('drag-over');
    }

    handleDragLeave(e) {
        e.preventDefault();
        const uploadArea = document.getElementById('uploadArea');
        if (uploadArea) uploadArea.classList.remove('drag-over');
    }

    // Process Files with Auto-Discovery
    async processFiles(files) {
        for (const file of files) {
            try {
                const content = await this.readFile(file);
                const fileType = this.detectFileType(file.name, content);
                
                const fileObj = {
                    name: file.name,
                    content: content,
                    size: file.size,
                    type: fileType,
                    uploadDate: new Date().toISOString(),
                    id: Date.now() + Math.random(),
                    components: this.extractComponentsFromFile(content, fileType),
                    metrics: this.calculateFileMetrics(content, fileType)
                };
                
                this.uploadedFiles.push(fileObj);
                
                // Auto-discover components
                await this.autoDiscoverComponents(fileObj);
                
            } catch (error) {
                this.showError(`Failed to read ${file.name}: ${error.message}`);
            }
        }
        
        this.updateDashboardStats();
        this.displayDiscoveredComponents();
        this.enableAutoAnalysis();
        this.saveToDatabase();
        
        this.showSuccess(`üìÅ ${files.length} files uploaded and components auto-discovered!`);
    }

    // Read File
    readFile(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = e => resolve(e.target.result);
            reader.onerror = e => reject(new Error('File read failed'));
            reader.readAsText(file);
        });
    }

    // Detect File Type
    detectFileType(fileName, content) {
        const name = fileName.toLowerCase();
        const upperContent = content.toUpperCase();
        
        if (name.includes('.cpy') || name.includes('copybook')) {
            return 'Copybook';
        } else if (name.includes('.jcl') || upperContent.includes('//JOB ')) {
            return 'JCL Job';
        } else if (name.includes('.cbl') || name.includes('.cob') || 
                  upperContent.includes('IDENTIFICATION DIVISION') ||
                  upperContent.includes('PROGRAM-ID')) {
            return 'COBOL Program';
        } else if (name.includes('.proc')) {
            return 'JCL Procedure';
        } else {
            return 'Text File';
        }
    }

    // Calculate File Metrics
    calculateFileMetrics(content, fileType) {
        const lines = content.split('\n');
        const totalLines = lines.length;
        const codeLines = lines.filter(line => {
            const trimmed = line.trim();
            return trimmed.length > 0 && !trimmed.startsWith('*') && !trimmed.startsWith('//');
        }).length;
        
        const complexity = this.calculateComplexity(content, fileType);
        
        return {
            totalLines,
            codeLines,
            commentLines: totalLines - codeLines,
            complexity,
            fileSize: content.length
        };
    }

    // Calculate Complexity Score
    calculateComplexity(content, fileType) {
        const upperContent = content.toUpperCase();
        let complexity = 1;
        
        if (fileType === 'COBOL Program') {
            // Count decision points
            const ifCount = (upperContent.match(/\bIF\b/g) || []).length;
            const performCount = (upperContent.match(/\bPERFORM\b/g) || []).length;
            const evaluateCount = (upperContent.match(/\bEVALUATE\b/g) || []).length;
            
            complexity = 1 + ifCount + performCount + evaluateCount;
        } else if (fileType === 'Copybook') {
            // Count field definitions
            const fieldCount = (upperContent.match(/^\s*\d{2}\s+/gm) || []).length;
            complexity = Math.ceil(fieldCount / 10);
        }
        
        return Math.min(complexity, 10);
    }

    // ============================================
    // COMPONENT EXTRACTION AND DISCOVERY
    // ============================================

    // Extract Components from Files
    extractComponentsFromFile(content, fileType) {
        const components = [];
        const lines = content.split('\n');

        lines.forEach((line, index) => {
            const trimmed = line.trim().toUpperCase();
            
            // Extract COBOL 01-level fields (main focus for copybooks)
            const field01Match = trimmed.match(/^\s*01\s+([A-Z][A-Z0-9\-_]{2,})/);
            if (field01Match) {
                components.push({
                    name: field01Match[1],
                    type: 'RECORD_LAYOUT',
                    level: '01',
                    lineNumber: index + 1,
                    fileType: fileType,
                    isMainComponent: true,
                    businessPurpose: this.generateBusinessPurpose(field01Match[1])
                });
            }
            
            // Extract ALL field levels for complete analysis
            const fieldMatch = trimmed.match(/^\s*(\d{2})\s+([A-Z][A-Z0-9\-_]*)/);
            if (fieldMatch) {
                const level = parseInt(fieldMatch[1]);
                const fieldName = fieldMatch[2];
                
                if (level !== 88 && fieldName) {
                    components.push({
                        name: fieldName,
                        type: level === 1 ? 'RECORD_LAYOUT' : 'FIELD',
                        level: level,
                        lineNumber: index + 1,
                        fileType: fileType,
                        isMainComponent: level === 1,
                        businessPurpose: this.generateBusinessPurpose(fieldName)
                    });
                }
            }
            
            // Extract copybook names
            const copyMatch = trimmed.match(/COPY\s+([A-Z][A-Z0-9\-_]{2,})/);
            if (copyMatch) {
                components.push({
                    name: copyMatch[1],
                    type: 'COPYBOOK',
                    lineNumber: index + 1,
                    fileType: fileType,
                    isMainComponent: false,
                    businessPurpose: this.generateBusinessPurpose(copyMatch[1])
                });
            }
            
            // Extract program names
            const programMatch = trimmed.match(/PROGRAM-ID\.?\s+([A-Z][A-Z0-9\-_]{2,})/);
            if (programMatch) {
                components.push({
                    name: programMatch[1],
                    type: 'PROGRAM',
                    lineNumber: index + 1,
                    fileType: fileType,
                    isMainComponent: true,
                    businessPurpose: this.generateBusinessPurpose(programMatch[1])
                });
            }

            // Extract file names from FD statements
            const fileMatch = trimmed.match(/FD\s+([A-Z][A-Z0-9\-_]{2,})/);
            if (fileMatch) {
                components.push({
                    name: fileMatch[1],
                    type: 'FILE',
                    lineNumber: index + 1,
                    fileType: fileType,
                    isMainComponent: false,
                    businessPurpose: this.generateBusinessPurpose(fileMatch[1])
                });
            }
        });
        
        return components;
    }

    // Generate Business Purpose based on naming patterns
    generateBusinessPurpose(componentName) {
        const name = componentName.toUpperCase();
        
        // Customer-related
        if (name.includes('CUST') || name.includes('CUSTOMER')) {
            if (name.includes('MASTER') || name.includes('MAST')) {
                return 'Customer Master Data Management';
            } else if (name.includes('TRANS') || name.includes('TXN')) {
                return 'Customer Transaction Processing';
            } else if (name.includes('VALID') || name.includes('CHECK')) {
                return 'Customer Data Validation';
            } else {
                return 'Customer Information Processing';
            }
        }
        
        // Account-related
        else if (name.includes('ACCT') || name.includes('ACCOUNT')) {
            if (name.includes('BAL') || name.includes('BALANCE')) {
                return 'Account Balance Management';
            } else if (name.includes('TRANS') || name.includes('TXN')) {
                return 'Account Transaction Processing';
            } else if (name.includes('MAINT') || name.includes('UPD')) {
                return 'Account Maintenance Operations';
            } else {
                return 'Account Management System';
            }
        }
        
        // Financial/Payment
        else if (name.includes('PAY') || name.includes('PAYMENT')) {
            return 'Payment Processing System';
        } else if (name.includes('INVOICE') || name.includes('INV')) {
            return 'Invoice Management System';
        } else if (name.includes('BILLING') || name.includes('BILL')) {
            return 'Billing Operations System';
        }
        
        // Transaction-related
        else if (name.includes('TRANS') || name.includes('TXN')) {
            if (name.includes('LOG') || name.includes('HIST')) {
                return 'Transaction History & Logging';
            } else if (name.includes('PROC') || name.includes('PROCESS')) {
                return 'Transaction Processing Engine';
            } else {
                return 'Transaction Management System';
            }
        }
        
        // Data management
        else if (name.includes('MASTER') || name.includes('MAST')) {
            return 'Master Data Management';
        } else if (name.includes('COPY') || name.includes('CPY')) {
            return 'Data Structure Definition';
        } else if (name.includes('VALID') || name.includes('CHECK')) {
            return 'Data Validation & Quality Control';
        }
        
        // Reports
        else if (name.includes('REPORT') || name.includes('RPT')) {
            return 'Report Generation System';
        } else if (name.includes('EXTRACT') || name.includes('EXT')) {
            return 'Data Extraction & ETL';
        }
        
        // Maintenance
        else if (name.includes('MAINT') || name.includes('UPD')) {
            return 'Data Maintenance Operations';
        } else if (name.includes('DELETE') || name.includes('DEL')) {
            return 'Data Deletion & Cleanup';
        }
        
        // Generic based on type indicators
        else if (name.includes('PROC') || name.includes('PROCESS')) {
            return 'Business Process Automation';
        } else if (name.includes('UTIL') || name.includes('UTILITY')) {
            return 'System Utility Functions';
        } else if (name.includes('BATCH') || name.includes('JOB')) {
            return 'Batch Processing System';
        } else if (name.includes('ONLINE') || name.includes('CICS')) {
            return 'Online Transaction Processing';
        }
        
        // Fallback based on common patterns
        else if (name.endsWith('-RECORD') || name.endsWith('-REC')) {
            return 'Data Record Structure';
        } else if (name.endsWith('-FILE') || name.endsWith('-FL')) {
            return 'File Management System';
        } else if (name.endsWith('-PROG') || name.endsWith('-PGM')) {
            return 'Business Logic Program';
        } else {
            return 'Mainframe Business Component';
        }
    }

    // Utility function
    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    // Settings Change Handlers
    onEndpointChange() {
        this.serverValidated = false;
        this.updateConnectionStatus('disconnected', 'Connection not validated');
    }

    onSettingsChange() {
        const maxTokensInput = document.getElementById('maxTokens');
        if (maxTokensInput) {
            this.maxTokens = parseInt(maxTokensInput.value) || 4000;
            this.saveToDatabase();
        }
    }
    // ============================================
    // AUTO-DISCOVERY AND COMPONENT ANALYSIS
    // ============================================

    // Auto-Discover Components
    async autoDiscoverComponents(fileObj) {
        for (const component of fileObj.components) {
            if (component.isMainComponent) {
                const discoveredComponent = {
                    name: component.name,
                    friendlyName: await this.generateFriendlyName(component.name),
                    type: component.type,
                    businessPurpose: component.businessPurpose,
                    fileSource: fileObj.name,
                    lineCount: fileObj.metrics.codeLines,
                    complexityScore: fileObj.metrics.complexity,
                    inputFiles: this.extractInputFiles(fileObj.content),
                    outputFiles: this.extractOutputFiles(fileObj.content),
                    fieldCount: fileObj.components.filter(c => c.type === 'FIELD' || c.type === 'RECORD_LAYOUT').length,
                    analyzed: false,
                    timestamp: new Date().toISOString()
                };
                
                this.discoveredComponents.set(component.name, discoveredComponent);
            }
        }
    }

    // Extract Input/Output Files
    extractInputFiles(content) {
        const files = [];
        const lines = content.split('\n');
        
        lines.forEach(line => {
            const trimmed = line.trim().toUpperCase();
            
            // Look for INPUT file patterns
            const inputPatterns = [
                /SELECT\s+([A-Z][A-Z0-9\-_]+)\s+ASSIGN/,
                /OPEN\s+INPUT\s+([A-Z][A-Z0-9\-_]+)/,
                /READ\s+([A-Z][A-Z0-9\-_]+)/
            ];
            
            for (const pattern of inputPatterns) {
                const match = trimmed.match(pattern);
                if (match && !files.includes(match[1])) {
                    files.push(match[1]);
                }
            }
        });
        
        return files.slice(0, 10); // Limit to top 10
    }

    extractOutputFiles(content) {
        const files = [];
        const lines = content.split('\n');
        
        lines.forEach(line => {
            const trimmed = line.trim().toUpperCase();
            
            // Look for OUTPUT file patterns
            const outputPatterns = [
                /OPEN\s+OUTPUT\s+([A-Z][A-Z0-9\-_]+)/,
                /WRITE\s+([A-Z][A-Z0-9\-_]+)/,
                /DISPLAY\s+.*\s+UPON\s+([A-Z][A-Z0-9\-_]+)/
            ];
            
            for (const pattern of outputPatterns) {
                const match = trimmed.match(pattern);
                if (match && !files.includes(match[1])) {
                    files.push(match[1]);
                }
            }
        });
        
        return files.slice(0, 10); // Limit to top 10
    }

    // Generate Friendly Name using LLM or patterns
    async generateFriendlyName(componentName) {
        // Check cache first
        if (this.friendlyNameCache.has(componentName.toUpperCase())) {
            return this.friendlyNameCache.get(componentName.toUpperCase());
        }
        
        // Try LLM generation if available
        if (this.serverValidated) {
            try {
                const prompt = `Generate a business-friendly name for this mainframe component: "${componentName}"

Examples:
- CUST-MASTER ‚Üí "Customer Master File"
- ACCT-VALIDATE ‚Üí "Account Validation Program" 
- TRANS-LOG ‚Üí "Transaction Log Handler"
- PAY-PROCESS ‚Üí "Payment Processing System"

Return only the friendly name, no explanation.`;

                const response = await this.callLLMAPI(prompt);
                if (response && typeof response === 'string' && response.length < 100) {
                    this.friendlyNameCache.set(componentName.toUpperCase(), response.trim());
                    return response.trim();
                }
            } catch (error) {
                console.warn('LLM friendly name generation failed:', error);
            }
        }
        
        // Fallback to pattern-based generation
        return this.generateFriendlyNameFromPattern(componentName);
    }

    // Pattern-based friendly name generation
    generateFriendlyNameFromPattern(componentName) {
        const name = componentName.toUpperCase();
        
        // Common mainframe patterns to friendly names
        const patterns = [
            { pattern: /CUST.*MASTER/, replacement: 'Customer Master File' },
            { pattern: /CUST.*MAINT/, replacement: 'Customer Maintenance Program' },
            { pattern: /CUST.*VALID/, replacement: 'Customer Validation Program' },
            { pattern: /ACCT.*MASTER/, replacement: 'Account Master File' },
            { pattern: /ACCT.*TRANS/, replacement: 'Account Transaction Program' },
            { pattern: /ACCT.*BAL/, replacement: 'Account Balance Program' },
            { pattern: /PAY.*PROC/, replacement: 'Payment Processing System' },
            { pattern: /TRANS.*LOG/, replacement: 'Transaction Log Handler' },
            { pattern: /INVOICE.*PROC/, replacement: 'Invoice Processing System' },
            { pattern: /REPORT.*GEN/, replacement: 'Report Generation Program' },
            { pattern: /.*MASTER.*/, replacement: `${name.split('-')[0]} Master Data` },
            { pattern: /.*COPY.*/, replacement: `${name.split('-')[0]} Data Structure` },
            { pattern: /.*VALID.*/, replacement: `${name.split('-')[0]} Validation Program` },
            { pattern: /.*PROC.*/, replacement: `${name.split('-')[0]} Processing System` }
        ];
        
        for (const { pattern, replacement } of patterns) {
            if (pattern.test(name)) {
                return replacement;
            }
        }
        
        // Final fallback
        const parts = name.split('-');
        if (parts.length > 1) {
            return `${parts[0]} ${parts[1]} System`;
        } else {
            return `${name} Component`;
        }
    }

    // Enable Auto Analysis
    enableAutoAnalysis() {
        const autoAnalyzeBtn = document.getElementById('autoAnalyzeBtn');
        if (autoAnalyzeBtn && this.discoveredComponents.size > 0 && this.serverValidated) {
            autoAnalyzeBtn.disabled = false;
        }
    }

    // Start Auto Analysis
    async startAutoAnalysis() {
        if (this.autoAnalysisInProgress) {
            this.showWarning('Auto-analysis already in progress');
            return;
        }
        
        if (this.discoveredComponents.size === 0) {
            this.showError('No components discovered for analysis');
            return;
        }
        
        this.autoAnalysisInProgress = true;
        this.showLoading();
        this.updateLoadingStatus('üöÄ Starting auto-analysis of discovered components...');
        
        try {
            const components = Array.from(this.discoveredComponents.values())
                .filter(comp => !comp.analyzed)
                .slice(0, 8); // Limit to 8 components for performance
            
            let completed = 0;
            
            for (const component of components) {
                try {
                    this.updateLoadingStatus(`Analyzing ${component.friendlyName || component.name} (${completed + 1}/${components.length})...`);
                    this.updateProgress((completed / components.length) * 100);
                    
                    const relevantFiles = this.findRelevantFiles(component.name);
                    const analysisResult = await this.runComponentAnalysis(component.name, relevantFiles);
                    
                    this.analysisResults[component.name] = analysisResult;
                    component.analyzed = true;
                    component.qualityScore = analysisResult.qualityScore;
                    
                    completed++;
                    
                    // Brief pause between analyses
                    await this.sleep(1000);
                    
                } catch (error) {
                    console.warn(`Failed to analyze ${component.name}:`, error);
                    component.analyzed = false;
                }
            }
            
            this.hideLoading();
            this.updateDashboardWithResults();
            this.enableChat();
            this.saveToDatabase();
            
            this.showSuccess(`‚ú® Auto-analysis complete! ${completed}/${components.length} components analyzed`);
            
            // Switch to dashboard to show results
            document.querySelector('.tab[data-tab="dashboard"]').click();
            
        } catch (error) {
            this.hideLoading();
            this.showError(`Auto-analysis failed: ${error.message}`);
        } finally {
            this.autoAnalysisInProgress = false;
        }
    }

    // Find Relevant Files for Component
    findRelevantFiles(componentName) {
        const componentUpper = componentName.toUpperCase();
        const componentBase = componentUpper.replace(/\.(CPY|COPYBOOK|COP)$/, '');
        
        return this.uploadedFiles.filter(file => {
            const fileNameUpper = file.name.toUpperCase();
            const fileNameBase = fileNameUpper.replace(/\.(CPY|COPYBOOK|COP)$/, '');
            
            // Direct name match
            if (fileNameUpper.includes(componentUpper) || 
                fileNameBase === componentBase ||
                componentBase === fileNameBase) {
                return true;
            }
            
            // Content-based matching
            const contentUpper = file.content.toUpperCase();
            if (contentUpper.includes(componentUpper) ||
                contentUpper.includes(componentBase) ||
                contentUpper.includes(`COPY ${componentBase}`) ||
                contentUpper.includes(`"${componentBase}"`) ||
                contentUpper.includes(`'${componentBase}'`)) {
                return true;
            }
            
            // Component-based matching
            if (file.components) {
                return file.components.some(comp => {
                    const compNameUpper = comp.name.toUpperCase();
                    const compNameBase = compNameUpper.replace(/\.(CPY|COPYBOOK|COP)$/, '');
                    return compNameUpper === componentUpper || 
                           compNameBase === componentBase ||
                           componentBase === compNameBase;
                });
            }
            
            return false;
        });
    }

    // Run Component Analysis (simplified for auto-analysis)
    async runComponentAnalysis(componentName, relevantFiles) {
        console.log(`Running analysis for: ${componentName}`);
        
        const component = this.discoveredComponents.get(componentName);
        const friendlyName = component?.friendlyName || componentName;
        
        try {
            // Stage 1: Basic component analysis
            const componentType = this.detectComponentType(componentName, relevantFiles);
            
            // Stage 2: Extract dependencies
            const dependencyAnalysis = await this.extractDependencies(relevantFiles);
            
            // Stage 3: Field analysis (for copybooks)
            let fieldAnalysis = null;
            if (componentType === 'Copybook' || componentType === 'RECORD_LAYOUT') {
                fieldAnalysis = await this.analyzeFieldsInComponent(componentName, relevantFiles);
            }
            
            // Stage 4: LLM-enhanced analysis
            let llmAnalysis = null;
            try {
                llmAnalysis = await this.getBusinessIntelligenceFromLLM(
                    componentName, friendlyName, componentType, relevantFiles, dependencyAnalysis, fieldAnalysis
                );
            } catch (llmError) {
                console.warn('LLM analysis failed:', llmError);
                llmAnalysis = {
                    error: true,
                    message: llmError.message,
                    businessPurpose: component?.businessPurpose || 'Business purpose analysis failed',
                    recommendations: ['Check LLM server connection', 'Verify component data', 'Try manual analysis']
                };
            }
            
            const results = {
                componentName: componentName,
                friendlyName: friendlyName,
                timestamp: new Date().toISOString(),
                filesAnalyzed: relevantFiles.map(f => f.name),
                componentType: componentType,
                dependencyAnalysis: dependencyAnalysis,
                fieldAnalysis: fieldAnalysis,
                llmAnalysis: llmAnalysis,
                totalFields: fieldAnalysis?.fields?.length || 0,
                qualityScore: this.calculateQualityScore(llmAnalysis, fieldAnalysis),
                analysisMethod: 'Auto-Discovery-Enhanced'
            };
            
            return results;
            
        } catch (error) {
            console.error(`Analysis failed for ${componentName}:`, error);
            throw new Error(`Analysis failed: ${error.message}`);
        }
    }

    // Detect Component Type
    detectComponentType(componentName, relevantFiles) {
        const component = this.discoveredComponents.get(componentName);
        if (component?.type) {
            return component.type;
        }
        
        // Analyze files to determine type
        for (const file of relevantFiles) {
            if (file.type === 'Copybook') return 'Copybook';
            if (file.type === 'COBOL Program') return 'Program';
            if (file.type === 'JCL Job') return 'Job';
        }
        
        return 'Unknown';
    }

    // Extract Dependencies
    async extractDependencies(relevantFiles) {
        const dependencies = {
            found: { copybooks: [], programs: [], files: [] },
            missing: { copybooks: [], programs: [], files: [] },
            summary: { foundCount: 0, missingCount: 0 }
        };
        
        for (const file of relevantFiles) {
            const content = file.content.toUpperCase();
            const lines = content.split('\n');
            
            lines.forEach(line => {
                const trimmed = line.trim();
                
                // Extract COPY statements
                const copyMatch = trimmed.match(/COPY\s+([A-Z][A-Z0-9\-_]+)/);
                if (copyMatch) {
                    const copybook = copyMatch[1];
                    if (this.discoveredComponents.has(copybook)) {
                        if (!dependencies.found.copybooks.includes(copybook)) {
                            dependencies.found.copybooks.push(copybook);
                        }
                    } else {
                        if (!dependencies.missing.copybooks.includes(copybook)) {
                            dependencies.missing.copybooks.push(copybook);
                        }
                    }
                }
                
                // Extract CALL statements
                const callMatch = trimmed.match(/CALL\s+['"]([A-Z][A-Z0-9\-_]+)['"]/);
                if (callMatch) {
                    const program = callMatch[1];
                    if (this.discoveredComponents.has(program)) {
                        if (!dependencies.found.programs.includes(program)) {
                            dependencies.found.programs.push(program);
                        }
                    } else {
                        if (!dependencies.missing.programs.includes(program)) {
                            dependencies.missing.programs.push(program);
                        }
                    }
                }
                
                // Extract file references
                const fileMatch = trimmed.match(/SELECT\s+([A-Z][A-Z0-9\-_]+)/);
                if (fileMatch) {
                    const fileName = fileMatch[1];
                    if (this.discoveredComponents.has(fileName)) {
                        if (!dependencies.found.files.includes(fileName)) {
                            dependencies.found.files.push(fileName);
                        }
                    } else {
                        if (!dependencies.missing.files.includes(fileName)) {
                            dependencies.missing.files.push(fileName);
                        }
                    }
                }
            });
        }
        
        // Calculate summary
        dependencies.summary.foundCount = 
            dependencies.found.copybooks.length + 
            dependencies.found.programs.length + 
            dependencies.found.files.length;
            
        dependencies.summary.missingCount = 
            dependencies.missing.copybooks.length + 
            dependencies.missing.programs.length + 
            dependencies.missing.files.length;
        
        return dependencies;
    }

    // Analyze Fields in Component
    async analyzeFieldsInComponent(componentName, relevantFiles) {
        const fieldAnalysis = {
            fields: [],
            inputFields: [],
            outputFields: [],
            referenceFields: [],
            unusedFields: [],
            businessLogicSummary: {
                totalValidationRules: 0,
                totalCalculations: 0,
                fieldsWithBusinessLogic: 0
            }
        };
        
        for (const file of relevantFiles) {
            const content = file.content;
            const lines = content.split('\n');
            
            lines.forEach((line, index) => {
                const trimmed = line.trim().toUpperCase();
                
                // Extract field definitions
                const fieldMatch = trimmed.match(/^\s*(\d{2})\s+([A-Z][A-Z0-9\-_]+)(?:\s+PIC\s+([X9VS\(\)]+))?/);
                if (fieldMatch) {
                    const level = parseInt(fieldMatch[1]);
                    const fieldName = fieldMatch[2];
                    const picture = fieldMatch[3] || '';
                    
                    if (level !== 88 && fieldName) {
                        const field = {
                            name: fieldName,
                            level: level,
                            picture: picture,
                            lineNumber: index + 1,
                            fileName: file.name,
                            businessLogic: {
                                businessMeaning: this.generateFieldPurpose(fieldName),
                                validationRules: [],
                                calculations: []
                            }
                        };
                        
                        fieldAnalysis.fields.push(field);
                        
                        // Determine usage pattern
                        if (this.isInputField(fieldName, content)) {
                            fieldAnalysis.inputFields.push(fieldName);
                        } else if (this.isOutputField(fieldName, content)) {
                            fieldAnalysis.outputFields.push(fieldName);
                        } else if (this.isReferenceField(fieldName, content)) {
                            fieldAnalysis.referenceFields.push(fieldName);
                        } else {
                            fieldAnalysis.unusedFields.push(fieldName);
                        }
                    }
                }
            });
        }
        
        return fieldAnalysis;
    }

    // Field Usage Detection Methods
    isInputField(fieldName, content) {
        const patterns = [
            new RegExp(`MOVE\\s+\\w+\\s+TO\\s+${fieldName}`, 'i'),
            new RegExp(`ACCEPT\\s+${fieldName}`, 'i'),
            new RegExp(`READ\\s+\\w+\\s+INTO\\s+${fieldName}`, 'i')
        ];
        
        return patterns.some(pattern => pattern.test(content));
    }

    isOutputField(fieldName, content) {
        const patterns = [
            new RegExp(`DISPLAY\\s+${fieldName}`, 'i'),
            new RegExp(`WRITE\\s+${fieldName}`, 'i'),
            new RegExp(`MOVE\\s+${fieldName}\\s+TO`, 'i')
        ];
        
        return patterns.some(pattern => pattern.test(content));
    }

    isReferenceField(fieldName, content) {
        const patterns = [
            new RegExp(`IF\\s+${fieldName}`, 'i'),
            new RegExp(`WHEN\\s+${fieldName}`, 'i'),
            new RegExp(`COMPUTE\\s+\\w+\\s*=.*${fieldName}`, 'i')
        ];
        
        return patterns.some(pattern => pattern.test(content));
    }

    // Generate Field Purpose
    generateFieldPurpose(fieldName) {
        const name = fieldName.toUpperCase();
        
        if (name.includes('RECORD') || name.includes('REC')) {
            return `Main record structure for ${fieldName.toLowerCase().replace(/-/g, ' ')} data`;
        } else if (name.includes('ID') || name.includes('KEY')) {
            return `Unique identifier for ${fieldName.toLowerCase().replace(/-/g, ' ')}`;
        } else if (name.includes('DATE') || name.includes('TIME')) {
            return `Date/time field for ${fieldName.toLowerCase().replace(/-/g, ' ')} tracking`;
        } else if (name.includes('AMT') || name.includes('AMOUNT')) {
            return `Monetary amount for ${fieldName.toLowerCase().replace(/-/g, ' ')}`;
        } else if (name.includes('DESC') || name.includes('NAME')) {
            return `Descriptive text for ${fieldName.toLowerCase().replace(/-/g, ' ')}`;
        } else if (name.includes('FLAG') || name.includes('IND')) {
            return `Status indicator for ${fieldName.toLowerCase().replace(/-/g, ' ')}`;
        } else if (name.includes('CODE') || name.includes('CD')) {
            return `Coded value for ${fieldName.toLowerCase().replace(/-/g, ' ')}`;
        } else if (name.includes('COUNT') || name.includes('CNT')) {
            return `Counter/number field for ${fieldName.toLowerCase().replace(/-/g, ' ')}`;
        } else {
            return `Business data field for ${fieldName.toLowerCase().replace(/-/g, ' ')} processing`;
        }
    }

    // Calculate Quality Score
    calculateQualityScore(llmAnalysis, fieldAnalysis) {
        let score = 5; // Base score
        
        // LLM analysis quality factors
        if (llmAnalysis && !llmAnalysis.error) {
            score += 2;
            
            if (llmAnalysis.businessPurpose && llmAnalysis.businessPurpose.length > 50) {
                score += 1;
            }
            
            if (llmAnalysis.recommendations && llmAnalysis.recommendations.length > 0) {
                score += 1;
            }
        }
        
        // Field analysis quality factors
        if (fieldAnalysis) {
            if (fieldAnalysis.fields && fieldAnalysis.fields.length > 0) {
                score += 1;
            }
            
            if (fieldAnalysis.inputFields && fieldAnalysis.inputFields.length > 0) {
                score += 0.5;
            }
            
            if (fieldAnalysis.outputFields && fieldAnalysis.outputFields.length > 0) {
                score += 0.5;
            }
        }
        
        return Math.min(Math.round(score), 10);
    }

    // ============================================
    // LLM API INTEGRATION
    // ============================================

    // Enhanced LLM API Call
    async callLLMAPI(prompt, retries = 0) {
        console.log('ü§ñ Enhanced LLM API call initiated');
        
        try {
            return await this.callLLMAPIChunked(prompt, {
                maxResponseTokens: Math.min(this.maxTokens * 0.7, 4000),
                allowChunking: true,
                chunkingStrategy: 'auto',
                retries: Math.min(retries, 2)
            });
            
        } catch (error) {
            console.error('Enhanced LLM call failed:', error);
            
            // Return fallback data instead of throwing
            return {
                error: true,
                message: error.message,
                fallbackData: this.createComponentFallback(
                    'Unknown',
                    'Unknown',
                    null
                )
            };
        }
    }

    // Enhanced Token Management
    estimateTokens(text) {
        if (!text || typeof text !== 'string') return 0;
        
        // More accurate token estimation for mainframe content
        // COBOL and technical content tends to have more tokens per character
        const baseEstimate = Math.ceil(text.length / 3.2);
        
        // Adjust for technical content density
        const technicalWords = (text.match(/\b[A-Z][A-Z0-9\-_]{3,}\b/g) || []).length;
        const codeLines = (text.match(/^\s*\d{2}\s+/gm) || []).length;
        
        // Technical content adjustment
        const adjustment = Math.floor((technicalWords + codeLines) * 0.1);
        
        return baseEstimate + adjustment;
    }

    validateTokenLimits(prompt, maxResponseTokens = 4000) {
        const promptTokens = this.estimateTokens(prompt);
        const safePromptLimit = this.maxTokens - maxResponseTokens - 200; // Safety buffer
        
        console.log(`Token validation: ${promptTokens} prompt tokens, limit: ${safePromptLimit}`);
        
        if (promptTokens > safePromptLimit) {
            throw new Error(`Prompt too large: ${promptTokens} tokens exceeds limit of ${safePromptLimit}`);
        }
        
        return {
            promptTokens,
            responseTokensAvailable: maxResponseTokens,
            withinLimits: true
        };
    }

    // LLM API Call with Chunking Support
    async callLLMAPIChunked(prompt, options = {}) {
        const {
            maxResponseTokens = 3000,
            allowChunking = true,
            retries = 2
        } = options;
        
        try {
            // First, try to validate if we can send as single request
            this.validateTokenLimits(prompt, maxResponseTokens);
            
            // If validation passes, try single request first
            return await this.makeSingleLLMRequest(prompt, maxResponseTokens, retries);
            
        } catch (tokenError) {
            if (!allowChunking) {
                throw new Error(`Prompt too large and chunking disabled: ${tokenError.message}`);
            }
            
            console.log('Prompt too large, switching to chunked analysis:', tokenError.message);
            return await this.makeChunkedLLMRequest(prompt, options);
        }
    }

    // Single LLM Request
    async makeSingleLLMRequest(prompt, maxResponseTokens, retries = 2) {
        for (let attempt = 0; attempt <= retries; attempt++) {
            try {
                console.log(`LLM API call attempt ${attempt + 1}/${retries + 1}`);
                
                const response = await fetch(`${this.vllmEndpoint}/generate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: prompt,
                        max_tokens: maxResponseTokens,
                        temperature: 0.1,
                        top_p: 0.9,
                        stop: [],
                        stream: false,
                        frequency_penalty: 0.1,
                        presence_penalty: 0.0
                    }),
                    signal: AbortSignal.timeout(90000) // 90 second timeout
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                const resultText = this.extractTextFromResponse(data);
                
                if (!resultText) {
                    throw new Error('No valid text content in LLM response');
                }

                // Parse and validate response
                const parseResult = this.parseJSONResponse(resultText);
                
                if (parseResult.success) {
                    console.log('‚úÖ Single LLM request successful');
                    return parseResult.data;
                } else if (parseResult.fallbackData) {
                    console.warn('‚ö†Ô∏è JSON parsing failed, using fallback data');
                    return parseResult.fallbackData;
                } else {
                    throw new Error(`JSON parsing failed: ${parseResult.error}`);
                }

            } catch (error) {
                console.error(`LLM attempt ${attempt + 1} failed:`, error);
                
                if (attempt < retries) {
                    const delay = 2000 * (attempt + 1); // Exponential backoff
                    console.log(`Retrying in ${delay}ms...`);
                    await this.sleep(delay);
                } else {
                    throw error;
                }
            }
        }
    }

    // Extract Text from LLM Response
    extractTextFromResponse(data) {
        if (typeof data === 'string') return data.trim();
        if (data.text) return data.text.trim();
        if (data.choices && data.choices[0]) {
            if (data.choices[0].text) return data.choices[0].text.trim();
            if (data.choices[0].message?.content) return data.choices[0].message.content.trim();
        }
        if (data.generated_text) return data.generated_text.trim();
        if (data.response) return data.response.trim();
        
        return null;
    }

    // Parse JSON Response
    parseJSONResponse(text) {
        try {
            // Try to extract JSON from response
            const jsonMatch = text.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                const parsed = JSON.parse(jsonMatch[0]);
                return { success: true, data: parsed };
            }
            
            // If no JSON found, create fallback structure
            return {
                success: false,
                error: 'No JSON found in response',
                fallbackData: {
                    businessPurpose: text.substring(0, 200) + '...',
                    recommendations: ['Manual review recommended'],
                    qualityScore: 5
                }
            };
            
        } catch (error) {
            return {
                success: false,
                error: error.message,
                fallbackData: {
                    businessPurpose: 'Analysis failed - manual review required',
                    recommendations: ['Check LLM connection', 'Verify component data'],
                    qualityScore: 3
                }
            };
        }
    }

    // Create Component Fallback
    createComponentFallback(componentName, friendlyName, componentType) {
        return {
            componentName: componentName,
            friendlyName: friendlyName,
            componentType: componentType || 'Unknown',
            businessPurpose: 'Business purpose analysis not available',
            recommendations: [
                'Verify LLM server connection',
                'Check component data quality',
                'Consider manual analysis'
            ],
            qualityScore: 3,
            error: true,
            fallback: true
        };
    }

    // Get Business Intelligence from LLM
    async getBusinessIntelligenceFromLLM(componentName, friendlyName, componentType, relevantFiles, dependencyAnalysis, fieldAnalysis) {
        const fileContents = relevantFiles.map(f => `=== ${f.name} (${f.type}) ===\n${f.content}`).join('\n\n');
        
        const prompt = `MAINFRAME COMPONENT BUSINESS INTELLIGENCE ANALYSIS

Component: ${componentName}
Friendly Name: ${friendlyName}
Type: ${componentType}

FILE CONTENTS:
${fileContents.substring(0, 8000)} // Truncate for token limits

DEPENDENCY ANALYSIS:
Found Dependencies: ${JSON.stringify(dependencyAnalysis.found)}
Missing Dependencies: ${JSON.stringify(dependencyAnalysis.missing)}

${fieldAnalysis ? `FIELD ANALYSIS:
Total Fields: ${fieldAnalysis.fields.length}
Input Fields: ${fieldAnalysis.inputFields.length}
Output Fields: ${fieldAnalysis.outputFields.length}
Unused Fields: ${fieldAnalysis.unusedFields.length}` : ''}

TASK: Provide comprehensive business intelligence analysis for this mainframe component.

Return JSON format:
{
  "componentName": "${componentName}",
  "friendlyName": "${friendlyName}",
  "businessPurpose": "detailed business purpose and role in the system",
  "businessLogic": {
    "validationRules": ["rule1", "rule2"],
    "businessRules": ["rule1", "rule2"],
    "dataProcessing": "description of data processing logic"
  },
  "qualityScore": 8,
  "recommendations": ["rec1", "rec2", "rec3"],
  "modernizationSuggestions": ["suggestion1", "suggestion2"],
  "riskAssessment": "low/medium/high risk assessment with reasoning"
}`;

        return await this.callLLMAPI(prompt);
    }
    // ============================================
    // AUTO-DISCOVERY AND COMPONENT ANALYSIS
    // ============================================

    // Auto-Discover Components
    async autoDiscoverComponents(fileObj) {
        for (const component of fileObj.components) {
            if (component.isMainComponent) {
                const discoveredComponent = {
                    name: component.name,
                    friendlyName: await this.generateFriendlyName(component.name),
                    type: component.type,
                    businessPurpose: component.businessPurpose,
                    fileSource: fileObj.name,
                    lineCount: fileObj.metrics.codeLines,
                    complexityScore: fileObj.metrics.complexity,
                    inputFiles: this.extractInputFiles(fileObj.content),
                    outputFiles: this.extractOutputFiles(fileObj.content),
                    fieldCount: fileObj.components.filter(c => c.type === 'FIELD' || c.type === 'RECORD_LAYOUT').length,
                    analyzed: false,
                    timestamp: new Date().toISOString()
                };
                
                this.discoveredComponents.set(component.name, discoveredComponent);
            }
        }
    }

    // Extract Input/Output Files
    extractInputFiles(content) {
        const files = [];
        const lines = content.split('\n');
        
        lines.forEach(line => {
            const trimmed = line.trim().toUpperCase();
            
            // Look for INPUT file patterns
            const inputPatterns = [
                /SELECT\s+([A-Z][A-Z0-9\-_]+)\s+ASSIGN/,
                /OPEN\s+INPUT\s+([A-Z][A-Z0-9\-_]+)/,
                /READ\s+([A-Z][A-Z0-9\-_]+)/
            ];
            
            for (const pattern of inputPatterns) {
                const match = trimmed.match(pattern);
                if (match && !files.includes(match[1])) {
                    files.push(match[1]);
                }
            }
        });
        
        return files.slice(0, 10); // Limit to top 10
    }

    extractOutputFiles(content) {
        const files = [];
        const lines = content.split('\n');
        
        lines.forEach(line => {
            const trimmed = line.trim().toUpperCase();
            
            // Look for OUTPUT file patterns
            const outputPatterns = [
                /OPEN\s+OUTPUT\s+([A-Z][A-Z0-9\-_]+)/,
                /WRITE\s+([A-Z][A-Z0-9\-_]+)/,
                /DISPLAY\s+.*\s+UPON\s+([A-Z][A-Z0-9\-_]+)/
            ];
            
            for (const pattern of outputPatterns) {
                const match = trimmed.match(pattern);
                if (match && !files.includes(match[1])) {
                    files.push(match[1]);
                }
            }
        });
        
        return files.slice(0, 10); // Limit to top 10
    }

    // Generate Friendly Name using LLM or patterns
    async generateFriendlyName(componentName) {
        // Check cache first
        if (this.friendlyNameCache.has(componentName.toUpperCase())) {
            return this.friendlyNameCache.get(componentName.toUpperCase());
        }
        
        // Try LLM generation if available
        if (this.serverValidated) {
            try {
                const prompt = `Generate a business-friendly name for this mainframe component: "${componentName}"

Examples:
- CUST-MASTER ‚Üí "Customer Master File"
- ACCT-VALIDATE ‚Üí "Account Validation Program" 
- TRANS-LOG ‚Üí "Transaction Log Handler"
- PAY-PROCESS ‚Üí "Payment Processing System"

Return only the friendly name, no explanation.`;

                const response = await this.callLLMAPI(prompt);
                if (response && typeof response === 'string' && response.length < 100) {
                    this.friendlyNameCache.set(componentName.toUpperCase(), response.trim());
                    return response.trim();
                }
            } catch (error) {
                console.warn('LLM friendly name generation failed:', error);
            }
        }
        
        // Fallback to pattern-based generation
        return this.generateFriendlyNameFromPattern(componentName);
    }

    // Pattern-based friendly name generation
    generateFriendlyNameFromPattern(componentName) {
        const name = componentName.toUpperCase();
        
        // Common mainframe patterns to friendly names
        const patterns = [
            { pattern: /CUST.*MASTER/, replacement: 'Customer Master File' },
            { pattern: /CUST.*MAINT/, replacement: 'Customer Maintenance Program' },
            { pattern: /CUST.*VALID/, replacement: 'Customer Validation Program' },
            { pattern: /ACCT.*MASTER/, replacement: 'Account Master File' },
            { pattern: /ACCT.*TRANS/, replacement: 'Account Transaction Program' },
            { pattern: /ACCT.*BAL/, replacement: 'Account Balance Program' },
            { pattern: /PAY.*PROC/, replacement: 'Payment Processing System' },
            { pattern: /TRANS.*LOG/, replacement: 'Transaction Log Handler' },
            { pattern: /INVOICE.*PROC/, replacement: 'Invoice Processing System' },
            { pattern: /REPORT.*GEN/, replacement: 'Report Generation Program' },
            { pattern: /.*MASTER.*/, replacement: `${name.split('-')[0]} Master Data` },
            { pattern: /.*COPY.*/, replacement: `${name.split('-')[0]} Data Structure` },
            { pattern: /.*VALID.*/, replacement: `${name.split('-')[0]} Validation Program` },
            { pattern: /.*PROC.*/, replacement: `${name.split('-')[0]} Processing System` }
        ];
        
        for (const { pattern, replacement } of patterns) {
            if (pattern.test(name)) {
                return replacement;
            }
        }
        
        // Final fallback
        const parts = name.split('-');
        if (parts.length > 1) {
            return `${parts[0]} ${parts[1]} System`;
        } else {
            return `${name} Component`;
        }
    }

    // Enable Auto Analysis
    enableAutoAnalysis() {
        const autoAnalyzeBtn = document.getElementById('autoAnalyzeBtn');
        if (autoAnalyzeBtn && this.discoveredComponents.size > 0 && this.serverValidated) {
            autoAnalyzeBtn.disabled = false;
        }
    }

    // Start Auto Analysis
    async startAutoAnalysis() {
        if (this.autoAnalysisInProgress) {
            this.showWarning('Auto-analysis already in progress');
            return;
        }
        
        if (this.discoveredComponents.size === 0) {
            this.showError('No components discovered for analysis');
            return;
        }
        
        this.autoAnalysisInProgress = true;
        this.showLoading();
        this.updateLoadingStatus('üöÄ Starting auto-analysis of discovered components...');
        
        try {
            const components = Array.from(this.discoveredComponents.values())
                .filter(comp => !comp.analyzed)
                .slice(0, 8); // Limit to 8 components for performance
            
            let completed = 0;
            
            for (const component of components) {
                try {
                    this.updateLoadingStatus(`Analyzing ${component.friendlyName || component.name} (${completed + 1}/${components.length})...`);
                    this.updateProgress((completed / components.length) * 100);
                    
                    const relevantFiles = this.findRelevantFiles(component.name);
                    const analysisResult = await this.runComponentAnalysis(component.name, relevantFiles);
                    
                    this.analysisResults[component.name] = analysisResult;
                    component.analyzed = true;
                    component.qualityScore = analysisResult.qualityScore;
                    
                    completed++;
                    
                    // Brief pause between analyses
                    await this.sleep(1000);
                    
                } catch (error) {
                    console.warn(`Failed to analyze ${component.name}:`, error);
                    component.analyzed = false;
                }
            }
            
            this.hideLoading();
            this.updateDashboardWithResults();
            this.enableChat();
            this.saveToDatabase();
            
            this.showSuccess(`‚ú® Auto-analysis complete! ${completed}/${components.length} components analyzed`);
            
            // Switch to dashboard to show results
            document.querySelector('.tab[data-tab="dashboard"]').click();
            
        } catch (error) {
            this.hideLoading();
            this.showError(`Auto-analysis failed: ${error.message}`);
        } finally {
            this.autoAnalysisInProgress = false;
        }
    }

    // Find Relevant Files for Component
    findRelevantFiles(componentName) {
        const componentUpper = componentName.toUpperCase();
        const componentBase = componentUpper.replace(/\.(CPY|COPYBOOK|COP)$/, '');
        
        return this.uploadedFiles.filter(file => {
            const fileNameUpper = file.name.toUpperCase();
            const fileNameBase = fileNameUpper.replace(/\.(CPY|COPYBOOK|COP)$/, '');
            
            // Direct name match
            if (fileNameUpper.includes(componentUpper) || 
                fileNameBase === componentBase ||
                componentBase === fileNameBase) {
                return true;
            }
            
            // Content-based matching
            const contentUpper = file.content.toUpperCase();
            if (contentUpper.includes(componentUpper) ||
                contentUpper.includes(componentBase) ||
                contentUpper.includes(`COPY ${componentBase}`) ||
                contentUpper.includes(`"${componentBase}"`) ||
                contentUpper.includes(`'${componentBase}'`)) {
                return true;
            }
            
            // Component-based matching
            if (file.components) {
                return file.components.some(comp => {
                    const compNameUpper = comp.name.toUpperCase();
                    const compNameBase = compNameUpper.replace(/\.(CPY|COPYBOOK|COP)$/, '');
                    return compNameUpper === componentUpper || 
                           compNameBase === componentBase ||
                           componentBase === compNameBase;
                });
            }
            
            return false;
        });
    }

    // Run Component Analysis (simplified for auto-analysis)
    async runComponentAnalysis(componentName, relevantFiles) {
        console.log(`Running analysis for: ${componentName}`);
        
        const component = this.discoveredComponents.get(componentName);
        const friendlyName = component?.friendlyName || componentName;
        
        try {
            // Stage 1: Basic component analysis
            const componentType = this.detectComponentType(componentName, relevantFiles);
            
            // Stage 2: Extract dependencies
            const dependencyAnalysis = await this.extractDependencies(relevantFiles);
            
            // Stage 3: Field analysis (for copybooks)
            let fieldAnalysis = null;
            if (componentType === 'Copybook' || componentType === 'RECORD_LAYOUT') {
                fieldAnalysis = await this.analyzeFieldsInComponent(componentName, relevantFiles);
            }
            
            // Stage 4: LLM-enhanced analysis
            let llmAnalysis = null;
            try {
                llmAnalysis = await this.getBusinessIntelligenceFromLLM(
                    componentName, friendlyName, componentType, relevantFiles, dependencyAnalysis, fieldAnalysis
                );
            } catch (llmError) {
                console.warn('LLM analysis failed:', llmError);
                llmAnalysis = {
                    error: true,
                    message: llmError.message,
                    businessPurpose: component?.businessPurpose || 'Business purpose analysis failed',
                    recommendations: ['Check LLM server connection', 'Verify component data', 'Try manual analysis']
                };
            }
            
            const results = {
                componentName: componentName,
                friendlyName: friendlyName,
                timestamp: new Date().toISOString(),
                filesAnalyzed: relevantFiles.map(f => f.name),
                componentType: componentType,
                dependencyAnalysis: dependencyAnalysis,
                fieldAnalysis: fieldAnalysis,
                llmAnalysis: llmAnalysis,
                totalFields: fieldAnalysis?.fields?.length || 0,
                qualityScore: this.calculateQualityScore(llmAnalysis, fieldAnalysis),
                analysisMethod: 'Auto-Discovery-Enhanced'
            };
            
            return results;
            
        } catch (error) {
            console.error(`Analysis failed for ${componentName}:`, error);
            throw new Error(`Analysis failed: ${error.message}`);
        }
    }

    // Detect Component Type
    detectComponentType(componentName, relevantFiles) {
        const component = this.discoveredComponents.get(componentName);
        if (component?.type) {
            return component.type;
        }
        
        // Analyze files to determine type
        for (const file of relevantFiles) {
            if (file.type === 'Copybook') return 'Copybook';
            if (file.type === 'COBOL Program') return 'Program';
            if (file.type === 'JCL Job') return 'Job';
        }
        
        return 'Unknown';
    }

    // Extract Dependencies
    async extractDependencies(relevantFiles) {
        const dependencies = {
            found: { copybooks: [], programs: [], files: [] },
            missing: { copybooks: [], programs: [], files: [] },
            summary: { foundCount: 0, missingCount: 0 }
        };
        
        for (const file of relevantFiles) {
            const content = file.content.toUpperCase();
            const lines = content.split('\n');
            
            lines.forEach(line => {
                const trimmed = line.trim();
                
                // Extract COPY statements
                const copyMatch = trimmed.match(/COPY\s+([A-Z][A-Z0-9\-_]+)/);
                if (copyMatch) {
                    const copybook = copyMatch[1];
                    if (this.discoveredComponents.has(copybook)) {
                        if (!dependencies.found.copybooks.includes(copybook)) {
                            dependencies.found.copybooks.push(copybook);
                        }
                    } else {
                        if (!dependencies.missing.copybooks.includes(copybook)) {
                            dependencies.missing.copybooks.push(copybook);
                        }
                    }
                }
                
                // Extract CALL statements
                const callMatch = trimmed.match(/CALL\s+['"]([A-Z][A-Z0-9\-_]+)['"]/);
                if (callMatch) {
                    const program = callMatch[1];
                    if (this.discoveredComponents.has(program)) {
                        if (!dependencies.found.programs.includes(program)) {
                            dependencies.found.programs.push(program);
                        }
                    } else {
                        if (!dependencies.missing.programs.includes(program)) {
                            dependencies.missing.programs.push(program);
                        }
                    }
                }
                
                // Extract file references
                const fileMatch = trimmed.match(/SELECT\s+([A-Z][A-Z0-9\-_]+)/);
                if (fileMatch) {
                    const fileName = fileMatch[1];
                    if (this.discoveredComponents.has(fileName)) {
                        if (!dependencies.found.files.includes(fileName)) {
                            dependencies.found.files.push(fileName);
                        }
                    } else {
                        if (!dependencies.missing.files.includes(fileName)) {
                            dependencies.missing.files.push(fileName);
                        }
                    }
                }
            });
        }
        
        // Calculate summary
        dependencies.summary.foundCount = 
            dependencies.found.copybooks.length + 
            dependencies.found.programs.length + 
            dependencies.found.files.length;
            
        dependencies.summary.missingCount = 
            dependencies.missing.copybooks.length + 
            dependencies.missing.programs.length + 
            dependencies.missing.files.length;
        
        return dependencies;
    }

    // Analyze Fields in Component
    async analyzeFieldsInComponent(componentName, relevantFiles) {
        const fieldAnalysis = {
            fields: [],
            inputFields: [],
            outputFields: [],
            referenceFields: [],
            unusedFields: [],
            businessLogicSummary: {
                totalValidationRules: 0,
                totalCalculations: 0,
                fieldsWithBusinessLogic: 0
            }
        };
        
        for (const file of relevantFiles) {
            const content = file.content;
            const lines = content.split('\n');
            
            lines.forEach((line, index) => {
                const trimmed = line.trim().toUpperCase();
                
                // Extract field definitions
                const fieldMatch = trimmed.match(/^\s*(\d{2})\s+([A-Z][A-Z0-9\-_]+)(?:\s+PIC\s+([X9VS\(\)]+))?/);
                if (fieldMatch) {
                    const level = parseInt(fieldMatch[1]);
                    const fieldName = fieldMatch[2];
                    const picture = fieldMatch[3] || '';
                    
                    if (level !== 88 && fieldName) {
                        const field = {
                            name: fieldName,
                            level: level,
                            picture: picture,
                            lineNumber: index + 1,
                            fileName: file.name,
                            businessLogic: {
                                businessMeaning: this.generateFieldPurpose(fieldName),
                                validationRules: [],
                                calculations: []
                            }
                        };
                        
                        fieldAnalysis.fields.push(field);
                        
                        // Determine usage pattern
                        if (this.isInputField(fieldName, content)) {
                            fieldAnalysis.inputFields.push(fieldName);
                        } else if (this.isOutputField(fieldName, content)) {
                            fieldAnalysis.outputFields.push(fieldName);
                        } else if (this.isReferenceField(fieldName, content)) {
                            fieldAnalysis.referenceFields.push(fieldName);
                        } else {
                            fieldAnalysis.unusedFields.push(fieldName);
                        }
                    }
                }
            });
        }
        
        return fieldAnalysis;
    }

    // Field Usage Detection Methods
    isInputField(fieldName, content) {
        const patterns = [
            new RegExp(`MOVE\\s+\\w+\\s+TO\\s+${fieldName}`, 'i'),
            new RegExp(`ACCEPT\\s+${fieldName}`, 'i'),
            new RegExp(`READ\\s+\\w+\\s+INTO\\s+${fieldName}`, 'i')
        ];
        
        return patterns.some(pattern => pattern.test(content));
    }

    isOutputField(fieldName, content) {
        const patterns = [
            new RegExp(`DISPLAY\\s+${fieldName}`, 'i'),
            new RegExp(`WRITE\\s+${fieldName}`, 'i'),
            new RegExp(`MOVE\\s+${fieldName}\\s+TO`, 'i')
        ];
        
        return patterns.some(pattern => pattern.test(content));
    }

    isReferenceField(fieldName, content) {
        const patterns = [
            new RegExp(`IF\\s+${fieldName}`, 'i'),
            new RegExp(`WHEN\\s+${fieldName}`, 'i'),
            new RegExp(`COMPUTE\\s+\\w+\\s*=.*${fieldName}`, 'i')
        ];
        
        return patterns.some(pattern => pattern.test(content));
    }

    // Generate Field Purpose
    generateFieldPurpose(fieldName) {
        const name = fieldName.toUpperCase();
        
        if (name.includes('RECORD') || name.includes('REC')) {
            return `Main record structure for ${fieldName.toLowerCase().replace(/-/g, ' ')} data`;
        } else if (name.includes('ID') || name.includes('KEY')) {
            return `Unique identifier for ${fieldName.toLowerCase().replace(/-/g, ' ')}`;
        } else if (name.includes('DATE') || name.includes('TIME')) {
            return `Date/time field for ${fieldName.toLowerCase().replace(/-/g, ' ')} tracking`;
        } else if (name.includes('AMT') || name.includes('AMOUNT')) {
            return `Monetary amount for ${fieldName.toLowerCase().replace(/-/g, ' ')}`;
        } else if (name.includes('DESC') || name.includes('NAME')) {
            return `Descriptive text for ${fieldName.toLowerCase().replace(/-/g, ' ')}`;
        } else if (name.includes('FLAG') || name.includes('IND')) {
            return `Status indicator for ${fieldName.toLowerCase().replace(/-/g, ' ')}`;
        } else if (name.includes('CODE') || name.includes('CD')) {
            return `Coded value for ${fieldName.toLowerCase().replace(/-/g, ' ')}`;
        } else if (name.includes('COUNT') || name.includes('CNT')) {
            return `Counter/number field for ${fieldName.toLowerCase().replace(/-/g, ' ')}`;
        } else {
            return `Business data field for ${fieldName.toLowerCase().replace(/-/g, ' ')} processing`;
        }
    }

    // Calculate Quality Score
    calculateQualityScore(llmAnalysis, fieldAnalysis) {
        let score = 5; // Base score
        
        // LLM analysis quality factors
        if (llmAnalysis && !llmAnalysis.error) {
            score += 2;
            
            if (llmAnalysis.businessPurpose && llmAnalysis.businessPurpose.length > 50) {
                score += 1;
            }
            
            if (llmAnalysis.recommendations && llmAnalysis.recommendations.length > 0) {
                score += 1;
            }
        }
        
        // Field analysis quality factors
        if (fieldAnalysis) {
            if (fieldAnalysis.fields && fieldAnalysis.fields.length > 0) {
                score += 1;
            }
            
            if (fieldAnalysis.inputFields && fieldAnalysis.inputFields.length > 0) {
                score += 0.5;
            }
            
            if (fieldAnalysis.outputFields && fieldAnalysis.outputFields.length > 0) {
                score += 0.5;
            }
        }
        
        return Math.min(Math.round(score), 10);
    }

    // ============================================
    // LLM API INTEGRATION
    // ============================================

    // Enhanced LLM API Call
    async callLLMAPI(prompt, retries = 0) {
        console.log('ü§ñ Enhanced LLM API call initiated');
        
        try {
            return await this.callLLMAPIChunked(prompt, {
                maxResponseTokens: Math.min(this.maxTokens * 0.7, 4000),
                allowChunking: true,
                chunkingStrategy: 'auto',
                retries: Math.min(retries, 2)
            });
            
        } catch (error) {
            console.error('Enhanced LLM call failed:', error);
            
            // Return fallback data instead of throwing
            return {
                error: true,
                message: error.message,
                fallbackData: this.createComponentFallback(
                    'Unknown',
                    'Unknown',
                    null
                )
            };
        }
    }

    // Enhanced Token Management
    estimateTokens(text) {
        if (!text || typeof text !== 'string') return 0;
        
        // More accurate token estimation for mainframe content
        // COBOL and technical content tends to have more tokens per character
        const baseEstimate = Math.ceil(text.length / 3.2);
        
        // Adjust for technical content density
        const technicalWords = (text.match(/\b[A-Z][A-Z0-9\-_]{3,}\b/g) || []).length;
        const codeLines = (text.match(/^\s*\d{2}\s+/gm) || []).length;
        
        // Technical content adjustment
        const adjustment = Math.floor((technicalWords + codeLines) * 0.1);
        
        return baseEstimate + adjustment;
    }

    validateTokenLimits(prompt, maxResponseTokens = 4000) {
        const promptTokens = this.estimateTokens(prompt);
        const safePromptLimit = this.maxTokens - maxResponseTokens - 200; // Safety buffer
        
        console.log(`Token validation: ${promptTokens} prompt tokens, limit: ${safePromptLimit}`);
        
        if (promptTokens > safePromptLimit) {
            throw new Error(`Prompt too large: ${promptTokens} tokens exceeds limit of ${safePromptLimit}`);
        }
        
        return {
            promptTokens,
            responseTokensAvailable: maxResponseTokens,
            withinLimits: true
        };
    }

    // LLM API Call with Chunking Support
    async callLLMAPIChunked(prompt, options = {}) {
        const {
            maxResponseTokens = 3000,
            allowChunking = true,
            retries = 2
        } = options;
        
        try {
            // First, try to validate if we can send as single request
            this.validateTokenLimits(prompt, maxResponseTokens);
            
            // If validation passes, try single request first
            return await this.makeSingleLLMRequest(prompt, maxResponseTokens, retries);
            
        } catch (tokenError) {
            if (!allowChunking) {
                throw new Error(`Prompt too large and chunking disabled: ${tokenError.message}`);
            }
            
            console.log('Prompt too large, switching to chunked analysis:', tokenError.message);
            return await this.makeChunkedLLMRequest(prompt, options);
        }
    }

    // Single LLM Request
    async makeSingleLLMRequest(prompt, maxResponseTokens, retries = 2) {
        for (let attempt = 0; attempt <= retries; attempt++) {
            try {
                console.log(`LLM API call attempt ${attempt + 1}/${retries + 1}`);
                
                const response = await fetch(`${this.vllmEndpoint}/generate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: prompt,
                        max_tokens: maxResponseTokens,
                        temperature: 0.1,
                        top_p: 0.9,
                        stop: [],
                        stream: false,
                        frequency_penalty: 0.1,
                        presence_penalty: 0.0
                    }),
                    signal: AbortSignal.timeout(90000) // 90 second timeout
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                const resultText = this.extractTextFromResponse(data);
                
                if (!resultText) {
                    throw new Error('No valid text content in LLM response');
                }

                // Parse and validate response
                const parseResult = this.parseJSONResponse(resultText);
                
                if (parseResult.success) {
                    console.log('‚úÖ Single LLM request successful');
                    return parseResult.data;
                } else if (parseResult.fallbackData) {
                    console.warn('‚ö†Ô∏è JSON parsing failed, using fallback data');
                    return parseResult.fallbackData;
                } else {
                    throw new Error(`JSON parsing failed: ${parseResult.error}`);
                }

            } catch (error) {
                console.error(`LLM attempt ${attempt + 1} failed:`, error);
                
                if (attempt < retries) {
                    const delay = 2000 * (attempt + 1); // Exponential backoff
                    console.log(`Retrying in ${delay}ms...`);
                    await this.sleep(delay);
                } else {
                    throw error;
                }
            }
        }
    }

    // Chunked LLM Request (simplified for this part)
    async makeChunkedLLMRequest(prompt, options) {
        // For now, return a fallback response
        console.warn('Chunked LLM request not fully implemented, using fallback');
        return this.createComponentFallback('Component', 'Friendly Name', 'Type');
    }

    // Extract Text from LLM Response
    extractTextFromResponse(data) {
        if (typeof data === 'string') return data.trim();
        if (data.text) return data.text.trim();
        if (data.choices && data.choices[0]) {
            if (data.choices[0].text) return data.choices[0].text.trim();
            if (data.choices[0].message?.content) return data.choices[0].message.content.trim();
        }
        if (data.generated_text) return data.generated_text.trim();
        if (data.response) return data.response.trim();
        
        return null;
    }

    // Parse JSON Response
    parseJSONResponse(text) {
        try {
            // Try to extract JSON from response
            const jsonMatch = text.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                const parsed = JSON.parse(jsonMatch[0]);
                return { success: true, data: parsed };
            }
            
            // If no JSON found, create fallback structure
            return {
                success: false,
                error: 'No JSON found in response',
                fallbackData: {
                    businessPurpose: text.substring(0, 200) + '...',
                    recommendations: ['Manual review recommended'],
                    qualityScore: 5
                }
            };
            
        } catch (error) {
            return {
                success: false,
                error: error.message,
                fallbackData: {
                    businessPurpose: 'Analysis failed - manual review required',
                    recommendations: ['Check LLM connection', 'Verify component data'],
                    qualityScore: 3
                }
            };
        }
    }

    // Create Component Fallback
    createComponentFallback(componentName, friendlyName, componentType) {
        return {
            componentName: componentName,
            friendlyName: friendlyName,
            componentType: componentType || 'Unknown',
            businessPurpose: 'Business purpose analysis not available',
            recommendations: [
                'Verify LLM server connection',
                'Check component data quality',
                'Consider manual analysis'
            ],
            qualityScore: 3,
            error: true,
            fallback: true
        };
    }

    // Get Business Intelligence from LLM
    async getBusinessIntelligenceFromLLM(componentName, friendlyName, componentType, relevantFiles, dependencyAnalysis, fieldAnalysis) {
        const fileContents = relevantFiles.map(f => `=== ${f.name} (${f.type}) ===\n${f.content}`).join('\n\n');
        
        const prompt = `MAINFRAME COMPONENT BUSINESS INTELLIGENCE ANALYSIS

Component: ${componentName}
Friendly Name: ${friendlyName}
Type: ${componentType}

FILE CONTENTS:
${fileContents.substring(0, 8000)} // Truncate for token limits

DEPENDENCY ANALYSIS:
Found Dependencies: ${JSON.stringify(dependencyAnalysis.found)}
Missing Dependencies: ${JSON.stringify(dependencyAnalysis.missing)}

${fieldAnalysis ? `FIELD ANALYSIS:
Total Fields: ${fieldAnalysis.fields.length}
Input Fields: ${fieldAnalysis.inputFields.length}
Output Fields: ${fieldAnalysis.outputFields.length}
Unused Fields: ${fieldAnalysis.unusedFields.length}` : ''}

TASK: Provide comprehensive business intelligence analysis for this mainframe component.

Return JSON format:
{
  "componentName": "${componentName}",
  "friendlyName": "${friendlyName}",
  "businessPurpose": "detailed business purpose and role in the system",
  "businessLogic": {
    "validationRules": ["rule1", "rule2"],
    "businessRules": ["rule1", "rule2"],
    "dataProcessing": "description of data processing logic"
  },
  "qualityScore": 8,
  "recommendations": ["rec1", "rec2", "rec3"],
  "modernizationSuggestions": ["suggestion1", "suggestion2"],
  "riskAssessment": "low/medium/high risk assessment with reasoning"
}`;

        return await this.callLLMAPI(prompt);
    }

    // ============================================
    // CHAT SYSTEM AND BUSINESS INTELLIGENCE
    // ============================================

    // Initialize Chat System
    initializeChat() {
        const chatInput = document.getElementById('chatInput');
        const chatSendBtn = document.getElementById('chatSendBtn');
        const chatSuggestions = document.querySelectorAll('.chat-suggestion-btn');
        
        if (chatInput && chatSendBtn) {
            // Chat input event handlers
            chatInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    this.sendChatMessage();
                }
            });
            
            chatSendBtn.addEventListener('click', () => this.sendChatMessage());
            
            // Auto-resize chat input
            chatInput.addEventListener('input', () => {
                chatInput.style.height = 'auto';
                chatInput.style.height = Math.min(chatInput.scrollHeight, 160) + 'px';
            });
        }
        
        // Chat suggestion buttons
        chatSuggestions.forEach(btn => {
            btn.addEventListener('click', () => {
                const question = btn.getAttribute('data-question');
                if (question && chatInput) {
                    chatInput.value = question;
                    this.sendChatMessage();
                }
            });
        });
    }

    // Enable Chat
    enableChat() {
        const chatInput = document.getElementById('chatInput');
        const chatSendBtn = document.getElementById('chatSendBtn');
        const chatContextSection = document.getElementById('chatContextSection');
        const chatSuggestions = document.getElementById('chatSuggestions');
        
        if (chatInput) chatInput.disabled = false;
        if (chatSendBtn) chatSendBtn.disabled = false;
        if (chatContextSection) chatContextSection.style.display = 'block';
        if (chatSuggestions) chatSuggestions.style.display = 'block';
        
        // Show welcome message for analyzed components
        this.addChatMessage('assistant', `üéâ **Analysis Complete!**

I can now provide intelligent insights about your ${this.discoveredComponents.size} discovered components.

**Available Analysis:**
‚Ä¢ ${Object.keys(this.analysisResults).length} components fully analyzed
‚Ä¢ Business purpose and logic understanding
‚Ä¢ Dependency mapping and impact analysis
‚Ä¢ Field-level insights and relationships
‚Ä¢ Modernization recommendations

**Try asking:**
"What's the business purpose of [component name]?"
"Show me missing dependencies"
"Which fields are most critical?"
"How can we optimize this system?"

Select any component from the dashboard to get contextual suggestions!`);
    }

    // Send Chat Message
    async sendChatMessage() {
        const chatInput = document.getElementById('chatInput');
        const message = chatInput.value.trim();
        
        if (!message) return;
        
        // Clear input and add user message
        chatInput.value = '';
        chatInput.style.height = 'auto';
        this.addChatMessage('user', message);
        
        // Show typing indicator
        this.showTypingIndicator();
        
        try {
            // Get contextual response
            const response = await this.getChatResponse(message);
            
            // Remove typing indicator and add response
            this.hideTypingIndicator();
            this.addChatMessage('assistant', response);
            
            // Save chat to database
            this.saveChatToDatabase(message, response);
            
        } catch (error) {
            this.hideTypingIndicator();
            this.addChatMessage('assistant', `‚ùå **Error:** ${error.message}\n\nPlease check your LLM connection and try again.`);
        }
    }

    // Add Chat Message to UI
    addChatMessage(sender, content) {
        const chatMessages = document.getElementById('chatMessages');
        if (!chatMessages) return;
        
        const messageDiv = document.createElement('div');
        messageDiv.className = `chat-message ${sender}`;
        
        const bubble = document.createElement('div');
        bubble.className = 'chat-bubble';
        
        if (sender === 'assistant') {
            bubble.innerHTML = `
                <div class="chat-message-header">Business Intelligence Assistant</div>
                <div class="chat-message-content">${content}</div>
                <div class="chat-message-time">${new Date().toLocaleTimeString()}</div>
            `;
        } else {
            bubble.innerHTML = `
                <div class="chat-message-content">${content}</div>
                <div class="chat-message-time">${new Date().toLocaleTimeString()}</div>
            `;
        }
        
        messageDiv.appendChild(bubble);
        chatMessages.appendChild(messageDiv);
        
        // Scroll to bottom
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    // Show/Hide Typing Indicator
    showTypingIndicator() {
        const chatMessages = document.getElementById('chatMessages');
        if (!chatMessages) return;
        
        const typingDiv = document.createElement('div');
        typingDiv.className = 'typing-indicator';
        typingDiv.id = 'typingIndicator';
        typingDiv.innerHTML = `
            <span>ü§ñ Assistant is thinking...</span>
            <div class="typing-dots">
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
            </div>
        `;
        
        chatMessages.appendChild(typingDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    hideTypingIndicator() {
        const typingIndicator = document.getElementById('typingIndicator');
        if (typingIndicator) {
            typingIndicator.remove();
        }
    }

    // Get Chat Response
    async getChatResponse(message) {
        const context = this.buildChatContext(message);
        
        const prompt = `BUSINESS INTELLIGENCE CHAT ASSISTANT

CONTEXT:
${context}

USER QUESTION: "${message}"

INSTRUCTIONS:
- Provide intelligent, business-focused insights
- Use the analysis data to give specific, actionable answers
- Format response in markdown for readability
- Include relevant component names, statistics, and recommendations
- Be conversational but professional
- If asked about specific components, reference their analysis data
- For dependency questions, highlight critical missing items
- For optimization questions, provide concrete modernization suggestions

RESPONSE:`;

        try {
            const response = await this.callLLMAPI(prompt);
            
            if (response && typeof response === 'string') {
                return response;
            } else if (response && response.businessPurpose) {
                return response.businessPurpose;
            } else {
                return this.generateFallbackResponse(message);
            }
            
        } catch (error) {
            console.error('Chat response failed:', error);
            return this.generateFallbackResponse(message);
        }
    }

    // Build Chat Context
    buildChatContext(message) {
        let context = `SYSTEM OVERVIEW:
- Total Components: ${this.discoveredComponents.size}
- Analyzed Components: ${Object.keys(this.analysisResults).length}
- Files Uploaded: ${this.uploadedFiles.length}
- Current Selection: ${this.currentSelectedComponent || 'None'}

`;

        // Add component summaries
        if (Object.keys(this.analysisResults).length > 0) {
            context += `ANALYZED COMPONENTS:\n`;
            Object.entries(this.analysisResults).slice(0, 5).forEach(([name, result]) => {
                context += `- ${name} (${result.friendlyName}): ${result.componentType}\n`;
                context += `  Purpose: ${result.llmAnalysis?.businessPurpose?.substring(0, 100) || 'Not available'}...\n`;
                if (result.qualityScore) {
                    context += `  Quality Score: ${result.qualityScore}/10\n`;
                }
            });
            context += '\n';
        }

        // Add specific component context if selected
        if (this.currentSelectedComponent && this.analysisResults[this.currentSelectedComponent]) {
            const selectedResult = this.analysisResults[this.currentSelectedComponent];
            context += `CURRENT COMPONENT FOCUS: ${this.currentSelectedComponent}
${JSON.stringify(selectedResult, null, 2).substring(0, 2000)}

`;
        }

        return context;
    }

    // Generate Fallback Response
    generateFallbackResponse(message) {
        const lowerMessage = message.toLowerCase();
        
        if (lowerMessage.includes('business purpose') || lowerMessage.includes('what does')) {
            return `üìä **Business Purpose Analysis**

Based on the analyzed components, I can help you understand:

${Object.entries(this.analysisResults).slice(0, 3).map(([name, result]) => 
    `‚Ä¢ **${name}**: ${result.llmAnalysis?.businessPurpose || result.componentType + ' component'}`
).join('\n')}

*Select a specific component from the dashboard for detailed analysis.*`;
        }
        
        if (lowerMessage.includes('dependencies') || lowerMessage.includes('missing')) {
            const totalMissing = Object.values(this.analysisResults).reduce((sum, result) => 
                sum + (result.dependencyAnalysis?.summary?.missingCount || 0), 0);
            
            return `üîó **Dependency Analysis**

**System Health:**
‚Ä¢ Total Missing Dependencies: ${totalMissing}
‚Ä¢ Critical Impact Assessment: ${totalMissing > 10 ? 'HIGH' : totalMissing > 5 ? 'MEDIUM' : 'LOW'}

**Recommendations:**
‚Ä¢ Review missing copybooks and programs
‚Ä¢ Validate file references
‚Ä¢ Consider impact on system functionality

*Ask about specific components for detailed dependency maps.*`;
        }
        
        if (lowerMessage.includes('fields') || lowerMessage.includes('data')) {
            const totalFields = Object.values(this.analysisResults).reduce((sum, result) => 
                sum + (result.totalFields || 0), 0);
            
            return `üìã **Field Analysis Summary**

**Data Structure Overview:**
‚Ä¢ Total Fields Analyzed: ${totalFields}
‚Ä¢ Components with Field Data: ${Object.values(this.analysisResults).filter(r => r.fieldAnalysis).length}

**Key Insights:**
‚Ä¢ Input/Output field patterns identified
‚Ä¢ Business logic validation rules discovered
‚Ä¢ Field relationship mapping available

*Select a copybook component for detailed field matrix analysis.*`;
        }
        
        if (lowerMessage.includes('optimize') || lowerMessage.includes('modernize')) {
            return `üöÄ **Modernization Recommendations**

**System Optimization Opportunities:**
‚Ä¢ Legacy code refactoring candidates identified
‚Ä¢ Dependency simplification possibilities
‚Ä¢ Data structure optimization potential

**Next Steps:**
‚Ä¢ Review high-complexity components first
‚Ä¢ Address missing dependencies
‚Ä¢ Consider microservices decomposition
‚Ä¢ Implement automated testing coverage

*Ask about specific components for targeted modernization strategies.*`;
        }
        
        return `ü§ñ **I'm here to help with your mainframe analysis!**

**What I can assist with:**
‚Ä¢ Business purpose explanations
‚Ä¢ Dependency analysis and impact assessment
‚Ä¢ Field-level data insights
‚Ä¢ Modernization recommendations
‚Ä¢ Component quality evaluation

**Try asking:**
‚Ä¢ "What's the purpose of [component name]?"
‚Ä¢ "Show me missing dependencies"
‚Ä¢ "Which components need attention?"
‚Ä¢ "How can we optimize this system?"

*Select any component from the dashboard for focused analysis.*`;
    }

    // Update Chat Context
    updateChatContext(contextType, selectedItem) {
        const chatContext = document.getElementById('chatContext');
        const chatSelectedItem = document.getElementById('chatSelectedItem');
        const chatSuggestions = document.getElementById('chatSuggestions');
        
        if (chatContext) chatContext.value = contextType;
        if (chatSelectedItem) chatSelectedItem.value = selectedItem || '';
        
        this.chatContext = contextType;
        this.currentSelectedComponent = contextType === 'component' ? selectedItem : null;
        
        // Update suggestions based on context
        if (chatSuggestions && selectedItem) {
            this.updateChatSuggestions(contextType, selectedItem);
        }
    }

    // Update Chat Suggestions
    updateChatSuggestions(contextType, selectedItem) {
        const suggestionsContainer = document.querySelector('.chat-suggestion-chips');
        if (!suggestionsContainer) return;
        
        let suggestions = [];
        
        if (contextType === 'component' && selectedItem) {
            suggestions = [
                { text: 'üéØ Business Purpose', question: `What is the business purpose of ${selectedItem}?` },
                { text: 'üåä Field Lifecycle', question: `Show me the complete field lifecycle for ${selectedItem}` },
                { text: 'üîó Dependencies', question: `What are the dependencies for ${selectedItem}?` },
                { text: '‚öñÔ∏è Business Rules', question: `What business rules are implemented in ${selectedItem}?` },
                { text: 'üöÄ Optimization', question: `How can we optimize ${selectedItem} for modernization?` },
                { text: '‚ö†Ô∏è Risk Assessment', question: `What are the risks associated with ${selectedItem}?` }
            ];
        } else {
            suggestions = [
                { text: 'üìä System Overview', question: 'Give me a high-level overview of the system' },
                { text: 'üîç Critical Components', question: 'Which components are most critical to review?' },
                { text: '‚ö†Ô∏è Missing Dependencies', question: 'Show me all missing dependencies and their impact' },
                { text: 'üí° Modernization Plan', question: 'Create a modernization roadmap for this system' },
                { text: 'üìà Quality Report', question: 'Generate a quality assessment report' },
                { text: 'üéØ Business Value', question: 'What business value does this system provide?' }
            ];
        }
        
        suggestionsContainer.innerHTML = suggestions.map(s => 
            `<button class="chat-suggestion-btn" data-question="${s.question}">${s.text}</button>`
        ).join('');
        
        // Re-attach event listeners
        suggestionsContainer.querySelectorAll('.chat-suggestion-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const question = btn.getAttribute('data-question');
                const chatInput = document.getElementById('chatInput');
                if (question && chatInput) {
                    chatInput.value = question;
                    this.sendChatMessage();
                }
            });
        });
    }

    // Save Chat to Database
    saveChatToDatabase(userMessage, assistantResponse) {
        if (!this.db || !this.dbInitialized) return;
        
        try {
            const timestamp = new Date().toISOString();
            
            // Save user message
            this.db.run(`
                INSERT INTO chat_history 
                (component_name, context_type, sender, content, timestamp)
                VALUES (?, ?, ?, ?, ?)
            `, [
                this.currentSelectedComponent || '',
                this.chatContext,
                'user',
                userMessage,
                timestamp
            ]);
            
            // Save assistant response
            this.db.run(`
                INSERT INTO chat_history 
                (component_name, context_type, sender, content, timestamp)
                VALUES (?, ?, ?, ?, ?)
            `, [
                this.currentSelectedComponent || '',
                this.chatContext,
                'assistant',
                assistantResponse,
                timestamp
            ]);
            
        } catch (error) {
            console.error('Failed to save chat to database:', error);
        }
    }

    // Add Typing Animation Styles
    addTypingAnimationStyles() {
        // Styles are already included in the CSS
        console.log('‚úÖ Typing animation styles loaded');
    }

    // Chat context change handler
    onChatContextChange() {
        const chatContext = document.getElementById('chatContext');
        if (chatContext) {
            this.chatContext = chatContext.value;
        }
    }

    // Utility function
    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}
// ============================================
// GLOBAL FUNCTIONS FOR HTML ONCLICK HANDLERS
// Add these functions to the main JavaScript section
// ============================================

// Global functions for HTML onclick handlers
function togglePanel(side) {
    if (window.analyzer) {
        window.analyzer.togglePanel(side);
    }
}

function toggleCollapsible(header) {
    if (window.analyzer) {
        window.analyzer.toggleCollapsible(header);
    }
}

// Add the missing methods to the EnhancedCodeAnalyzer class:
// --- Persist discovered components (call after discovery/selection) ---
EnhancedCodeAnalyzer.prototype.saveDiscoveredComponentsToDb = function() {
    if (!this.db || !this.dbInitialized) return;
    try {
        // Create table if missing (non-destructive)
        this.db.run(`
            CREATE TABLE IF NOT EXISTS discovered_components (
                name TEXT PRIMARY KEY,
                friendly_name TEXT,
                type TEXT,
                business_purpose TEXT,
                file_source TEXT,
                line_count INTEGER,
                complexity_score REAL,
                input_files TEXT,
                output_files TEXT,
                field_count INTEGER,
                analyzed INTEGER DEFAULT 0,
                quality_score REAL,
                timestamp TEXT,
                selected INTEGER DEFAULT 0
            );
        `);

        // Upsert all components
        const stmt = this.db.prepare(`
            INSERT OR REPLACE INTO discovered_components
            (name, friendly_name, type, business_purpose, file_source, line_count, complexity_score,
             input_files, output_files, field_count, analyzed, quality_score, timestamp, selected)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `);

        for (const comp of this.discoveredComponents.values()) {
            stmt.run([
                comp.name,
                comp.friendlyName || comp.name,
                comp.type || '',
                comp.businessPurpose || '',
                comp.fileSource || '',
                comp.lineCount || 0,
                comp.complexityScore || 0,
                JSON.stringify(comp.inputFiles || []),
                JSON.stringify(comp.outputFiles || []),
                comp.fieldCount || 0,
                comp.analyzed ? 1 : 0,
                comp.qualityScore ?? null,
                comp.timestamp || new Date().toISOString(),
                comp.selected ? 1 : 0
            ]);
        }
        stmt.free();
    } catch (e) {
        console.error('Failed to save discovered components:', e);
    }
};

// --- Mark selection in DB when user selects a component ---
EnhancedCodeAnalyzer.prototype.persistSelection = function(selectedName) {
    if (!this.db || !this.dbInitialized) return;
    try {
        // Clear previous selection flags
        this.db.run(`UPDATE discovered_components SET selected = 0`);
        // Set current
        this.db.run(`UPDATE discovered_components SET selected = 1 WHERE name = ?`, [selectedName]);
        // Also reflect in memory
        for (const comp of this.discoveredComponents.values()) {
            comp.selected = (comp.name === selectedName);
        }
    } catch (e) {
        console.error('Failed to persist selection:', e);
    }
};

// --- Update header & dashboard counters everywhere they appear ---
EnhancedCodeAnalyzer.prototype.updateDashboardStats = function() {
    // Counts
    const totalComponents = this.discoveredComponents.size;
    const totalFiles = this.uploadedFiles.length;
    const totalFields = Array.from(this.discoveredComponents.values())
        .reduce((sum, c) => sum + (c.fieldCount || 0), 0);

    const programs = Array.from(this.discoveredComponents.values())
        .filter(c => (c.type || '').toUpperCase().includes('PROGRAM')).length;
    const copybooks = Array.from(this.discoveredComponents.values())
        .filter(c => (c.type || '').toUpperCase().includes('COPY')).length;

    // Quality average (only analyzed comps with numeric score)
    const scored = Array.from(this.discoveredComponents.values())
        .map(c => Number(c.qualityScore))
        .filter(v => Number.isFinite(v));
    const avgQuality = scored.length ? (scored.reduce((a,b)=>a+b,0) / scored.length).toFixed(1) : '-';

    // Header stats
    const setText = (id, val) => { const el = document.getElementById(id); if (el) el.textContent = String(val); };
    setText('headerComponents', totalComponents);
    setText('headerPrograms', programs);
    setText('headerCopybooks', copybooks);
    setText('headerFields', totalFields);

    // Dashboard card stats
    setText('dashTotalComponents', totalComponents);
    setText('dashTotalFiles', totalFiles);
    setText('dashTotalFields', totalFields);
    setText('dashQualityScore', avgQuality);

    // Left-panel section badges (when present)
    setText('componentCount', totalComponents);
    setText('programCount', programs);
    setText('copybookCount', copybooks);
    // Files count badge is optional; if you have an element id="fileCount", update it:
    const fileCountEl = document.getElementById('fileCount');
    if (fileCountEl) fileCountEl.textContent = String(totalFiles);
};

// --- (Optional) ensure DB schema for other tables too; call inside createTables() if missing ---
EnhancedCodeAnalyzer.prototype.createTables = function() {
    if (!this.db) return;
    try {
        this.db.run(`
            CREATE TABLE IF NOT EXISTS uploaded_files (
                file_id INTEGER PRIMARY KEY,
                name TEXT,
                size INTEGER,
                type TEXT,
                content TEXT,
                metrics_json TEXT,
                created_at TEXT
            );
        `);
        this.db.run(`
            CREATE TABLE IF NOT EXISTS analysis_results (
                component_name TEXT PRIMARY KEY,
                result_json TEXT,
                quality_score REAL,
                updated_at TEXT
            );
        `);
        this.db.run(`
            CREATE TABLE IF NOT EXISTS business_intelligence (
                component_name TEXT,
                topic TEXT,
                content TEXT,
                created_at TEXT,
                PRIMARY KEY (component_name, topic)
            );
        `);
        this.db.run(`
            CREATE TABLE IF NOT EXISTS chat_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                component_name TEXT,
                context_type TEXT,
                sender TEXT,
                content TEXT,
                timestamp TEXT
            );
        `);
        // discovered_components table is created in saveDiscoveredComponentsToDb() if not present
        this.db.run(`
            CREATE TABLE IF NOT EXISTS system_settings (
                setting_key TEXT PRIMARY KEY,
                setting_value TEXT,
                updated_at TEXT
            );
        `);
    } catch (e) {
        console.error('Failed to (re)create tables:', e);
    }
};

// Basic UI Functions
EnhancedCodeAnalyzer.prototype.togglePanel = function(side) {
    const panel = document.getElementById(side + 'Panel');
    if (!panel) return;
    
    panel.classList.toggle('collapsed');
    
    // Update button icon
    const btn = panel.querySelector('.collapse-btn');
    if (btn) {
        if (side === 'left') {
            btn.textContent = panel.classList.contains('collapsed') ? '‚ñ∂' : '‚óÄ';
        } else {
            btn.textContent = panel.classList.contains('collapsed') ? '‚óÄ' : '‚ñ∂';
        }
    }
    
    // Save state to database
    if (this.db && this.dbInitialized) {
        try {
            this.db.run(`
                INSERT OR REPLACE INTO system_settings (setting_key, setting_value, updated_at)
                VALUES (?, ?, CURRENT_TIMESTAMP)
            `, [`${side}_panel_collapsed`, panel.classList.contains('collapsed') ? '1' : '0']);
        } catch (error) {
            console.warn('Could not save panel state:', error);
        }
    }
};

EnhancedCodeAnalyzer.prototype.toggleCollapsible = function(header) {
    if (!header || !header.parentElement) return;
    
    const section = header.parentElement;
    section.classList.toggle('expanded');
    
    // Update expand icon rotation
    const expandIcon = header.querySelector('.expand-icon');
    if (expandIcon) {
        if (section.classList.contains('expanded')) {
            expandIcon.style.transform = 'rotate(180deg)';
        } else {
            expandIcon.style.transform = 'rotate(0deg)';
        }
    }
};

// Select Component function
EnhancedCodeAnalyzer.prototype.selectComponent = function(componentName) {
    this.currentSelectedComponent = componentName;
    
    // Update UI selection
    document.querySelectorAll('.component-card').forEach(card => {
        card.classList.remove('selected');
    });
    
    const selectedCard = document.querySelector(`[data-component="${componentName}"]`);
    if (selectedCard) {
        selectedCard.classList.add('selected');
    }
    
    // Update chat context
    this.updateChatContext('component', componentName);
    
    // Show field matrix for selected component if analyzed
    if (this.analysisResults[componentName]) {
        this.displayFieldMatrix(componentName);
        
        // Switch to field matrix tab
        const fieldMatrixTab = document.querySelector('.tab[data-tab="fieldmatrix"]');
        if (fieldMatrixTab) fieldMatrixTab.click();
    } else {
        // Show message that analysis is needed
        const fieldMatrixContent = document.getElementById('fieldMatrixContent');
        if (fieldMatrixContent) {
            fieldMatrixContent.innerHTML = `
                <div style="text-align: center; padding: 2rem; color: var(--grey-500);">
                    <h4>Component Analysis Required</h4>
                    <p>The component "${componentName}" needs to be analyzed first.</p>
                    <p>Run auto-analysis to see detailed field matrix information.</p>
                </div>
            `;
        }
    }
    
    this.showInfo(`Selected component: ${this.getDisplayName(componentName)}`);
};

// Remove File function
EnhancedCodeAnalyzer.prototype.removeFile = function(fileId) {
    const fileIndex = this.uploadedFiles.findIndex(f => f.id == fileId);
    if (fileIndex === -1) return;
    
    const file = this.uploadedFiles[fileIndex];
    
    // Remove associated components
    if (file.components) {
        file.components.forEach(comp => {
            if (comp.isMainComponent) {
                this.discoveredComponents.delete(comp.name);
                delete this.analysisResults[comp.name];
            }
        });
    }
    
    // Remove file
    this.uploadedFiles.splice(fileIndex, 1);
    
    // Remove from database
    if (this.db && this.dbInitialized) {
        try {
            this.db.run('DELETE FROM uploaded_files WHERE file_id = ?', [fileId]);
        } catch (error) {
            console.error('Failed to remove file from database:', error);
        }
    }
    
    this.updateDashboardStats();
    this.displayDiscoveredComponents();
    this.showInfo('File removed and components updated');
};

// Get Display Name (friendly name if available)
EnhancedCodeAnalyzer.prototype.getDisplayName = function(componentName) {
    const component = this.discoveredComponents.get(componentName);
    return component?.friendlyName || componentName;
};

// Load Stored Data (for backwards compatibility)
EnhancedCodeAnalyzer.prototype.loadStoredData = function() {
    // This will be handled by loadDataFromDatabase()
    console.log('üìä Loading stored data from database...');
};

// Save to Storage (for backwards compatibility)
EnhancedCodeAnalyzer.prototype.saveToStorage = function() {
    // This will be handled by saveToDatabase()
    this.saveToDatabase();
};

// Add these missing UI display functions that are referenced:

// Display Field Matrix for Selected Component
EnhancedCodeAnalyzer.prototype.displayFieldMatrix = function(componentName) {
    const container = document.getElementById('fieldMatrixContent');
    if (!container) return;
    
    const analysisResult = this.analysisResults[componentName];
    const component = this.discoveredComponents.get(componentName);
    const displayName = component?.friendlyName || componentName;
    
    if (!analysisResult || !analysisResult.fieldAnalysis) {
        container.innerHTML = `
            <div style="text-align: center; padding: 2rem; color: var(--grey-500);">
                <h4>Field Analysis Not Available</h4>
                <p>Component "${displayName}" either hasn't been analyzed or doesn't contain field data.</p>
            </div>
        `;
        return;
    }
    
    const fieldAnalysis = analysisResult.fieldAnalysis;
    
    let html = `
        <h4>Field Matrix Analysis for ${displayName}</h4>
        
        <!-- Field Overview Metrics -->
        <div class="metrics-grid" style="margin-bottom: 1.5rem;">
            <div class="metric-card">
                <div class="metric-icon">üìã</div>
                <div class="metric-details">
                    <div class="metric-label">Total Fields</div>
                    <div class="metric-value">${fieldAnalysis.fields?.length || 0}</div>
                </div>
            </div>
            <div class="metric-card">
                <div class="metric-icon">üì•</div>
                <div class="metric-details">
                    <div class="metric-label">Input Fields</div>
                    <div class="metric-value">${fieldAnalysis.inputFields?.length || 0}</div>
                </div>
            </div>
            <div class="metric-card">
                <div class="metric-icon">üì§</div>
                <div class="metric-details">
                    <div class="metric-label">Output Fields</div>
                    <div class="metric-value">${fieldAnalysis.outputFields?.length || 0}</div>
                </div>
            </div>
            <div class="metric-card">
                <div class="metric-icon">‚ö†Ô∏è</div>
                <div class="metric-details">
                    <div class="metric-label">Unused Fields</div>
                    <div class="metric-value">${fieldAnalysis.unusedFields?.length || 0}</div>
                </div>
            </div>
        </div>
    `;
    
    if (fieldAnalysis.fields && fieldAnalysis.fields.length > 0) {
        html += `
            <div class="data-table">
                <table>
                    <thead>
                        <tr>
                            <th>Field Name</th>
                            <th>Level</th>
                            <th>Picture</th>
                            <th>Usage Pattern</th>
                            <th>Business Purpose</th>
                            <th>Operations</th>
                        </tr>
                    </thead>
                    <tbody>
        `;
        
        fieldAnalysis.fields.slice(0, 50).forEach(field => {
            const usage = this.determineFieldUsage(field, fieldAnalysis);
            const badgeClass = this.getUsageBadgeClass(usage);
            const businessPurpose = field.businessLogic?.businessMeaning || this.generateFieldPurpose(field.name);
            
            html += `
                <tr onclick="analyzer.updateChatContext('field', '${field.name}')" style="cursor: pointer;">
                    <td style="font-family: monospace; font-weight: 600;">${field.name}</td>
                    <td><span class="badge badge-grey">${field.level}</span></td>
                    <td style="font-family: monospace;">${field.picture || '-'}</td>
                    <td><span class="badge ${badgeClass}">${usage}</span></td>
                    <td style="font-size: 0.85rem; max-width: 200px;">${businessPurpose}</td>
                    <td>
                        <span class="badge badge-grey">Analysis</span>
                    </td>
                </tr>
            `;
        });
        
        html += `
                    </tbody>
                </table>
            </div>
        `;
        
        if (fieldAnalysis.fields.length > 50) {
            html += `<p style="margin-top: 1rem; color: var(--grey-500);">Showing 50 of ${fieldAnalysis.fields.length} fields</p>`;
        }
    } else {
        html += '<p style="color: var(--grey-500); text-align: center;">No fields found for analysis</p>';
    }
    
    container.innerHTML = html;
};

// Determine Field Usage
EnhancedCodeAnalyzer.prototype.determineFieldUsage = function(field, fieldAnalysis) {
    const fieldName = field.name;
    
    if (fieldAnalysis.inputFields && fieldAnalysis.inputFields.includes(fieldName)) return 'INPUT';
    if (fieldAnalysis.outputFields && fieldAnalysis.outputFields.includes(fieldName)) return 'OUTPUT';
    if (fieldAnalysis.referenceFields && fieldAnalysis.referenceFields.includes(fieldName)) return 'REFERENCE';
    if (fieldAnalysis.unusedFields && fieldAnalysis.unusedFields.includes(fieldName)) return 'UNUSED';
    
    return 'UNKNOWN';
};

// Get Usage Badge Class
EnhancedCodeAnalyzer.prototype.getUsageBadgeClass = function(usage) {
    switch(usage) {
        case 'INPUT': return 'badge-success';
        case 'OUTPUT': return 'badge-primary';
        case 'REFERENCE': return 'badge-warning';
        case 'UNUSED': return 'badge-danger';
        default: return 'badge-grey';
    }
};

// Make sure these global functions are available immediately
window.togglePanel = togglePanel;
window.toggleCollapsible = toggleCollapsible;

// Initialize analyzer on page load with proper error handling
let analyzer;
document.addEventListener('DOMContentLoaded', function() {
    try {
        analyzer = new EnhancedCodeAnalyzer();
        window.analyzer = analyzer; // Make globally accessible
        
        // Restore panel states if saved
        if (analyzer.db && analyzer.dbInitialized) {
            try {
                const stmt = analyzer.db.prepare('SELECT * FROM system_settings WHERE setting_key LIKE "%_panel_collapsed"');
                while (stmt.step()) {
                    const row = stmt.getAsObject();
                    if (row.setting_value === '1') {
                        const side = row.setting_key.replace('_panel_collapsed', '');
                        togglePanel(side);
                    }
                }
                stmt.free();
            } catch (error) {
                console.warn('Could not restore panel states:', error);
            }
        }
        
        console.log('‚úÖ Enhanced Code Analyzer - Powered by Opulence Ready!');
    } catch (error) {
        console.error('Failed to initialize Enhanced Code Analyzer:', error);
        // Show error message to user
        document.body.innerHTML = `
            <div style="display: flex; align-items: center; justify-content: center; height: 100vh; background: #f9fafb;">
                <div style="text-align: center; padding: 2rem; background: white; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                    <h2 style="color: #ef4444; margin-bottom: 1rem;">‚ùå Initialization Failed</h2>
                    <p style="color: #6b7280; margin-bottom: 1rem;">Enhanced Code Analyzer failed to initialize properly.</p>
                    <p style="color: #374151; font-size: 0.9rem;">Error: ${error.message}</p>
                    <button onclick="location.reload()" style="margin-top: 1rem; padding: 0.5rem 1rem; background: #3b82f6; color: white; border: none; border-radius: 6px; cursor: pointer;">
                        Reload Page
                    </button>
                </div>
            </div>
        `;
    }
});
</script>
</body>
</html>