<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Mainframe Analyzer</title>
    <style>
        /* Your existing styles remain the same */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 25%, #334155 50%, #475569 75%, #64748b 100%);
            color: #f8fafc;
            min-height: 100vh;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 50%, rgba(120, 119, 198, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.08) 0%, transparent 50%),
                radial-gradient(circle at 40% 80%, rgba(120, 198, 121, 0.06) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 30px;
            background: rgba(15, 23, 42, 0.7);
            backdrop-filter: blur(20px);
            border-radius: 24px;
            border: 1px solid rgba(148, 163, 184, 0.2);
            box-shadow: 
                0 20px 25px -5px rgba(0, 0, 0, 0.1),
                0 10px 10px -5px rgba(0, 0, 0, 0.04),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .header h1 {
            font-size: 3.2rem;
            margin-bottom: 12px;
            font-weight: 800;
            background: linear-gradient(135deg, #06b6d4 0%, #3b82f6 25%, #8b5cf6 50%, #ec4899 75%, #f59e0b 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: none;
            letter-spacing: -0.02em;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 520px 1fr 400px;
            gap: 25px;
            min-height: 80vh;
        }

        .control-panel, .analysis-workspace, .chat-panel {
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 28px;
            border: 1px solid rgba(148, 163, 184, 0.2);
            box-shadow: 
                0 10px 15px -3px rgba(0, 0, 0, 0.1),
                0 4px 6px -2px rgba(0, 0, 0, 0.05),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .control-panel {
            height: fit-content;
            max-height: 85vh;
            overflow-y: auto;
        }

        .analysis-workspace {
            min-height: 80vh;
            overflow-y: auto;
        }

        .chat-panel {
            display: flex;
            flex-direction: column;
            max-height: 85vh;
        }

        /* Component Search Section */
        .component-search-section {
            margin-bottom: 25px;
            padding: 24px;
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.1) 0%, rgba(16, 185, 129, 0.08) 100%);
            border-radius: 16px;
            border: 1px solid rgba(34, 197, 94, 0.3);
            box-shadow: 0 4px 6px -1px rgba(34, 197, 94, 0.1);
        }

        .component-input {
            width: 100%;
            padding: 14px 16px;
            border: 2px solid rgba(148, 163, 184, 0.3);
            border-radius: 12px;
            background: rgba(30, 41, 59, 0.6);
            color: #f8fafc;
            font-size: 14px;
            margin-bottom: 10px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 500;
        }

        .component-input:focus {
            outline: none;
            border-color: #06b6d4;
            background: rgba(30, 41, 59, 0.8);
            box-shadow: 
                0 0 0 3px rgba(6, 182, 212, 0.1),
                0 4px 6px -1px rgba(6, 182, 212, 0.1);
            transform: translateY(-1px);
        }

        .component-input::placeholder {
            color: rgba(148, 163, 184, 0.7);
        }

        .component-suggestions {
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 12px;
            max-height: 150px;
            overflow-y: auto;
            display: none;
            border: 1px solid rgba(148, 163, 184, 0.3);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
        }

        .suggestion-item {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid rgba(148, 163, 184, 0.1);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 13px;
        }

        .suggestion-item:hover {
            background: linear-gradient(135deg, rgba(6, 182, 212, 0.1) 0%, rgba(59, 130, 246, 0.05) 100%);
            transform: translateX(4px);
            border-left: 3px solid #06b6d4;
        }

        /* Token Management */
        .token-info {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.1) 0%, rgba(217, 119, 6, 0.08) 100%);
            border: 1px solid rgba(245, 158, 11, 0.3);
            border-radius: 12px;
            padding: 16px;
            margin: 12px 0;
            font-size: 12px;
            box-shadow: 0 4px 6px -1px rgba(245, 158, 11, 0.1);
        }

        .token-bar {
            background: rgba(15, 23, 42, 0.6);
            height: 8px;
            border-radius: 4px;
            margin: 10px 0;
            overflow: hidden;
            border: 1px solid rgba(148, 163, 184, 0.2);
        }

        .token-fill {
            height: 100%;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 4px;
            background: linear-gradient(90deg, var(--token-color-start), var(--token-color-end));
        }

        .token-fill.safe { 
            --token-color-start: #22c55e;
            --token-color-end: #16a34a;
        }
        .token-fill.warning { 
            --token-color-start: #f59e0b;
            --token-color-end: #d97706;
        }
        .token-fill.danger { 
            --token-color-start: #ef4444;
            --token-color-end: #dc2626;
        }

        /* General Form Styles */
        .section-title { 
            color: #06b6d4; 
            font-size: 1.3rem; 
            margin-bottom: 18px; 
            font-weight: 700; 
            display: flex; 
            align-items: center; 
            gap: 12px;
            letter-spacing: -0.01em;
        }

        .form-group { 
            margin-bottom: 20px; 
        }

        .form-group input, 
        .form-group select, 
        .form-group textarea { 
            width: 100%; 
            padding: 14px 16px; 
            border: 2px solid rgba(148, 163, 184, 0.3); 
            border-radius: 12px; 
            background: rgba(30, 41, 59, 0.6); 
            color: #f8fafc; 
            font-size: 14px; 
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 500;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #06b6d4;
            background: rgba(30, 41, 59, 0.8);
            box-shadow: 
                0 0 0 3px rgba(6, 182, 212, 0.1),
                0 4px 6px -1px rgba(6, 182, 212, 0.1);
            transform: translateY(-1px);
        }

        .form-group input::placeholder,
        .form-group textarea::placeholder {
            color: rgba(148, 163, 184, 0.7);
        }

        .action-btn { 
            width: 100%; 
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); 
            color: white; 
            border: none; 
            padding: 16px 20px; 
            border-radius: 12px; 
            cursor: pointer; 
            font-size: 15px; 
            font-weight: 600; 
            margin-bottom: 12px; 
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); 
            text-transform: uppercase; 
            letter-spacing: 0.5px;
            box-shadow: 0 4px 6px -1px rgba(239, 68, 68, 0.25);
        }

        .action-btn:hover:not(:disabled) { 
            transform: translateY(-2px); 
            box-shadow: 0 10px 15px -3px rgba(239, 68, 68, 0.4);
            background: linear-gradient(135deg, #f87171 0%, #ef4444 100%);
        }

        .action-btn:active:not(:disabled) {
            transform: translateY(0);
        }

        .action-btn:disabled { 
            opacity: 0.5; 
            cursor: not-allowed; 
            transform: none; 
            box-shadow: none; 
        }

        .validate-btn { 
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%); 
            box-shadow: 0 4px 6px -1px rgba(34, 197, 94, 0.25);
        }

        .validate-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
            box-shadow: 0 10px 15px -3px rgba(34, 197, 94, 0.4);
        }

        .component-btn { 
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%); 
            box-shadow: 0 4px 6px -1px rgba(34, 197, 94, 0.25);
        }

        .component-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
            box-shadow: 0 10px 15px -3px rgba(34, 197, 94, 0.4);
        }

        .secondary-btn { 
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); 
            box-shadow: 0 4px 6px -1px rgba(59, 130, 246, 0.25);
        }

        .secondary-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #60a5fa 0%, #3b82f6 100%);
            box-shadow: 0 10px 15px -3px rgba(59, 130, 246, 0.4);
        }

        /* API Status */
        .api-status {
            padding: 14px 16px;
            border-radius: 12px;
            margin-top: 12px;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .api-status.connected {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.15) 0%, rgba(22, 163, 74, 0.1) 100%);
            border: 1px solid rgba(34, 197, 94, 0.3);
            color: #4ade80;
            box-shadow: 0 4px 6px -1px rgba(34, 197, 94, 0.1);
        }

        .api-status.connecting {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.15) 0%, rgba(217, 119, 6, 0.1) 100%);
            border: 1px solid rgba(245, 158, 11, 0.3);
            color: #fbbf24;
            box-shadow: 0 4px 6px -1px rgba(245, 158, 11, 0.1);
        }

        .api-status.disconnected {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.15) 0%, rgba(220, 38, 38, 0.1) 100%);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: #f87171;
            box-shadow: 0 4px 6px -1px rgba(239, 68, 68, 0.1);
        }

        /* Upload Area */
        .upload-area {
            border: 2px dashed rgba(148, 163, 184, 0.4);
            border-radius: 16px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            margin-bottom: 20px;
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.3) 0%, rgba(51, 65, 85, 0.2) 100%);
        }

        .upload-area:hover {
            border-color: #06b6d4;
            background: linear-gradient(135deg, rgba(6, 182, 212, 0.1) 0%, rgba(59, 130, 246, 0.05) 100%);
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(6, 182, 212, 0.1);
        }

        .upload-area.drag-over {
            border-color: #22c55e;
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.15) 0%, rgba(16, 185, 129, 0.1) 100%);
            transform: scale(1.02);
        }

        .file-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .file-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .file-info {
            flex: 1;
        }

        .file-name {
            font-weight: bold;
            margin-bottom: 2px;
        }

        .file-details {
            font-size: 11px;
            opacity: 0.8;
        }

        .file-remove {
            background: #f44336;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .file-remove:hover {
            background: #d32f2f;
        }

        /* Loading Indicator */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.95) 0%, rgba(30, 41, 59, 0.9) 100%);
            backdrop-filter: blur(20px);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 9999;
        }

        .loading.show {
            display: flex;
        }

        .spinner {
            width: 80px;
            height: 80px;
            border: 4px solid rgba(148, 163, 184, 0.3);
            border-top: 4px solid #06b6d4;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 24px;
            box-shadow: 0 0 20px rgba(6, 182, 212, 0.3);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading h3 {
            color: #06b6d4;
            margin-bottom: 12px;
            font-size: 1.5rem;
            font-weight: 700;
        }

        .loading p {
            color: rgba(248, 250, 252, 0.8);
            text-align: center;
            max-width: 400px;
            font-size: 1.1rem;
        }

        /* Tabs */
        .tabs {
            display: flex;
            margin-bottom: 25px;
            background: rgba(15, 23, 42, 0.6);
            border-radius: 16px;
            padding: 6px;
            border: 1px solid rgba(148, 163, 184, 0.2);
        }

        .tab {
            flex: 1;
            background: transparent;
            color: rgba(148, 163, 184, 0.8);
            border: none;
            padding: 14px 12px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            letter-spacing: 0.3px;
        }

        .tab.active {
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
            color: #ffffff;
            box-shadow: 0 4px 6px -1px rgba(6, 182, 212, 0.25);
        }

        .tab:hover:not(.active) {
            background: rgba(148, 163, 184, 0.1);
            color: #f8fafc;
            transform: translateY(-1px);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Message Types */
        .error, .success, .warning {
            position: fixed;
            top: 24px;
            right: 24px;
            padding: 16px 24px;
            border-radius: 12px;
            font-weight: 600;
            z-index: 10000;
            animation: slideInRight 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(20px);
        }

        .error {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.95) 0%, rgba(220, 38, 38, 0.9) 100%);
            color: #ffffff;
            border: 1px solid rgba(239, 68, 68, 0.5);
        }

        .success {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.95) 0%, rgba(22, 163, 74, 0.9) 100%);
            color: #ffffff;
            border: 1px solid rgba(34, 197, 94, 0.5);
        }

        .warning {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.95) 0%, rgba(217, 119, 6, 0.9) 100%);
            color: #ffffff;
            border: 1px solid rgba(245, 158, 11, 0.5);
        }

        @keyframes slideInRight {
            from { 
                transform: translateX(100%); 
                opacity: 0;
            }
            to { 
                transform: translateX(0); 
                opacity: 1;
            }
        }

        /* Enhanced Chat Styles */
        .chat-suggestions {
            margin-bottom: 15px;
            padding: 15px;
            background: rgba(30, 41, 59, 0.6);
            border-radius: 12px;
            border: 1px solid rgba(148, 163, 184, 0.2);
        }

        .chat-suggestion-btn {
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.8) 0%, rgba(51, 65, 85, 0.6) 100%);
            border: 1px solid rgba(148, 163, 184, 0.3);
            color: #f8fafc;
            padding: 8px 14px;
            border-radius: 20px;
            font-size: 11px;
            cursor: pointer;
            margin: 4px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: inline-block;
            font-weight: 500;
        }

        .chat-suggestion-btn:hover {
            background: linear-gradient(135deg, rgba(6, 182, 212, 0.2) 0%, rgba(59, 130, 246, 0.15) 100%);
            border-color: #06b6d4;
            transform: translateY(-2px);
            box-shadow: 0 4px 6px -1px rgba(6, 182, 212, 0.25);
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 15px;
            padding: 15px;
            background: rgba(30, 41, 59, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(148, 163, 184, 0.2);
            max-height: 400px;
        }

        .chat-input-section {
            display: flex;
            gap: 10px;
            padding: 15px;
            background: rgba(30, 41, 59, 0.6);
            border-radius: 12px;
            border: 1px solid rgba(148, 163, 184, 0.2);
        }

        .chat-input {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid rgba(148, 163, 184, 0.3);
            border-radius: 10px;
            background: rgba(30, 41, 59, 0.6);
            color: #f8fafc;
            font-size: 14px;
            resize: none;
            min-height: 40px;
            max-height: 120px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .chat-send-btn {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 6px -1px rgba(34, 197, 94, 0.25);
            min-width: 80px;
        }

        .chat-send-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(34, 197, 94, 0.4);
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
        }

        .chat-send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .chat-message {
            margin-bottom: 20px;
            padding: 20px;
            border-radius: 16px;
            max-width: 90%;
            word-wrap: break-word;
            line-height: 1.6;
            animation: fadeInUp 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .chat-message.user {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.2) 0%, rgba(37, 99, 235, 0.15) 100%);
            border: 1px solid rgba(59, 130, 246, 0.3);
            margin-left: auto;
            text-align: right;
        }

        .chat-message.assistant {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.15) 0%, rgba(22, 163, 74, 0.1) 100%);
            border: 1px solid rgba(34, 197, 94, 0.3);
        }

        .chat-message .sender {
            font-weight: bold;
            font-size: 12px;
            opacity: 0.8;
            margin-bottom: 8px;
        }

        .chat-message .content {
            font-size: 14px;
            line-height: 1.6;
        }

        .chat-message .timestamp {
            font-size: 10px;
            opacity: 0.6;
            margin-top: 8px;
        }

        .chat-message .export-btn {
            position: absolute;
            top: 12px;
            right: 12px;
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.8) 0%, rgba(51, 65, 85, 0.7) 100%);
            border: 1px solid rgba(148, 163, 184, 0.3);
            border-radius: 8px;
            padding: 6px 10px;
            font-size: 10px;
            color: #f8fafc;
            cursor: pointer;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 500;
        }

        .chat-message:hover .export-btn {
            opacity: 1;
        }

        .chat-message .export-btn:hover {
            background: linear-gradient(135deg, rgba(6, 182, 212, 0.2) 0%, rgba(59, 130, 246, 0.15) 100%);
            border-color: #06b6d4;
            transform: translateY(-1px);
        }

        /* Lifecycle Flow Styles */
        .lifecycle-flow {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid #8b5cf6;
        }

        .lifecycle-step {
            display: flex;
            align-items: center;
            margin: 15px 0;
            padding: 12px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            position: relative;
        }

        .lifecycle-step::before {
            content: '';
            position: absolute;
            left: -10px;
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
            height: 8px;
            background: #8b5cf6;
            border-radius: 50%;
            border: 2px solid #1e293b;
        }

        .lifecycle-step.active::before {
            background: #22c55e;
            box-shadow: 0 0 10px rgba(34, 197, 94, 0.5);
        }

        .lifecycle-step-icon {
            margin-right: 12px;
            font-size: 1.2em;
        }

        .lifecycle-step-content {
            flex: 1;
        }

        .lifecycle-step-title {
            font-weight: bold;
            color: #f8fafc;
            margin-bottom: 4px;
        }

        .lifecycle-step-description {
            font-size: 12px;
            opacity: 0.8;
            line-height: 1.4;
        }

        .lifecycle-step-programs {
            margin-top: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .program-tag {
            background: rgba(59, 130, 246, 0.2);
            color: #93c5fd;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 10px;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }

        .field-flow-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid #f59e0b;
        }

        .field-flow-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .field-flow-category {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            border-left: 3px solid var(--category-color);
        }

        .field-flow-category h6 {
            color: var(--category-color);
            margin-bottom: 10px;
            font-size: 13px;
            font-weight: 600;
        }

        .field-flow-list {
            max-height: 150px;
            overflow-y: auto;
        }

        .field-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 8px;
            margin: 4px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            font-size: 11px;
            font-family: monospace;
        }

        .field-name {
            font-weight: bold;
        }

        .field-usage {
            font-size: 9px;
            opacity: 0.7;
        }

        .usage-pattern-visual {
            display: flex;
            align-items: center;
            margin: 10px 0;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
        }

        .usage-bar {
            height: 6px;
            background: rgba(148, 163, 184, 0.3);
            border-radius: 3px;
            margin: 0 10px;
            flex: 1;
            overflow: hidden;
        }

        .usage-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--usage-color-start), var(--usage-color-end));
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        .usage-label {
            font-size: 10px;
            font-weight: 600;
            min-width: 60px;
        }

        .usage-percentage {
            font-size: 10px;
            opacity: 0.8;
            min-width: 40px;
            text-align: right;
        }

        /* Export Buttons */
        .export-section {
            margin-top: 20px;
            padding: 20px;
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.1) 0%, rgba(217, 119, 6, 0.08) 100%);
            border-radius: 16px;
            border: 1px solid rgba(245, 158, 11, 0.3);
            box-shadow: 0 4px 6px -1px rgba(245, 158, 11, 0.1);
        }

        .export-btn-group {
            display: flex;
            gap: 12px;
            margin-top: 12px;
        }

        .export-btn-small {
            flex: 1;
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 6px -1px rgba(139, 92, 246, 0.25);
        }

        .export-btn-small:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(139, 92, 246, 0.4);
            background: linear-gradient(135deg, #a78bfa 0%, #8b5cf6 100%);
        }

        .export-btn-small:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Scrollbar Styles */
        .chat-messages::-webkit-scrollbar,
        .file-list::-webkit-scrollbar,
        .component-suggestions::-webkit-scrollbar,
        .field-flow-list::-webkit-scrollbar {
            width: 8px;
        }

        .chat-messages::-webkit-scrollbar-track,
        .file-list::-webkit-scrollbar-track,
        .component-suggestions::-webkit-scrollbar-track,
        .field-flow-list::-webkit-scrollbar-track {
            background: rgba(30, 41, 59, 0.3);
            border-radius: 4px;
        }

        .chat-messages::-webkit-scrollbar-thumb,
        .file-list::-webkit-scrollbar-thumb,
        .component-suggestions::-webkit-scrollbar-thumb,
        .field-flow-list::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #64748b 0%, #475569 100%);
            border-radius: 4px;
        }

        .chat-messages::-webkit-scrollbar-thumb:hover,
        .file-list::-webkit-scrollbar-thumb:hover,
        .component-suggestions::-webkit-scrollbar-thumb:hover,
        .field-flow-list::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
        }

        /* Responsive Design */
        @media (max-width: 1600px) { 
            .main-grid { 
                grid-template-columns: 450px 1fr 350px; 
            } 
        }

        @media (max-width: 1400px) { 
            .main-grid { 
                grid-template-columns: 400px 1fr 300px; 
            } 
        }

        @media (max-width: 1200px) { 
            .main-grid { 
                grid-template-columns: 1fr; 
                gap: 20px; 
            }
            
            .control-panel, 
            .analysis-workspace, 
            .chat-panel {
                max-height: none;
            }
        }

        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🔬 Enhanced Mainframe Analyzer</h1>
            <p>Advanced mainframe analysis with LLM-powered field flow tracking, business rules, and lifecycle mapping</p>
        </div>

        <div class="main-grid">
            <!-- Control Panel -->
            <div class="control-panel">
                <!-- Component Search Section -->
                <div class="component-search-section">
                    <h2 class="section-title">🎯 Component Analysis</h2>
                    <div class="form-group">
                        <label for="componentName">Enter Component Name:</label>
                        <input type="text" id="componentName" class="component-input" 
                               placeholder="e.g., CUSTOMER-RECORD, ACCOUNT-COPY, PAYROLL-PROC">
                        <div id="componentSuggestions" class="component-suggestions"></div>
                    </div>
                    
                    <!-- Token Usage Display -->
                    <div id="tokenInfo" class="token-info" style="display: none;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                            <span style="font-weight: bold;">Token Management</span>
                            <span id="tokenCount">0 / 4000</span>
                        </div>
                        <div class="token-bar">
                            <div id="tokenFill" class="token-fill safe" style="width: 0%"></div>
                        </div>
                        <div id="tokenWarning" style="font-size: 11px; margin-top: 5px;"></div>
                    </div>
                    
                    <button class="action-btn component-btn" id="analyzeComponentBtn" disabled>
                        🔍 Analyze Component
                    </button>
                </div>

                <!-- vLLM API Setup -->
                <div style="margin-bottom: 25px; padding: 20px; background: rgba(0, 0, 0, 0.2); border-radius: 15px; border-left: 4px solid #4CAF50;">
                    <h2 class="section-title">🚀 vLLM Server Setup</h2>
                    <div class="form-group">
                        <label for="vllmEndpoint">Server Endpoint:</label>
                        <input type="text" id="vllmEndpoint" placeholder="http://localhost:8000" value="http://localhost:8000">
                    </div>
                    <div class="form-group">
                        <label for="maxTokens">Max Tokens:</label>
                        <input type="number" id="maxTokens" value="4000" min="1000" max="8000">
                    </div>
                    <button class="action-btn validate-btn" id="validateApiBtn">
                        🔐 Test Connection
                    </button>
                    <div class="api-status disconnected" id="apiStatus">
                        <span>🔴</span> Enter server details and test connection
                    </div>
                </div>

                <!-- File Upload Section -->
                <div style="margin-bottom: 25px;">
                    <h2 class="section-title">📁 Upload Mainframe Files</h2>
                    <div class="upload-area" id="uploadArea">
                        <div>
                            <h3 style="margin-bottom: 8px;">📤 Drop files here</h3>
                            <p style="font-size: 14px;">COBOL (.cbl), Copybooks (.cpy), JCL (.jcl)</p>
                        </div>
                        <input type="file" id="fileInput" multiple accept=".cbl,.cob,.cpy,.copybook,.jcl,.txt,.proc" style="display: none;">
                    </div>
                    <div id="uploadedFiles" class="file-list"></div>
                </div>

                <!-- Quick Actions -->
                <div>
                    <h3 class="section-title">⚡ Actions</h3>
                    <button class="action-btn secondary-btn" id="bulkAnalyzeBtn" disabled>
                        📊 Bulk Analyze
                    </button>
                    
                    <!-- Export Section -->
                    <div class="export-section">
                        <h4 style="color: #FFC107; margin-bottom: 10px; font-size: 14px;">📤 Export Options</h4>
                        <div class="export-btn-group">
                            <button class="export-btn-small" id="exportJsonBtn" disabled>
                                📋 JSON Export
                            </button>
                            <button class="export-btn-small" id="exportMdBtn" disabled>
                                📝 Markdown Export
                            </button>
                        </div>
                    </div>
                    
                    <button class="action-btn secondary-btn" id="clearBtn">
                        🗑️ Clear All Data
                    </button>
                </div>
            </div>

            <!-- Analysis Workspace -->
            <div class="analysis-workspace">
                <div class="tabs">
                    <button class="tab active" data-tab="lifecycle">🔄 Analysis Results</button>
                    <button class="tab" data-tab="fieldmatrix">📋 Field Matrix</button>
                    <button class="tab" data-tab="usage">📈 Usage Patterns</button>
                    <button class="tab" data-tab="dependencies">🔗 Dependencies</button>
                    <button class="tab" data-tab="fileflow">🌊 File Lifecycle</button>
                </div>

                <!-- Tab Contents -->
                <div id="lifecycle" class="tab-content active">
                    <div id="lifecycleContent">
                        <h3>🎯 LLM-Powered Component Analysis</h3>
                        <p style="margin-bottom: 20px; line-height: 1.6;">
                            Upload files, test your connection, and analyze components for detailed LLM-powered field flows and business rules.
                        </p>
                        
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px; border-left: 4px solid #FFD700;">
                            <h4 style="color: #FFD700; margin-bottom: 15px;">🤖 LLM-Enhanced Features:</h4>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                                <div>
                                    <strong style="color: #4CAF50;">🧠 LLM Field Analysis:</strong>
                                    <ul style="list-style: none; margin-left: 10px; line-height: 1.8;">
                                        <li>• Smart field lifecycle tracking</li>
                                        <li>• Context-aware usage patterns</li>
                                        <li>• Intelligent field categorization</li>
                                        <li>• Cross-program flow analysis</li>
                                    </ul>
                                </div>
                                <div>
                                    <strong style="color: #2196F3;">⚖️ Smart Business Rules:</strong>
                                    <ul style="list-style: none; margin-left: 10px; line-height: 1.8;">
                                        <li>• LLM-extracted validation logic</li>
                                        <li>• Context-aware decision mapping</li>
                                        <li>• Business calculation analysis</li>
                                        <li>• Rule complexity assessment</li>
                                    </ul>
                                </div>
                                <div>
                                    <strong style="color: #FF9800;">🔗 Smart Dependencies:</strong>
                                    <ul style="list-style: none; margin-left: 10px; line-height: 1.8;">
                                        <li>• Regex + LLM validation</li>
                                        <li>• Smart call chain analysis</li>
                                        <li>• Contextual file references</li>
                                        <li>• Impact assessment</li>
                                    </ul>
                                </div>
                                <div>
                                    <strong style="color: #9C27B0;">🌊 File Lifecycle:</strong>
                                    <ul style="list-style: none; margin-left: 10px; line-height: 1.8;">
                                        <li>• Creation to purge tracking</li>
                                        <li>• Program usage mapping</li>
                                        <li>• Field update patterns</li>
                                        <li>• CICS screen integration</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="fieldmatrix" class="tab-content">
                    <div id="fieldMatrixContent">
                        <h3>📋 LLM Field Matrix Analysis</h3>
                        <p style="margin-bottom: 20px;">Enhanced field-level analysis with LLM-powered categorization will appear here after component analysis.</p>
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px;">
                            <p style="text-align: center; opacity: 0.8;">LLM-enhanced field matrix will appear here after analysis.</p>
                        </div>
                    </div>
                </div>

                <div id="usage" class="tab-content">
                    <div id="usageContent">
                        <h3>📈 Smart Usage Patterns</h3>
                        <p style="margin-bottom: 20px;">LLM-powered usage pattern analysis with field lifecycle flows will appear here after component analysis.</p>
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px;">
                            <p style="text-align: center; opacity: 0.8;">Smart usage patterns will appear here after analysis.</p>
                        </div>
                    </div>
                </div>

                <div id="dependencies" class="tab-content">
                    <div id="dependenciesContent">
                        <h3>🔗 Hybrid Dependency Analysis</h3>
                        <p style="margin-bottom: 20px;">Regex + LLM dependency mapping will appear here after component analysis.</p>
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px;">
                            <p style="text-align: center; opacity: 0.8;">Hybrid dependency graph will appear here after analysis.</p>
                        </div>
                    </div>
                </div>

                <div id="fileflow" class="tab-content">
                    <div id="fileflowContent">
                        <h3>🌊 File Lifecycle Flow Analysis</h3>
                        <p style="margin-bottom: 20px;">Complete file lifecycle from creation through purge, including program usage patterns and field update tracking.</p>
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px;">
                            <p style="text-align: center; opacity: 0.8;">File lifecycle flow analysis will appear here after component analysis.</p>
                        </div>
                    </div>
                </div>

                <!-- Loading Indicator -->
                <div class="loading" id="loadingIndicator">
                    <div class="spinner"></div>
                    <h3>🤖 LLM Analyzing Component</h3>
                    <p id="loadingStatus">Processing component analysis with LLM...</p>
                    <div id="progressBar" style="background: rgba(255,255,255,0.2); height: 6px; border-radius: 3px; margin: 15px 0; overflow: hidden;">
                        <div id="progressFill" style="height: 100%; background: #4CAF50; width: 0%; transition: width 0.3s ease;"></div>
                    </div>
                </div>
            </div>

            <!-- Enhanced Chat Panel -->
            <div class="chat-panel">
                <div style="background: rgba(76, 175, 80, 0.2); border-radius: 10px; padding: 15px; margin-bottom: 15px; border-left: 4px solid #4CAF50;">
                    <h3 style="margin-bottom: 8px; color: #FFD700;">💬 LLM Analysis Chat</h3>
                    <p style="font-size: 12px; opacity: 0.8;">Enhanced interactive chat with rich formatting and export</p>
                </div>
                
                <!-- Chat Suggestions -->
                <div class="chat-suggestions" id="chatSuggestions" style="display: none;">
                    <h4 style="color: #06b6d4; margin-bottom: 10px; font-size: 13px;">💡 Suggested Questions:</h4>
                    <button class="chat-suggestion-btn" data-question="Explain the file lifecycle flow for this component">📊 File Lifecycle</button>
                    <button class="chat-suggestion-btn" data-question="What fields are updated by which programs?">🔄 Field Updates</button>
                    <button class="chat-suggestion-btn" data-question="Show me the creation and purge process">🌊 Creation/Purge</button>
                    <button class="chat-suggestion-btn" data-question="Which programs only read vs modify data?">📖 Read/Write Patterns</button>
                </div>
                
                <!-- Chat Messages Area -->
                <div class="chat-messages" id="chatMessages">
                    <div class="chat-message assistant">
                        <div class="sender">LLM Analysis Assistant</div>
                        <div class="content">
                            👋 <strong>Welcome to LLM-Enhanced Mainframe Analysis!</strong>
                            <br><br>
                            I can provide detailed analysis using advanced language models including:
                            <br><br>
                            🧠 <strong>Smart Field Analysis:</strong> Context-aware field lifecycle tracking
                            <br>⚖️ <strong>Business Logic Extraction:</strong> Intelligent rule and validation discovery  
                            <br>🔗 <strong>Dependency Mapping:</strong> Comprehensive relationship analysis
                            <br>🌊 <strong>File Lifecycle Flow:</strong> Creation to purge tracking with program mapping
                            <br>💡 <strong>Modernization Guidance:</strong> AI-powered optimization recommendations
                            <br><br>
                            <em>Upload files and analyze a component to unlock the full power of LLM analysis!</em>
                        </div>
                        <div class="timestamp">${new Date().toLocaleTimeString()}</div>
                    </div>
                </div>
                
                <!-- Chat Input -->
                <div class="chat-input-section">
                    <textarea class="chat-input" id="chatInput" placeholder="Ask about field flows, program dependencies, lifecycle patterns..." disabled rows="2"></textarea>
                    <button class="chat-send-btn" id="chatSendBtn" disabled>Send</button>
                </div>
            </div>
        </div>
    </div>
    <script>
// ===================================================================
// PART 1: CORE STRUCTURE AND BASIC SETUP
// Enhanced Mainframe Analyzer - Fixed for Copybook Lifecycle Analysis
// ===================================================================

class EnhancedMainframeAnalyzer {
    constructor() {
        // Core properties
        this.uploadedFiles = [];
        this.analysisResults = {};
        this.componentSuggestions = [];
        this.serverValidated = false;
        this.vllmEndpoint = 'http://localhost:8000';
        this.maxTokens = 4000;
        this.storageKey = 'enhanced_mainframe_analysis';
        this.currentAnalyzedComponent = null;
        this.chatHistory = [];
        
        // Token management
        this.averageCharsPerToken = 3;
        this.tokenSafetyMargin = 0.7;
        
        // LLM Analysis configuration
        this.llmConfig = {
            temperature: 0.1,
            maxRetries: 2,
            chunkSize: 2000,
            analysisTimeout: 90000
        };
        
        // File lifecycle patterns
        this.lifecyclePatterns = {
            creation: ['CREATE', 'WRITE', 'OUTPUT', 'OPEN OUTPUT', 'FD ', 'FILE-CONTROL'],
            reading: ['READ', 'INPUT', 'OPEN INPUT', 'SELECT'],
            updating: ['WRITE', 'REWRITE', 'UPDATE', 'MODIFY', 'OPEN I-O'],
            deletion: ['DELETE', 'PURGE', 'REMOVE'],
            cicsOperations: ['EXEC CICS', 'SEND MAP', 'RECEIVE MAP', 'READ TD', 'WRITE TD'],
            batchOperations: ['SORT', 'MERGE', 'COPY', '//EXEC PGM=']
        };
        
        this.initializeBasicEventListeners();
        this.loadStoredData();
        this.initializeTokenManagement();
        this.initializeChat();
        
        console.log('🚀 Enhanced Mainframe Analyzer with Focused Copybook Analysis Initialized');
    }

    // === BASIC EVENT LISTENERS ===
    initializeBasicEventListeners() {
        // API validation
        document.getElementById('validateApiBtn').addEventListener('click', () => this.validateConnection());
        document.getElementById('vllmEndpoint').addEventListener('input', () => this.onEndpointChange());
        document.getElementById('maxTokens').addEventListener('input', () => this.onSettingsChange());
        
        // File upload handlers
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        
        uploadArea.addEventListener('click', () => {
            if (this.serverValidated) fileInput.click();
        });
        uploadArea.addEventListener('drop', (e) => this.handleFileDrop(e));
        uploadArea.addEventListener('dragover', (e) => this.handleDragOver(e));
        uploadArea.addEventListener('dragleave', (e) => this.handleDragLeave(e));
        fileInput.addEventListener('change', (e) => this.handleFileSelect(e));

        // Component analysis
        document.getElementById('componentName').addEventListener('input', () => this.onComponentInput());
        document.getElementById('analyzeComponentBtn').addEventListener('click', () => this.analyzeComponent());
        
        // Quick actions
        document.getElementById('bulkAnalyzeBtn').addEventListener('click', () => this.bulkAnalyze());
        document.getElementById('exportJsonBtn').addEventListener('click', () => this.exportResults('json'));
        document.getElementById('exportMdBtn').addEventListener('click', () => this.exportResults('markdown'));
        document.getElementById('clearBtn').addEventListener('click', () => this.clearAllData());

        // Tab navigation
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', (e) => this.switchTab(e));
        });

        // Hide suggestions when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.component-search-section')) {
                document.getElementById('componentSuggestions').style.display = 'none';
            }
        });
    }

    initializeTokenManagement() {
        this.updateTokenDisplay(0);
        this.showSuccess('🚀 Enhanced Mainframe Analyzer Ready for Focused Component Analysis!');
    }

    // === TOKEN MANAGEMENT ===
    estimateTokenCount(text) {
        if (!text) return 0;
        return Math.ceil(text.length / this.averageCharsPerToken);
    }

    updateTokenDisplay(currentTokens) {
        const tokenInfo = document.getElementById('tokenInfo');
        const tokenCount = document.getElementById('tokenCount');
        const tokenFill = document.getElementById('tokenFill');
        const tokenWarning = document.getElementById('tokenWarning');

        if (!tokenInfo) return;

        tokenInfo.style.display = 'block';
        tokenCount.textContent = `${currentTokens} / ${this.maxTokens}`;
        
        const percentage = (currentTokens / this.maxTokens) * 100;
        tokenFill.style.width = `${Math.min(percentage, 100)}%`;
        
        tokenFill.className = 'token-fill';
        if (percentage <= 50) {
            tokenFill.classList.add('safe');
            tokenWarning.textContent = '🟢 Optimal token usage - full analysis available';
        } else if (percentage <= 70) {
            tokenFill.classList.add('warning');
            tokenWarning.textContent = '🟡 Moderate usage - focused analysis active';
        } else {
            tokenFill.classList.add('danger');
            tokenWarning.textContent = '🔴 High usage - scope optimization required';
        }
    }

    // === API CONNECTION ===
    async validateConnection() {
        const endpoint = document.getElementById('vllmEndpoint').value.trim();
        if (!endpoint) {
            this.showError('Please enter vLLM endpoint');
            return;
        }

        this.updateConnectionStatus('connecting', 'Testing LLM connection...');

        try {
            const response = await fetch(`${endpoint}/generate`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    prompt: "Test connection. Respond with 'Connected'",
                    max_tokens: 10,
                    temperature: 0.1
                }),
                signal: AbortSignal.timeout(10000)
            });

            if (response.ok) {
                const data = await response.json();
                this.serverValidated = true;
                this.vllmEndpoint = endpoint;
                this.updateConnectionStatus('connected', `✅ LLM connection verified`);
                this.showSuccess('🚀 vLLM server connected successfully!');
            } else {
                throw new Error(`HTTP ${response.status}`);
            }
        } catch (error) {
            this.serverValidated = false;
            this.updateConnectionStatus('disconnected', `❌ Connection failed: ${error.message}`);
            this.showError(`LLM connection failed: ${error.message}`);
        }
        
        this.validateForm();
    }

    updateConnectionStatus(status, message) {
        const statusElement = document.getElementById('apiStatus');
        if (statusElement) {
            statusElement.className = `api-status ${status}`;
            statusElement.innerHTML = message;
        }
    }

    // === UTILITY METHODS ===
    showLoading() { 
        const loading = document.getElementById('loadingIndicator');
        if (loading) loading.classList.add('show'); 
    }
    
    hideLoading() { 
        const loading = document.getElementById('loadingIndicator');
        if (loading) loading.classList.remove('show'); 
    }
    
    updateLoadingStatus(status) { 
        const statusElement = document.getElementById('loadingStatus');
        if (statusElement) statusElement.textContent = status; 
    }

    updateProgress(percentage) {
        const progressFill = document.getElementById('progressFill');
        if (progressFill) {
            progressFill.style.width = `${percentage}%`;
        }
    }

    showMessage(type, message, duration = 3000) {
        const messageDiv = document.createElement('div');
        messageDiv.className = type;
        messageDiv.textContent = message;
        document.body.appendChild(messageDiv);
        
        setTimeout(() => {
            if (messageDiv.parentNode) {
                messageDiv.parentNode.removeChild(messageDiv);
            }
        }, duration);
    }
    
    showError(message) { this.showMessage('error', message, 5000); }
    showSuccess(message) { this.showMessage('success', message, 3000); }
    showWarning(message) { this.showMessage('warning', message, 4000); }
    
    sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

    // === FORM VALIDATION ===
    validateForm() {
        const hasFiles = this.uploadedFiles.length > 0;
        const hasComponent = document.getElementById('componentName') && 
                           document.getElementById('componentName').value.trim().length > 0;
        const hasConnection = this.serverValidated;
        
        const analyzeBtn = document.getElementById('analyzeComponentBtn');
        const bulkBtn = document.getElementById('bulkAnalyzeBtn');
        
        if (analyzeBtn) analyzeBtn.disabled = !(hasFiles && hasComponent && hasConnection);
        if (bulkBtn) bulkBtn.disabled = !(hasFiles && hasConnection);
        
        const hasResults = Object.keys(this.analysisResults).length > 0;
        const exportJsonBtn = document.getElementById('exportJsonBtn');
        const exportMdBtn = document.getElementById('exportMdBtn');
        
        if (exportJsonBtn) exportJsonBtn.disabled = !hasResults;
        if (exportMdBtn) exportMdBtn.disabled = !hasResults;
    }

    // === EVENT HANDLERS ===
    onEndpointChange() {
        this.serverValidated = false;
        this.updateConnectionStatus('disconnected', '🔴 Connection not validated');
        this.validateForm();
    }

    onSettingsChange() {
        const maxTokensInput = document.getElementById('maxTokens');
        if (maxTokensInput) {
            this.maxTokens = parseInt(maxTokensInput.value) || 4000;
            this.saveToStorage();
        }
    }

    switchTab(e) {
        const targetTab = e.target?.dataset?.tab || e.dataset?.tab;
        if (!targetTab) return;
        
        document.querySelectorAll('.tab').forEach(tab => {
            tab.classList.remove('active');
        });
        
        const clickedTab = e.target || e;
        if (clickedTab.classList) {
            clickedTab.classList.add('active');
        }
        
        document.querySelectorAll('.tab-content').forEach(content => {
            content.classList.remove('active');
        });
        
        const targetContent = document.getElementById(targetTab);
        if (targetContent) {
            targetContent.classList.add('active');
        }
    }

    // === STORAGE MANAGEMENT ===
    saveToStorage() {
        try {
            const data = {
                uploadedFiles: this.uploadedFiles,
                analysisResults: this.analysisResults,
                chatHistory: this.chatHistory,
                vllmEndpoint: this.vllmEndpoint,
                maxTokens: this.maxTokens,
                timestamp: new Date().toISOString()
            };
            localStorage.setItem(this.storageKey, JSON.stringify(data));
        } catch (error) {
            console.warn('Failed to save to storage:', error);
        }
    }

    loadStoredData() {
        try {
            const stored = localStorage.getItem(this.storageKey);
            if (stored) {
                const data = JSON.parse(stored);
                this.uploadedFiles = data.uploadedFiles || [];
                this.analysisResults = data.analysisResults || {};
                this.chatHistory = data.chatHistory || [];
                
                const endpointInput = document.getElementById('vllmEndpoint');
                const maxTokensInput = document.getElementById('maxTokens');
                
                if (data.vllmEndpoint && endpointInput) {
                    endpointInput.value = data.vllmEndpoint;
                    this.vllmEndpoint = data.vllmEndpoint;
                }
                
                if (data.maxTokens && maxTokensInput) {
                    maxTokensInput.value = data.maxTokens;
                    this.maxTokens = data.maxTokens;
                }
                
                this.displayUploadedFiles();
                this.updateComponentSuggestions();
                this.validateForm();
                
                console.log('📁 Stored analysis data loaded successfully');
            }
        } catch (error) {
            console.warn('Failed to load stored data:', error);
        }
    }

    clearAllData() {
        if (confirm('Are you sure you want to clear all analysis data? This cannot be undone.')) {
            this.uploadedFiles = [];
            this.analysisResults = {};
            this.componentSuggestions = [];
            this.currentAnalyzedComponent = null;
            this.chatHistory = [];
            
            localStorage.removeItem(this.storageKey);
            
            this.displayUploadedFiles();
            this.validateForm();
            
            // Reset chat area
            const chatMessages = document.getElementById('chatMessages');
            if (chatMessages) {
                chatMessages.innerHTML = `
                    <div class="chat-message assistant">
                        <div class="sender">Analysis Assistant</div>
                        <div class="content">
                            👋 <strong>Welcome to Enhanced Mainframe Analysis!</strong>
                            <br><br>Upload files and analyze a component to get started.
                        </div>
                        <div class="timestamp">${new Date().toLocaleTimeString()}</div>
                    </div>
                `;
            }
            
            // Disable chat input
            const chatInput = document.getElementById('chatInput');
            const chatSendBtn = document.getElementById('chatSendBtn');
            if (chatInput) chatInput.disabled = true;
            if (chatSendBtn) chatSendBtn.disabled = true;
            
            this.showSuccess('🗑️ All analysis data cleared successfully');
        }
    }

// ===================================================================
// PART 2: FILE UPLOAD AND COMPONENT DETECTION
// Enhanced file handling with focused component analysis
// ===================================================================

// === FILE UPLOAD HANDLING ===
handleFileDrop(e) {
    e.preventDefault();
    e.stopPropagation();
    
    const uploadArea = document.getElementById('uploadArea');
    uploadArea.classList.remove('drag-over');
    
    if (!this.serverValidated) {
        this.showError('Please validate LLM API connection first');
        return;
    }
    
    const files = Array.from(e.dataTransfer.files);
    this.processFiles(files);
}

handleDragOver(e) {
    e.preventDefault();
    e.stopPropagation();
    const uploadArea = document.getElementById('uploadArea');
    if (uploadArea) uploadArea.classList.add('drag-over');
}

handleDragLeave(e) {
    e.preventDefault();
    e.stopPropagation();
    const uploadArea = document.getElementById('uploadArea');
    if (uploadArea) uploadArea.classList.remove('drag-over');
}

handleFileSelect(e) {
    if (!this.serverValidated) {
        this.showError('Please validate LLM API connection first');
        return;
    }
    
    const files = Array.from(e.target.files);
    this.processFiles(files);
}

async processFiles(files) {
    for (const file of files) {
        try {
            const content = await this.readFile(file);
            const fileType = this.detectFileType(file.name, content);
            
            const fileObj = {
                name: file.name,
                content: content,
                size: file.size,
                type: fileType,
                uploadDate: new Date().toISOString(),
                id: Date.now() + Math.random(),
                components: this.extractComponentsFromFile(content, fileType)
            };
            
            this.uploadedFiles.push(fileObj);
            this.updateComponentSuggestions();
            
        } catch (error) {
            this.showError(`Failed to read ${file.name}: ${error.message}`);
        }
    }
    
    this.displayUploadedFiles();
    this.validateForm();
    this.saveToStorage();
    this.showSuccess(`📁 ${files.length} files uploaded successfully!`);
}

readFile(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = e => resolve(e.target.result);
        reader.onerror = e => reject(new Error('File read failed'));
        reader.readAsText(file);
    });
}

detectFileType(fileName, content) {
    const name = fileName.toLowerCase();
    const upperContent = content.toUpperCase();
    
    if (name.includes('.cpy') || name.includes('copybook')) {
        return 'Copybook';
    } else if (name.includes('.jcl') || upperContent.includes('//JOB ')) {
        return 'JCL Job';
    } else if (name.includes('.cbl') || name.includes('.cob') || 
              upperContent.includes('IDENTIFICATION DIVISION') ||
              upperContent.includes('PROGRAM-ID')) {
        return 'COBOL Program';
    } else if (name.includes('.proc')) {
        return 'JCL Procedure';
    } else {
        return 'Text File';
    }
}

// === EXTRACT COMPONENTS FROM FILES ===
extractComponentsFromFile(content, fileType) {
    const components = [];
    const lines = content.split('\n');
    const upperContent = content.toUpperCase();

    lines.forEach((line, index) => {
        const trimmed = line.trim().toUpperCase();
        
        // Extract COBOL 01-level fields (main focus)
        const field01Match = trimmed.match(/^\s*01\s+([A-Z][A-Z0-9\-_]{2,})/);
        if (field01Match) {
            components.push({
                name: field01Match[1],
                type: 'RECORD_LAYOUT',
                level: '01',
                lineNumber: index + 1,
                fileType: fileType,
                isMainComponent: true
            });
        }
        
        // Extract copybook names
        const copyMatch = trimmed.match(/COPY\s+([A-Z][A-Z0-9\-_]{2,})/);
        if (copyMatch) {
            components.push({
                name: copyMatch[1],
                type: 'COPYBOOK',
                lineNumber: index + 1,
                fileType: fileType,
                isMainComponent: false
            });
        }
        
        // Extract program names
        const programMatch = trimmed.match(/PROGRAM-ID\.?\s+([A-Z][A-Z0-9\-_]{2,})/);
        if (programMatch) {
            components.push({
                name: programMatch[1],
                type: 'PROGRAM',
                lineNumber: index + 1,
                fileType: fileType,
                isMainComponent: true
            });
        }

        // Extract file names from FD statements
        const fileMatch = trimmed.match(/FD\s+([A-Z][A-Z0-9\-_]{2,})/);
        if (fileMatch) {
            components.push({
                name: fileMatch[1],
                type: 'FILE',
                lineNumber: index + 1,
                fileType: fileType,
                isMainComponent: false
            });
        }
    });
    
    return components;
}

// === COMPONENT SUGGESTIONS ===
updateComponentSuggestions() {
    this.componentSuggestions = [];
    
    this.uploadedFiles.forEach(file => {
        if (file.components) {
            file.components.forEach(component => {
                // Focus on main components (01-level fields, programs)
                if (component.isMainComponent) {
                    this.componentSuggestions.push({
                        name: component.name,
                        type: component.type,
                        level: component.level,
                        file: file.name,
                        fileType: file.type,
                        lineNumber: component.lineNumber
                    });
                }
            });
        }
    });
    
    // Remove duplicates and sort by importance
    this.componentSuggestions = this.componentSuggestions
        .filter((item, index, self) => 
            index === self.findIndex(t => t.name === item.name && t.type === item.type)
        )
        .sort((a, b) => {
            // Prioritize 01-level fields and programs
            if (a.type === 'RECORD_LAYOUT' && b.type !== 'RECORD_LAYOUT') return -1;
            if (b.type === 'RECORD_LAYOUT' && a.type !== 'RECORD_LAYOUT') return 1;
            if (a.type === 'PROGRAM' && b.type !== 'PROGRAM') return -1;
            if (b.type === 'PROGRAM' && a.type !== 'PROGRAM') return 1;
            return a.name.localeCompare(b.name);
        });
}

onComponentInput() {
    const input = document.getElementById('componentName');
    const suggestions = document.getElementById('componentSuggestions');
    
    if (!input || !suggestions) {
        this.validateForm();
        return;
    }
    
    const value = input.value.trim().toUpperCase();
    
    if (value.length < 2) {
        suggestions.style.display = 'none';
        this.validateForm();
        return;
    }
    
    const filtered = this.componentSuggestions.filter(item => 
        item.name.includes(value)
    ).slice(0, 8);
    
    if (filtered.length > 0) {
        let html = '';
        filtered.forEach(item => {
            const icon = this.getComponentIcon(item.type);
            const priority = item.type === 'RECORD_LAYOUT' ? '🎯' : 
                           item.type === 'PROGRAM' ? '💼' : '📁';
            
            html += `
                <div class="suggestion-item" onclick="analyzer.selectSuggestion('${item.name}')">
                    <strong>${priority} ${item.name}</strong> 
                    <span style="opacity: 0.7;">(${item.type} in ${item.file})</span>
                    ${item.level ? `<span style="margin-left: 8px; background: #FFD700; color: #000; padding: 1px 4px; border-radius: 2px; font-size: 9px;">L${item.level}</span>` : ''}
                </div>
            `;
        });
        suggestions.innerHTML = html;
        suggestions.style.display = 'block';
    } else {
        suggestions.style.display = 'none';
    }
    
    this.validateForm();
}

getComponentIcon(type) {
    const icons = {
        'RECORD_LAYOUT': '🎯',
        'PROGRAM': '💼',
        'COPYBOOK': '📚',
        'FILE': '📁'
    };
    return icons[type] || '📋';
}

selectSuggestion(componentName) {
    const input = document.getElementById('componentName');
    const suggestions = document.getElementById('componentSuggestions');
    
    if (input) input.value = componentName;
    if (suggestions) suggestions.style.display = 'none';
    
    this.validateForm();
}

// === FILE DISPLAY ===
displayUploadedFiles() {
    const container = document.getElementById('uploadedFiles');
    if (!container) return;
    
    if (this.uploadedFiles.length === 0) {
        container.innerHTML = '';
        return;
    }
    
    let html = '';
    this.uploadedFiles.forEach(file => {
        const mainComponents = file.components ? 
            file.components.filter(c => c.isMainComponent).length : 0;
        const totalComponents = file.components ? file.components.length : 0;
        
        html += `
            <div class="file-item">
                <div class="file-info">
                    <div class="file-name">${file.name}</div>
                    <div class="file-details">
                        ${file.type} • ${Math.round(file.size/1024)}KB
                        ${mainComponents > 0 ? ` • 🎯 ${mainComponents} main components` : ''}
                        ${totalComponents > mainComponents ? ` • 📁 ${totalComponents - mainComponents} references` : ''}
                    </div>
                </div>
                <button class="file-remove" onclick="analyzer.removeFile('${file.id}')">🗑️</button>
            </div>
        `;
    });
    
    container.innerHTML = html;
}

removeFile(fileId) {
    this.uploadedFiles = this.uploadedFiles.filter(f => f.id != fileId);
    this.displayUploadedFiles();
    this.updateComponentSuggestions();
    this.validateForm();
    this.saveToStorage();
}

// === COMPONENT HELPER METHODS ===
findRelevantFiles(componentName) {
    return this.uploadedFiles.filter(file => {
        // Check if file contains the component directly
        if (file.content.toUpperCase().includes(componentName.toUpperCase()) ||
            file.name.toUpperCase().includes(componentName.toUpperCase())) {
            return true;
        }
        
        // Check if any component in the file matches
        if (file.components) {
            return file.components.some(comp => 
                comp.name.toUpperCase() === componentName.toUpperCase()
            );
        }
        
        return false;
    });
}

detectComponentType(componentName, files) {
    // Check if it's a 01-level field (record layout)
    for (const file of files) {
        if (file.components) {
            const component = file.components.find(c => 
                c.name.toUpperCase() === componentName.toUpperCase()
            );
            if (component) {
                if (component.type === 'RECORD_LAYOUT') return 'Copybook';
                if (component.type === 'PROGRAM') return 'COBOL Program';
                if (component.type === 'FILE') return 'File Definition';
            }
        }
    }
    
    // Fallback to file type detection
    const copybookFile = files.find(f => f.type === 'Copybook');
    if (copybookFile) return 'Copybook';
    
    const programFile = files.find(f => f.type === 'COBOL Program');
    if (programFile) return 'COBOL Program';
    
    return 'Component';
}
// ===================================================================
// PART 3: FOCUSED COPYBOOK FIELD ANALYSIS
// Extract and analyze 01-level fields with lifecycle tracking
// ===================================================================

// === EXTRACT 01-LEVEL FIELDS FROM COPYBOOKS ===
extractCopybookFields(copybookName, relevantFiles) {
    const fields = [];
    
    // Find the copybook file
    const copybookFile = relevantFiles.find(f => 
        f.type === 'Copybook' || 
        f.name.toUpperCase().includes(copybookName.toUpperCase()) ||
        (f.components && f.components.some(c => c.name.toUpperCase() === copybookName.toUpperCase()))
    );
    
    if (!copybookFile) {
        console.warn('Copybook file not found for:', copybookName);
        return fields;
    }

    const lines = copybookFile.content.split('\n');
    
    lines.forEach((line, index) => {
        const trimmed = line.trim();
        
        // EXTRACT ALL FIELD LEVELS (01, 05, 10, 15, 20, etc.)
        const fieldMatch = trimmed.match(/^\s*(\d{2})\s+([A-Z][A-Z0-9\-_]*)/);
        if (fieldMatch) {
            const level = parseInt(fieldMatch[1]);
            const fieldName = fieldMatch[2];
            
            // Skip 88-level conditions for now (they're conditional values)
            if (level === 88) return;
            
            // Extract PIC clause if present
            const picMatch = trimmed.match(/PIC\s+([X9VS\(\)]+)/i);
            const picture = picMatch ? picMatch[1] : '';
            
            // Extract VALUE clause if present
            const valueMatch = trimmed.match(/VALUE\s+([^.]+)/i);
            const value = valueMatch ? valueMatch[1].trim() : '';
            
            // Extract OCCURS clause if present
            const occursMatch = trimmed.match(/OCCURS\s+(\d+)/i);
            const occurs = occursMatch ? parseInt(occursMatch[1]) : 0;
            
            // Extract REDEFINES clause if present
            const redefinesMatch = trimmed.match(/REDEFINES\s+([A-Z][A-Z0-9\-_]*)/i);
            const redefines = redefinesMatch ? redefinesMatch[1] : '';
            
            // Determine field type
            const isRecordLayout = level === 1 && !picture && !value;
            const isGroupField = !picture && !value && level > 1;
            const isElementaryField = !!picture;
            const isConstant = !!value;
            
            fields.push({
                name: fieldName,
                level: level,
                picture: picture,
                value: value,
                occurs: occurs,
                redefines: redefines,
                isRecordLayout: isRecordLayout,
                isGroupField: isGroupField,
                isElementaryField: isElementaryField,
                isConstant: isConstant,
                lineNumber: index + 1,
                definition: trimmed,
                // Add lifecycle tracking properties
                lifecycle: {
                    createdBy: [],
                    updatedBy: [],
                    readBy: [],
                    displayedBy: [],
                    validatedBy: []
                }
            });
        }
    });
    
    console.log(`Extracted ${fields.length} fields (all levels) from copybook ${copybookName}`);
    return fields;
}

// === FIND PROGRAMS USING COPYBOOK ===
findProgramsUsingCopybook(copybookName) {
    const usingPrograms = [];
    const copybookUpper = copybookName.toUpperCase().replace('.CPY', '');
    
    this.uploadedFiles.forEach(file => {
        if (file.type === 'COBOL Program' || file.content.toUpperCase().includes('PROGRAM-ID')) {
            const content = file.content.toUpperCase();
            
            // Check for COPY statements
            const copyPatterns = [
                `COPY ${copybookUpper}`,
                `COPY "${copybookUpper}"`,
                `COPY '${copybookUpper}'`,
                `COPY ${copybookUpper}.`,
                `INCLUDE ${copybookUpper}`
            ];
            
            const usesCopybook = copyPatterns.some(pattern => content.includes(pattern));
            
            if (usesCopybook) {
                console.log(`Program ${file.name} uses copybook ${copybookName}`);
                usingPrograms.push(file);
            }
        }
    });
    
    return usingPrograms;
}

// === ANALYZE FIELD USAGE IN PROGRAM ===
analyzeFieldUsageInProgram(fieldName, programFile) {
    const usage = {
        fieldName: fieldName,
        programName: '',
        isRead: false,
        isWritten: false,
        isDisplayed: false,
        isInput: false,
        isValidated: false,
        isCalculated: false,
        operations: []
    };

    const lines = programFile.content.split('\n');
    const upperContent = programFile.content.toUpperCase();
    const fieldUpper = fieldName.toUpperCase();
    
    // Get program name
    const programMatch = upperContent.match(/PROGRAM-ID\.?\s+([A-Z][A-Z0-9\-_]+)/);
    usage.programName = programMatch ? programMatch[1] : programFile.name.replace(/\.[^/.]+$/, "");

    lines.forEach((line, lineNum) => {
        const trimmed = line.trim().toUpperCase();
        
        // Skip if line doesn't contain our field
        if (!trimmed.includes(fieldUpper)) {
            return;
        }

        // MOVE operations (reading/writing)
        if (trimmed.includes('MOVE')) {
            const moveFromMatch = trimmed.match(new RegExp(`MOVE\\s+${fieldUpper}\\s+TO\\s+([A-Z][A-Z0-9\\-_]+)`));
            const moveToMatch = trimmed.match(new RegExp(`MOVE\\s+([A-Z][A-Z0-9\\-_]+)\\s+TO\\s+${fieldUpper}`));
            
            if (moveFromMatch) {
                usage.isRead = true;
                usage.operations.push({
                    type: 'read',
                    operation: 'MOVE FROM',
                    line: lineNum + 1,
                    context: trimmed,
                    target: moveFromMatch[1]
                });
            }
            
            if (moveToMatch) {
                usage.isWritten = true;
                usage.operations.push({
                    type: 'write',
                    operation: 'MOVE TO',
                    line: lineNum + 1,
                    context: trimmed,
                    source: moveToMatch[1]
                });
            }
        }

        // DISPLAY operations (output)
        if (trimmed.includes('DISPLAY') && trimmed.includes(fieldUpper)) {
            usage.isDisplayed = true;
            usage.operations.push({
                type: 'display',
                operation: 'DISPLAY',
                line: lineNum + 1,
                context: trimmed
            });
        }

        // ACCEPT operations (input)
        if (trimmed.includes('ACCEPT') && trimmed.includes(fieldUpper)) {
            usage.isInput = true;
            usage.operations.push({
                type: 'input',
                operation: 'ACCEPT',
                line: lineNum + 1,
                context: trimmed
            });
        }

        // IF/WHEN conditions (validation/comparison)
        if ((trimmed.includes('IF') || trimmed.includes('WHEN')) && trimmed.includes(fieldUpper)) {
            usage.isValidated = true;
            usage.operations.push({
                type: 'validation',
                operation: 'CONDITION',
                line: lineNum + 1,
                context: trimmed
            });
        }

        // COMPUTE/ADD/SUBTRACT/MULTIPLY/DIVIDE (calculation)
        const calcOperations = ['COMPUTE', 'ADD', 'SUBTRACT', 'MULTIPLY', 'DIVIDE'];
        for (const op of calcOperations) {
            if (trimmed.includes(op) && trimmed.includes(fieldUpper)) {
                usage.isCalculated = true;
                usage.operations.push({
                    type: 'calculation',
                    operation: op,
                    line: lineNum + 1,
                    context: trimmed
                });
                break;
            }
        }

        // CICS SEND/RECEIVE MAP operations
        if (trimmed.includes('EXEC CICS')) {
            if (trimmed.includes('SEND MAP') && trimmed.includes(fieldUpper)) {
                usage.isDisplayed = true;
                usage.operations.push({
                    type: 'cics_output',
                    operation: 'CICS SEND MAP',
                    line: lineNum + 1,
                    context: trimmed
                });
            }
            
            if (trimmed.includes('RECEIVE MAP') && trimmed.includes(fieldUpper)) {
                usage.isInput = true;
                usage.operations.push({
                    type: 'cics_input',
                    operation: 'CICS RECEIVE MAP',
                    line: lineNum + 1,
                    context: trimmed
                });
            }
        }

        // File operations
        if (trimmed.includes('WRITE') && trimmed.includes(fieldUpper)) {
            usage.isWritten = true;
            usage.operations.push({
                type: 'file_write',
                operation: 'WRITE',
                line: lineNum + 1,
                context: trimmed
            });
        }

        if (trimmed.includes('READ') && trimmed.includes(fieldUpper)) {
            usage.isRead = true;
            usage.operations.push({
                type: 'file_read',
                operation: 'READ',
                line: lineNum + 1,
                context: trimmed
            });
        }
    });

    return usage;
}

// === EXTRACT LIFECYCLE FLOW FOR COMPONENT ===
async extractFileLifecycleFlow(componentName, relevantFiles) {
    console.log('Extracting focused lifecycle flow for component:', componentName);
    
    const lifecycleFlow = {
        componentName: componentName,
        componentType: this.detectComponentType(componentName, relevantFiles),
        scope: 'COMPONENT_FOCUSED',
        creationSources: [],
        inputPrograms: [],
        updatePrograms: [],
        cicsScreens: [],
        batchJobs: [],
        purgeProcesses: [],
        usagePattern: 'UNKNOWN',
        // For copybooks - focus on 01-level fields
        primaryFields: [],
        // Dependencies - distinguish between found and missing
        foundDependencies: {
            copybooks: [],
            programs: [],
            files: []
        },
        missingDependencies: {
            copybooks: [],
            programs: [],
            files: []
        }
    };

    try {
        if (lifecycleFlow.componentType === 'Copybook') {
            // Focus on 01-level fields for copybooks
            const fields01 = this.extractCopybookFields(componentName, relevantFiles);
            lifecycleFlow.primaryFields = fields01;
            
            console.log(`Analyzing ${fields01.length} 01-level fields for lifecycle`);
            
            // Analyze each 01-level field's lifecycle
            for (const field of fields01) {
                console.log(`Analyzing lifecycle of 01-level field: ${field.name}`);
                await this.analyzeFieldLifecycleInPrograms(field, lifecycleFlow);
            }
        } else if (lifecycleFlow.componentType === 'COBOL Program') {
            // For programs, analyze the main program logic
            await this.analyzeProgramSpecificLifecycle(componentName, relevantFiles, lifecycleFlow);
        }

        // Determine usage pattern based on actual analysis
        lifecycleFlow.usagePattern = this.determineUsagePatternFromAnalysis(lifecycleFlow);
        
    } catch (error) {
        console.error('Error in extractFileLifecycleFlow:', error);
    }
    
    console.log('Component-focused lifecycle flow analysis complete:', lifecycleFlow);
    return lifecycleFlow;
}

async analyzeProgramSpecificLifecycle(componentName, relevantFiles, lifecycleFlow) {
    console.log(`Analyzing program-specific lifecycle for: ${componentName}`);
    
    const programFile = relevantFiles.find(f => 
        f.type === 'COBOL Program' && 
        (f.name.toUpperCase().includes(componentName.toUpperCase()) || 
         f.content.toUpperCase().includes(`PROGRAM-ID. ${componentName.toUpperCase()}`))
    );

    if (!programFile) {
        console.warn('Program file not found for:', componentName);
        return;
    }

    const lines = programFile.content.split('\n');
    const upperContent = programFile.content.toUpperCase();
    
    // Extract program structure
    const programStructure = this.extractProgramStructure(programFile.content);
    
    // Analyze file operations
    this.analyzeFileOperations(lines, lifecycleFlow);
    
    // Analyze CICS operations
    this.analyzeCICSOperations(lines, lifecycleFlow);
    
    // Analyze batch operations
    this.analyzeBatchOperations(lines, lifecycleFlow);
    
    // Analyze business logic patterns
    this.analyzeBusinessLogicPatterns(lines, lifecycleFlow);
    
    // Set program-specific properties
    lifecycleFlow.programStructure = programStructure;
    lifecycleFlow.mainProgram = componentName;
    
    console.log('Program-specific lifecycle analysis complete');
}

// === 2. EXTRACT PROGRAM STRUCTURE ===
extractProgramStructure(content) {
    const structure = {
        divisions: [],
        sections: [],
        paragraphs: [],
        procedures: [],
        workingStorage: [],
        linkageSection: []
    };
    
    const lines = content.split('\n');
    
    lines.forEach((line, index) => {
        const trimmed = line.trim().toUpperCase();
        
        // Divisions
        if (trimmed.includes('DIVISION')) {
            const divisionMatch = trimmed.match(/(\w+)\s+DIVISION/);
            if (divisionMatch) {
                structure.divisions.push({
                    name: divisionMatch[1],
                    lineNumber: index + 1
                });
            }
        }
        
        // Sections
        if (trimmed.includes('SECTION')) {
            const sectionMatch = trimmed.match(/(\w+)\s+SECTION/);
            if (sectionMatch) {
                structure.sections.push({
                    name: sectionMatch[1],
                    lineNumber: index + 1
                });
            }
        }
        
        // Paragraphs (labels followed by period)
        const paragraphMatch = trimmed.match(/^([A-Z][A-Z0-9\-_]*)\s*\./);
        if (paragraphMatch && !trimmed.includes('DIVISION') && !trimmed.includes('SECTION')) {
            structure.paragraphs.push({
                name: paragraphMatch[1],
                lineNumber: index + 1
            });
        }
        
        // Working Storage variables
        if (trimmed.match(/^\s*01\s+/) && upperContent.includes('WORKING-STORAGE')) {
            const wsMatch = trimmed.match(/01\s+([A-Z][A-Z0-9\-_]*)/);
            if (wsMatch) {
                structure.workingStorage.push({
                    name: wsMatch[1],
                    lineNumber: index + 1
                });
            }
        }
    });
    
    return structure;
}

analyzeFileOperations(lines, lifecycleFlow) {
    lines.forEach((line, lineNum) => {
        const trimmed = line.trim().toUpperCase();
        
        // File creation operations
        if (trimmed.includes('OPEN OUTPUT') || trimmed.includes('WRITE')) {
            const fileMatch = trimmed.match(/(?:OPEN OUTPUT|WRITE)\s+([A-Z][A-Z0-9\-_]*)/);
            if (fileMatch) {
                this.addToLifecycleArray(lifecycleFlow.creationSources, {
                    program: lifecycleFlow.componentName,
                    operation: 'FILE_CREATE',
                    file: fileMatch[1],
                    evidence: [{
                        type: 'file_create',
                        operation: trimmed.includes('OPEN OUTPUT') ? 'OPEN OUTPUT' : 'WRITE',
                        line: lineNum + 1,
                        context: trimmed
                    }]
                });
            }
        }
        
        // File read operations
        if (trimmed.includes('OPEN INPUT') || trimmed.includes('READ')) {
            const fileMatch = trimmed.match(/(?:OPEN INPUT|READ)\s+([A-Z][A-Z0-9\-_]*)/);
            if (fileMatch) {
                this.addToLifecycleArray(lifecycleFlow.inputPrograms, {
                    program: lifecycleFlow.componentName,
                    operation: 'FILE_READ',
                    file: fileMatch[1],
                    evidence: [{
                        type: 'file_read',
                        operation: trimmed.includes('OPEN INPUT') ? 'OPEN INPUT' : 'READ',
                        line: lineNum + 1,
                        context: trimmed
                    }]
                });
            }
        }
        
        // File update operations
        if (trimmed.includes('REWRITE') || trimmed.includes('OPEN I-O')) {
            const fileMatch = trimmed.match(/(?:REWRITE|OPEN I-O)\s+([A-Z][A-Z0-9\-_]*)/);
            if (fileMatch) {
                this.addToLifecycleArray(lifecycleFlow.updatePrograms, {
                    program: lifecycleFlow.componentName,
                    operation: 'FILE_UPDATE',
                    file: fileMatch[1],
                    evidence: [{
                        type: 'file_update',
                        operation: trimmed.includes('REWRITE') ? 'REWRITE' : 'OPEN I-O',
                        line: lineNum + 1,
                        context: trimmed
                    }]
                });
            }
        }
    });
}

// === 4. ANALYZE CICS OPERATIONS ===
analyzeCICSOperations(lines, lifecycleFlow) {
    lines.forEach((line, lineNum) => {
        const trimmed = line.trim().toUpperCase();
        
        if (trimmed.includes('EXEC CICS')) {
            // CICS screen operations
            if (trimmed.includes('SEND MAP') || trimmed.includes('RECEIVE MAP')) {
                const mapMatch = trimmed.match(/MAP\s*\(\s*['"]*([A-Z][A-Z0-9\-_]*)['"]*\s*\)/);
                const screenName = mapMatch ? mapMatch[1] : 'UNKNOWN_SCREEN';
                
                this.addToLifecycleArray(lifecycleFlow.cicsScreens, {
                    screen: screenName,
                    program: lifecycleFlow.componentName,
                    operation: trimmed.includes('SEND MAP') ? 'SCREEN_OUTPUT' : 'SCREEN_INPUT',
                    evidence: [{
                        type: trimmed.includes('SEND MAP') ? 'cics_output' : 'cics_input',
                        operation: trimmed.includes('SEND MAP') ? 'CICS SEND MAP' : 'CICS RECEIVE MAP',
                        line: lineNum + 1,
                        context: trimmed
                    }]
                });
            }
            
            // CICS file operations
            if (trimmed.includes('READ') || trimmed.includes('WRITE') || trimmed.includes('REWRITE')) {
                const fileMatch = trimmed.match(/FILE\s*\(\s*['"]*([A-Z][A-Z0-9\-_]*)['"]*\s*\)/);
                if (fileMatch) {
                    const operation = trimmed.includes('READ') ? 'CICS_READ' : 
                                    trimmed.includes('WRITE') ? 'CICS_WRITE' : 'CICS_UPDATE';
                    
                    const targetArray = operation === 'CICS_READ' ? lifecycleFlow.inputPrograms :
                                      operation === 'CICS_WRITE' ? lifecycleFlow.creationSources :
                                      lifecycleFlow.updatePrograms;
                    
                    this.addToLifecycleArray(targetArray, {
                        program: lifecycleFlow.componentName,
                        operation: operation,
                        file: fileMatch[1],
                        evidence: [{
                            type: 'cics_file',
                            operation: operation,
                            line: lineNum + 1,
                            context: trimmed
                        }]
                    });
                }
            }
        }
    });
}

// === 5. ANALYZE BATCH OPERATIONS ===
analyzeBatchOperations(lines, lifecycleFlow) {
    lines.forEach((line, lineNum) => {
        const trimmed = line.trim().toUpperCase();
        
        // JCL-style operations within COBOL comments or embedded JCL
        if (trimmed.includes('//') && (trimmed.includes('EXEC PGM=') || trimmed.includes('SORT') || trimmed.includes('COPY'))) {
            this.addToLifecycleArray(lifecycleFlow.batchJobs, {
                job: 'EMBEDDED_JCL',
                program: lifecycleFlow.componentName,
                operation: 'BATCH_PROCESSING',
                evidence: [{
                    type: 'batch_operation',
                    operation: 'JCL_EMBEDDED',
                    line: lineNum + 1,
                    context: trimmed
                }]
            });
        }
        
        // SORT operations
        if (trimmed.includes('SORT') && (trimmed.includes('INPUT') || trimmed.includes('OUTPUT'))) {
            this.addToLifecycleArray(lifecycleFlow.batchJobs, {
                job: 'SORT_OPERATION',
                program: lifecycleFlow.componentName,
                operation: 'SORT_PROCESSING',
                evidence: [{
                    type: 'sort_operation',
                    operation: 'SORT',
                    line: lineNum + 1,
                    context: trimmed
                }]
            });
        }
    });
}

// === 6. ANALYZE BUSINESS LOGIC PATTERNS ===
analyzeBusinessLogicPatterns(lines, lifecycleFlow) {
    const businessPatterns = {
        validations: [],
        calculations: [],
        decisions: [],
        loops: []
    };
    
    lines.forEach((line, lineNum) => {
        const trimmed = line.trim().toUpperCase();
        
        // Validation patterns
        if (trimmed.includes('IF') && (trimmed.includes('NOT') || trimmed.includes('EQUAL') || trimmed.includes('>'))) {
            businessPatterns.validations.push({
                type: 'VALIDATION',
                line: lineNum + 1,
                context: trimmed.substring(0, 80)
            });
        }
        
        // Calculation patterns
        if (trimmed.includes('COMPUTE') || trimmed.includes('ADD') || trimmed.includes('SUBTRACT') || 
            trimmed.includes('MULTIPLY') || trimmed.includes('DIVIDE')) {
            businessPatterns.calculations.push({
                type: 'CALCULATION',
                line: lineNum + 1,
                context: trimmed.substring(0, 80)
            });
        }
        
        // Decision patterns
        if (trimmed.includes('EVALUATE') || trimmed.includes('WHEN') || 
            (trimmed.includes('IF') && trimmed.includes('THEN'))) {
            businessPatterns.decisions.push({
                type: 'DECISION',
                line: lineNum + 1,
                context: trimmed.substring(0, 80)
            });
        }
        
        // Loop patterns
        if (trimmed.includes('PERFORM') && (trimmed.includes('UNTIL') || trimmed.includes('TIMES'))) {
            businessPatterns.loops.push({
                type: 'LOOP',
                line: lineNum + 1,
                context: trimmed.substring(0, 80)
            });
        }
    });
    
    lifecycleFlow.businessPatterns = businessPatterns;
}

// === 7. DISPLAY PROGRAM LLM RESULTS ===
displayProgramLLMResults(llmAnalysis) {
    let html = `
        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px; border-left: 4px solid #2196F3; margin-bottom: 20px;">
            <h4 style="color: #2196F3; margin-bottom: 15px;">🤖 COBOL Program Analysis Results</h4>
    `;

    // Program info
    if (llmAnalysis.componentName) {
        html += `
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; margin-bottom: 20px;">
                <div style="text-align: center; background: rgba(33, 150, 243, 0.1); padding: 8px; border-radius: 4px;">
                    <div style="font-size: 12px; font-weight: bold; color: #2196F3;">${llmAnalysis.componentName}</div>
                    <div style="font-size: 9px;">Program</div>
                </div>
                ${llmAnalysis.complexity ? `
                    <div style="text-align: center; background: rgba(255, 152, 0, 0.1); padding: 8px; border-radius: 4px;">
                        <div style="font-size: 12px; font-weight: bold; color: #FF9800;">${llmAnalysis.complexity}</div>
                        <div style="font-size: 9px;">Complexity</div>
                    </div>
                ` : ''}
                ${llmAnalysis.lifecycleRole?.primaryFunction ? `
                    <div style="text-align: center; background: rgba(76, 175, 80, 0.1); padding: 8px; border-radius: 4px;">
                        <div style="font-size: 12px; font-weight: bold; color: #4CAF50;">${llmAnalysis.lifecycleRole.primaryFunction}</div>
                        <div style="font-size: 9px;">Function</div>
                    </div>
                ` : ''}
            </div>
        `;
    }

    // Program structure
    if (llmAnalysis.programStructure) {
        html += `
            <div style="margin-bottom: 20px;">
                <h5 style="color: #2196F3; margin-bottom: 10px;">🏗️ Program Structure:</h5>
                <div style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
                        ${llmAnalysis.programStructure.divisions ? `
                            <div>
                                <strong style="color: #4CAF50;">Divisions:</strong>
                                <div style="font-size: 10px; margin-top: 4px;">
                                    ${Array.isArray(llmAnalysis.programStructure.divisions) ? 
                                        llmAnalysis.programStructure.divisions.join(', ') : 
                                        llmAnalysis.programStructure.divisions}
                                </div>
                            </div>
                        ` : ''}
                        ${llmAnalysis.programStructure.paragraphs && llmAnalysis.programStructure.paragraphs.length > 0 ? `
                            <div>
                                <strong style="color: #FF9800;">Paragraphs:</strong>
                                <div style="font-size: 10px; margin-top: 4px;">
                                    ${llmAnalysis.programStructure.paragraphs.length} found
                                </div>
                            </div>
                        ` : ''}
                        ${llmAnalysis.programStructure.sections && llmAnalysis.programStructure.sections.length > 0 ? `
                            <div>
                                <strong style="color: #9C27B0;">Sections:</strong>
                                <div style="font-size: 10px; margin-top: 4px;">
                                    ${llmAnalysis.programStructure.sections.length} found
                                </div>
                            </div>
                        ` : ''}
                    </div>
                </div>
            </div>
        `;
    }

    // Lifecycle role
    if (llmAnalysis.lifecycleRole) {
        html += `
            <div style="margin-bottom: 20px;">
                <h5 style="color: #8b5cf6; margin-bottom: 10px;">🌊 Lifecycle Role:</h5>
                <div style="background: rgba(139, 92, 246, 0.1); padding: 15px; border-radius: 8px;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px;">
                        ${llmAnalysis.lifecycleRole.primaryFunction ? `
                            <div style="text-align: center;">
                                <div style="font-weight: bold; color: #8b5cf6;">Function</div>
                                <div style="font-size: 11px;">${llmAnalysis.lifecycleRole.primaryFunction}</div>
                            </div>
                        ` : ''}
                        ${llmAnalysis.lifecycleRole.processingType ? `
                            <div style="text-align: center;">
                                <div style="font-weight: bold; color: #8b5cf6;">Type</div>
                                <div style="font-size: 11px;">${llmAnalysis.lifecycleRole.processingType}</div>
                            </div>
                        ` : ''}
                        ${llmAnalysis.lifecycleRole.dataFlowDirection ? `
                            <div style="text-align: center;">
                                <div style="font-weight: bold; color: #8b5cf6;">Data Flow</div>
                                <div style="font-size: 11px;">${llmAnalysis.lifecycleRole.dataFlowDirection}</div>
                            </div>
                        ` : ''}
                    </div>
                </div>
            </div>
        `;
    }

    // Business logic
    if (llmAnalysis.businessLogic) {
        html += `
            <div style="margin-bottom: 20px;">
                <h5 style="color: #FFC107; margin-bottom: 10px;">⚖️ Business Logic:</h5>
                <div style="background: rgba(255, 193, 7, 0.1); padding: 15px; border-radius: 8px;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
                        ${llmAnalysis.businessLogic.validationRules && llmAnalysis.businessLogic.validationRules.length > 0 ? `
                            <div>
                                <strong style="color: #FFC107;">Validations:</strong>
                                <div style="font-size: 11px; margin-top: 4px;">
                                    ${llmAnalysis.businessLogic.validationRules.length} rules found
                                </div>
                            </div>
                        ` : ''}
                        ${llmAnalysis.businessLogic.calculations && llmAnalysis.businessLogic.calculations.length > 0 ? `
                            <div>
                                <strong style="color: #FFC107;">Calculations:</strong>
                                <div style="font-size: 11px; margin-top: 4px;">
                                    ${llmAnalysis.businessLogic.calculations.length} operations
                                </div>
                            </div>
                        ` : ''}
                        ${llmAnalysis.businessLogic.decisionPoints && llmAnalysis.businessLogic.decisionPoints.length > 0 ? `
                            <div>
                                <strong style="color: #FFC107;">Decisions:</strong>
                                <div style="font-size: 11px; margin-top: 4px;">
                                    ${llmAnalysis.businessLogic.decisionPoints.length} points
                                </div>
                            </div>
                        ` : ''}
                    </div>
                </div>
            </div>
        `;
    }

    // Dependencies
    if (llmAnalysis.dependencies) {
        html += this.displayProgramDependencies(llmAnalysis.dependencies);
    }

    // Recommendations
    if (llmAnalysis.recommendations && llmAnalysis.recommendations.length > 0) {
        html += `
            <div style="margin-top: 20px;">
                <h5 style="color: #FFC107; margin-bottom: 10px;">💡 Recommendations:</h5>
                <div style="background: rgba(255, 193, 7, 0.1); padding: 15px; border-radius: 8px;">
                    ${llmAnalysis.recommendations.map((rec, index) => `
                        <div style="margin-bottom: 8px; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 4px;">
                            <strong style="color: #FFC107;">💡 ${index + 1}.</strong> ${rec}
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    }

    html += '</div>';
    return html;
}

// === 8. DISPLAY PROGRAM DEPENDENCIES ===
displayProgramDependencies(dependencies) {
    return `
        <div style="margin-bottom: 20px;">
            <h5 style="color: #3b82f6; margin-bottom: 10px;">🔗 Program Dependencies:</h5>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                <div style="background: rgba(34, 197, 94, 0.1); padding: 10px; border-radius: 6px;">
                    <div style="font-weight: bold; color: #22c55e; font-size: 12px; margin-bottom: 5px;">✅ Available</div>
                    <div style="font-size: 10px;">
                        <div><strong>Copybooks:</strong> ${(dependencies.copybooks || []).slice(0, 3).join(', ') || 'None'}</div>
                        <div><strong>Programs:</strong> ${(dependencies.calledPrograms || []).slice(0, 3).join(', ') || 'None'}</div>
                    </div>
                </div>
                <div style="background: rgba(239, 68, 68, 0.1); padding: 10px; border-radius: 6px;">
                    <div style="font-weight: bold; color: #ef4444; font-size: 12px; margin-bottom: 5px;">❌ Missing</div>
                    <div style="font-size: 10px;">
                        <div><strong>Copybooks:</strong> ${(dependencies.missingCopybooks || []).slice(0, 3).join(', ') || 'None'}</div>
                        <div><strong>Programs:</strong> ${(dependencies.missingPrograms || []).slice(0, 3).join(', ') || 'None'}</div>
                    </div>
                </div>
            </div>
        </div>
    `;
}

// === 9. DISPLAY GENERIC LLM RESULTS ===
displayGenericLLMResults(llmAnalysis) {
    let html = `
        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px; border-left: 4px solid #9C27B0; margin-bottom: 20px;">
            <h4 style="color: #9C27B0; margin-bottom: 15px;">🤖 Component Analysis Results</h4>
    `;

    // Component info
    if (llmAnalysis.componentName) {
        html += `
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; margin-bottom: 20px;">
                <div style="text-align: center; background: rgba(156, 39, 176, 0.1); padding: 8px; border-radius: 4px;">
                    <div style="font-size: 12px; font-weight: bold; color: #9C27B0;">${llmAnalysis.componentName}</div>
                    <div style="font-size: 9px;">Component</div>
                </div>
                ${llmAnalysis.componentType ? `
                    <div style="text-align: center; background: rgba(103, 58, 183, 0.1); padding: 8px; border-radius: 4px;">
                        <div style="font-size: 12px; font-weight: bold; color: #673AB7;">${llmAnalysis.componentType}</div>
                        <div style="font-size: 9px;">Type</div>
                    </div>
                ` : ''}
            </div>
        `;
    }

    // Purpose
    if (llmAnalysis.purpose) {
        html += `
            <div style="margin-bottom: 20px;">
                <h5 style="color: #9C27B0; margin-bottom: 10px;">🎯 Purpose:</h5>
                <div style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px;">
                    <p style="font-size: 13px; line-height: 1.5;">${llmAnalysis.purpose}</p>
                </div>
            </div>
        `;
    }

    // Key elements
    if (llmAnalysis.keyElements && llmAnalysis.keyElements.length > 0) {
        html += `
            <div style="margin-bottom: 20px;">
                <h5 style="color: #673AB7; margin-bottom: 10px;">🔑 Key Elements:</h5>
                <div style="background: rgba(103, 58, 183, 0.1); padding: 15px; border-radius: 8px;">
                    <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                        ${llmAnalysis.keyElements.map(element => `
                            <span style="background: rgba(0,0,0,0.3); padding: 4px 8px; border-radius: 4px; font-size: 11px; border: 1px solid rgba(103, 58, 183, 0.3);">
                                ${element}
                            </span>
                        `).join('')}
                    </div>
                </div>
            </div>
        `;
    }

    // Patterns
    if (llmAnalysis.patterns && llmAnalysis.patterns.length > 0) {
        html += `
            <div style="margin-bottom: 20px;">
                <h5 style="color: #E91E63; margin-bottom: 10px;">📊 Identified Patterns:</h5>
                <div style="background: rgba(233, 30, 99, 0.1); padding: 15px; border-radius: 8px;">
                    ${llmAnalysis.patterns.map((pattern, index) => `
                        <div style="margin-bottom: 8px; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 4px;">
                            <strong style="color: #E91E63;">📋 ${index + 1}.</strong> ${pattern}
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    }

    // Recommendations
    if (llmAnalysis.recommendations && llmAnalysis.recommendations.length > 0) {
        html += `
            <div style="margin-top: 20px;">
                <h5 style="color: #FFC107; margin-bottom: 10px;">💡 Recommendations:</h5>
                <div style="background: rgba(255, 193, 7, 0.1); padding: 15px; border-radius: 8px;">
                    ${llmAnalysis.recommendations.map((rec, index) => `
                        <div style="margin-bottom: 8px; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 4px;">
                            <strong style="color: #FFC107;">💡 ${index + 1}.</strong> ${rec}
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    }

    html += '</div>';
    return html;
}

// === 10. FIX DUPLICATE onComponentInput METHOD ===
// Remove the duplicate definition and keep only this enhanced version:
onComponentInput() {
    const input = document.getElementById('componentName');
    const suggestions = document.getElementById('componentSuggestions');
    
    if (!input || !suggestions) {
        this.validateForm();
        return;
    }
    
    const value = input.value.trim().toUpperCase();
    
    if (value.length < 2) {
        suggestions.style.display = 'none';
        this.validateForm();
        return;
    }
    
    // Enhanced filtering with better matching
    const filtered = this.componentSuggestions.filter(item => {
        const nameMatch = item.name.includes(value);
        const typeMatch = item.type.includes(value);
        const fileMatch = item.file.toUpperCase().includes(value);
        return nameMatch || typeMatch || fileMatch;
    }).slice(0, 8);
    
    if (filtered.length > 0) {
        let html = '';
        filtered.forEach(item => {
            const priority = item.type === 'RECORD_LAYOUT' ? '🎯' : 
                           item.type === 'PROGRAM' ? '💼' : '📁';
            
            html += `
                <div class="suggestion-item" onclick="analyzer.selectSuggestion('${item.name}')">
                    <strong>${priority} ${item.name}</strong> 
                    <span style="opacity: 0.7;">(${item.type} in ${item.file})</span>
                    ${item.level ? `<span style="margin-left: 8px; background: #FFD700; color: #000; padding: 1px 4px; border-radius: 2px; font-size: 9px;">L${item.level}</span>` : ''}
                </div>
            `;
        });
        suggestions.innerHTML = html;
        suggestions.style.display = 'block';
    } else {
        suggestions.style.display = 'none';
    }
    
    this.validateForm();
}

// === 11. ENHANCED ERROR HANDLING FOR LLM RESPONSES ===
validateLLMResponse(response) {
    const validation = {
        isValid: false,
        errors: [],
        warnings: [],
        data: null
    };
    
    try {
        // Check if response exists
        if (!response) {
            validation.errors.push('No response received from LLM');
            return validation;
        }
        
        // Check for error flag
        if (response.error) {
            validation.errors.push(`LLM reported error: ${response.message || 'Unknown error'}`);
            if (response.fallbackData) {
                validation.data = response.fallbackData;
                validation.warnings.push('Using fallback data due to LLM error');
            }
            return validation;
        }
        
        // Validate required fields
        const requiredFields = ['componentName', 'componentType'];
        for (const field of requiredFields) {
            if (!response[field]) {
                validation.warnings.push(`Missing required field: ${field}`);
            }
        }
        
        // Validate data types
        if (response.totalFields && typeof response.totalFields !== 'number') {
            validation.warnings.push('totalFields should be a number');
        }
        
        if (response.recommendations && !Array.isArray(response.recommendations)) {
            validation.warnings.push('recommendations should be an array');
        }
        
        if (response.primaryFields && !Array.isArray(response.primaryFields)) {
            validation.warnings.push('primaryFields should be an array');
        }
        
        // Check for empty critical arrays
        if (response.primaryFields && response.primaryFields.length === 0) {
            validation.warnings.push('No primary fields found - analysis may be incomplete');
        }
        
        // Validate quality score
        if (response.qualityScore && (response.qualityScore < 1 || response.qualityScore > 10)) {
            validation.warnings.push('Quality score should be between 1-10');
        }
        
        validation.isValid = validation.errors.length === 0;
        validation.data = response;
        
        console.log('LLM Response validation:', validation);
        return validation;
        
    } catch (error) {
        validation.errors.push(`Response validation failed: ${error.message}`);
        console.error('LLM response validation error:', error);
        return validation;
    }
}

// === 12. ENHANCED FILE UPLOAD ERROR RECOVERY ===
async retryFileUpload(file, maxRetries = 3) {
    let lastError = null;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            console.log(`File upload attempt ${attempt}/${maxRetries} for: ${file.name}`);
            
            // Show retry status to user
            if (attempt > 1) {
                this.showWarning(`Retrying upload for ${file.name} (attempt ${attempt}/${maxRetries})`);
                await this.sleep(1000 * attempt); // Progressive delay
            }
            
            const content = await this.readFileWithTimeout(file, 30000); // 30 second timeout
            const fileType = this.detectFileType(file.name, content);
            
            // Validate file content
            if (!content || content.trim().length === 0) {
                throw new Error('File appears to be empty');
            }
            
            // Check for binary content (basic check)
            if (this.isBinaryContent(content)) {
                throw new Error('File appears to contain binary data');
            }
            
            const fileObj = {
                name: file.name,
                content: content,
                size: file.size,
                type: fileType,
                uploadDate: new Date().toISOString(),
                id: Date.now() + Math.random(),
                components: this.extractComponentsFromFile(content, fileType),
                uploadAttempts: attempt
            };
            
            console.log(`File upload successful on attempt ${attempt}: ${file.name}`);
            return fileObj;
            
        } catch (error) {
            lastError = error;
            console.warn(`File upload attempt ${attempt} failed for ${file.name}:`, error.message);
            
            if (attempt === maxRetries) {
                break;
            }
        }
    }
    
    // All retries failed
    const errorMsg = `Failed to upload ${file.name} after ${maxRetries} attempts: ${lastError.message}`;
    console.error(errorMsg);
    throw new Error(errorMsg);
}

// === 13. READ FILE WITH TIMEOUT ===
readFileWithTimeout(file, timeout = 30000) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        let timeoutId;
        
        // Set up timeout
        timeoutId = setTimeout(() => {
            reader.abort();
            reject(new Error(`File read timeout after ${timeout}ms`));
        }, timeout);
        
        reader.onload = (e) => {
            clearTimeout(timeoutId);
            resolve(e.target.result);
        };
        
        reader.onerror = (e) => {
            clearTimeout(timeoutId);
            reject(new Error(`File read error: ${reader.error?.message || 'Unknown error'}`));
        };
        
        reader.onabort = (e) => {
            clearTimeout(timeoutId);
            reject(new Error('File read was aborted'));
        };
        
        try {
            reader.readAsText(file);
        } catch (error) {
            clearTimeout(timeoutId);
            reject(new Error(`Failed to start file read: ${error.message}`));
        }
    });
}

// === 14. CHECK FOR BINARY CONTENT ===
isBinaryContent(content) {
    if (!content || typeof content !== 'string') {
        return true;
    }
    
    // Check for null bytes (common in binary files)
    if (content.includes('\0')) {
        return true;
    }
    
    // Check ratio of printable characters
    const printableChars = content.match(/[\x20-\x7E\s]/g) || [];
    const printableRatio = printableChars.length / content.length;
    
    // If less than 80% printable characters, likely binary
    return printableRatio < 0.8;
}

// === 15. ENHANCED PROGRESS TRACKING ===
updateDetailedProgress(operation, current, total, status, details = null) {
    const progressFill = document.getElementById('progressFill');
    const loadingStatus = document.getElementById('loadingStatus');
    
    if (progressFill) {
        const percentage = total > 0 ? Math.round((current / total) * 100) : 0;
        progressFill.style.width = `${percentage}%`;
    }
    
    if (loadingStatus) {
        let statusText = `${operation} (${current}/${total})`;
        if (status) {
            statusText += ` - ${status}`;
        }
        if (details) {
            statusText += ` | ${details}`;
        }
        loadingStatus.textContent = statusText;
    }
    
    // Update any operation-specific progress displays
    this.updateOperationProgress(operation, current, total, status, details);
}

// === 16. UPDATE OPERATION PROGRESS ===
updateOperationProgress(operation, current, total, status, details) {
    // Create or update operation-specific progress display
    let progressContainer = document.getElementById('operationProgress');
    
    if (!progressContainer) {
        const loadingIndicator = document.getElementById('loadingIndicator');
        if (loadingIndicator) {
            progressContainer = document.createElement('div');
            progressContainer.id = 'operationProgress';
            progressContainer.style.cssText = `
                margin-top: 20px;
                background: rgba(0,0,0,0.3);
                padding: 15px;
                border-radius: 8px;
                border-left: 4px solid #4CAF50;
            `;
            loadingIndicator.appendChild(progressContainer);
        }
    }
    
    if (progressContainer) {
        progressContainer.innerHTML = `
            <div style="color: #4CAF50; font-weight: bold; margin-bottom: 8px;">
                ${operation}
            </div>
            <div style="font-size: 12px; margin-bottom: 5px;">
                Progress: ${current}/${total} (${Math.round((current/total)*100)}%)
            </div>
            ${status ? `<div style="font-size: 11px; opacity: 0.8;">Status: ${status}</div>` : ''}
            ${details ? `<div style="font-size: 10px; opacity: 0.7; margin-top: 4px;">${details}</div>` : ''}
        `;
    }
}

// === 17. VALIDATE EXPORT DATA ===
validateExportData(data, format) {
    const validation = {
        isValid: false,
        errors: [],
        warnings: [],
        stats: {
            totalSize: 0,
            componentCount: 0,
            chatMessageCount: 0
        }
    };
    
    try {
        if (!data) {
            validation.errors.push('No data provided for export');
            return validation;
        }
        
        // Calculate data size
        const dataString = JSON.stringify(data);
        validation.stats.totalSize = dataString.length;
        
        // Check for very large exports (>10MB)
        if (validation.stats.totalSize > 10 * 1024 * 1024) {
            validation.warnings.push('Export data is very large (>10MB) - consider filtering');
        }
        
        // Validate structure based on format
        if (format === 'json') {
            validation = this.validateJSONExport(data, validation);
        } else if (format === 'markdown') {
            validation = this.validateMarkdownExport(data, validation);
        }
        
        // Count components and messages
        if (data.analysisResults) {
            validation.stats.componentCount = Object.keys(data.analysisResults).length;
        }
        
        if (data.chatHistory && Array.isArray(data.chatHistory)) {
            validation.stats.chatMessageCount = data.chatHistory.length;
        }
        
        validation.isValid = validation.errors.length === 0;
        
        console.log('Export data validation:', validation);
        return validation;
        
    } catch (error) {
        validation.errors.push(`Export validation failed: ${error.message}`);
        return validation;
    }
}

// === 18. VALIDATE JSON EXPORT ===
validateJSONExport(data, validation) {
    // Check required metadata
    if (!data.metadata) {
        validation.errors.push('Missing metadata in export data');
    } else {
        if (!data.metadata.timestamp) {
            validation.warnings.push('Missing timestamp in metadata');
        }
        if (!data.metadata.analysisMethod) {
            validation.warnings.push('Missing analysis method in metadata');
        }
    }
    
    // Check analysis results structure
    if (!data.analysisResults) {
        validation.warnings.push('No analysis results in export data');
    } else {
        for (const [componentName, results] of Object.entries(data.analysisResults)) {
            if (!results.componentType) {
                validation.warnings.push(`Component ${componentName} missing type information`);
            }
            if (!results.qualityScore) {
                validation.warnings.push(`Component ${componentName} missing quality score`);
            }
        }
    }
    
    return validation;
}

// === 19. VALIDATE MARKDOWN EXPORT ===
validateMarkdownExport(data, validation) {
    // For markdown exports, mainly check that we have renderable content
    if (!data.analysisResults || Object.keys(data.analysisResults).length === 0) {
        validation.errors.push('No analysis results available for markdown export');
    }
    
    // Check for components without recommendations (empty markdown sections)
    let emptyComponents = 0;
    for (const [componentName, results] of Object.entries(data.analysisResults || {})) {
        if (!results.llmAnalysis?.recommendations || results.llmAnalysis.recommendations.length === 0) {
            emptyComponents++;
        }
    }
    
    if (emptyComponents > 0) {
        validation.warnings.push(`${emptyComponents} components have no recommendations for markdown export`);
    }
    
    return validation;
}


// === ANALYZE FIELD LIFECYCLE IN PROGRAMS ===
async analyzeFieldLifecycleInPrograms(field, lifecycleFlow) {
    const fieldName = field.name;
    const programsUsingCopybook = this.findProgramsUsingCopybook(lifecycleFlow.componentName);
    
    console.log(`Found ${programsUsingCopybook.length} programs using copybook for field ${fieldName}`);
    
    for (const program of programsUsingCopybook) {
        const fieldUsage = this.analyzeFieldUsageInProgram(fieldName, program);
        
        // Track field lifecycle
        if (fieldUsage.isInput) {
            field.lifecycle.createdBy.push(program.name);
            this.addToLifecycleArray(lifecycleFlow.creationSources, {
                program: fieldUsage.programName,
                operation: 'FIELD_INPUT',
                field: fieldName,
                evidence: fieldUsage.operations.filter(op => op.type === 'input').slice(0, 3)
            });
        }
        
        if (fieldUsage.isWritten) {
            field.lifecycle.updatedBy.push(program.name);
            this.addToLifecycleArray(lifecycleFlow.updatePrograms, {
                program: fieldUsage.programName,
                operation: 'FIELD_UPDATE',
                field: fieldName,
                evidence: fieldUsage.operations.filter(op => op.type === 'write').slice(0, 3)
            });
        }
        
        if (fieldUsage.isRead) {
            field.lifecycle.readBy.push(program.name);
            this.addToLifecycleArray(lifecycleFlow.inputPrograms, {
                program: fieldUsage.programName,
                operation: 'FIELD_READ',
                field: fieldName,
                evidence: fieldUsage.operations.filter(op => op.type === 'read').slice(0, 3)
            });
        }
        
        if (fieldUsage.isDisplayed) {
            field.lifecycle.displayedBy.push(program.name);
            this.addToLifecycleArray(lifecycleFlow.cicsScreens, {
                screen: 'DISPLAY_SCREEN',
                program: fieldUsage.programName,
                operation: 'FIELD_DISPLAY',
                field: fieldName,
                evidence: fieldUsage.operations.filter(op => op.type === 'display' || op.type === 'cics_output').slice(0, 3)
            });
        }

        if (fieldUsage.isValidated) {
            field.lifecycle.validatedBy.push(program.name);
        }
    }
}

// === HELPER FUNCTION TO AVOID DUPLICATES ===
addToLifecycleArray(array, newItem) {
    const exists = array.find(item => 
        item.program === newItem.program && 
        item.operation === newItem.operation &&
        item.field === newItem.field
    );
    
    if (!exists) {
        array.push(newItem);
    }
}

// === DETERMINE USAGE PATTERN FROM ANALYSIS ===
determineUsagePatternFromAnalysis(lifecycleFlow) {
    const hasCreation = lifecycleFlow.creationSources.length > 0;
    const hasReading = lifecycleFlow.inputPrograms.length > 0;
    const hasUpdating = lifecycleFlow.updatePrograms.length > 0;
    const hasCics = lifecycleFlow.cicsScreens.length > 0;
    const hasBatch = lifecycleFlow.batchJobs.length > 0;

    // Count fields by their usage patterns for copybooks
    if (lifecycleFlow.componentType === 'Copybook' && lifecycleFlow.primaryFields) {
        let readOnlyFields = 0;
        let writeOnlyFields = 0;
        let readWriteFields = 0;

        lifecycleFlow.primaryFields.forEach(field => {
            const isRead = field.lifecycle.readBy.length > 0;
            const isWritten = field.lifecycle.updatedBy.length > 0;
            
            if (isRead && isWritten) {
                readWriteFields++;
            } else if (isRead) {
                readOnlyFields++;
            } else if (isWritten) {
                writeOnlyFields++;
            }
        });

        console.log(`Field usage summary: ${readOnlyFields} read-only, ${writeOnlyFields} write-only, ${readWriteFields} read-write fields`);

        if (hasCics && hasCreation && hasUpdating) {
            return 'ONLINE_TRANSACTIONAL';
        } else if (hasBatch && hasUpdating) {
            return 'BATCH_PROCESSING';
        } else if (readOnlyFields > readWriteFields && !hasUpdating) {
            return 'READ_ONLY';
        } else if (hasCreation && !hasUpdating) {
            return 'CREATION_ONLY';
        } else if (hasUpdating && !hasCreation) {
            return 'UPDATE_ONLY';
        } else if (hasCreation && hasUpdating) {
            return 'FULL_LIFECYCLE';
        } else {
            return 'REFERENCE_ONLY';
        }
    }

    // For programs
    if (hasCreation && hasUpdating && hasCics) {
        return 'ONLINE_TRANSACTIONAL';
    } else if (hasCreation && hasUpdating && hasBatch) {
        return 'BATCH_PROCESSING';
    } else if (hasReading && !hasUpdating && !hasCreation) {
        return 'READ_ONLY';
    } else if (hasCreation && !hasUpdating) {
        return 'CREATION_ONLY';
    } else if (hasUpdating && !hasCreation) {
        return 'UPDATE_ONLY';
    } else if (hasCreation && hasUpdating) {
        return 'FULL_LIFECYCLE';
    } else {
        return 'REFERENCE_ONLY';
    }
}
// ===================================================================
// PART 4: DEPENDENCY ANALYSIS WITH FOUND/MISSING ITEMS
// Track which dependencies are available vs missing
// ===================================================================

// === EXTRACT DEPENDENCIES WITH FOUND/MISSING TRACKING ===
async extractBasicDependencies() {
    console.log('Extracting dependencies with missing item tracking...');
    
    const dependencies = {
        found: {
            copyStatements: new Set(),
            callStatements: new Set(),
            execStatements: new Set(),
            programIds: new Set(),
            fileReferences: new Set()
        },
        missing: {
            copyStatements: new Set(),
            callStatements: new Set(),
            execStatements: new Set(),
            programIds: new Set(),
            fileReferences: new Set()
        },
        uploadedFiles: this.uploadedFiles.map(f => ({
            name: f.name.toUpperCase(),
            originalName: f.name,
            components: f.components || []
        }))
    };

    // Extract all dependencies first
    const allDependencies = {
        copyStatements: new Set(),
        callStatements: new Set(),
        execStatements: new Set(),
        programIds: new Set(),
        fileReferences: new Set()
    };

    for (const file of this.uploadedFiles) {
        const fileDeps = this.extractDependenciesFromFile(file);
        
        Object.keys(fileDeps).forEach(depType => {
            if (allDependencies[depType]) {
                fileDeps[depType].forEach(dep => allDependencies[depType].add(dep));
            }
        });
    }

    // Categorize as found or missing
    this.categorizeDependencies(allDependencies.copyStatements, dependencies, 'copyStatements');
    this.categorizeDependencies(allDependencies.callStatements, dependencies, 'callStatements');
    this.categorizeDependencies(allDependencies.execStatements, dependencies, 'execStatements');
    this.categorizeDependencies(allDependencies.programIds, dependencies, 'programIds');
    this.categorizeDependencies(allDependencies.fileReferences, dependencies, 'fileReferences');

    // Convert sets to arrays and create summary
    const result = {
        found: {},
        missing: {},
        summary: { foundCount: 0, missingCount: 0 }
    };

    Object.keys(dependencies.found).forEach(key => {
        result.found[key] = Array.from(dependencies.found[key]).slice(0, 20);
        result.summary.foundCount += result.found[key].length;
    });

    Object.keys(dependencies.missing).forEach(key => {
        result.missing[key] = Array.from(dependencies.missing[key]).slice(0, 20);
        result.summary.missingCount += result.missing[key].length;
    });

    console.log('Dependency analysis complete:', {
        found: result.summary.foundCount,
        missing: result.summary.missingCount
    });

    return result;
}

// === CATEGORIZE DEPENDENCIES AS FOUND OR MISSING ===
categorizeDependencies(dependencySet, dependencies, type) {
    dependencySet.forEach(dependency => {
        const isFound = this.isDependencyFound(dependency, type, dependencies.uploadedFiles);
        
        if (isFound) {
            dependencies.found[type].add(dependency);
        } else {
            dependencies.missing[type].add(dependency);
        }
    });
}

// === CHECK IF DEPENDENCY IS FOUND ===
isDependencyFound(dependency, type, uploadedFiles) {
    const depUpper = dependency.toUpperCase();
    
    // Check exact name matches
    const exactMatch = uploadedFiles.some(file => {
        // Check filename
        if (file.name.includes(depUpper) || depUpper.includes(file.name.replace(/\.[^/.]+$/, "").toUpperCase())) {
            return true;
        }
        
        // Check components within files
        if (file.components) {
            return file.components.some(comp => comp.name.toUpperCase() === depUpper);
        }
        
        return false;
    });

    if (exactMatch) return true;

    // For copybooks, check without .CPY extension
    if (type === 'copyStatements') {
        const baseName = depUpper.replace('.CPY', '').replace('.COPYBOOK', '');
        return uploadedFiles.some(file => {
            const fileBaseName = file.name.replace(/\.[^/.]+$/, "").toUpperCase();
            return fileBaseName === baseName || baseName.includes(fileBaseName);
        });
    }

    // For programs, check PROGRAM-ID matches
    if (type === 'callStatements' || type === 'programIds') {
        return uploadedFiles.some(file => {
            if (file.components) {
                return file.components.some(comp => 
                    comp.type === 'PROGRAM' && comp.name.toUpperCase() === depUpper
                );
            }
            return false;
        });
    }

    return false;
}

// === EXTRACT DEPENDENCIES FROM FILE ===
extractDependenciesFromFile(file) {
    const dependencies = {
        copyStatements: [],
        callStatements: [],
        execStatements: [],
        jclDatasets: [],
        programIds: [],
        sqlTables: [],
        fileReferences: []
    };

    const lines = file.content.split('\n');
    
    lines.forEach((line, lineNum) => {
        const trimmed = line.trim().toUpperCase();
        
        // COPY statements
        let copyMatch = trimmed.match(/COPY\s+(['"]*[A-Z][A-Z0-9\-_]{1,}['"]*)/);
        if (copyMatch) {
            const copyName = copyMatch[1].replace(/['"]/g, '');
            dependencies.copyStatements.push(copyName);
        }

        // CALL statements
        let callMatch = trimmed.match(/CALL\s+['"]*([A-Z][A-Z0-9\-_]{1,})['"]*/) ||
                       trimmed.match(/LINK\s+['"]*([A-Z][A-Z0-9\-_]{1,})['"]*/) ||
                       trimmed.match(/XCTL\s+['"]*([A-Z][A-Z0-9\-_]{1,})['"]*/);
        if (callMatch) {
            dependencies.callStatements.push(callMatch[1]);
        }

        // JCL EXEC statements
        let execMatch = trimmed.match(/EXEC\s+PGM=([A-Z][A-Z0-9\-_]{1,})/) ||
                       trimmed.match(/\/\/\w+\s+EXEC\s+([A-Z][A-Z0-9\-_]{1,})/);
        if (execMatch) {
            dependencies.execStatements.push(execMatch[1]);
        }

        // PROGRAM-ID
        let programMatch = trimmed.match(/PROGRAM-ID\.?\s+([A-Z][A-Z0-9\-_]{1,})/);
        if (programMatch) {
            dependencies.programIds.push(programMatch[1]);
        }

        // File references
        let fileMatch = trimmed.match(/FD\s+([A-Z][A-Z0-9\-_]{1,})/) ||
                       trimmed.match(/SELECT\s+([A-Z][A-Z0-9\-_]{1,})\s+ASSIGN/) ||
                       trimmed.match(/OPEN\s+(?:INPUT|OUTPUT|I-O)\s+([A-Z][A-Z0-9\-_]{1,})/);
        if (fileMatch) {
            dependencies.fileReferences.push(fileMatch[1]);
        }
    });

    return dependencies;
}

// === DISPLAY DEPENDENCY ANALYSIS ===
displayDependencyAnalysis(dependencyAnalysis) {
    const found = dependencyAnalysis.found || {};
    const missing = dependencyAnalysis.missing || {};
    const summary = dependencyAnalysis.summary || { foundCount: 0, missingCount: 0 };

    return `
        <div style="background: rgba(59, 130, 246, 0.1); padding: 20px; border-radius: 10px; border-left: 4px solid #3b82f6; margin-bottom: 20px;">
            <h4 style="color: #3b82f6; margin-bottom: 15px;">🔗 Dependency Analysis</h4>
            
            <!-- Summary -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                <div style="text-align: center; background: rgba(34, 197, 94, 0.1); padding: 12px; border-radius: 6px;">
                    <div style="font-size: 1.5rem; font-weight: bold; color: #22c55e;">${summary.foundCount}</div>
                    <div style="font-size: 11px;">✅ Dependencies Found</div>
                </div>
                <div style="text-align: center; background: rgba(239, 68, 68, 0.1); padding: 12px; border-radius: 6px;">
                    <div style="font-size: 1.5rem; font-weight: bold; color: #ef4444;">${summary.missingCount}</div>
                    <div style="font-size: 11px;">❌ Dependencies Missing</div>
                </div>
            </div>

            <!-- Found Dependencies -->
            ${Object.keys(found).length > 0 ? `
                <div style="margin-bottom: 15px;">
                    <h5 style="color: #22c55e; margin-bottom: 10px;">✅ Found Dependencies:</h5>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
                        ${Object.entries(found).map(([type, items]) => {
                            if (!items || items.length === 0) return '';
                            return `
                                <div style="background: rgba(34, 197, 94, 0.1); padding: 10px; border-radius: 6px;">
                                    <div style="font-weight: bold; color: #22c55e; font-size: 12px; margin-bottom: 5px;">
                                        ${this.formatDependencyType(type)} (${items.length})
                                    </div>
                                    <div style="max-height: 80px; overflow-y: auto;">
                                        ${items.slice(0, 5).map(item => `
                                            <div style="font-size: 10px; font-family: monospace; padding: 2px; background: rgba(0,0,0,0.2); border-radius: 2px; margin: 1px 0;">
                                                ${item}
                                            </div>
                                        `).join('')}
                                        ${items.length > 5 ? `<div style="font-size: 9px; opacity: 0.7;">...and ${items.length - 5} more</div>` : ''}
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
            ` : ''}

            <!-- Missing Dependencies -->
            ${Object.keys(missing).length > 0 && Object.values(missing).some(arr => arr && arr.length > 0) ? `
                <div>
                    <h5 style="color: #ef4444; margin-bottom: 10px;">❌ Missing Dependencies:</h5>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
                        ${Object.entries(missing).map(([type, items]) => {
                            if (!items || items.length === 0) return '';
                            return `
                                <div style="background: rgba(239, 68, 68, 0.1); padding: 10px; border-radius: 6px;">
                                    <div style="font-weight: bold; color: #ef4444; font-size: 12px; margin-bottom: 5px;">
                                        ${this.formatDependencyType(type)} (${items.length})
                                    </div>
                                    <div style="max-height: 80px; overflow-y: auto;">
                                        ${items.slice(0, 5).map(item => `
                                            <div style="font-size: 10px; font-family: monospace; padding: 2px; background: rgba(0,0,0,0.2); border-radius: 2px; margin: 1px 0;">
                                                ${item}
                                            </div>
                                        `).join('')}
                                        ${items.length > 5 ? `<div style="font-size: 9px; opacity: 0.7;">...and ${items.length - 5} more</div>` : ''}
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
            ` : ''}
        </div>
    `;
}

// === FORMAT DEPENDENCY TYPE FOR DISPLAY ===
formatDependencyType(type) {
    const typeMap = {
        'copyStatements': '📚 Copybooks',
        'callStatements': '📞 Programs',
        'execStatements': '⚡ JCL Exec',
        'programIds': '💼 Program IDs',
        'fileReferences': '📁 Files'
    };
    return typeMap[type] || type;
}
// ===================================================================
// PART 5: LLM INTEGRATION AND JSON RESPONSE HANDLING
// Improved LLM calls with better JSON parsing and fallback handling
// ===================================================================

// === MAIN ANALYSIS METHOD ===
async runLLMEnhancedAnalysisWithLifecycle(componentName) {
    console.log(`Starting focused LLM analysis for: ${componentName}`);
    
    try {
        // Stage 1: Find relevant files and component type
        this.updateLoadingStatus('🔍 Stage 1: Analyzing component scope...');
        this.updateProgress(10);
        
        const relevantFiles = this.findRelevantFiles(componentName);
        if (relevantFiles.length === 0) {
            throw new Error(`Component "${componentName}" not found in uploaded files. Please check the component name.`);
        }

        const componentType = this.detectComponentType(componentName, relevantFiles);
        console.log(`Component type: ${componentType}`);

        // Stage 2: Extract dependencies with found/missing tracking
        this.updateLoadingStatus('🔗 Stage 2: Analyzing dependencies...');
        this.updateProgress(25);
        
        const dependencyAnalysis = await this.extractBasicDependencies();

        // Stage 3: Extract focused lifecycle flow
        this.updateLoadingStatus('🌊 Stage 3: Analyzing component lifecycle...');
        this.updateProgress(50);
        
        const lifecycleFlow = await this.extractFileLifecycleFlow(componentName, relevantFiles);

        // Stage 4: LLM analysis with focused scope
        this.updateLoadingStatus('🤖 Stage 4: LLM analysis...');
        this.updateProgress(75);
        
        let llmAnalysis;
        try {
            if (componentType === 'Copybook') {
                llmAnalysis = await this.analyzeCopybookWithLLMAndLifecycle(
                    componentName, relevantFiles, dependencyAnalysis, lifecycleFlow
                );
            } else if (componentType === 'COBOL Program') {
                llmAnalysis = await this.analyzeProgramWithLLMAndLifecycle(
                    componentName, relevantFiles, dependencyAnalysis, lifecycleFlow
                );
            } else {
                llmAnalysis = await this.analyzeGenericComponentWithLLM(
                    componentName, relevantFiles, dependencyAnalysis
                );
            }
        } catch (llmError) {
            console.error('LLM analysis failed:', llmError);
            llmAnalysis = {
                error: true,
                message: llmError.message,
                fallbackData: this.createComponentFallback(componentName, componentType, lifecycleFlow)
            };
        }

        // Stage 5: Finalize results
        this.updateLoadingStatus('📊 Stage 5: Finalizing analysis...');
        this.updateProgress(90);
        
        const results = {
            componentName: componentName,
            timestamp: new Date().toISOString(),
            filesAnalyzed: relevantFiles.map(f => f.name),
            componentType: componentType,
            dependencyAnalysis: dependencyAnalysis,
            lifecycleFlow: lifecycleFlow,
            llmAnalysis: llmAnalysis,
            qualityScore: this.calculateQualityScore(llmAnalysis),
            completeness: this.assessCompleteness(llmAnalysis),
            analysisMethod: 'LLM-Enhanced-Focused'
        };

        this.updateProgress(100);
        return results;

    } catch (error) {
        console.error('Analysis failed:', error);
        throw new Error(`Analysis failed: ${error.message}`);
    }
}

// === LLM API CALL WITH IMPROVED RESPONSE HANDLING ===
async callLLMAPI(prompt, retries = 0) {
    let resultText = '';
    
    try {
        console.log(`Making LLM API call attempt ${retries + 1}...`);
        
        const response = await fetch(`${this.vllmEndpoint}/generate`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                prompt: prompt,
                max_tokens: Math.min(this.maxTokens * 0.8, 4000), // Conservative token usage
                temperature: 0.1, // Low temperature for structured output
                top_p: 0.9,
                stop: [], // No stop sequences to avoid cutting off JSON
                stream: false,
                frequency_penalty: 0.1,
                presence_penalty: 0.0
            }),
            signal: AbortSignal.timeout(60000) // 60 second timeout
        });

        if (!response.ok) {
            throw new Error(`LLM API request failed: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();
        console.log('LLM API Response received, keys:', Object.keys(data));
        
        // Extract text from various response formats
        if (data.text) {
            resultText = data.text.trim();
        } else if (data.choices && data.choices.length > 0) {
            if (data.choices[0].text) {
                resultText = data.choices[0].text.trim();
            } else if (data.choices[0].message && data.choices[0].message.content) {
                resultText = data.choices[0].message.content.trim();
            }
        } else if (data.generated_text) {
            resultText = data.generated_text.trim();
        } else if (data.response) {
            resultText = data.response.trim();
        } else if (typeof data === 'string') {
            resultText = data.trim();
        }

        if (!resultText) {
            throw new Error('No valid text content in LLM response');
        }

        console.log(`LLM response length: ${resultText.length} chars`);
        console.log('Response preview:', resultText.substring(0, 200) + '...');

        // Parse the response
        const parseResult = this.parseJSONResponse(resultText);
        
        if (parseResult.success) {
            console.log('LLM JSON parsing successful');
            return parseResult.data;
        } else {
            console.warn('LLM JSON parsing failed, using fallback');
            if (parseResult.fallbackData) {
                // Add raw response for debugging
                parseResult.fallbackData.rawResponse = resultText.substring(0, 1000);
                parseResult.fallbackData.parseError = parseResult.error;
                return parseResult.fallbackData;
            } else {
                throw new Error(`JSON parsing failed: ${parseResult.error}`);
            }
        }

    } catch (error) {
        console.error(`LLM API call attempt ${retries + 1} failed:`, error);
        
        if (retries < 2) { // Max 3 attempts
            console.log(`Retrying LLM API call (${retries + 1}/2)...`);
            await this.sleep(2000 * (retries + 1)); // Exponential backoff
            return this.callLLMAPI(prompt, retries + 1);
        }
        
        // Final fallback
        return {
            error: true,
            message: error.message,
            fallbackData: this.createComponentFallback(
                this.currentAnalyzedComponent || 'Unknown',
                'Unknown',
                null
            )
        };
    }
}

// === IMPROVED JSON PARSING WITH MULTIPLE ATTEMPTS ===
parseJSONResponse(text) {
    if (!text || typeof text !== 'string') {
        return { 
            success: false, 
            error: 'No text provided', 
            fallbackData: this.createBasicFallback() 
        };
    }

    console.log('=== JSON PARSING DEBUG ===');
    console.log('Raw text length:', text.length);
    console.log('First 500 chars:', text.substring(0, 500));
    console.log('Last 500 chars:', text.substring(Math.max(0, text.length - 500)));

    // Step 1: Try JSON parsing first (existing methods)
    const extractionMethods = [
        () => this.extractJSONMethod1(text),
        () => this.extractJSONMethod2(text),
        () => this.extractJSONMethod3(text),
        () => this.extractJSONMethod4(text)
    ];

    for (let i = 0; i < extractionMethods.length; i++) {
        try {
            console.log(`Trying extraction method ${i + 1}...`);
            const jsonText = extractionMethods[i]();
            
            if (jsonText) {
                const parseAttempts = [
                    () => JSON.parse(jsonText),
                    () => JSON.parse(this.cleanJSONText(jsonText)),
                    () => JSON.parse(this.fixCommonJSONIssues(jsonText)),
                ];
                
                for (let j = 0; j < parseAttempts.length; j++) {
                    try {
                        const result = parseAttempts[j]();
                        if (result && typeof result === 'object') {
                            console.log('✅ JSON parsing successful!');
                            return { success: true, data: result };
                        }
                    } catch (parseError) {
                        console.warn(`Parse method ${j + 1} failed:`, parseError.message);
                    }
                }
            }
        } catch (extractError) {
            console.warn(`Extraction method ${i + 1} failed:`, extractError.message);
        }
    }

    // Step 2: JSON failed, use SMART PLAIN TEXT PARSING
    console.log('🔍 JSON parsing failed, using smart plain text analysis...');
    const plainTextAnalysis = this.parseSmartPlainText(text);
    
    return { 
        success: true, // Mark as successful since we have good data
        data: plainTextAnalysis,
        source: 'PlainTextParser',
        rawText: text.substring(0, 2000)
    };
}

parseSmartPlainText(text) {
    console.log('📝 Starting smart plain text analysis...');
    
    const analysis = {
        componentName: this.currentAnalyzedComponent || 'Unknown',
        componentType: this.detectComponentTypeFromText(text),
        analysisScope: 'SMART_TEXT_ANALYSIS',
        status: 'Plain text analysis successful',
        
        // Field and program analysis
        programAnalysis: this.extractProgramAnalysis(text),
        fieldOperations: this.extractFieldOperations(text),
        primaryFields: this.extractFieldsFromPlainText(text),
        
        // Business logic
        businessLogic: this.extractBusinessLogicFromText(text),
        
        // Dependencies
        dependencyStatus: this.extractDependenciesFromText(text),
        
        // Recommendations
        recommendations: this.extractRecommendationsFromText(text),
        
        // Metadata
        textLength: text.length,
        analysisMethod: 'SmartTextParser',
        qualityScore: this.calculateTextAnalysisQuality(text)
    };
    
    console.log('📊 Plain text analysis complete:', {
        programs: analysis.programAnalysis.length,
        fields: analysis.primaryFields.length,
        operations: analysis.fieldOperations.length,
        recommendations: analysis.recommendations.length
    });
    
    return analysis;
}

extractProgramAnalysis(text) {
    const programs = [];
    const lines = text.split('\n');
    
    lines.forEach((line, index) => {
        // Pattern: "1. PROGRAM123: This program reads..."
        const programMatch = line.match(/^\s*(\d+)\.\s*([A-Z][A-Z0-9\-_]{3,}):\s*(.+)/);
        if (programMatch) {
            const [, number, programName, description] = programMatch;
            
            programs.push({
                name: programName,
                sequence: parseInt(number),
                description: description.trim(),
                operations: this.extractOperationsFromDescription(description),
                lineNumber: index + 1
            });
        }
        
        // Pattern: "PROGRAM123: This program updates..."
        const simpleMatch = line.match(/([A-Z][A-Z0-9\-_]{3,}):\s*This program\s+(.+)/i);
        if (simpleMatch && !programMatch) {
            const [, programName, description] = simpleMatch;
            
            programs.push({
                name: programName,
                description: description.trim(),
                operations: this.extractOperationsFromDescription(description),
                lineNumber: index + 1
            });
        }
    });
    
    return programs;
}
extractOperationsFromDescription(description) {
    const operations = [];
    
    // Extract field operations with line numbers
    const fieldOpPattern = /(reads?|updates?|moves?)\s+(?:the\s+)?["\']?([A-Z][A-Z0-9\-_]+)["\']?\s+field(?:\s+[a-z\s]+)?(?:at\s+line\s+(\d+))?/gi;
    let match;
    
    while ((match = fieldOpPattern.exec(description)) !== null) {
        const [, operation, fieldName, lineNumber] = match;
        
        operations.push({
            type: operation.toLowerCase().includes('read') ? 'READ' : 
                  operation.toLowerCase().includes('update') ? 'UPDATE' : 'MOVE',
            field: fieldName,
            lineNumber: lineNumber ? parseInt(lineNumber) : null,
            context: match[0]
        });
    }
    
    // Extract value movements: moves "VALUE1" to "FIELD2"
    const movePattern = /moves?\s+(?:its\s+value\s+of\s+)?["\']?([^"'\s]+)["\']?\s+to\s+["\']?([A-Z][A-Z0-9\-_]+)["\']?/gi;
    while ((match = movePattern.exec(description)) !== null) {
        const [, sourceValue, targetField] = match;
        
        operations.push({
            type: 'MOVE_VALUE',
            sourceValue: sourceValue,
            targetField: targetField,
            context: match[0]
        });
    }
    
    return operations;
}

// === 5. EXTRACT FIELD OPERATIONS FROM TEXT ===
extractFieldOperations(text) {
    const fieldOperations = [];
    const lines = text.split('\n');
    
    lines.forEach((line, index) => {
        // Look for field operations in various formats
        const patterns = [
            // "reads the FIELD-NAME field"
            /(\w+)\s+(reads?|updates?|moves?)\s+(?:the\s+)?["\']?([A-Z][A-Z0-9\-_]+)["\']?\s+field/gi,
            // "FIELD-NAME is read by PROGRAM"
            /["\']?([A-Z][A-Z0-9\-_]+)["\']?\s+is\s+(read|updated|modified)\s+by\s+(\w+)/gi,
            // "at line 123"
            /at\s+line\s+(\d+)/gi
        ];
        
        patterns.forEach(pattern => {
            let match;
            while ((match = pattern.exec(line)) !== null) {
                if (match.length >= 4) {
                    fieldOperations.push({
                        program: match[1],
                        operation: match[2].toUpperCase(),
                        field: match[3],
                        lineNumber: index + 1,
                        context: line.trim()
                    });
                } else if (match.length === 2 && pattern.source.includes('line')) {
                    // Handle line number matches
                    if (fieldOperations.length > 0) {
                        fieldOperations[fieldOperations.length - 1].sourceLineNumber = parseInt(match[1]);
                    }
                }
            }
        });
    });
    
    return fieldOperations;
}

// === 6. EXTRACT FIELDS FROM PLAIN TEXT ===
extractFieldsFromPlainText(text) {
    const fields = [];
    const fieldNames = new Set();
    
    // Extract field names from various patterns
    const patterns = [
        // "FIELD-NAME" field
        /["\']([A-Z][A-Z0-9\-_]{3,})["\']?\s+field/gi,
        // Field in quotes
        /["\']([A-Z][A-Z0-9\-_]{4,})["\'](?!\s+field)/gi,
        // Standalone field names (more selective)
        /\b([A-Z][A-Z0-9\-_]{5,})\b(?=\s+(?:is|was|field|record))/gi
    ];
    
    patterns.forEach(pattern => {
        let match;
        while ((match = pattern.exec(text)) !== null) {
            const fieldName = match[1];
            
            // Filter out program names and common words
            if (!fieldName.match(/^(PROGRAM|PROC|JOB|STEP|CLASS|USER|DATE|TIME|CODE)$/) && 
                fieldName.length >= 4 && 
                !fieldNames.has(fieldName)) {
                
                fieldNames.add(fieldName);
                
                // Determine field purpose from context
                const purpose = this.determineFieldPurpose(fieldName, text);
                const usagePattern = this.determineFieldUsage(fieldName, text);
                
                fields.push({
                    name: fieldName,
                    level: fieldName.includes('-RECORD') || fieldName.includes('-REC') ? 1 : 5,
                    businessPurpose: purpose,
                    usagePattern: usagePattern,
                    isRecordLayout: fieldName.includes('-RECORD') || fieldName.includes('-REC'),
                    isElementaryField: !fieldName.includes('-RECORD'),
                    source: 'PlainTextExtraction'
                });
            }
        }
    });
    
    return Array.from(fields).slice(0, 20); // Limit to 20 fields
}

// === 7. DETERMINE FIELD PURPOSE ===
determineFieldPurpose(fieldName, text) {
    const fieldContext = this.getFieldContext(fieldName, text);
    
    // Look for contextual clues
    if (fieldName.includes('RECORD') || fieldName.includes('REC')) {
        return `Main record structure containing ${fieldName.toLowerCase().replace(/-/g, ' ')} data`;
    } else if (fieldName.includes('ID') || fieldName.includes('KEY')) {
        return `Unique identifier field for ${fieldName.toLowerCase().replace(/-/g, ' ')}`;
    } else if (fieldName.includes('DATE') || fieldName.includes('TIME')) {
        return `Date/time field for ${fieldName.toLowerCase().replace(/-/g, ' ')} tracking`;
    } else if (fieldName.includes('AMT') || fieldName.includes('AMOUNT')) {
        return `Monetary amount field for ${fieldName.toLowerCase().replace(/-/g, ' ')}`;
    } else if (fieldName.includes('DESC') || fieldName.includes('NAME')) {
        return `Descriptive text field for ${fieldName.toLowerCase().replace(/-/g, ' ')}`;
    } else if (fieldName.includes('FLAG') || fieldName.includes('IND')) {
        return `Status indicator field for ${fieldName.toLowerCase().replace(/-/g, ' ')}`;
    } else if (fieldContext.includes('read') && fieldContext.includes('update')) {
        return `Transactional field - both read and updated by programs`;
    } else if (fieldContext.includes('read')) {
        return `Reference field - primarily read by programs`;
    } else if (fieldContext.includes('update')) {
        return `Output field - primarily updated by programs`;
    } else {
        return `Business field for ${fieldName.toLowerCase().replace(/-/g, ' ')} processing`;
    }
}

// === 8. DETERMINE FIELD USAGE PATTERN ===
determineFieldUsage(fieldName, text) {
    const fieldContext = this.getFieldContext(fieldName, text);
    
    const hasRead = fieldContext.includes('read');
    const hasUpdate = fieldContext.includes('update') || fieldContext.includes('move');
    
    if (hasRead && hasUpdate) return 'BOTH';
    if (hasRead) return 'INPUT';
    if (hasUpdate) return 'OUTPUT';
    return 'REFERENCE';
}

// === 9. GET FIELD CONTEXT ===
getFieldContext(fieldName, text) {
    const lines = text.split('\n');
    let context = '';
    
    lines.forEach(line => {
        if (line.toUpperCase().includes(fieldName)) {
            context += ' ' + line.toLowerCase();
        }
    });
    
    return context;
}

// === 10. EXTRACT BUSINESS LOGIC FROM TEXT ===
extractBusinessLogicFromText(text) {
    const businessLogic = {
        validationRules: [],
        calculations: [],
        decisionPoints: [],
        fileOperations: []
    };
    
    const lines = text.split('\n');
    
    lines.forEach((line, index) => {
        const lowerLine = line.toLowerCase();
        
        // Look for validation patterns
        if (lowerLine.includes('validate') || lowerLine.includes('check') || lowerLine.includes('verify')) {
            businessLogic.validationRules.push({
                description: line.trim(),
                lineNumber: index + 1,
                type: 'VALIDATION'
            });
        }
        
        // Look for calculation patterns
        if (lowerLine.includes('calculat') || lowerLine.includes('compute') || lowerLine.includes('total')) {
            businessLogic.calculations.push({
                description: line.trim(),
                lineNumber: index + 1,
                type: 'CALCULATION'
            });
        }
        
        // Look for decision patterns
        if (lowerLine.includes('if') || lowerLine.includes('when') || lowerLine.includes('condition')) {
            businessLogic.decisionPoints.push({
                description: line.trim(),
                lineNumber: index + 1,
                type: 'DECISION'
            });
        }
        
        // Look for file operations
        if (lowerLine.includes('file') || lowerLine.includes('read') || lowerLine.includes('write')) {
            businessLogic.fileOperations.push({
                description: line.trim(),
                lineNumber: index + 1,
                type: 'FILE_OP'
            });
        }
    });
    
    return businessLogic;
}

// === 11. CALCULATE TEXT ANALYSIS QUALITY ===
calculateTextAnalysisQuality(text) {
    let quality = 5; // Base score
    
    // Bonus for structured content
    if (text.includes('1.') && text.includes('2.')) quality += 1;
    if (text.match(/line\s+\d+/gi)) quality += 1;
    if (text.includes('program') && text.includes('field')) quality += 1;
    if (text.includes('read') || text.includes('update')) quality += 1;
    if (text.includes('copybook') || text.includes('record')) quality += 1;
    if (text.length > 1000) quality += 1;
    
    return Math.min(quality, 10);
}

// === 12. DETECT COMPONENT TYPE FROM TEXT ===
detectComponentTypeFromText(text) {
    const upperText = text.toUpperCase();
    
    if (upperText.includes('COPYBOOK') || upperText.includes('RECORD')) {
        return 'Copybook';
    } else if (upperText.includes('PROGRAM') || upperText.includes('COBOL')) {
        return 'COBOL Program';
    } else if (upperText.includes('JCL') || upperText.includes('JOB')) {
        return 'JCL Job';
    } else {
        return 'Component';
    }
}

// === 13. ENHANCED DISPLAY FOR PLAIN TEXT ANALYSIS ===
displayPlainTextAnalysis(analysis) {
    return `
        <div style="background: rgba(76, 175, 80, 0.1); padding: 20px; border-radius: 10px; border-left: 4px solid #4CAF50; margin-bottom: 20px;">
            <h4 style="color: #4CAF50; margin-bottom: 15px;">📝 Smart Plain Text Analysis Results</h4>
            
            <!-- Analysis Quality Indicator -->
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <span style="background: rgba(76, 175, 80, 0.2); padding: 4px 8px; border-radius: 4px; font-size: 11px; color: #4CAF50;">
                    ✅ Plain Text Parser • Quality: ${analysis.qualityScore}/10
                </span>
                <span style="font-size: 11px; opacity: 0.8;">
                    📊 ${analysis.textLength} chars analyzed
                </span>
            </div>
            
            <!-- Program Analysis -->
            ${analysis.programAnalysis && analysis.programAnalysis.length > 0 ? `
                <div style="margin-bottom: 20px;">
                    <h5 style="color: #4CAF50; margin-bottom: 10px;">🖥️ Program Analysis (${analysis.programAnalysis.length} programs)</h5>
                    <div style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px; max-height: 300px; overflow-y: auto;">
                        ${analysis.programAnalysis.map(program => `
                            <div style="margin-bottom: 12px; padding: 10px; background: rgba(76, 175, 80, 0.1); border-radius: 6px; border-left: 3px solid #4CAF50;">
                                <div style="font-weight: bold; font-family: monospace; color: #FFD700; margin-bottom: 5px;">
                                    ${program.sequence ? `${program.sequence}. ` : ''}${program.name}
                                </div>
                                <div style="font-size: 11px; margin-bottom: 8px; line-height: 1.4;">
                                    ${program.description}
                                </div>
                                ${program.operations && program.operations.length > 0 ? `
                                    <div style="margin-top: 8px;">
                                        <div style="font-size: 10px; font-weight: bold; color: #4CAF50; margin-bottom: 4px;">Operations:</div>
                                        ${program.operations.map(op => `
                                            <div style="font-size: 9px; margin: 2px 0; padding: 3px 6px; background: rgba(0,0,0,0.3); border-radius: 3px;">
                                                <span style="color: #FFD700;">${op.type}</span> 
                                                <span style="color: #4dd0e1;">${op.field || op.targetField || ''}</span>
                                                ${op.lineNumber ? `<span style="opacity: 0.7;"> @line ${op.lineNumber}</span>` : ''}
                                            </div>
                                        `).join('')}
                                    </div>
                                ` : ''}
                            </div>
                        `).join('')}
                    </div>
                </div>
            ` : ''}
            
            <!-- Field Operations -->
            ${analysis.fieldOperations && analysis.fieldOperations.length > 0 ? `
                <div style="margin-bottom: 20px;">
                    <h5 style="color: #2196F3; margin-bottom: 10px;">📋 Field Operations (${analysis.fieldOperations.length} operations)</h5>
                    <div style="background: rgba(33, 150, 243, 0.1); padding: 15px; border-radius: 8px; max-height: 200px; overflow-y: auto;">
                        ${analysis.fieldOperations.map(op => `
                            <div style="margin-bottom: 6px; padding: 6px; background: rgba(0,0,0,0.2); border-radius: 4px; font-size: 10px;">
                                <span style="color: #FFD700; font-weight: bold;">${op.program}</span>
                                <span style="color: #4CAF50;"> ${op.operation}</span>
                                <span style="color: #4dd0e1;"> ${op.field}</span>
                                ${op.sourceLineNumber ? `<span style="opacity: 0.7;"> @${op.sourceLineNumber}</span>` : ''}
                            </div>
                        `).join('')}
                    </div>
                </div>
            ` : ''}
            
            <!-- Primary Fields -->
            ${analysis.primaryFields && analysis.primaryFields.length > 0 ? `
                <div style="margin-bottom: 20px;">
                    <h5 style="color: #FF9800; margin-bottom: 10px;">🎯 Identified Fields (${analysis.primaryFields.length} fields)</h5>
                    <div style="display: flex; flex-wrap: wrap; gap: 6px;">
                        ${analysis.primaryFields.slice(0, 15).map(field => `
                            <span style="background: rgba(255, 152, 0, 0.2); color: #FF9800; padding: 4px 8px; border-radius: 4px; font-size: 10px; font-family: monospace;">
                                ${field.name} (${field.usagePattern})
                            </span>
                        `).join('')}
                        ${analysis.primaryFields.length > 15 ? `
                            <span style="padding: 4px 8px; opacity: 0.7; font-size: 9px;">
                                +${analysis.primaryFields.length - 15} more...
                            </span>
                        ` : ''}
                    </div>
                </div>
            ` : ''}
            
            <!-- Recommendations -->
            ${analysis.recommendations && analysis.recommendations.length > 0 ? `
                <div>
                    <h5 style="color: #FFC107; margin-bottom: 10px;">💡 Recommendations</h5>
                    <div style="background: rgba(255, 193, 7, 0.1); padding: 15px; border-radius: 8px;">
                        ${analysis.recommendations.map((rec, index) => `
                            <div style="margin-bottom: 8px; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 4px;">
                                <strong style="color: #FFC107;">💡 ${index + 1}.</strong> ${rec}
                            </div>
                        `).join('')}
                    </div>
                </div>
            ` : ''}
        </div>
    `;
}



// === EXTRACT JSON FROM TEXT ===
extractJSONFromText(text) {
    // Look for JSON object boundaries
    const jsonStart = text.indexOf('{');
    const jsonEnd = text.lastIndexOf('}');
    
    if (jsonStart === -1 || jsonEnd === -1 || jsonStart >= jsonEnd) {
        console.warn('No JSON object boundaries found');
        return text;
    }
    
    return text.substring(jsonStart, jsonEnd + 1);
}

extractJSONMethod1(text) {
    const jsonStart = text.indexOf('{');
    const jsonEnd = text.lastIndexOf('}');
    
    if (jsonStart === -1 || jsonEnd === -1 || jsonStart >= jsonEnd) {
        return null;
    }
    
    let jsonText = text.substring(jsonStart, jsonEnd + 1);
    
    // Balance braces
    let braceCount = 0;
    let balancedEnd = -1;
    
    for (let i = 0; i < jsonText.length; i++) {
        if (jsonText[i] === '{') braceCount++;
        if (jsonText[i] === '}') braceCount--;
        if (braceCount === 0) {
            balancedEnd = i;
            break;
        }
    }
    
    if (balancedEnd > 0) {
        jsonText = jsonText.substring(0, balancedEnd + 1);
    }
    
    return jsonText;
}

// === 4. JSON EXTRACTION METHOD 2 - Marker Based ===
extractJSONMethod2(text) {
    // Look for common JSON start patterns
    const patterns = [
        /{\s*"componentName"/i,
        /{\s*"component"/i,
        /{\s*"analysis"/i,
        /REQUIRED JSON RESPONSE[:\s]*({.*})/is,
        /JSON[:\s]*({.*})/is
    ];
    
    for (const pattern of patterns) {
        const match = text.match(pattern);
        if (match) {
            if (match[1]) {
                return match[1]; // Captured group
            } else {
                // Find JSON starting from match position
                const startIndex = text.indexOf(match[0]);
                const remaining = text.substring(startIndex);
                const jsonStart = remaining.indexOf('{');
                if (jsonStart >= 0) {
                    return this.extractJSONMethod1(remaining.substring(jsonStart));
                }
            }
        }
    }
    
    return null;
}

// === 5. JSON EXTRACTION METHOD 3 - Line Based ===
extractJSONMethod3(text) {
    const lines = text.split('\n');
    let jsonLines = [];
    let inJSON = false;
    let braceCount = 0;
    
    for (const line of lines) {
        const trimmed = line.trim();
        
        // Start JSON capture
        if (!inJSON && trimmed.includes('{')) {
            inJSON = true;
            jsonLines = [line];
            braceCount = (line.match(/{/g) || []).length - (line.match(/}/g) || []).length;
        } else if (inJSON) {
            jsonLines.push(line);
            braceCount += (line.match(/{/g) || []).length - (line.match(/}/g) || []).length;
            
            // End JSON capture when braces are balanced
            if (braceCount === 0) {
                break;
            }
        }
    }
    
    return inJSON ? jsonLines.join('\n') : null;
}

// === 6. JSON EXTRACTION METHOD 4 - Regex Based ===
extractJSONMethod4(text) {
    // Try to find JSON-like structures with regex
    const jsonRegex = /{[^{}]*(?:{[^{}]*}[^{}]*)*}/g;
    const matches = text.match(jsonRegex);
    
    if (matches && matches.length > 0) {
        // Return the largest match (likely the main JSON)
        return matches.reduce((a, b) => a.length > b.length ? a : b);
    }
    
    return null;
}

// === 7. ENHANCED PARTIAL JSON PARSER ===
parsePartialJSON(text) {
    console.log('Attempting partial JSON parsing...');
    
    const partial = {
        componentName: this.extractValue(text, 'componentName') || this.currentAnalyzedComponent,
        componentType: this.extractValue(text, 'componentType') || 'Unknown',
        analysisScope: this.extractValue(text, 'analysisScope') || 'PARTIAL_EXTRACTION',
        totalFields: parseInt(this.extractValue(text, 'totalFields')) || 0,
        status: 'Partial extraction from LLM response'
    };
    
    // Try to extract arrays
    partial.recommendations = this.extractArrayFromText(text, 'recommendations');
    partial.primaryFields = this.extractFieldsFromText(text);
    
    // Try to extract quality score
    const qualityMatch = text.match(/"qualityScore":\s*(\d+)/i);
    if (qualityMatch) {
        partial.qualityScore = parseInt(qualityMatch[1]);
    }
    
    // Extract dependency information
    partial.dependencyStatus = this.extractDependencyStatusFromText(text);
    
    console.log('Partial JSON extraction result:', partial);
    return partial;
}

extractFieldsFromText(text) {
    const fields = [];
    
    // Look for field patterns in the text
    const fieldPatterns = [
        /"name":\s*"([^"]+)"/gi,
        /field[:\s]*([A-Z][A-Z0-9\-_]+)/gi,
        /01\s+([A-Z][A-Z0-9\-_]+)/gi
    ];
    
    const foundFields = new Set();
    
    for (const pattern of fieldPatterns) {
        let match;
        while ((match = pattern.exec(text)) !== null) {
            const fieldName = match[1];
            if (fieldName && !foundFields.has(fieldName)) {
                foundFields.add(fieldName);
                fields.push({
                    name: fieldName,
                    level: 1,
                    businessPurpose: 'Extracted from LLM response',
                    usagePattern: 'UNKNOWN'
                });
            }
        }
    }
    
    return fields;
}

extractDependencyStatusFromText(text) {
    return {
        foundCopybooks: this.extractArrayFromText(text, 'foundCopybooks'),
        missingCopybooks: this.extractArrayFromText(text, 'missingCopybooks'),
        foundPrograms: this.extractArrayFromText(text, 'foundPrograms'),
        missingPrograms: this.extractArrayFromText(text, 'missingPrograms')
    };
}

// === CLEAN JSON TEXT ===
cleanJSONText(text) {
    if (!text) return '{}';
    
    return text
        // Remove trailing commas
        .replace(/,(\s*[\}\]])/g, '$1')
        // Fix unquoted property names
        .replace(/([{,]\s*)([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g, '$1"$2":')
        // Fix single quotes to double quotes
        .replace(/'/g, '"')
        // Remove comments
        .replace(/\/\/.*$/gm, '')
        .replace(/\/\*[\s\S]*?\*\//g, '')
        // Fix line breaks in strings
        .replace(/"\s*\n\s*"/g, '" + "');
}

// === FIX COMMON JSON ISSUES ===
fixCommonJSONIssues(text) {
    return text
        // Fix array formatting
        .replace(/\[\s*([^"]\w+[^"]*?)\s*\]/g, (match, content) => {
            const items = content.split(',').map(item => {
                const trimmed = item.trim();
                if (trimmed === 'true' || trimmed === 'false' || trimmed === 'null' || /^\d+(\.\d+)?$/.test(trimmed)) {
                    return trimmed;
                }
                return `"${trimmed.replace(/"/g, '\\"')}"`;
            });
            return `[${items.join(', ')}]`;
        })
        // Fix boolean values
        .replace(/:\s*True\b/g, ': true')
        .replace(/:\s*False\b/g, ': false')
        // Fix null values
        .replace(/:\s*None\b/g, ': null');
}

// === EXTRACT PARTIAL JSON STRUCTURE ===
extractPartialJSONStructure(text) {
    const structure = {
        componentName: this.extractValue(text, 'componentName') || this.currentAnalyzedComponent,
        componentType: this.extractValue(text, 'componentType') || 'Unknown',
        analysisScope: 'PARTIAL_EXTRACTION',
        totalFields: parseInt(this.extractValue(text, 'totalFields')) || 0,
        status: 'Partial extraction successful'
    };
    
    // Try to extract arrays
    structure.recommendations = this.extractArray(text, 'recommendations');
    structure.primaryFields = this.extractArray(text, 'primaryFields');
    
    return structure;
}

// === EXTRACT VALUE FROM TEXT ===
extractValue(text, key) {
    const patterns = [
        new RegExp(`"${key}":\\s*"([^"]+)"`, 'i'),
        new RegExp(`"${key}":\\s*(\\d+)`, 'i'),
        new RegExp(`${key}[\\s]*:[\\s]*["']([^"']+)["']`, 'i')
    ];
    
    for (const pattern of patterns) {
        const match = text.match(pattern);
        if (match) return match[1];
    }
    
    return null;
}

extractArrayFromText(text, arrayName) {
    const patterns = [
        new RegExp(`"${arrayName}":\\s*\\[(.*?)\\]`, 'is'),
        new RegExp(`${arrayName}[:\\s]*\\[(.*?)\\]`, 'is'),
        new RegExp(`${arrayName}[:\\s]*([^,\\n]+)`, 'i')
    ];
    
    for (const pattern of patterns) {
        const match = text.match(pattern);
        if (match) {
            const arrayContent = match[1];
            const items = [];
            
            // Extract quoted strings
            const quotedPattern = /"([^"]+)"/g;
            let quotedMatch;
            
            while ((quotedMatch = quotedPattern.exec(arrayContent)) !== null) {
                items.push(quotedMatch[1]);
            }
            
            if (items.length > 0) {
                return items;
            }
            
            // If no quoted strings, try comma-separated values
            const commaSeparated = arrayContent.split(',').map(item => 
                item.trim().replace(/['"]/g, '')
            ).filter(item => item.length > 0);
            
            if (commaSeparated.length > 0) {
                return commaSeparated;
            }
        }
    }
    
    return [];
}

// === EXTRACT ARRAY FROM TEXT ===
extractArray(text, arrayName) {
    const arrayPattern = new RegExp(`"${arrayName}":\\s*\\[(.*?)\\]`, 's');
    const match = text.match(arrayPattern);
    
    if (!match) return [];
    
    const arrayContent = match[1];
    const items = [];
    
    // Extract quoted strings
    const quotedPattern = /"([^"]+)"/g;
    let quotedMatch;
    
    while ((quotedMatch = quotedPattern.exec(arrayContent)) !== null) {
        items.push(quotedMatch[1]);
    }
    
    return items;
}
createStructuredFallbackFromText(text) {
    console.log('Creating structured fallback from LLM text...');
    
    const fallback = {
        componentName: this.currentAnalyzedComponent || 'Unknown',
        componentType: 'Unknown',
        analysisScope: 'FALLBACK_TEXT_ANALYSIS',
        status: 'JSON parsing failed - extracted from text analysis',
        totalFields: 0,
        qualityScore: 5
    };
    
    // Try to extract key information from the text
    if (text.toLowerCase().includes('copybook')) {
        fallback.componentType = 'Copybook';
    } else if (text.toLowerCase().includes('program')) {
        fallback.componentType = 'COBOL Program';
    }
    
    // Count field references
    const fieldMatches = text.match(/\b[A-Z][A-Z0-9\-_]{3,}\b/g) || [];
    fallback.totalFields = Math.min(fieldMatches.length, 20); // Cap at reasonable number
    
    // Extract recommendations from text
    fallback.recommendations = this.extractRecommendationsFromText(text);
    
    // Look for analysis content
    if (text.includes('business') || text.includes('purpose')) {
        fallback.hasBusinessAnalysis = true;
    }
    
    if (text.includes('depend') || text.includes('copy') || text.includes('call')) {
        fallback.hasDependencyAnalysis = true;
    }
    
    console.log('Fallback analysis created:', fallback);
    return fallback;
}

// === 12. EXTRACT RECOMMENDATIONS FROM TEXT ===
extractRecommendationsFromText(text) {
    const recommendations = [];
    
    // Look for recommendation patterns
    const patterns = [
        /recommend[a-z]*[:\s]*([^.]+)/gi,
        /suggest[a-z]*[:\s]*([^.]+)/gi,
        /should[:\s]*([^.]+)/gi,
        /consider[:\s]*([^.]+)/gi
    ];
    
    for (const pattern of patterns) {
        let match;
        while ((match = pattern.exec(text)) !== null && recommendations.length < 5) {
            const rec = match[1].trim();
            if (rec.length > 10 && rec.length < 200) {
                recommendations.push(rec);
            }
        }
    }
    
    // If no patterns found, provide generic recommendations
    if (recommendations.length === 0) {
        recommendations.push(
            'Review the component structure and dependencies',
            'Validate field usage patterns across programs',
            'Check for missing dependencies and resolve them',
            'Consider optimization opportunities based on usage patterns'
        );
    }
    
    return recommendations.slice(0, 5); // Limit to 5 recommendations
}

// === CREATE STRUCTURED FALLBACK ===
createStructuredFallback(rawText) {
    return {
        componentName: this.currentAnalyzedComponent || 'Unknown',
        componentType: 'Unknown',
        analysisScope: 'FALLBACK_ANALYSIS',
        status: 'JSON parsing failed - using text analysis',
        textContent: rawText.substring(0, 500),
        extractedInfo: {
            hasFieldInfo: rawText.includes('field') || rawText.includes('FIELD'),
            hasRecommendations: rawText.includes('recommend') || rawText.includes('RECOMMEND'),
            hasDependencies: rawText.includes('depend') || rawText.includes('DEPEND')
        },
        recommendations: [
            'Review raw LLM response for detailed analysis',
            'Check LLM prompt format and token limits',
            'Verify component exists in uploaded files'
        ],
        qualityScore: 4
    };
}

// === CREATE BASIC FALLBACK ===
createBasicFallback() {
    return {
        componentName: 'Unknown',
        componentType: 'Unknown',
        status: 'No data available',
        recommendations: ['Upload files and analyze component'],
        qualityScore: 1
    };
}

// === CREATE COMPONENT FALLBACK ===
createComponentFallback(componentName, componentType, lifecycleFlow) {
    const fallback = {
        componentName: componentName,
        componentType: componentType,
        analysisScope: 'FALLBACK_ANALYSIS',
        status: 'LLM analysis failed - using extracted data',
        totalFields: 0,
        recommendations: [
            'Check LLM server connection and configuration',
            'Verify component exists in uploaded files',
            'Try simplifying the analysis scope',
            'Use chat interface for specific questions'
        ],
        qualityScore: 3
    };

    // Add lifecycle data if available
    if (lifecycleFlow) {
        fallback.lifecycleAnalysis = {
            creationPrograms: lifecycleFlow.creationSources?.map(s => s.program) || [],
            updatePrograms: lifecycleFlow.updatePrograms?.map(u => u.program) || [],
            readPrograms: lifecycleFlow.inputPrograms?.map(i => i.program) || []
        };
        
        if (lifecycleFlow.primaryFields) {
            fallback.totalFields = lifecycleFlow.primaryFields.length;
            fallback.primaryFields = lifecycleFlow.primaryFields.map(f => ({
                name: f.name,
                level: f.level,
                isRecordLayout: f.isRecordLayout,
                businessPurpose: 'Analysis failed - check component manually',
                usagePattern: 'UNKNOWN'
            }));
        }
    }

    return fallback;
}
// ===================================================================
// PART 6: LLM PROMPTS AND ANALYSIS METHODS
// Focused prompts for copybook and program analysis
// ===================================================================

// === COPYBOOK ANALYSIS WITH LLM ===
analyzeCopybookWithLLMAndLifecycle(copybookName, relevantFiles, basicDependencies, lifecycleFlow) {
    console.log(`LLM analyzing copybook with ALL field levels: ${copybookName}`);
    
    const copybookFile = relevantFiles.find(f => 
        f.type === 'Copybook' && 
        (f.name.toUpperCase().includes(copybookName.toUpperCase()) || 
         f.content.toUpperCase().includes(copybookName.toUpperCase()))
    );

    if (!copybookFile) {
        throw new Error(`Copybook file for ${copybookName} not found`);
    }

    // Get ALL field levels (not just 01)
    const allFields = lifecycleFlow.primaryFields || [];
    const field01Names = allFields.filter(f => f.level === 1).map(f => f.name).join(', ');
    const fieldLevels = allFields.map(f => `${f.level}-${f.name}`).join(', ');
    
    const copybookContent = this.prepareContentForLLM(copybookFile.content, 'copybook');
    const foundDeps = basicDependencies.found || basicDependencies;
    const missingDeps = basicDependencies.missing || {};

    const llmPrompt = `You are a mainframe copybook analysis expert. Analyze the copybook and return ONLY valid JSON.

COPYBOOK: ${copybookName}
ALL FIELDS FOUND: ${fieldLevels}
01-LEVEL RECORDS: ${field01Names}

COPYBOOK CONTENT:
${copybookContent}

DEPENDENCIES:
Found: ${(foundDeps.copyStatements || []).join(', ') || 'None'}
Missing: ${(missingDeps.copyStatements || []).join(', ') || 'None'}

RETURN ONLY THIS JSON STRUCTURE (no other text):
{
  "componentName": "${copybookName}",
  "componentType": "Copybook",
  "analysisScope": "ALL_FIELD_LEVELS",
  "totalFields": ${allFields.length},
  "primaryFields": [
    {
      "name": "SAMPLE-FIELD",
      "level": 1,
      "isRecordLayout": true,
      "businessPurpose": "Main record structure for business data",
      "usagePattern": "INPUT"
    }
  ],
  "fieldHierarchy": {
    "level01Count": ${allFields.filter(f => f.level === 1).length},
    "level05Count": ${allFields.filter(f => f.level === 5).length},
    "elementaryFieldCount": ${allFields.filter(f => f.isElementaryField).length},
    "groupFieldCount": ${allFields.filter(f => f.isGroupField).length}
  },
  "dependencyStatus": {
    "foundCopybooks": [${(foundDeps.copyStatements || []).map(c => `"${c}"`).join(', ')}],
    "missingCopybooks": [${(missingDeps.copyStatements || []).map(c => `"${c}"`).join(', ')}]
  },
  "recommendations": [
    "Optimize field access patterns for ${copybookName}",
    "Review dependency management for missing copybooks",
    "Consider field usage consolidation"
  ],
  "qualityScore": 8
}`;

    return this.callLLMAPI(llmPrompt);
}


// === PROGRAM ANALYSIS WITH LLM ===
async analyzeProgramWithLLMAndLifecycle(programName, relevantFiles, basicDependencies, lifecycleFlow) {
    console.log(`LLM analyzing program with lifecycle: ${programName}`);
    
    const programFile = relevantFiles.find(f => 
        f.type === 'COBOL Program' && 
        (f.name.toUpperCase().includes(programName.toUpperCase()) || 
         f.content.toUpperCase().includes(`PROGRAM-ID. ${programName.toUpperCase()}`))
    );

    if (!programFile) {
        throw new Error(`Program file for ${programName} not found`);
    }

    const programContent = this.prepareContentForLLM(programFile.content, 'program');
    const foundDeps = basicDependencies.found || basicDependencies;
    const missingDeps = basicDependencies.missing || {};

    const llmPrompt = `MAINFRAME COBOL PROGRAM LIFECYCLE ANALYSIS - JSON RESPONSE REQUIRED

CRITICAL: Respond with ONLY valid JSON. No explanatory text before or after the JSON.

TASK: Analyze COBOL program "${programName}" with complete lifecycle context.

PROGRAM CONTENT:
${programContent}

LIFECYCLE CONTEXT:
- Usage Pattern: ${lifecycleFlow.usagePattern}
- Program Role: ${this.determineProgramRole(programName, lifecycleFlow)}
- Dependencies Found: COPY: ${(foundDeps.copyStatements || []).slice(0,5).join(', ')}, CALL: ${(foundDeps.callStatements || []).slice(0,5).join(', ')}
- Dependencies Missing: COPY: ${(missingDeps.copyStatements || []).slice(0,3).join(', ')}, CALL: ${(missingDeps.callStatements || []).slice(0,3).join(', ')}

REQUIRED JSON OUTPUT:
{
  "componentName": "${programName}",
  "componentType": "COBOL Program",
  "programStructure": {
    "divisions": ["IDENTIFICATION", "ENVIRONMENT", "DATA", "PROCEDURE"],
    "paragraphs": [],
    "sections": []
  },
  "lifecycleRole": {
    "primaryFunction": "PROCESS|CREATE|UPDATE|READ",
    "lifecycleStage": "creation|processing|output|maintenance",
    "dataFlowDirection": "INPUT|OUTPUT|BIDIRECTIONAL",
    "processingType": "BATCH|ONLINE|MIXED"
  },
  "businessLogic": {
    "validationRules": [],
    "calculations": [],
    "decisionPoints": [],
    "fileOperations": []
  },
  "dataFlow": {
    "inputFiles": [],
    "outputFiles": [],
    "fieldTransformations": []
  },
  "dependencies": {
    "copybooks": [${(foundDeps.copyStatements || []).map(c => `"${c}"`).join(', ')}],
    "calledPrograms": [${(foundDeps.callStatements || []).map(p => `"${p}"`).join(', ')}],
    "missingCopybooks": [${(missingDeps.copyStatements || []).map(c => `"${c}"`).join(', ')}],
    "missingPrograms": [${(missingDeps.callStatements || []).map(p => `"${p}"`).join(', ')}]
  },
  "recommendations": [
    "Program-specific optimization recommendations",
    "Lifecycle improvement suggestions"
  ],
  "complexity": "LOW|MEDIUM|HIGH",
  "qualityScore": 7
}

RESPOND WITH VALID JSON ONLY:`;

    return await this.callLLMAPI(llmPrompt);
}

// === GENERIC COMPONENT ANALYSIS ===
async analyzeGenericComponentWithLLM(componentName, relevantFiles, basicDependencies) {
    console.log(`LLM analyzing generic component: ${componentName}`);
    
    const componentFile = relevantFiles[0];
    const componentContent = this.prepareContentForLLM(componentFile.content, 'generic');

    const llmPrompt = `MAINFRAME COMPONENT ANALYSIS

TASK: Analyze the mainframe component "${componentName}" and provide general analysis.

COMPONENT CONTENT:
${componentContent}

COMPONENT TYPE: ${componentFile.type}
FILE SIZE: ${componentFile.size} bytes

DEPENDENCIES FOUND:
${Object.keys(basicDependencies.found || basicDependencies).map(key => 
    `${key}: ${(basicDependencies.found || basicDependencies)[key].join(', ')}`
).join('\n')}

INSTRUCTIONS:
1. Identify the component type and purpose
2. Extract key elements and structures
3. Identify any patterns or notable features
4. Provide general recommendations

OUTPUT FORMAT:
{
  "componentName": "${componentName}",
  "componentType": "${componentFile.type}",
  "purpose": "identified_purpose",
  "keyElements": ["important_elements"],
  "patterns": ["identified_patterns"],
  "recommendations": ["general_recommendations"],
  "qualityScore": 7
}

Respond with valid JSON only.`;

    return await this.callLLMAPI(llmPrompt);
}

// === DETERMINE PROGRAM ROLE ===
determineProgramRole(programName, lifecycleFlow) {
    const isInputProgram = lifecycleFlow.inputPrograms.find(p => p.program === programName);
    const isUpdateProgram = lifecycleFlow.updatePrograms.find(p => p.program === programName);
    const isCreationSource = lifecycleFlow.creationSources.find(s => s.program === programName);
    
    if (isCreationSource) return 'CREATOR';
    if (isUpdateProgram) return 'UPDATER';
    if (isInputProgram) return 'READER';
    return 'PROCESSOR';
}

// === PREPARE CONTENT FOR LLM ===
prepareContentForLLM(content, type) {
    const maxChars = this.maxTokens * this.averageCharsPerToken * 0.6; // Conservative limit
    
    if (content.length <= maxChars) {
        return content;
    }
    
    if (type === 'copybook') {
        // Focus on 01-level field definitions
        const lines = content.split('\n');
        const importantLines = lines.filter(line => {
            const trimmed = line.trim().toUpperCase();
            return trimmed.match(/^\s*01\s+/) ||           // 01-level fields
                   trimmed.includes('PIC ') ||             // Picture clauses
                   trimmed.includes('VALUE ') ||           // Value clauses
                   trimmed.includes('REDEFINES ') ||       // Redefines
                   trimmed.includes('OCCURS ');            // Arrays
        });
        
        let result = importantLines.join('\n');
        if (result.length > maxChars) {
            result = result.substring(0, maxChars);
        }
        return result;
        
    } else if (type === 'program') {
        // Focus on procedure division
        const procedureIndex = content.toUpperCase().indexOf('PROCEDURE DIVISION');
        if (procedureIndex > -1) {
            const procedureContent = content.substring(procedureIndex);
            if (procedureContent.length <= maxChars) {
                return procedureContent;
            }
            return procedureContent.substring(0, maxChars);
        }
    }
    
    // Generic truncation
    return content.substring(0, maxChars);
}

// === QUALITY SCORING ===
calculateQualityScore(analysisResult) {
    if (!analysisResult) return 3;
    
    if (analysisResult.error) return 2;
    
    if (analysisResult.qualityScore) {
        return analysisResult.qualityScore;
    }
    
    let score = 5;
    
    // Bonus points for structured data
    if (analysisResult.primaryFields || analysisResult.fieldCategories) score += 2;
    if (analysisResult.businessLogic || analysisResult.businessRules) score += 1;
    if (analysisResult.recommendations && analysisResult.recommendations.length > 0) score += 1;
    if (analysisResult.lifecycleAnalysis) score += 1;
    
    return Math.min(Math.max(score, 1), 10);
}

// === COMPLETENESS ASSESSMENT ===
assessCompleteness(analysisResult) {
    if (!analysisResult) {
        return { score: 0, checkpoints: {}, completed: 0, total: 6 };
    }
    
    const checkpoints = {
        'Component Analysis': !!analysisResult && !analysisResult.error,
        'Field Analysis': !!(analysisResult.primaryFields || analysisResult.fieldCategories || analysisResult.fieldDetails),
        'Business Logic': !!(analysisResult.businessLogic || analysisResult.businessRules),
        'Dependencies': !!(analysisResult.dependencies || analysisResult.dependencyStatus),
        'Lifecycle Analysis': !!(analysisResult.lifecycleRole || analysisResult.lifecycleAnalysis),
        'Recommendations': !!(analysisResult.recommendations && analysisResult.recommendations.length > 0)
    };
    
    const completed = Object.values(checkpoints).filter(Boolean).length;
    const total = Object.keys(checkpoints).length;
    
    return {
        score: Math.round((completed / total) * 100),
        checkpoints: checkpoints,
        completed: completed,
        total: total
    };
}

// ===================================================================
// PART 7: MAIN ANALYSIS & INITIALIZATION METHODS
// Core analysis execution and chat initialization
// ===================================================================

// === MAIN COMPONENT ANALYSIS METHOD ===
async analyzeComponent() {
    const componentName = document.getElementById('componentName').value.trim();
    if (!componentName) {
        this.showError('Please enter a component name');
        return;
    }

    if (!this.serverValidated) {
        this.showError('Please validate LLM server connection first');
        return;
    }

    this.showLoading();
    this.updateProgress(0);

    try {
        console.log(`=== Starting Analysis for Component: ${componentName} ===`);
        this.updateLoadingStatus('🚀 Initializing focused component analysis...');
        
        // Check if component exists in uploaded files
        const relevantFiles = this.findRelevantFiles(componentName);
        if (relevantFiles.length === 0) {
            throw new Error(`Component "${componentName}" not found in uploaded files. Please check the component name and ensure related files are uploaded.`);
        }

        console.log(`Found ${relevantFiles.length} relevant files:`, relevantFiles.map(f => f.name));

        const results = await this.runLLMEnhancedAnalysisWithLifecycle(componentName);
        
        // Store results
        this.analysisResults[componentName] = results;
        this.currentAnalyzedComponent = componentName;
        
        // Update UI
        this.displayAnalysisResults(componentName, results);
        this.enableChat();
        this.saveToStorage();
        
        this.hideLoading();
        
        // Show success with details
        const successMessage = `✅ Analysis complete for ${componentName}! 
        Quality: ${results.qualityScore}/10 | 
        Files: ${results.filesAnalyzed.length} | 
        Dependencies: ${results.dependencyAnalysis?.summary?.foundCount || 0} found, ${results.dependencyAnalysis?.summary?.missingCount || 0} missing`;
        
        this.showSuccess(successMessage);
        
        console.log(`=== Analysis Complete for ${componentName} ===`);
        
    } catch (error) {
        this.hideLoading();
        console.error('Component analysis failed:', error);
        this.showError(`Analysis failed: ${error.message}`);
    }
}

// === DISPLAY ANALYSIS RESULTS ===
displayAnalysisResults(componentName, results) {
    console.log('Displaying analysis results for:', componentName);
    
    this.displayMainAnalysis(componentName, results);
    this.displayFieldMatrix(componentName, results);
    this.displayUsagePatterns(componentName, results);
    this.displayDependencies(componentName, results);
    
    // Switch to main results tab
    this.switchTab({ target: { dataset: { tab: 'lifecycle' } } });
}

// === DISPLAY MAIN ANALYSIS ===
displayMainAnalysis(componentName, results) {
    const container = document.getElementById('lifecycleContent');
    if (!container) return;
    
    let html = `
        <h3>🤖 Focused Component Analysis: ${componentName}</h3>
        <p style="margin-bottom: 20px;">
            Component: <strong>${results.componentType}</strong> • 
            Method: <strong>${results.analysisMethod}</strong> • 
            Files: <strong>${results.filesAnalyzed.length}</strong> • 
            Completed: <strong>${new Date(results.timestamp).toLocaleString()}</strong>
        </p>
        
        <!-- Quality Metrics -->
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 15px; margin-bottom: 25px;">
            <div style="background: rgba(76, 175, 80, 0.1); padding: 15px; border-radius: 8px; text-align: center; border-left: 4px solid #4CAF50;">
                <div style="font-size: 1.5rem; font-weight: bold; color: #FFD700;">${results.qualityScore}/10</div>
                <div style="font-size: 11px;">Analysis Quality</div>
            </div>
            <div style="background: rgba(33, 150, 243, 0.1); padding: 15px; border-radius: 8px; text-align: center; border-left: 4px solid #2196F3;">
                <div style="font-size: 1.5rem; font-weight: bold; color: #FFD700;">${results.completeness.score}%</div>
                <div style="font-size: 11px;">Completeness</div>
            </div>
            <div style="background: rgba(255, 152, 0, 0.1); padding: 15px; border-radius: 8px; text-align: center; border-left: 4px solid #FF9800;">
                <div style="font-size: 1.5rem; font-weight: bold; color: #FFD700;">${results.filesAnalyzed.length}</div>
                <div style="font-size: 11px;">Files Analyzed</div>
            </div>
            <div style="background: rgba(139, 92, 246, 0.1); padding: 15px; border-radius: 8px; text-align: center; border-left: 4px solid #8b5cf6;">
                <div style="font-size: 1.2rem; font-weight: bold; color: #FFD700;">${results.lifecycleFlow ? results.lifecycleFlow.scope : 'N/A'}</div>
                <div style="font-size: 11px;">Analysis Scope</div>
            </div>
        </div>
    `;

    // Display dependency analysis
    if (results.dependencyAnalysis) {
        html += this.displayDependencyAnalysis(results.dependencyAnalysis);
    }

    // Display LLM analysis results
    if (results.llmAnalysis) {
        if (results.llmAnalysis.error) {
            html += this.displayLLMError(results.llmAnalysis);
        } else {
            html += this.displayLLMResults(results.llmAnalysis, results.componentType);
        }
    }

    // Display lifecycle flow summary
    if (results.lifecycleFlow) {
        html += this.displayLifecycleFlowSummary(results.lifecycleFlow);
    }
    
    container.innerHTML = html;
}

// === DISPLAY LLM ERROR ===
displayLLMError(llmAnalysis) {
    return `
        <div style="background: rgba(239, 68, 68, 0.1); padding: 20px; border-radius: 10px; border-left: 4px solid #ef4444; margin-bottom: 20px;">
            <h4 style="color: #ef4444; margin-bottom: 15px;">⚠️ LLM Analysis Issue</h4>
            <p style="margin-bottom: 15px;">
                <strong>Issue:</strong> ${llmAnalysis.message || 'LLM analysis encountered an error'}
            </p>
            
            ${llmAnalysis.fallbackData ? `
                <div style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px; margin-top: 15px;">
                    <h5 style="color: #FFD700; margin-bottom: 10px;">🔧 Available Information:</h5>
                    ${this.displayFallbackData(llmAnalysis.fallbackData)}
                </div>
            ` : ''}
            
            <div style="margin-top: 15px; padding: 10px; background: rgba(255, 193, 7, 0.1); border-radius: 6px;">
                <strong style="color: #FFC107;">💡 Recommendations:</strong>
                <ul style="margin-top: 8px; margin-left: 20px;">
                    <li>Check LLM server connection and response format</li>
                    <li>Verify component exists in uploaded files</li>
                    <li>Try adjusting max tokens or simplifying the analysis</li>
                    <li>Use the chat interface for specific questions</li>
                </ul>
            </div>
        </div>
    `;
}

// === DISPLAY FALLBACK DATA ===
displayFallbackData(fallbackData) {
    if (!fallbackData) return '<p>No fallback data available</p>';
    
    let html = '';
    
    if (fallbackData.componentName) {
        html += `<p><strong>Component:</strong> ${fallbackData.componentName}</p>`;
    }
    
    if (fallbackData.componentType) {
        html += `<p><strong>Type:</strong> ${fallbackData.componentType}</p>`;
    }
    
    if (fallbackData.totalFields) {
        html += `<p><strong>Fields Found:</strong> ${fallbackData.totalFields}</p>`;
    }
    
    if (fallbackData.lifecycleAnalysis) {
        const lifecycle = fallbackData.lifecycleAnalysis;
        html += '<p><strong>Lifecycle Data:</strong></p>';
        html += `<ul style="margin-left: 20px;">`;
        if (lifecycle.creationPrograms && lifecycle.creationPrograms.length > 0) {
            html += `<li>Creation: ${lifecycle.creationPrograms.join(', ')}</li>`;
        }
        if (lifecycle.updatePrograms && lifecycle.updatePrograms.length > 0) {
            html += `<li>Update: ${lifecycle.updatePrograms.join(', ')}</li>`;
        }
        if (lifecycle.readPrograms && lifecycle.readPrograms.length > 0) {
            html += `<li>Read: ${lifecycle.readPrograms.join(', ')}</li>`;
        }
        html += '</ul>';
    }
    
    if (fallbackData.recommendations && fallbackData.recommendations.length > 0) {
        html += '<p><strong>Suggestions:</strong></p><ul style="margin-left: 20px;">';
        fallbackData.recommendations.forEach(rec => {
            html += `<li>${rec}</li>`;
        });
        html += '</ul>';
    }
    
    return html;
}

// === DISPLAY LLM RESULTS ===
displayLLMResults(llmAnalysis, componentType) {
    // Check if this is plain text analysis
    if (llmAnalysis.analysisMethod === 'SmartTextParser') {
        return this.displayPlainTextAnalysis(llmAnalysis);
    }
    
    // Otherwise, use existing display methods
    if (componentType === 'Copybook') {
        return this.displayCopybookLLMResults(llmAnalysis);
    } else if (componentType === 'COBOL Program') {
        return this.displayProgramLLMResults(llmAnalysis);
    } else {
        return this.displayGenericLLMResults(llmAnalysis);
    }
}

// === DISPLAY COPYBOOK LLM RESULTS ===
displayCopybookLLMResults(llmAnalysis) {
    let html = `
        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px; border-left: 4px solid #FFD700; margin-bottom: 20px;">
            <h4 style="color: #FFD700; margin-bottom: 15px;">🤖 Copybook Analysis Results</h4>
    `;

    // Component info
    if (llmAnalysis.componentName || llmAnalysis.totalFields) {
        html += `
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; margin-bottom: 20px;">
                ${llmAnalysis.componentName ? `
                    <div style="text-align: center; background: rgba(34, 197, 94, 0.1); padding: 8px; border-radius: 4px;">
                        <div style="font-size: 12px; font-weight: bold; color: #22c55e;">${llmAnalysis.componentName}</div>
                        <div style="font-size: 9px;">Component</div>
                    </div>
                ` : ''}
                ${llmAnalysis.totalFields ? `
                    <div style="text-align: center; background: rgba(59, 130, 246, 0.1); padding: 8px; border-radius: 4px;">
                        <div style="font-size: 12px; font-weight: bold; color: #3b82f6;">${llmAnalysis.totalFields}</div>
                        <div style="font-size: 9px;">01-Level Fields</div>
                    </div>
                ` : ''}
                ${llmAnalysis.analysisScope ? `
                    <div style="text-align: center; background: rgba(139, 92, 246, 0.1); padding: 8px; border-radius: 4px;">
                        <div style="font-size: 12px; font-weight: bold; color: #8b5cf6;">${llmAnalysis.analysisScope}</div>
                        <div style="font-size: 9px;">Scope</div>
                    </div>
                ` : ''}
            </div>
        `;
    }

    // Primary fields
    if (llmAnalysis.primaryFields && llmAnalysis.primaryFields.length > 0) {
        html += `
            <div style="margin-bottom: 20px;">
                <h5 style="color: #FFD700; margin-bottom: 10px;">📋 01-Level Fields Analysis:</h5>
                <div style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px; max-height: 200px; overflow-y: auto;">
                    ${llmAnalysis.primaryFields.map(field => `
                        <div style="margin-bottom: 8px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 4px; border-left: 3px solid #FFD700;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <strong style="font-family: monospace; color: #4dd0e1;">${field.name}</strong>
                                <span style="font-size: 10px; background: #FFD700; color: #000; padding: 2px 6px; border-radius: 3px;">
                                    ${field.usagePattern || 'ANALYZED'}
                                </span>
                            </div>
                            ${field.businessPurpose ? `
                                <div style="font-size: 11px; margin-top: 4px; opacity: 0.9;">${field.businessPurpose}</div>
                            ` : ''}
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    }

    // Dependency status
    if (llmAnalysis.dependencyStatus) {
        html += this.displayDependencyStatus(llmAnalysis.dependencyStatus);
    }

    // Lifecycle analysis
    if (llmAnalysis.lifecycleAnalysis) {
        html += this.displayLifecycleAnalysisResults(llmAnalysis.lifecycleAnalysis);
    }

    // Recommendations
    if (llmAnalysis.recommendations && llmAnalysis.recommendations.length > 0) {
        html += `
            <div style="margin-top: 20px;">
                <h5 style="color: #FFC107; margin-bottom: 10px;">💡 Recommendations:</h5>
                <div style="background: rgba(255, 193, 7, 0.1); padding: 15px; border-radius: 8px;">
                    ${llmAnalysis.recommendations.map((rec, index) => `
                        <div style="margin-bottom: 8px; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 4px;">
                            <strong style="color: #FFC107;">💡 ${index + 1}.</strong> ${rec}
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    }

    html += '</div>';
    return html;
}

// === DISPLAY DEPENDENCY STATUS ===
displayDependencyStatus(dependencyStatus) {
    return `
        <div style="margin-bottom: 20px;">
            <h5 style="color: #3b82f6; margin-bottom: 10px;">🔗 Dependency Status:</h5>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                <div style="background: rgba(34, 197, 94, 0.1); padding: 10px; border-radius: 6px;">
                    <div style="font-weight: bold; color: #22c55e; font-size: 12px; margin-bottom: 5px;">✅ Available</div>
                    <div style="font-size: 10px;">
                        <div><strong>Copybooks:</strong> ${(dependencyStatus.foundCopybooks || []).join(', ') || 'None'}</div>
                        <div><strong>Programs:</strong> ${(dependencyStatus.foundPrograms || []).join(', ') || 'None'}</div>
                    </div>
                </div>
                <div style="background: rgba(239, 68, 68, 0.1); padding: 10px; border-radius: 6px;">
                    <div style="font-weight: bold; color: #ef4444; font-size: 12px; margin-bottom: 5px;">❌ Missing</div>
                    <div style="font-size: 10px;">
                        <div><strong>Copybooks:</strong> ${(dependencyStatus.missingCopybooks || []).join(', ') || 'None'}</div>
                        <div><strong>Programs:</strong> ${(dependencyStatus.missingPrograms || []).join(', ') || 'None'}</div>
                    </div>
                </div>
            </div>
        </div>
    `;
}

// === DISPLAY LIFECYCLE ANALYSIS RESULTS ===
displayLifecycleAnalysisResults(lifecycleAnalysis) {
    return `
        <div style="margin-bottom: 20px;">
            <h5 style="color: #8b5cf6; margin-bottom: 10px;">🌊 Lifecycle Analysis:</h5>
            <div style="background: rgba(139, 92, 246, 0.1); padding: 15px; border-radius: 8px;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 10px;">
                    ${lifecycleAnalysis.creationPrograms && lifecycleAnalysis.creationPrograms.length > 0 ? `
                        <div style="text-align: center; background: rgba(34, 197, 94, 0.1); padding: 8px; border-radius: 4px;">
                            <div style="font-size: 12px; font-weight: bold; color: #22c55e;">${lifecycleAnalysis.creationPrograms.length}</div>
                            <div style="font-size: 9px;">🌱 Create</div>
                        </div>
                    ` : ''}
                    ${lifecycleAnalysis.updatePrograms && lifecycleAnalysis.updatePrograms.length > 0 ? `
                        <div style="text-align: center; background: rgba(245, 158, 11, 0.1); padding: 8px; border-radius: 4px;">
                            <div style="font-size: 12px; font-weight: bold; color: #f59e0b;">${lifecycleAnalysis.updatePrograms.length}</div>
                            <div style="font-size: 9px;">⚙️ Update</div>
                        </div>
                    ` : ''}
                    ${lifecycleAnalysis.readPrograms && lifecycleAnalysis.readPrograms.length > 0 ? `
                        <div style="text-align: center; background: rgba(59, 130, 246, 0.1); padding: 8px; border-radius: 4px;">
                            <div style="font-size: 12px; font-weight: bold; color: #3b82f6;">${lifecycleAnalysis.readPrograms.length}</div>
                            <div style="font-size: 9px;">📖 Read</div>
                        </div>
                    ` : ''}
                </div>
            </div>
        </div>
    `;
}

// === DISPLAY LIFECYCLE FLOW SUMMARY ===
displayLifecycleFlowSummary(lifecycleFlow) {
    if (!lifecycleFlow) return '';

    // Safe array access with defaults
    const creationCount = (lifecycleFlow.creationSources && Array.isArray(lifecycleFlow.creationSources)) 
        ? lifecycleFlow.creationSources.length : 0;
    const inputCount = (lifecycleFlow.inputPrograms && Array.isArray(lifecycleFlow.inputPrograms)) 
        ? lifecycleFlow.inputPrograms.length : 0;
    const updateCount = (lifecycleFlow.updatePrograms && Array.isArray(lifecycleFlow.updatePrograms)) 
        ? lifecycleFlow.updatePrograms.length : 0;
    const primaryFieldCount = (lifecycleFlow.primaryFields && Array.isArray(lifecycleFlow.primaryFields)) 
        ? lifecycleFlow.primaryFields.length : 0;

    return `
        <div style="background: rgba(139, 92, 246, 0.1); padding: 20px; border-radius: 10px; border-left: 4px solid #8b5cf6; margin-bottom: 20px;">
            <h4 style="color: #8b5cf6; margin-bottom: 15px;">🌊 Component Lifecycle Summary</h4>
            
            <!-- Component Scope -->
            <div style="margin-bottom: 15px; text-align: center;">
                <span style="background: ${this.getUsagePatternColor(lifecycleFlow.usagePattern || 'UNKNOWN')}; color: white; padding: 8px 16px; border-radius: 8px; font-weight: bold; font-size: 14px;">
                    ${lifecycleFlow.scope || 'COMPONENT_FOCUSED'} - ${(lifecycleFlow.usagePattern || 'UNKNOWN').replace(/_/g, ' ')}
                </span>
            </div>

            <!-- Lifecycle Metrics -->
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 12px;">
                ${primaryFieldCount > 0 ? `
                    <div style="text-align: center; background: rgba(255, 193, 7, 0.1); padding: 10px; border-radius: 6px;">
                        <div style="font-size: 1.2rem; font-weight: bold; color: #FFC107;">${primaryFieldCount}</div>
                        <div style="font-size: 10px;">📋 Primary Fields</div>
                    </div>
                ` : ''}
                <div style="text-align: center; background: rgba(34, 197, 94, 0.1); padding: 10px; border-radius: 6px;">
                    <div style="font-size: 1.2rem; font-weight: bold; color: #22c55e;">${creationCount}</div>
                    <div style="font-size: 10px;">🌱 Creation</div>
                </div>
                <div style="text-align: center; background: rgba(59, 130, 246, 0.1); padding: 10px; border-radius: 6px;">
                    <div style="font-size: 1.2rem; font-weight: bold; color: #3b82f6;">${inputCount}</div>
                    <div style="font-size: 10px;">📖 Reading</div>
                </div>
                <div style="text-align: center; background: rgba(245, 158, 11, 0.1); padding: 10px; border-radius: 6px;">
                    <div style="font-size: 1.2rem; font-weight: bold; color: #f59e0b;">${updateCount}</div>
                    <div style="font-size: 10px;">⚙️ Updating</div>
                </div>
            </div>
        </div>
    `;
}

getUsagePatternColor(pattern) {
    const colors = {
        'ONLINE_TRANSACTIONAL': '#22c55e',
        'BATCH_PROCESSING': '#3b82f6',
        'READ_ONLY': '#64748b',
        'CREATION_ONLY': '#f59e0b',
        'UPDATE_ONLY': '#ef4444',
        'FULL_LIFECYCLE': '#8b5cf6',
        'REFERENCE_ONLY': '#6b7280'
    };
    return colors[pattern] || '#6b7280';
}
// ===================================================================
// PART 8: CHAT, DISPLAY METHODS & INITIALIZATION
// Chat functionality and remaining display methods
// ===================================================================

// === CHAT INITIALIZATION ===
initializeChat() {
    this.initializeChatEventListeners();
}

initializeChatEventListeners() {
    const chatSendBtn = document.getElementById('chatSendBtn');
    const chatInput = document.getElementById('chatInput');
    
    if (chatSendBtn && chatInput) {
        chatSendBtn.addEventListener('click', () => this.sendChatMessage());
        
        chatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                this.sendChatMessage();
            }
        });
    }

    // Chat suggestions
    document.querySelectorAll('.chat-suggestion-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const question = e.target.dataset.question;
            if (chatInput && question) {
                chatInput.value = question;
                this.sendChatMessage();
            }
        });
    });
}

enableChat() {
    const chatInput = document.getElementById('chatInput');
    const chatSendBtn = document.getElementById('chatSendBtn');
    const chatSuggestions = document.getElementById('chatSuggestions');
    
    if (chatInput && chatSendBtn) {
        chatInput.disabled = false;
        chatSendBtn.disabled = false;
        
        if (chatSuggestions) {
            chatSuggestions.style.display = 'block';
        }
        
        this.addChatMessage('assistant', 
            `🎯 **Analysis complete for ${this.currentAnalyzedComponent}!**
            
I can now provide detailed insights about this component:

🧠 **Field Analysis:** Context-aware categorization with lifecycle tracking
⚖️ **Business Logic:** Extracted rules and validation patterns  
🔗 **Dependency Analysis:** Found vs missing dependencies
🌊 **Lifecycle Flow:** Complete usage pattern mapping

**Ask me about:**
• "Which fields are most important in this component?"
• "What programs create vs update this data?"  
• "What dependencies are missing and why?"
• "How can we optimize this component?"`
        );
    }
}

async sendChatMessage() {
    const input = document.getElementById('chatInput');
    const sendBtn = document.getElementById('chatSendBtn');
    const message = input.value.trim();
    
    if (!message) {
        this.showError('Please enter a message');
        return;
    }
    
    if (!this.currentAnalyzedComponent) {
        this.showError('Please analyze a component first');
        return;
    }
    
    input.disabled = true;
    sendBtn.disabled = true;
    sendBtn.textContent = 'Processing...';
    
    this.addChatMessage('user', message);
    input.value = '';
    
    this.showChatTyping();
    
    try {
        const response = await this.processEnhancedChatQuery(message);
        this.hideChatTyping();
        this.addChatMessage('assistant', response);
    } catch (error) {
        console.error('Chat error:', error);
        this.hideChatTyping();
        this.addChatMessage('assistant', `I apologize, but I encountered an error: ${error.message}. Please try rephrasing your question.`);
    } finally {
        input.disabled = false;
        sendBtn.disabled = false;
        sendBtn.textContent = 'Send';
        input.focus();
    }
}

async processEnhancedChatQuery(question) {
    const analysisData = this.analysisResults[this.currentAnalyzedComponent];
    
    let context = `MAINFRAME COMPONENT ANALYSIS CHAT

COMPONENT: ${this.currentAnalyzedComponent}
COMPONENT TYPE: ${analysisData.componentType}
ANALYSIS METHOD: ${analysisData.analysisMethod}
FILES ANALYZED: ${analysisData.filesAnalyzed.join(', ')}

ANALYSIS RESULTS:
${JSON.stringify(analysisData.llmAnalysis, null, 2)}

LIFECYCLE FLOW:
${JSON.stringify(analysisData.lifecycleFlow, null, 2)}

DEPENDENCY ANALYSIS:
${JSON.stringify(analysisData.dependencyAnalysis, null, 2)}

USER QUESTION: "${question}"

Provide a detailed, helpful response based on the analysis data above. Use specific examples and data from the analysis.`;

    const response = await this.callLLMAPI(context);
    
    if (typeof response === 'string') {
        return response;
    } else if (response.rawResponse) {
        return response.rawResponse;
    } else if (response.error) {
        return `Based on the available analysis data: ${response.fallbackData?.recommendations?.join('. ') || 'Please check the analysis results for more details.'}`;
    }
    
    return 'I can provide information based on the component analysis. What specific aspect would you like to know more about?';
}

addChatMessage(sender, content) {
    const messagesContainer = document.getElementById('chatMessages');
    if (!messagesContainer) return;
    
    const messageId = 'msg_' + Date.now();
    const messageDiv = document.createElement('div');
    messageDiv.className = `chat-message ${sender}`;
    messageDiv.id = messageId;
    
    messageDiv.innerHTML = `
        <div class="sender">${sender === 'user' ? 'You' : 'Analysis Assistant'}</div>
        <div class="content">${this.formatChatMessage(content)}</div>
        <div class="timestamp">${new Date().toLocaleTimeString()}</div>
    `;
    
    messagesContainer.appendChild(messageDiv);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
    
    this.chatHistory.push({
        id: messageId,
        sender: sender,
        content: content,
        timestamp: new Date().toISOString()
    });
}

formatChatMessage(content) {
    return content
        .replace(/\n/g, '<br>')
        .replace(/\*\*([^*]+)\*\*/g, '<strong style="color: #FFD700;">$1</strong>')
        .replace(/`([^`]+)`/g, '<code style="background: rgba(0,0,0,0.3); padding: 2px 4px; border-radius: 3px; color: #4CAF50; font-family: monospace;">$1</code>')
        .replace(/^- /gm, '• ')
        .replace(/^• /gm, '<span style="color: #4CAF50;">•</span> ')
        .replace(/🧠|⚖️|🔗|💡|🎯|📊|🔍|🚀|🌊|⚙️|🖥️|📤/g, '<span style="font-size: 1.2em;">$&</span>');
}

addChatMessage(sender, content) {
    const messagesContainer = document.getElementById('chatMessages');
    if (!messagesContainer) return;
    
    const messageId = 'msg_' + Date.now();
    const messageDiv = document.createElement('div');
    messageDiv.className = `chat-message ${sender}`;
    messageDiv.id = messageId;
    
    messageDiv.innerHTML = `
        <div class="sender">${sender === 'user' ? 'You' : 'Analysis Assistant'}</div>
        <div class="content">${this.formatChatMessage(content)}</div>
        <div class="timestamp">${new Date().toLocaleTimeString()}</div>
    `;
    
    messagesContainer.appendChild(messageDiv);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
    
    this.chatHistory.push({
        id: messageId,
        sender: sender,
        content: content,
        timestamp: new Date().toISOString()
    });
}

showChatTyping() {
    const messagesContainer = document.getElementById('chatMessages');
    if (!messagesContainer) return;
    
    this.hideChatTyping();
    
    const typingDiv = document.createElement('div');
    typingDiv.id = 'typingIndicator';
    typingDiv.className = 'chat-message assistant';
    
    typingDiv.innerHTML = `
        <div class="sender">Analysis Assistant</div>
        <div class="content">
            <span style="opacity: 0.7;">🤖 Processing your question...</span>
            <span style="animation: blink 1s infinite; margin-left: 5px;">●●●</span>
        </div>
    `;
    
    messagesContainer.appendChild(typingDiv);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

hideChatTyping() {
    const typingIndicator = document.getElementById('typingIndicator');
    if (typingIndicator && typingIndicator.parentNode) {
        typingIndicator.parentNode.removeChild(typingIndicator);
    }
}

// === OTHER DISPLAY METHODS ===
displayFieldMatrix(componentName, results) {
    const container = document.getElementById('fieldMatrixContent');
    if (!container) return;
    
    let html = `
        <h3>📋 Field Matrix Analysis: ${componentName}</h3>
        <p style="margin-bottom: 20px;">Field-level analysis with lifecycle context.</p>
    `;
    
    if (results.componentType === 'Copybook' && results.llmAnalysis && results.llmAnalysis.primaryFields) {
        html += this.displayDetailedFieldMatrix(results.llmAnalysis.primaryFields);
    } else {
        html += `
            <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px; text-align: center;">
                <p style="opacity: 0.8;">Field matrix analysis is available for copybook components with field analysis.</p>
            </div>
        `;
    }
    
    container.innerHTML = html;
}

displayDetailedFieldMatrix(primaryFields) {
    return `
        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px;">
            <h4 style="color: #FFD700; margin-bottom: 15px;">🤖 Field Analysis Matrix</h4>
            <div style="overflow-x: auto;">
                <table style="width: 100%; border-collapse: collapse; font-size: 12px;">
                    <thead>
                        <tr style="background: rgba(0,0,0,0.3);">
                            <th style="padding: 8px; text-align: left; border: 1px solid rgba(255,255,255,0.1); color: #FFD700;">Field Name</th>
                            <th style="padding: 8px; text-align: center; border: 1px solid rgba(255,255,255,0.1); color: #4CAF50;">Level</th>
                            <th style="padding: 8px; text-align: center; border: 1px solid rgba(255,255,255,0.1); color: #2196F3;">Usage Pattern</th>
                            <th style="padding: 8px; text-align: left; border: 1px solid rgba(255,255,255,0.1); color: #FF9800;">Business Purpose</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${primaryFields.map(field => `
                            <tr style="border-bottom: 1px solid rgba(255,255,255,0.1);">
                                <td style="padding: 6px 8px; font-family: monospace; font-weight: bold;">${field.name}</td>
                                <td style="padding: 6px 8px; text-align: center;">${field.level || '01'}</td>
                                <td style="padding: 6px 8px; text-align: center; color: #2196F3; font-weight: bold; font-size: 10px;">${field.usagePattern || 'UNKNOWN'}</td>
                                <td style="padding: 6px 8px; font-size: 10px; max-width: 200px; word-wrap: break-word;">${field.businessPurpose || 'Not specified'}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            </div>
        </div>
    `;
}

displayUsagePatterns(componentName, results) {
    const container = document.getElementById('usageContent');
    if (!container) return;
    
    let html = `
        <h3>📈 Usage Patterns: ${componentName}</h3>
        <p style="margin-bottom: 20px;">Component usage pattern analysis.</p>
    `;
    
    if (results.lifecycleFlow) {
        html += this.displayUsagePatternDetails(results.lifecycleFlow);
    } else {
        html += `
            <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px; text-align: center;">
                <p style="opacity: 0.8;">Usage patterns will appear here after analysis.</p>
            </div>
        `;
    }
    
    container.innerHTML = html;
}

displayUsagePatternDetails(lifecycleFlow) {
    return `
        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px;">
            <h4 style="color: #FFD700; margin-bottom: 15px;">📊 Usage Pattern Analysis</h4>
            
            <div style="margin-bottom: 20px;">
                <h5 style="color: #8b5cf6; margin-bottom: 10px;">Pattern: ${lifecycleFlow.usagePattern}</h5>
                <div style="background: ${this.getUsagePatternColor(lifecycleFlow.usagePattern)}; color: white; padding: 10px; border-radius: 6px; text-align: center; font-weight: bold;">
                    ${lifecycleFlow.usagePattern.replace(/_/g, ' ')}
                </div>
            </div>
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                <div style="background: rgba(34, 197, 94, 0.1); padding: 15px; border-radius: 8px;">
                    <h6 style="color: #22c55e; margin-bottom: 10px;">🌱 Creation Sources</h6>
                    <div style="font-size: 12px;">${lifecycleFlow.creationSources.length} programs</div>
                    ${lifecycleFlow.creationSources.slice(0, 3).map(s => `
                        <div style="font-size: 10px; margin-top: 4px; opacity: 0.8;">${s.program}</div>
                    `).join('')}
                </div>
                
                <div style="background: rgba(59, 130, 246, 0.1); padding: 15px; border-radius: 8px;">
                    <h6 style="color: #3b82f6; margin-bottom: 10px;">📖 Reading Programs</h6>
                    <div style="font-size: 12px;">${lifecycleFlow.inputPrograms.length} programs</div>
                    ${lifecycleFlow.inputPrograms.slice(0, 3).map(p => `
                        <div style="font-size: 10px; margin-top: 4px; opacity: 0.8;">${p.program}</div>
                    `).join('')}
                </div>
                
                <div style="background: rgba(245, 158, 11, 0.1); padding: 15px; border-radius: 8px;">
                    <h6 style="color: #f59e0b; margin-bottom: 10px;">⚙️ Update Programs</h6>
                    <div style="font-size: 12px;">${lifecycleFlow.updatePrograms.length} programs</div>
                    ${lifecycleFlow.updatePrograms.slice(0, 3).map(u => `
                        <div style="font-size: 10px; margin-top: 4px; opacity: 0.8;">${u.program}</div>
                    `).join('')}
                </div>
            </div>
        </div>
    `;
}

displayDependencies(componentName, results) {
    const container = document.getElementById('dependenciesContent');
    if (!container) return;
    
    let html = `
        <h3>🔗 Dependency Analysis: ${componentName}</h3>
        <p style="margin-bottom: 20px;">Found vs missing dependencies.</p>
    `;
    
    if (results.dependencyAnalysis) {
        html += this.displayDependencyAnalysis(results.dependencyAnalysis);
    } else {
        html += `
            <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px; text-align: center;">
                <p style="opacity: 0.8;">Dependency analysis will appear here after component analysis.</p>
            </div>
        `;
    }
    
    container.innerHTML = html;
}

// === BULK ANALYSIS AND EXPORT ===
async bulkAnalyze() {
    if (this.uploadedFiles.length === 0) {
        this.showError('No files uploaded for bulk analysis');
        return;
    }

    this.showLoading();
    this.updateLoadingStatus('🔄 Starting bulk analysis...');

    const components = this.componentSuggestions
        .filter(c => c.type === 'RECORD_LAYOUT' || c.type === 'PROGRAM')
        .slice(0, 5);
    let completed = 0;

    try {
        for (const component of components) {
            this.updateLoadingStatus(`Analyzing ${component.name} (${completed + 1}/${components.length})...`);
            this.updateProgress((completed / components.length) * 100);
            
            try {
                document.getElementById('componentName').value = component.name;
                const results = await this.runLLMEnhancedAnalysisWithLifecycle(component.name);
                this.analysisResults[component.name] = results;
                completed++;
                
                await this.sleep(3000);
            } catch (error) {
                console.warn(`Failed to analyze ${component.name}:`, error);
            }
        }

        this.hideLoading();
        this.saveToStorage();
        this.showSuccess(`✨ Bulk analysis complete! ${completed}/${components.length} components analyzed`);

    } catch (error) {
        this.hideLoading();
        this.showError(`Bulk analysis failed: ${error.message}`);
    }
}

async exportResults(format) {
    if (Object.keys(this.analysisResults).length === 0) {
        this.showError('No analysis results to export');
        return;
    }

    try {
        if (format === 'json') {
            await this.exportAsJSON();
        } else if (format === 'markdown') {
            await this.exportAsMarkdown();
        }
    } catch (error) {
        this.showError(`Export failed: ${error.message}`);
    }
}

async exportAsJSON() {
    const exportData = {
        metadata: {
            timestamp: new Date().toISOString(),
            totalComponents: Object.keys(this.analysisResults).length,
            totalFiles: this.uploadedFiles.length,
            analysisMethod: 'LLM-Enhanced-Focused',
            version: '5.0.0-focused'
        },
        analysisResults: this.analysisResults,
        chatHistory: this.chatHistory
    };

    const dataStr = JSON.stringify(exportData, null, 2);
    const filename = `mainframe-analysis-${new Date().toISOString().split('T')[0]}.json`;
    
    this.downloadTextFile(dataStr, filename);
    this.showSuccess(`📋 Analysis results exported as ${filename}`);
}

async exportAsMarkdown() {
    let markdown = `# Mainframe Component Analysis Report\n\n`;
    markdown += `**Generated:** ${new Date().toLocaleString()}\n`;
    markdown += `**Analysis Method:** LLM-Enhanced Focused Analysis\n\n`;

    for (const [componentName, results] of Object.entries(this.analysisResults)) {
        markdown += `## ${componentName}\n\n`;
        markdown += `**Type:** ${results.componentType}\n`;
        markdown += `**Quality Score:** ${results.qualityScore}/10\n`;
        markdown += `**Usage Pattern:** ${results.lifecycleFlow?.usagePattern || 'N/A'}\n\n`;
        
        if (results.llmAnalysis?.recommendations) {
            markdown += `**Recommendations:**\n`;
            results.llmAnalysis.recommendations.forEach(rec => {
                markdown += `- ${rec}\n`;
            });
        }
        markdown += '\n---\n\n';
    }
    
    const filename = `mainframe-analysis-report-${new Date().toISOString().split('T')[0]}.md`;
    this.downloadTextFile(markdown, filename);
    this.showSuccess(`📝 Analysis report exported as ${filename}`);
}

downloadTextFile(content, filename) {
    const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

} // End of class

// === INITIALIZATION ===
document.addEventListener('DOMContentLoaded', function() {
    window.analyzer = new EnhancedMainframeAnalyzer();
    
    console.log('🚀 Enhanced Mainframe Analyzer with Focused Analysis Ready!');
    console.log('✅ Key Features:');
    console.log('   • Focused 01-level field analysis for copybooks');
    console.log('   • Found vs missing dependency tracking');
    console.log('   • Component-specific lifecycle analysis');
    console.log('   • Improved LLM response handling');
    console.log('   • Enhanced chat with component context');
    console.log('🎯 Ready for precise mainframe component analysis!');
});

// Fallback initialization
if (document.readyState === 'loading') {
    // Document still loading, wait for DOMContentLoaded
} else {
    // Document already loaded
    window.analyzer = new EnhancedMainframeAnalyzer();
    console.log('🚀 Enhanced Mainframe Analyzer initialized (fallback)');
}
        
</script>
</body>
</html>