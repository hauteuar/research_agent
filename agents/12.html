<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Mainframe Analyzer</title>
    <style>
        /* Your existing styles remain the same */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 25%, #334155 50%, #475569 75%, #64748b 100%);
            color: #f8fafc;
            min-height: 100vh;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 50%, rgba(120, 119, 198, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.08) 0%, transparent 50%),
                radial-gradient(circle at 40% 80%, rgba(120, 198, 121, 0.06) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 30px;
            background: rgba(15, 23, 42, 0.7);
            backdrop-filter: blur(20px);
            border-radius: 24px;
            border: 1px solid rgba(148, 163, 184, 0.2);
            box-shadow: 
                0 20px 25px -5px rgba(0, 0, 0, 0.1),
                0 10px 10px -5px rgba(0, 0, 0, 0.04),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .header h1 {
            font-size: 3.2rem;
            margin-bottom: 12px;
            font-weight: 800;
            background: linear-gradient(135deg, #06b6d4 0%, #3b82f6 25%, #8b5cf6 50%, #ec4899 75%, #f59e0b 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: none;
            letter-spacing: -0.02em;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 520px 1fr 400px;
            gap: 25px;
            min-height: 80vh;
        }

        .control-panel, .analysis-workspace, .chat-panel {
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 28px;
            border: 1px solid rgba(148, 163, 184, 0.2);
            box-shadow: 
                0 10px 15px -3px rgba(0, 0, 0, 0.1),
                0 4px 6px -2px rgba(0, 0, 0, 0.05),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .control-panel {
            height: fit-content;
            max-height: 85vh;
            overflow-y: auto;
        }

        .analysis-workspace {
            min-height: 80vh;
            overflow-y: auto;
        }

        .chat-panel {
            display: flex;
            flex-direction: column;
            max-height: 85vh;
        }

        /* Component Search Section */
        .component-search-section {
            margin-bottom: 25px;
            padding: 24px;
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.1) 0%, rgba(16, 185, 129, 0.08) 100%);
            border-radius: 16px;
            border: 1px solid rgba(34, 197, 94, 0.3);
            box-shadow: 0 4px 6px -1px rgba(34, 197, 94, 0.1);
        }

        .component-input {
            width: 100%;
            padding: 14px 16px;
            border: 2px solid rgba(148, 163, 184, 0.3);
            border-radius: 12px;
            background: rgba(30, 41, 59, 0.6);
            color: #f8fafc;
            font-size: 14px;
            margin-bottom: 10px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 500;
        }

        .component-input:focus {
            outline: none;
            border-color: #06b6d4;
            background: rgba(30, 41, 59, 0.8);
            box-shadow: 
                0 0 0 3px rgba(6, 182, 212, 0.1),
                0 4px 6px -1px rgba(6, 182, 212, 0.1);
            transform: translateY(-1px);
        }

        .component-input::placeholder {
            color: rgba(148, 163, 184, 0.7);
        }

        .component-suggestions {
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 12px;
            max-height: 150px;
            overflow-y: auto;
            display: none;
            border: 1px solid rgba(148, 163, 184, 0.3);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
        }

        .suggestion-item {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid rgba(148, 163, 184, 0.1);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 13px;
        }

        .suggestion-item:hover {
            background: linear-gradient(135deg, rgba(6, 182, 212, 0.1) 0%, rgba(59, 130, 246, 0.05) 100%);
            transform: translateX(4px);
            border-left: 3px solid #06b6d4;
        }

        /* Token Management */
        .token-info {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.1) 0%, rgba(217, 119, 6, 0.08) 100%);
            border: 1px solid rgba(245, 158, 11, 0.3);
            border-radius: 12px;
            padding: 16px;
            margin: 12px 0;
            font-size: 12px;
            box-shadow: 0 4px 6px -1px rgba(245, 158, 11, 0.1);
        }

        .token-bar {
            background: rgba(15, 23, 42, 0.6);
            height: 8px;
            border-radius: 4px;
            margin: 10px 0;
            overflow: hidden;
            border: 1px solid rgba(148, 163, 184, 0.2);
        }

        .token-fill {
            height: 100%;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 4px;
            background: linear-gradient(90deg, var(--token-color-start), var(--token-color-end));
        }

        .token-fill.safe { 
            --token-color-start: #22c55e;
            --token-color-end: #16a34a;
        }
        .token-fill.warning { 
            --token-color-start: #f59e0b;
            --token-color-end: #d97706;
        }
        .token-fill.danger { 
            --token-color-start: #ef4444;
            --token-color-end: #dc2626;
        }

        /* General Form Styles */
        .section-title { 
            color: #06b6d4; 
            font-size: 1.3rem; 
            margin-bottom: 18px; 
            font-weight: 700; 
            display: flex; 
            align-items: center; 
            gap: 12px;
            letter-spacing: -0.01em;
        }

        .form-group { 
            margin-bottom: 20px; 
        }

        .form-group input, 
        .form-group select, 
        .form-group textarea { 
            width: 100%; 
            padding: 14px 16px; 
            border: 2px solid rgba(148, 163, 184, 0.3); 
            border-radius: 12px; 
            background: rgba(30, 41, 59, 0.6); 
            color: #f8fafc; 
            font-size: 14px; 
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 500;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #06b6d4;
            background: rgba(30, 41, 59, 0.8);
            box-shadow: 
                0 0 0 3px rgba(6, 182, 212, 0.1),
                0 4px 6px -1px rgba(6, 182, 212, 0.1);
            transform: translateY(-1px);
        }

        .form-group input::placeholder,
        .form-group textarea::placeholder {
            color: rgba(148, 163, 184, 0.7);
        }

        .action-btn { 
            width: 100%; 
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); 
            color: white; 
            border: none; 
            padding: 16px 20px; 
            border-radius: 12px; 
            cursor: pointer; 
            font-size: 15px; 
            font-weight: 600; 
            margin-bottom: 12px; 
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); 
            text-transform: uppercase; 
            letter-spacing: 0.5px;
            box-shadow: 0 4px 6px -1px rgba(239, 68, 68, 0.25);
        }

        .action-btn:hover:not(:disabled) { 
            transform: translateY(-2px); 
            box-shadow: 0 10px 15px -3px rgba(239, 68, 68, 0.4);
            background: linear-gradient(135deg, #f87171 0%, #ef4444 100%);
        }

        .action-btn:active:not(:disabled) {
            transform: translateY(0);
        }

        .action-btn:disabled { 
            opacity: 0.5; 
            cursor: not-allowed; 
            transform: none; 
            box-shadow: none; 
        }

        .validate-btn { 
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%); 
            box-shadow: 0 4px 6px -1px rgba(34, 197, 94, 0.25);
        }

        .validate-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
            box-shadow: 0 10px 15px -3px rgba(34, 197, 94, 0.4);
        }

        .component-btn { 
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%); 
            box-shadow: 0 4px 6px -1px rgba(34, 197, 94, 0.25);
        }

        .component-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
            box-shadow: 0 10px 15px -3px rgba(34, 197, 94, 0.4);
        }

        .secondary-btn { 
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); 
            box-shadow: 0 4px 6px -1px rgba(59, 130, 246, 0.25);
        }

        .secondary-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #60a5fa 0%, #3b82f6 100%);
            box-shadow: 0 10px 15px -3px rgba(59, 130, 246, 0.4);
        }

        /* API Status */
        .api-status {
            padding: 14px 16px;
            border-radius: 12px;
            margin-top: 12px;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .api-status.connected {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.15) 0%, rgba(22, 163, 74, 0.1) 100%);
            border: 1px solid rgba(34, 197, 94, 0.3);
            color: #4ade80;
            box-shadow: 0 4px 6px -1px rgba(34, 197, 94, 0.1);
        }

        .api-status.connecting {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.15) 0%, rgba(217, 119, 6, 0.1) 100%);
            border: 1px solid rgba(245, 158, 11, 0.3);
            color: #fbbf24;
            box-shadow: 0 4px 6px -1px rgba(245, 158, 11, 0.1);
        }

        .api-status.disconnected {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.15) 0%, rgba(220, 38, 38, 0.1) 100%);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: #f87171;
            box-shadow: 0 4px 6px -1px rgba(239, 68, 68, 0.1);
        }

        /* Upload Area */
        .upload-area {
            border: 2px dashed rgba(148, 163, 184, 0.4);
            border-radius: 16px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            margin-bottom: 20px;
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.3) 0%, rgba(51, 65, 85, 0.2) 100%);
        }

        .upload-area:hover {
            border-color: #06b6d4;
            background: linear-gradient(135deg, rgba(6, 182, 212, 0.1) 0%, rgba(59, 130, 246, 0.05) 100%);
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(6, 182, 212, 0.1);
        }

        .upload-area.drag-over {
            border-color: #22c55e;
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.15) 0%, rgba(16, 185, 129, 0.1) 100%);
            transform: scale(1.02);
        }

        .file-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .file-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .file-info {
            flex: 1;
        }

        .file-name {
            font-weight: bold;
            margin-bottom: 2px;
        }

        .file-details {
            font-size: 11px;
            opacity: 0.8;
        }

        .file-remove {
            background: #f44336;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .file-remove:hover {
            background: #d32f2f;
        }

        /* Loading Indicator */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.95) 0%, rgba(30, 41, 59, 0.9) 100%);
            backdrop-filter: blur(20px);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 9999;
        }

        .loading.show {
            display: flex;
        }

        .spinner {
            width: 80px;
            height: 80px;
            border: 4px solid rgba(148, 163, 184, 0.3);
            border-top: 4px solid #06b6d4;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 24px;
            box-shadow: 0 0 20px rgba(6, 182, 212, 0.3);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading h3 {
            color: #06b6d4;
            margin-bottom: 12px;
            font-size: 1.5rem;
            font-weight: 700;
        }

        .loading p {
            color: rgba(248, 250, 252, 0.8);
            text-align: center;
            max-width: 400px;
            font-size: 1.1rem;
        }

        /* Tabs */
        .tabs {
            display: flex;
            margin-bottom: 25px;
            background: rgba(15, 23, 42, 0.6);
            border-radius: 16px;
            padding: 6px;
            border: 1px solid rgba(148, 163, 184, 0.2);
        }

        .tab {
            flex: 1;
            background: transparent;
            color: rgba(148, 163, 184, 0.8);
            border: none;
            padding: 14px 12px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            letter-spacing: 0.3px;
        }

        .tab.active {
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
            color: #ffffff;
            box-shadow: 0 4px 6px -1px rgba(6, 182, 212, 0.25);
        }

        .tab:hover:not(.active) {
            background: rgba(148, 163, 184, 0.1);
            color: #f8fafc;
            transform: translateY(-1px);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Message Types */
        .error, .success, .warning {
            position: fixed;
            top: 24px;
            right: 24px;
            padding: 16px 24px;
            border-radius: 12px;
            font-weight: 600;
            z-index: 10000;
            animation: slideInRight 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(20px);
        }

        .error {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.95) 0%, rgba(220, 38, 38, 0.9) 100%);
            color: #ffffff;
            border: 1px solid rgba(239, 68, 68, 0.5);
        }

        .success {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.95) 0%, rgba(22, 163, 74, 0.9) 100%);
            color: #ffffff;
            border: 1px solid rgba(34, 197, 94, 0.5);
        }

        .warning {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.95) 0%, rgba(217, 119, 6, 0.9) 100%);
            color: #ffffff;
            border: 1px solid rgba(245, 158, 11, 0.5);
        }

        @keyframes slideInRight {
            from { 
                transform: translateX(100%); 
                opacity: 0;
            }
            to { 
                transform: translateX(0); 
                opacity: 1;
            }
        }

        /* Enhanced Chat Styles */
        .chat-suggestions {
            margin-bottom: 15px;
            padding: 15px;
            background: rgba(30, 41, 59, 0.6);
            border-radius: 12px;
            border: 1px solid rgba(148, 163, 184, 0.2);
        }

        .chat-suggestion-btn {
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.8) 0%, rgba(51, 65, 85, 0.6) 100%);
            border: 1px solid rgba(148, 163, 184, 0.3);
            color: #f8fafc;
            padding: 8px 14px;
            border-radius: 20px;
            font-size: 11px;
            cursor: pointer;
            margin: 4px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: inline-block;
            font-weight: 500;
        }

        .chat-suggestion-btn:hover {
            background: linear-gradient(135deg, rgba(6, 182, 212, 0.2) 0%, rgba(59, 130, 246, 0.15) 100%);
            border-color: #06b6d4;
            transform: translateY(-2px);
            box-shadow: 0 4px 6px -1px rgba(6, 182, 212, 0.25);
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 15px;
            padding: 15px;
            background: rgba(30, 41, 59, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(148, 163, 184, 0.2);
            max-height: 400px;
        }

        .chat-input-section {
            display: flex;
            gap: 10px;
            padding: 15px;
            background: rgba(30, 41, 59, 0.6);
            border-radius: 12px;
            border: 1px solid rgba(148, 163, 184, 0.2);
        }

        .chat-input {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid rgba(148, 163, 184, 0.3);
            border-radius: 10px;
            background: rgba(30, 41, 59, 0.6);
            color: #f8fafc;
            font-size: 14px;
            resize: none;
            min-height: 40px;
            max-height: 120px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .chat-send-btn {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 6px -1px rgba(34, 197, 94, 0.25);
            min-width: 80px;
        }

        .chat-send-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(34, 197, 94, 0.4);
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
        }

        .chat-send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .chat-message {
            margin-bottom: 20px;
            padding: 20px;
            border-radius: 16px;
            max-width: 90%;
            word-wrap: break-word;
            line-height: 1.6;
            animation: fadeInUp 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .chat-message.user {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.2) 0%, rgba(37, 99, 235, 0.15) 100%);
            border: 1px solid rgba(59, 130, 246, 0.3);
            margin-left: auto;
            text-align: right;
        }

        .chat-message.assistant {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.15) 0%, rgba(22, 163, 74, 0.1) 100%);
            border: 1px solid rgba(34, 197, 94, 0.3);
        }

        .chat-message .sender {
            font-weight: bold;
            font-size: 12px;
            opacity: 0.8;
            margin-bottom: 8px;
        }

        .chat-message .content {
            font-size: 14px;
            line-height: 1.6;
        }

        .chat-message .timestamp {
            font-size: 10px;
            opacity: 0.6;
            margin-top: 8px;
        }

        .chat-message .export-btn {
            position: absolute;
            top: 12px;
            right: 12px;
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.8) 0%, rgba(51, 65, 85, 0.7) 100%);
            border: 1px solid rgba(148, 163, 184, 0.3);
            border-radius: 8px;
            padding: 6px 10px;
            font-size: 10px;
            color: #f8fafc;
            cursor: pointer;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 500;
        }

        .chat-message:hover .export-btn {
            opacity: 1;
        }

        .chat-message .export-btn:hover {
            background: linear-gradient(135deg, rgba(6, 182, 212, 0.2) 0%, rgba(59, 130, 246, 0.15) 100%);
            border-color: #06b6d4;
            transform: translateY(-1px);
        }

        /* Lifecycle Flow Styles */
        .lifecycle-flow {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid #8b5cf6;
        }

        .lifecycle-step {
            display: flex;
            align-items: center;
            margin: 15px 0;
            padding: 12px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            position: relative;
        }

        .lifecycle-step::before {
            content: '';
            position: absolute;
            left: -10px;
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
            height: 8px;
            background: #8b5cf6;
            border-radius: 50%;
            border: 2px solid #1e293b;
        }

        .lifecycle-step.active::before {
            background: #22c55e;
            box-shadow: 0 0 10px rgba(34, 197, 94, 0.5);
        }

        .lifecycle-step-icon {
            margin-right: 12px;
            font-size: 1.2em;
        }

        .lifecycle-step-content {
            flex: 1;
        }

        .lifecycle-step-title {
            font-weight: bold;
            color: #f8fafc;
            margin-bottom: 4px;
        }

        .lifecycle-step-description {
            font-size: 12px;
            opacity: 0.8;
            line-height: 1.4;
        }

        .lifecycle-step-programs {
            margin-top: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .program-tag {
            background: rgba(59, 130, 246, 0.2);
            color: #93c5fd;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 10px;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }

        .field-flow-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid #f59e0b;
        }

        .field-flow-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .field-flow-category {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            border-left: 3px solid var(--category-color);
        }

        .field-flow-category h6 {
            color: var(--category-color);
            margin-bottom: 10px;
            font-size: 13px;
            font-weight: 600;
        }

        .field-flow-list {
            max-height: 150px;
            overflow-y: auto;
        }

        .field-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 8px;
            margin: 4px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            font-size: 11px;
            font-family: monospace;
        }

        .field-name {
            font-weight: bold;
        }

        .field-usage {
            font-size: 9px;
            opacity: 0.7;
        }

        .usage-pattern-visual {
            display: flex;
            align-items: center;
            margin: 10px 0;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
        }

        .usage-bar {
            height: 6px;
            background: rgba(148, 163, 184, 0.3);
            border-radius: 3px;
            margin: 0 10px;
            flex: 1;
            overflow: hidden;
        }

        .usage-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--usage-color-start), var(--usage-color-end));
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        .usage-label {
            font-size: 10px;
            font-weight: 600;
            min-width: 60px;
        }

        .usage-percentage {
            font-size: 10px;
            opacity: 0.8;
            min-width: 40px;
            text-align: right;
        }

        /* Export Buttons */
        .export-section {
            margin-top: 20px;
            padding: 20px;
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.1) 0%, rgba(217, 119, 6, 0.08) 100%);
            border-radius: 16px;
            border: 1px solid rgba(245, 158, 11, 0.3);
            box-shadow: 0 4px 6px -1px rgba(245, 158, 11, 0.1);
        }

        .export-btn-group {
            display: flex;
            gap: 12px;
            margin-top: 12px;
        }

        .export-btn-small {
            flex: 1;
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 6px -1px rgba(139, 92, 246, 0.25);
        }

        .export-btn-small:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(139, 92, 246, 0.4);
            background: linear-gradient(135deg, #a78bfa 0%, #8b5cf6 100%);
        }

        .export-btn-small:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Scrollbar Styles */
        .chat-messages::-webkit-scrollbar,
        .file-list::-webkit-scrollbar,
        .component-suggestions::-webkit-scrollbar,
        .field-flow-list::-webkit-scrollbar {
            width: 8px;
        }

        .chat-messages::-webkit-scrollbar-track,
        .file-list::-webkit-scrollbar-track,
        .component-suggestions::-webkit-scrollbar-track,
        .field-flow-list::-webkit-scrollbar-track {
            background: rgba(30, 41, 59, 0.3);
            border-radius: 4px;
        }

        .chat-messages::-webkit-scrollbar-thumb,
        .file-list::-webkit-scrollbar-thumb,
        .component-suggestions::-webkit-scrollbar-thumb,
        .field-flow-list::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #64748b 0%, #475569 100%);
            border-radius: 4px;
        }

        .chat-messages::-webkit-scrollbar-thumb:hover,
        .file-list::-webkit-scrollbar-thumb:hover,
        .component-suggestions::-webkit-scrollbar-thumb:hover,
        .field-flow-list::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
        }

        /* Responsive Design */
        @media (max-width: 1600px) { 
            .main-grid { 
                grid-template-columns: 450px 1fr 350px; 
            } 
        }

        @media (max-width: 1400px) { 
            .main-grid { 
                grid-template-columns: 400px 1fr 300px; 
            } 
        }

        @media (max-width: 1200px) { 
            .main-grid { 
                grid-template-columns: 1fr; 
                gap: 20px; 
            }
            
            .control-panel, 
            .analysis-workspace, 
            .chat-panel {
                max-height: none;
            }
        }

        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üî¨ Enhanced Mainframe Analyzer</h1>
            <p>Advanced mainframe analysis with LLM-powered field flow tracking, business rules, and lifecycle mapping</p>
        </div>

        <div class="main-grid">
            <!-- Control Panel -->
            <div class="control-panel">
                <!-- Component Search Section -->
                <div class="component-search-section">
                    <h2 class="section-title">üéØ Component Analysis</h2>
                    <div class="form-group">
                        <label for="componentName">Enter Component Name:</label>
                        <input type="text" id="componentName" class="component-input" 
                               placeholder="e.g., CUSTOMER-RECORD, ACCOUNT-COPY, PAYROLL-PROC">
                        <div id="componentSuggestions" class="component-suggestions"></div>
                    </div>
                    
                    <!-- Token Usage Display -->
                    <div id="tokenInfo" class="token-info" style="display: none;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                            <span style="font-weight: bold;">Token Management</span>
                            <span id="tokenCount">0 / 4000</span>
                        </div>
                        <div class="token-bar">
                            <div id="tokenFill" class="token-fill safe" style="width: 0%"></div>
                        </div>
                        <div id="tokenWarning" style="font-size: 11px; margin-top: 5px;"></div>
                    </div>
                    
                    <button class="action-btn component-btn" id="analyzeComponentBtn" disabled>
                        üîç Analyze Component
                    </button>
                </div>

                <!-- vLLM API Setup -->
                <div style="margin-bottom: 25px; padding: 20px; background: rgba(0, 0, 0, 0.2); border-radius: 15px; border-left: 4px solid #4CAF50;">
                    <h2 class="section-title">üöÄ vLLM Server Setup</h2>
                    <div class="form-group">
                        <label for="vllmEndpoint">Server Endpoint:</label>
                        <input type="text" id="vllmEndpoint" placeholder="http://localhost:8000" value="http://localhost:8000">
                    </div>
                    <div class="form-group">
                        <label for="maxTokens">Max Tokens:</label>
                        <input type="number" id="maxTokens" value="4000" min="1000" max="8000">
                    </div>
                    <button class="action-btn validate-btn" id="validateApiBtn">
                        üîê Test Connection
                    </button>
                    <div class="api-status disconnected" id="apiStatus">
                        <span>üî¥</span> Enter server details and test connection
                    </div>
                </div>

                <!-- File Upload Section -->
                <div style="margin-bottom: 25px;">
                    <h2 class="section-title">üìÅ Upload Mainframe Files</h2>
                    <div class="upload-area" id="uploadArea">
                        <div>
                            <h3 style="margin-bottom: 8px;">üì§ Drop files here</h3>
                            <p style="font-size: 14px;">COBOL (.cbl), Copybooks (.cpy), JCL (.jcl)</p>
                        </div>
                        <input type="file" id="fileInput" multiple accept=".cbl,.cob,.cpy,.copybook,.jcl,.txt,.proc" style="display: none;">
                    </div>
                    <div id="uploadedFiles" class="file-list"></div>
                </div>

                <!-- Quick Actions -->
                <div>
                    <h3 class="section-title">‚ö° Actions</h3>
                    <button class="action-btn secondary-btn" id="bulkAnalyzeBtn" disabled>
                        üìä Bulk Analyze
                    </button>
                    
                    <!-- Export Section -->
                    <div class="export-section">
                        <h4 style="color: #FFC107; margin-bottom: 10px; font-size: 14px;">üì§ Export Options</h4>
                        <div class="export-btn-group">
                            <button class="export-btn-small" id="exportJsonBtn" disabled>
                                üìã JSON Export
                            </button>
                            <button class="export-btn-small" id="exportMdBtn" disabled>
                                üìù Markdown Export
                            </button>
                        </div>
                    </div>
                    
                    <button class="action-btn secondary-btn" id="clearBtn">
                        üóëÔ∏è Clear All Data
                    </button>
                </div>
            </div>

            <!-- Analysis Workspace -->
            <div class="analysis-workspace">
                <div class="tabs">
                    <button class="tab active" data-tab="lifecycle">üîÑ Analysis Results</button>
                    <button class="tab" data-tab="fieldmatrix">üìã Field Matrix</button>
                    <button class="tab" data-tab="usage">üìà Usage Patterns</button>
                    <button class="tab" data-tab="dependencies">üîó Dependencies</button>
                    <button class="tab" data-tab="fileflow">üåä File Lifecycle</button>
                </div>

                <!-- Tab Contents -->
                <div id="lifecycle" class="tab-content active">
                    <div id="lifecycleContent">
                        <h3>üéØ LLM-Powered Component Analysis</h3>
                        <p style="margin-bottom: 20px; line-height: 1.6;">
                            Upload files, test your connection, and analyze components for detailed LLM-powered field flows and business rules.
                        </p>
                        
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px; border-left: 4px solid #FFD700;">
                            <h4 style="color: #FFD700; margin-bottom: 15px;">ü§ñ LLM-Enhanced Features:</h4>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                                <div>
                                    <strong style="color: #4CAF50;">üß† LLM Field Analysis:</strong>
                                    <ul style="list-style: none; margin-left: 10px; line-height: 1.8;">
                                        <li>‚Ä¢ Smart field lifecycle tracking</li>
                                        <li>‚Ä¢ Context-aware usage patterns</li>
                                        <li>‚Ä¢ Intelligent field categorization</li>
                                        <li>‚Ä¢ Cross-program flow analysis</li>
                                    </ul>
                                </div>
                                <div>
                                    <strong style="color: #2196F3;">‚öñÔ∏è Smart Business Rules:</strong>
                                    <ul style="list-style: none; margin-left: 10px; line-height: 1.8;">
                                        <li>‚Ä¢ LLM-extracted validation logic</li>
                                        <li>‚Ä¢ Context-aware decision mapping</li>
                                        <li>‚Ä¢ Business calculation analysis</li>
                                        <li>‚Ä¢ Rule complexity assessment</li>
                                    </ul>
                                </div>
                                <div>
                                    <strong style="color: #FF9800;">üîó Smart Dependencies:</strong>
                                    <ul style="list-style: none; margin-left: 10px; line-height: 1.8;">
                                        <li>‚Ä¢ Regex + LLM validation</li>
                                        <li>‚Ä¢ Smart call chain analysis</li>
                                        <li>‚Ä¢ Contextual file references</li>
                                        <li>‚Ä¢ Impact assessment</li>
                                    </ul>
                                </div>
                                <div>
                                    <strong style="color: #9C27B0;">üåä File Lifecycle:</strong>
                                    <ul style="list-style: none; margin-left: 10px; line-height: 1.8;">
                                        <li>‚Ä¢ Creation to purge tracking</li>
                                        <li>‚Ä¢ Program usage mapping</li>
                                        <li>‚Ä¢ Field update patterns</li>
                                        <li>‚Ä¢ CICS screen integration</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="fieldmatrix" class="tab-content">
                    <div id="fieldMatrixContent">
                        <h3>üìã LLM Field Matrix Analysis</h3>
                        <p style="margin-bottom: 20px;">Enhanced field-level analysis with LLM-powered categorization will appear here after component analysis.</p>
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px;">
                            <p style="text-align: center; opacity: 0.8;">LLM-enhanced field matrix will appear here after analysis.</p>
                        </div>
                    </div>
                </div>

                <div id="usage" class="tab-content">
                    <div id="usageContent">
                        <h3>üìà Smart Usage Patterns</h3>
                        <p style="margin-bottom: 20px;">LLM-powered usage pattern analysis with field lifecycle flows will appear here after component analysis.</p>
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px;">
                            <p style="text-align: center; opacity: 0.8;">Smart usage patterns will appear here after analysis.</p>
                        </div>
                    </div>
                </div>

                <div id="dependencies" class="tab-content">
                    <div id="dependenciesContent">
                        <h3>üîó Hybrid Dependency Analysis</h3>
                        <p style="margin-bottom: 20px;">Regex + LLM dependency mapping will appear here after component analysis.</p>
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px;">
                            <p style="text-align: center; opacity: 0.8;">Hybrid dependency graph will appear here after analysis.</p>
                        </div>
                    </div>
                </div>

                <div id="fileflow" class="tab-content">
                    <div id="fileflowContent">
                        <h3>üåä File Lifecycle Flow Analysis</h3>
                        <p style="margin-bottom: 20px;">Complete file lifecycle from creation through purge, including program usage patterns and field update tracking.</p>
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px;">
                            <p style="text-align: center; opacity: 0.8;">File lifecycle flow analysis will appear here after component analysis.</p>
                        </div>
                    </div>
                </div>

                <!-- Loading Indicator -->
                <div class="loading" id="loadingIndicator">
                    <div class="spinner"></div>
                    <h3>ü§ñ LLM Analyzing Component</h3>
                    <p id="loadingStatus">Processing component analysis with LLM...</p>
                    <div id="progressBar" style="background: rgba(255,255,255,0.2); height: 6px; border-radius: 3px; margin: 15px 0; overflow: hidden;">
                        <div id="progressFill" style="height: 100%; background: #4CAF50; width: 0%; transition: width 0.3s ease;"></div>
                    </div>
                </div>
            </div>

            <!-- Enhanced Chat Panel -->
            <div class="chat-panel">
                <div style="background: rgba(76, 175, 80, 0.2); border-radius: 10px; padding: 15px; margin-bottom: 15px; border-left: 4px solid #4CAF50;">
                    <h3 style="margin-bottom: 8px; color: #FFD700;">üí¨ LLM Analysis Chat</h3>
                    <p style="font-size: 12px; opacity: 0.8;">Enhanced interactive chat with rich formatting and export</p>
                </div>
                
                <!-- Chat Suggestions -->
                <div class="chat-suggestions" id="chatSuggestions" style="display: none;">
                    <h4 style="color: #06b6d4; margin-bottom: 10px; font-size: 13px;">üí° Suggested Questions:</h4>
                    <button class="chat-suggestion-btn" data-question="Explain the file lifecycle flow for this component">üìä File Lifecycle</button>
                    <button class="chat-suggestion-btn" data-question="What fields are updated by which programs?">üîÑ Field Updates</button>
                    <button class="chat-suggestion-btn" data-question="Show me the creation and purge process">üåä Creation/Purge</button>
                    <button class="chat-suggestion-btn" data-question="Which programs only read vs modify data?">üìñ Read/Write Patterns</button>
                </div>
                
                <!-- Chat Messages Area -->
                <div class="chat-messages" id="chatMessages">
                    <div class="chat-message assistant">
                        <div class="sender">LLM Analysis Assistant</div>
                        <div class="content">
                            üëã <strong>Welcome to LLM-Enhanced Mainframe Analysis!</strong>
                            <br><br>
                            I can provide detailed analysis using advanced language models including:
                            <br><br>
                            üß† <strong>Smart Field Analysis:</strong> Context-aware field lifecycle tracking
                            <br>‚öñÔ∏è <strong>Business Logic Extraction:</strong> Intelligent rule and validation discovery  
                            <br>üîó <strong>Dependency Mapping:</strong> Comprehensive relationship analysis
                            <br>üåä <strong>File Lifecycle Flow:</strong> Creation to purge tracking with program mapping
                            <br>üí° <strong>Modernization Guidance:</strong> AI-powered optimization recommendations
                            <br><br>
                            <em>Upload files and analyze a component to unlock the full power of LLM analysis!</em>
                        </div>
                        <div class="timestamp">${new Date().toLocaleTimeString()}</div>
                    </div>
                </div>
                
                <!-- Chat Input -->
                <div class="chat-input-section">
                    <textarea class="chat-input" id="chatInput" placeholder="Ask about field flows, program dependencies, lifecycle patterns..." disabled rows="2"></textarea>
                    <button class="chat-send-btn" id="chatSendBtn" disabled>Send</button>
                </div>
            </div>
        </div>
    </div>
    <script>
        // Enhanced Mainframe Analyzer with LLM Integration and File Lifecycle Flow
        class EnhancedMainframeAnalyzer {
            constructor() {
                // Core properties
                this.uploadedFiles = [];
                this.analysisResults = {};
                this.componentSuggestions = [];
                this.serverValidated = false;
                this.vllmEndpoint = 'http://localhost:8000';
                this.maxTokens = 4000;
                this.storageKey = 'enhanced_mainframe_analysis';
                this.currentAnalyzedComponent = null;
                this.chatHistory = [];
                
                // Token management
                this.averageCharsPerToken = 3;
                this.tokenSafetyMargin = 0.7;
                
                // LLM Analysis configuration
                this.llmConfig = {
                    temperature: 0.1,
                    maxRetries: 3,
                    chunkSize: 2000,
                    analysisTimeout: 120000
                };
                
                // File lifecycle tracking
                this.lifecyclePatterns = {
                    creation: ['CREATE', 'WRITE', 'OUTPUT', 'OPEN OUTPUT', 'FD ', 'FILE-CONTROL'],
                    reading: ['READ', 'INPUT', 'OPEN INPUT', 'SELECT'],
                    updating: ['WRITE', 'REWRITE', 'UPDATE', 'MODIFY', 'OPEN I-O'],
                    deletion: ['DELETE', 'PURGE', 'REMOVE'],
                    cicsOperations: ['EXEC CICS', 'SEND MAP', 'RECEIVE MAP', 'READ TD', 'WRITE TD'],
                    batchOperations: ['SORT', 'MERGE', 'COPY', '//EXEC PGM=']
                };
                
                this.initializeBasicEventListeners();
                this.loadStoredData();
                this.initializeTokenManagement();
                this.initializeChat();
                
                console.log('üöÄ Enhanced Mainframe Analyzer with File Lifecycle Flow Initialized');
            }

            // === BASIC EVENT LISTENERS ===
            initializeBasicEventListeners() {
                // API validation
                document.getElementById('validateApiBtn').addEventListener('click', () => this.validateConnection());
                document.getElementById('vllmEndpoint').addEventListener('input', () => this.onEndpointChange());
                document.getElementById('maxTokens').addEventListener('input', () => this.onSettingsChange());
                
                // File upload handlers
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');
                
                uploadArea.addEventListener('click', () => {
                    if (this.serverValidated) fileInput.click();
                });
                uploadArea.addEventListener('drop', (e) => this.handleFileDrop(e));
                uploadArea.addEventListener('dragover', (e) => this.handleDragOver(e));
                uploadArea.addEventListener('dragleave', (e) => this.handleDragLeave(e));
                fileInput.addEventListener('change', (e) => this.handleFileSelect(e));

                // Component analysis
                document.getElementById('componentName').addEventListener('input', () => this.onComponentInput());
                document.getElementById('analyzeComponentBtn').addEventListener('click', () => this.analyzeComponent());
                
                // Quick actions
                document.getElementById('bulkAnalyzeBtn').addEventListener('click', () => this.bulkAnalyze());
                document.getElementById('exportJsonBtn').addEventListener('click', () => this.exportResults('json'));
                document.getElementById('exportMdBtn').addEventListener('click', () => this.exportResults('markdown'));
                document.getElementById('clearBtn').addEventListener('click', () => this.clearAllData());

                // Tab navigation
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', (e) => this.switchTab(e));
                });

                // Hide suggestions when clicking outside
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.component-search-section')) {
                        document.getElementById('componentSuggestions').style.display = 'none';
                    }
                });
            }

            initializeTokenManagement() {
                this.updateTokenDisplay(0);
                this.showSuccess('üöÄ Enhanced LLM Mainframe Analyzer with File Lifecycle Flow Ready!');
            }

            // === TOKEN MANAGEMENT ===
            estimateTokenCount(text) {
                if (!text) return 0;
                return Math.ceil(text.length / this.averageCharsPerToken);
            }

            updateTokenDisplay(currentTokens) {
                const tokenInfo = document.getElementById('tokenInfo');
                const tokenCount = document.getElementById('tokenCount');
                const tokenFill = document.getElementById('tokenFill');
                const tokenWarning = document.getElementById('tokenWarning');

                tokenInfo.style.display = 'block';
                tokenCount.textContent = `${currentTokens} / ${this.maxTokens}`;
                
                const percentage = (currentTokens / this.maxTokens) * 100;
                tokenFill.style.width = `${Math.min(percentage, 100)}%`;
                
                tokenFill.className = 'token-fill';
                if (percentage <= 50) {
                    tokenFill.classList.add('safe');
                    tokenWarning.textContent = 'üü¢ Optimal token usage - full LLM analysis available';
                } else if (percentage <= 70) {
                    tokenFill.classList.add('warning');
                    tokenWarning.textContent = 'üü° Moderate usage - intelligent LLM chunking active';
                } else {
                    tokenFill.classList.add('danger');
                    tokenWarning.textContent = 'üî¥ High usage - LLM optimization required';
                }
            }

            // === API CONNECTION ===
            async validateConnection() {
                const endpoint = document.getElementById('vllmEndpoint').value.trim();
                if (!endpoint) {
                    this.showError('Please enter vLLM endpoint');
                    return;
                }

                this.updateConnectionStatus('connecting', 'Testing LLM connection...');

                try {
                    const response = await fetch(`${endpoint}/generate`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            prompt: "Test LLM connection. Respond with 'LLM Connected'",
                            max_tokens: 20,
                            temperature: 0.1
                        }),
                        signal: AbortSignal.timeout(10000)
                    });

                    if (response.ok) {
                        const data = await response.json();
                        this.serverValidated = true;
                        this.vllmEndpoint = endpoint;
                        this.updateConnectionStatus('connected', `‚úÖ LLM connection verified`);
                        this.showSuccess('üöÄ vLLM server connected successfully!');
                    } else {
                        throw new Error(`HTTP ${response.status}`);
                    }
                } catch (error) {
                    this.serverValidated = false;
                    this.updateConnectionStatus('disconnected', `‚ùå LLM connection failed: ${error.message}`);
                    this.showError(`LLM connection failed: ${error.message}`);
                }
                
                this.validateForm();
            }

            updateConnectionStatus(status, message) {
                const statusElement = document.getElementById('apiStatus');
                statusElement.className = `api-status ${status}`;
                statusElement.innerHTML = message;
            }

            // === FILE UPLOAD HANDLING ===
            handleFileDrop(e) {
                e.preventDefault();
                e.stopPropagation();
                
                const uploadArea = document.getElementById('uploadArea');
                uploadArea.classList.remove('drag-over');
                
                if (!this.serverValidated) {
                    this.showError('Please validate LLM API connection first');
                    return;
                }
                
                const files = Array.from(e.dataTransfer.files);
                this.processFiles(files);
            }

            handleDragOver(e) {
                e.preventDefault();
                e.stopPropagation();
                document.getElementById('uploadArea').classList.add('drag-over');
            }

            handleDragLeave(e) {
                e.preventDefault();
                e.stopPropagation();
                document.getElementById('uploadArea').classList.remove('drag-over');
            }

            handleFileSelect(e) {
                if (!this.serverValidated) {
                    this.showError('Please validate LLM API connection first');
                    return;
                }
                
                const files = Array.from(e.target.files);
                this.processFiles(files);
            }

            async processFiles(files) {
                for (const file of files) {
                    try {
                        const content = await this.readFile(file);
                        const fileType = this.detectFileType(file.name, content);
                        
                        const fileObj = {
                            name: file.name,
                            content: content,
                            size: file.size,
                            type: fileType,
                            uploadDate: new Date().toISOString(),
                            id: Date.now() + Math.random(),
                            lifecycleInfo: this.extractBasicLifecycleInfo(content, fileType)
                        };
                        
                        this.uploadedFiles.push(fileObj);
                        this.updateComponentSuggestions();
                        
                    } catch (error) {
                        this.showError(`Failed to read ${file.name}: ${error.message}`);
                    }
                }
                
                this.displayUploadedFiles();
                this.validateForm();
                this.saveToStorage();
                this.showSuccess(`üìÅ ${files.length} files uploaded successfully!`);
            }

            readFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = e => resolve(e.target.result);
                    reader.onerror = e => reject(new Error('File read failed'));
                    reader.readAsText(file);
                });
            }

            detectFileType(fileName, content) {
                const name = fileName.toLowerCase();
                const upperContent = content.toUpperCase();
                
                if (name.includes('.cpy') || name.includes('copybook')) {
                    return 'Copybook';
                } else if (name.includes('.jcl') || upperContent.includes('//JOB ')) {
                    return 'JCL Job';
                } else if (name.includes('.cbl') || name.includes('.cob') || 
                          upperContent.includes('IDENTIFICATION DIVISION') ||
                          upperContent.includes('PROGRAM-ID')) {
                    return 'COBOL Program';
                } else if (name.includes('.proc')) {
                    return 'JCL Procedure';
                } else {
                    return 'Text File';
                }
            }

            // === NEW: BASIC LIFECYCLE INFO EXTRACTION ===
            extractBasicLifecycleInfo(content, fileType) {
                const lifecycleInfo = {
                    hasCreation: false,
                    hasReading: false,
                    hasUpdating: false,
                    hasDeletion: false,
                    hasCicsOps: false,
                    hasBatchOps: false,
                    fileOperations: [],
                    programs: [],
                    screens: []
                };

                const upperContent = content.toUpperCase();
                const lines = content.split('\n');

                // Check for different operation types
                lifecycleInfo.hasCreation = this.lifecyclePatterns.creation.some(pattern => 
                    upperContent.includes(pattern));
                lifecycleInfo.hasReading = this.lifecyclePatterns.reading.some(pattern => 
                    upperContent.includes(pattern));
                lifecycleInfo.hasUpdating = this.lifecyclePatterns.updating.some(pattern => 
                    upperContent.includes(pattern));
                lifecycleInfo.hasDeletion = this.lifecyclePatterns.deletion.some(pattern => 
                    upperContent.includes(pattern));
                lifecycleInfo.hasCicsOps = this.lifecyclePatterns.cicsOperations.some(pattern => 
                    upperContent.includes(pattern));
                lifecycleInfo.hasBatchOps = this.lifecyclePatterns.batchOperations.some(pattern => 
                    upperContent.includes(pattern));

                // Extract file operations
                lines.forEach(line => {
                    const trimmed = line.trim().toUpperCase();
                    
                    // File operations
                    if (trimmed.includes('FD ')) {
                        const match = trimmed.match(/FD\s+([A-Z][A-Z0-9\-_]+)/);
                        if (match) lifecycleInfo.fileOperations.push(`FD ${match[1]}`);
                    }
                    
                    if (trimmed.includes('OPEN ')) {
                        const match = trimmed.match(/OPEN\s+(INPUT|OUTPUT|I-O)\s+([A-Z][A-Z0-9\-_]+)/);
                        if (match) lifecycleInfo.fileOperations.push(`OPEN ${match[1]} ${match[2]}`);
                    }

                    // CICS screens
                    if (trimmed.includes('SEND MAP')) {
                        const match = trimmed.match(/MAP\s*\(\s*['"]*([A-Z][A-Z0-9\-_]+)['"]*\s*\)/);
                        if (match) lifecycleInfo.screens.push(match[1]);
                    }

                    // Called programs
                    if (trimmed.includes('CALL ')) {
                        const match = trimmed.match(/CALL\s+['"]*([A-Z][A-Z0-9\-_]+)['"]*/) ||
                                     trimmed.match(/LINK\s+['"]*([A-Z][A-Z0-9\-_]+)['"]*/) ||
                                     trimmed.match(/XCTL\s+['"]*([A-Z][A-Z0-9\-_]+)['"]*/) ||
                                     trimmed.match(/EXEC\s+PGM=([A-Z][A-Z0-9\-_]+)/);
                        if (match) lifecycleInfo.programs.push(match[1]);
                    }
                });

                return lifecycleInfo;
            }

            displayUploadedFiles() {
                const container = document.getElementById('uploadedFiles');
                if (this.uploadedFiles.length === 0) {
                    container.innerHTML = '';
                    return;
                }
                
                let html = '';
                this.uploadedFiles.forEach(file => {
                    const lifecycleIcons = this.getLifecycleIcons(file.lifecycleInfo);
                    html += `
                        <div class="file-item">
                            <div class="file-info">
                                <div class="file-name">${file.name}</div>
                                <div class="file-details">
                                    ${file.type} ‚Ä¢ ${Math.round(file.size/1024)}KB 
                                    ${lifecycleIcons ? `‚Ä¢ ${lifecycleIcons}` : ''}
                                </div>
                            </div>
                            <button class="file-remove" onclick="analyzer.removeFile('${file.id}')">üóëÔ∏è</button>
                        </div>
                    `;
                });
                
                container.innerHTML = html;
            }

            getLifecycleIcons(lifecycleInfo) {
                if (!lifecycleInfo) return '';
                
                const icons = [];
                if (lifecycleInfo.hasCreation) icons.push('üìù');
                if (lifecycleInfo.hasReading) icons.push('üìñ');
                if (lifecycleInfo.hasUpdating) icons.push('‚úèÔ∏è');
                if (lifecycleInfo.hasDeletion) icons.push('üóëÔ∏è');
                if (lifecycleInfo.hasCicsOps) icons.push('üñ•Ô∏è');
                if (lifecycleInfo.hasBatchOps) icons.push('‚öôÔ∏è');
                
                return icons.join(' ');
            }

            removeFile(fileId) {
                this.uploadedFiles = this.uploadedFiles.filter(f => f.id != fileId);
                this.displayUploadedFiles();
                this.updateComponentSuggestions();
                this.validateForm();
                this.saveToStorage();
            }
            // === ENHANCED COMPONENT SUGGESTIONS ===
            updateComponentSuggestions() {
                this.componentSuggestions = [];
                
                this.uploadedFiles.forEach(file => {
                    const content = file.content.toUpperCase();
                    const lines = content.split('\n');
                    
                    lines.forEach(line => {
                        const trimmed = line.trim();
                        
                        // Extract COBOL field names
                        const fieldMatch = trimmed.match(/^\s*\d{2}\s+([A-Z][A-Z0-9\-_]{2,})/);
                        if (fieldMatch) {
                            this.componentSuggestions.push({
                                name: fieldMatch[1],
                                type: 'FIELD',
                                file: file.name,
                                lifecycle: file.lifecycleInfo
                            });
                        }
                        
                        // Extract copybook names
                        const copyMatch = trimmed.match(/COPY\s+([A-Z][A-Z0-9\-_]{2,})/);
                        if (copyMatch) {
                            this.componentSuggestions.push({
                                name: copyMatch[1],
                                type: 'COPYBOOK',
                                file: file.name,
                                lifecycle: file.lifecycleInfo
                            });
                        }
                        
                        // Extract program names
                        const programMatch = trimmed.match(/PROGRAM-ID\.?\s+([A-Z][A-Z0-9\-_]{2,})/);
                        if (programMatch) {
                            this.componentSuggestions.push({
                                name: programMatch[1],
                                type: 'PROGRAM',
                                file: file.name,
                                lifecycle: file.lifecycleInfo
                            });
                        }

                        // Extract file names from FD statements
                        const fileMatch = trimmed.match(/FD\s+([A-Z][A-Z0-9\-_]{2,})/);
                        if (fileMatch) {
                            this.componentSuggestions.push({
                                name: fileMatch[1],
                                type: 'FILE',
                                file: file.name,
                                lifecycle: file.lifecycleInfo
                            });
                        }
                    });
                });
                
                // Remove duplicates
                this.componentSuggestions = this.componentSuggestions.filter((item, index, self) => 
                    index === self.findIndex(t => t.name === item.name && t.type === item.type)
                );
            }

            onComponentInput() {
                const input = document.getElementById('componentName');
                const value = input.value.trim().toUpperCase();
                const suggestions = document.getElementById('componentSuggestions');
                
                if (value.length < 2) {
                    suggestions.style.display = 'none';
                    this.validateForm();
                    return;
                }
                
                const filtered = this.componentSuggestions.filter(item => 
                    item.name.includes(value)
                ).slice(0, 8);
                
                if (filtered.length > 0) {
                    let html = '';
                    filtered.forEach(item => {
                        const lifecycleIcons = this.getLifecycleIcons(item.lifecycle);
                        html += `
                            <div class="suggestion-item" onclick="analyzer.selectSuggestion('${item.name}')">
                                <strong>${item.name}</strong> 
                                <span style="opacity: 0.7;">(${item.type} in ${item.file})</span>
                                ${lifecycleIcons ? `<span style="margin-left: 8px;">${lifecycleIcons}</span>` : ''}
                            </div>
                        `;
                    });
                    suggestions.innerHTML = html;
                    suggestions.style.display = 'block';
                } else {
                    suggestions.style.display = 'none';
                }
                
                this.validateForm();
            }

            selectSuggestion(componentName) {
                document.getElementById('componentName').value = componentName;
                document.getElementById('componentSuggestions').style.display = 'none';
                this.validateForm();
            }

            // === FORM VALIDATION ===
            validateForm() {
                const hasFiles = this.uploadedFiles.length > 0;
                const hasComponent = document.getElementById('componentName').value.trim().length > 0;
                const hasConnection = this.serverValidated;
                
                document.getElementById('analyzeComponentBtn').disabled = !(hasFiles && hasComponent && hasConnection);
                document.getElementById('bulkAnalyzeBtn').disabled = !(hasFiles && hasConnection);
                
                const hasResults = Object.keys(this.analysisResults).length > 0;
                document.getElementById('exportJsonBtn').disabled = !hasResults;
                document.getElementById('exportMdBtn').disabled = !hasResults;
            }

            // === EVENT HANDLERS ===
            onEndpointChange() {
                this.serverValidated = false;
                this.updateConnectionStatus('disconnected', 'üî¥ LLM connection not validated');
                this.validateForm();
            }

            onSettingsChange() {
                this.maxTokens = parseInt(document.getElementById('maxTokens').value) || 4000;
                this.saveToStorage();
            }

            switchTab(e) {
                const targetTab = e.target?.dataset?.tab || e.dataset?.tab;
                if (!targetTab) return;
                
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                
                const clickedTab = e.target || e;
                if (clickedTab.classList) {
                    clickedTab.classList.add('active');
                }
                
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                
                const targetContent = document.getElementById(targetTab);
                if (targetContent) {
                    targetContent.classList.add('active');
                }
            }

            // === ENHANCED LLM ANALYSIS ENGINE ===
            async analyzeComponent() {
                const componentName = document.getElementById('componentName').value.trim();
                if (!componentName) return;

                this.showLoading();
                this.updateProgress(0);

                try {
                    this.updateLoadingStatus('üß† Initializing LLM analysis with lifecycle tracking...');
                    const results = await this.runLLMEnhancedAnalysisWithLifecycle(componentName);
                    
                    this.analysisResults[componentName] = results;
                    this.currentAnalyzedComponent = componentName;
                    
                    this.displayAnalysisResults(componentName, results);
                    this.enableChat();
                    this.saveToStorage();
                    
                    this.hideLoading();
                    this.showSuccess(`‚úÖ LLM-enhanced analysis with lifecycle flow complete for ${componentName}!`);
                    
                } catch (error) {
                    this.hideLoading();
                    this.showError(`LLM analysis failed: ${error.message}`);
                    console.error('LLM Analysis error:', error);
                }
            }

            async runLLMEnhancedAnalysisWithLifecycle(componentName) {
                console.log(`Starting LLM-enhanced analysis with lifecycle tracking for: ${componentName}`);
                
                // Stage 1: Find relevant files and detect component type
                this.updateLoadingStatus('üîç Stage 1: Finding relevant files and lifecycle info...');
                this.updateProgress(10);
                
                const relevantFiles = this.findRelevantFiles(componentName);
                if (relevantFiles.length === 0) {
                    throw new Error(`Component "${componentName}" not found in uploaded files`);
                }

                const componentType = this.detectComponentType(componentName, relevantFiles);
                console.log(`Component type detected: ${componentType}`);

                // Stage 2: Basic dependency extraction (using regex for speed)
                this.updateLoadingStatus('üîó Stage 2: Extracting basic dependencies and lifecycle patterns...');
                this.updateProgress(25);
                
                const basicDependencies = await this.extractBasicDependencies();
                const lifecycleFlow = await this.extractFileLifecycleFlow(componentName, relevantFiles);

                // Stage 3: LLM-powered component analysis with lifecycle context
                this.updateLoadingStatus('ü§ñ Stage 3: LLM analyzing component with lifecycle context...');
                this.updateProgress(50);
                
                let llmAnalysis;
                if (componentType === 'Copybook') {
                    llmAnalysis = await this.analyzeCopybookWithLLMAndLifecycle(componentName, relevantFiles, basicDependencies, lifecycleFlow);
                } else if (componentType === 'COBOL Program') {
                    llmAnalysis = await this.analyzeProgramWithLLMAndLifecycle(componentName, relevantFiles, basicDependencies, lifecycleFlow);
                } else {
                    llmAnalysis = await this.analyzeGenericComponentWithLLM(componentName, relevantFiles, basicDependencies);
                }
                
                // Stage 4: LLM validation of dependencies with lifecycle context
                this.updateLoadingStatus('üîç Stage 4: LLM validating dependencies with lifecycle analysis...');
                this.updateProgress(80);
                
                const validatedDependencies = await this.validateDependenciesWithLLM(basicDependencies, relevantFiles);
                
                // Stage 5: Generate field usage patterns
                this.updateLoadingStatus('üìä Stage 5: Generating field usage patterns...');
                this.updateProgress(90);
                
                const fieldUsagePatterns = await this.generateFieldUsagePatterns(llmAnalysis, lifecycleFlow);
                
                this.updateProgress(100);
                
                return {
                    componentName: componentName,
                    timestamp: new Date().toISOString(),
                    filesAnalyzed: relevantFiles.map(f => f.name),
                    componentType: componentType,
                    basicDependencies: basicDependencies,
                    validatedDependencies: validatedDependencies,
                    llmAnalysis: llmAnalysis,
                    lifecycleFlow: lifecycleFlow,
                    fieldUsagePatterns: fieldUsagePatterns,
                    qualityScore: this.calculateQualityScore(llmAnalysis),
                    completeness: this.assessCompleteness(llmAnalysis),
                    analysisMethod: 'LLM-Enhanced-Lifecycle'
                };
            }
            // === NEW: FILE LIFECYCLE FLOW EXTRACTION ===
            async extractFileLifecycleFlow(componentName, relevantFiles) {
                console.log('Extracting file lifecycle flow...');
                
                const lifecycleFlow = {
                    componentName: componentName,
                    creationSources: [],
                    inputPrograms: [],
                    updatePrograms: [],
                    outputDestinations: [],
                    cicsScreens: [],
                    batchJobs: [],
                    purgeProcesses: [],
                    fieldUpdateTracking: {},
                    usagePattern: 'UNKNOWN'
                };

                // Analyze each relevant file for lifecycle information
                for (const file of relevantFiles) {
                    const fileLifecycle = this.analyzeFileForLifecycle(file, componentName);
                    this.mergeLifecycleData(lifecycleFlow, fileLifecycle, file.name);
                }

                // Determine overall usage pattern
                lifecycleFlow.usagePattern = this.determineUsagePattern(lifecycleFlow);
                
                // Find field-level lifecycle information
                lifecycleFlow.fieldUpdateTracking = this.extractFieldUpdateTracking(relevantFiles, componentName);

                console.log('File lifecycle flow extracted:', lifecycleFlow);
                return lifecycleFlow;
            }

            analyzeFileForLifecycle(file, componentName) {
                const fileLifecycle = {
                    creation: [],
                    reading: [],
                    updating: [],
                    deletion: [],
                    cicsOps: [],
                    batchOps: [],
                    fieldOps: {}
                };

                const lines = file.content.split('\n');
                const upperContent = file.content.toUpperCase();
                let currentProgram = '';

                lines.forEach((line, lineNum) => {
                    const trimmed = line.trim().toUpperCase();
                    
                    // Track current program
                    const programMatch = trimmed.match(/PROGRAM-ID\.?\s+([A-Z][A-Z0-9\-_]+)/);
                    if (programMatch) {
                        currentProgram = programMatch[1];
                    }

                    // File creation operations
                    if (trimmed.includes('OPEN OUTPUT') || trimmed.includes('WRITE ')) {
                        const fileMatch = trimmed.match(/(?:OPEN OUTPUT|WRITE)\s+([A-Z][A-Z0-9\-_]+)/);
                        if (fileMatch) {
                            fileLifecycle.creation.push({
                                operation: trimmed.includes('OPEN OUTPUT') ? 'OPEN_OUTPUT' : 'WRITE',
                                target: fileMatch[1],
                                program: currentProgram,
                                line: lineNum + 1
                            });
                        }
                    }

                    // File reading operations
                    if (trimmed.includes('OPEN INPUT') || trimmed.includes('READ ')) {
                        const fileMatch = trimmed.match(/(?:OPEN INPUT|READ)\s+([A-Z][A-Z0-9\-_]+)/);
                        if (fileMatch) {
                            fileLifecycle.reading.push({
                                operation: trimmed.includes('OPEN INPUT') ? 'OPEN_INPUT' : 'READ',
                                target: fileMatch[1],
                                program: currentProgram,
                                line: lineNum + 1
                            });
                        }
                    }

                    // File updating operations
                    if (trimmed.includes('REWRITE') || trimmed.includes('OPEN I-O')) {
                        const fileMatch = trimmed.match(/(?:REWRITE|OPEN I-O)\s+([A-Z][A-Z0-9\-_]+)/);
                        if (fileMatch) {
                            fileLifecycle.updating.push({
                                operation: trimmed.includes('REWRITE') ? 'REWRITE' : 'OPEN_IO',
                                target: fileMatch[1],
                                program: currentProgram,
                                line: lineNum + 1
                            });
                        }
                    }

                    // CICS operations
                    if (trimmed.includes('EXEC CICS')) {
                        if (trimmed.includes('SEND MAP')) {
                            const mapMatch = trimmed.match(/MAP\s*\(\s*['"]*([A-Z][A-Z0-9\-_]+)['"]*\s*\)/);
                            if (mapMatch) {
                                fileLifecycle.cicsOps.push({
                                    operation: 'SEND_MAP',
                                    target: mapMatch[1],
                                    program: currentProgram,
                                    line: lineNum + 1
                                });
                            }
                        }
                        if (trimmed.includes('RECEIVE MAP')) {
                            const mapMatch = trimmed.match(/MAP\s*\(\s*['"]*([A-Z][A-Z0-9\-_]+)['"]*\s*\)/);
                            if (mapMatch) {
                                fileLifecycle.cicsOps.push({
                                    operation: 'RECEIVE_MAP',
                                    target: mapMatch[1],
                                    program: currentProgram,
                                    line: lineNum + 1
                                });
                            }
                        }
                    }

                    // JCL batch operations
                    if (trimmed.includes('//EXEC PGM=')) {
                        const programMatch = trimmed.match(/\/\/EXEC\s+PGM=([A-Z][A-Z0-9\-_]+)/);
                        if (programMatch) {
                            fileLifecycle.batchOps.push({
                                operation: 'EXEC_PGM',
                                target: programMatch[1],
                                program: 'JCL',
                                line: lineNum + 1
                            });
                        }
                    }

                    // Field-level operations
                    const moveMatch = trimmed.match(/MOVE\s+([A-Z][A-Z0-9\-_]+)\s+TO\s+([A-Z][A-Z0-9\-_]+)/);
                    if (moveMatch) {
                        const sourceField = moveMatch[1];
                        const targetField = moveMatch[2];
                        
                        if (!fileLifecycle.fieldOps[targetField]) {
                            fileLifecycle.fieldOps[targetField] = [];
                        }
                        fileLifecycle.fieldOps[targetField].push({
                            operation: 'MOVE',
                            source: sourceField,
                            program: currentProgram,
                            line: lineNum + 1
                        });
                    }
                });

                return fileLifecycle;
            }

            mergeLifecycleData(lifecycleFlow, fileLifecycle, fileName) {
                // Merge creation sources
                fileLifecycle.creation.forEach(op => {
                    lifecycleFlow.creationSources.push({
                        ...op,
                        sourceFile: fileName
                    });
                });

                // Merge reading programs
                fileLifecycle.reading.forEach(op => {
                    if (op.program && !lifecycleFlow.inputPrograms.find(p => p.program === op.program)) {
                        lifecycleFlow.inputPrograms.push({
                            program: op.program,
                            operation: op.operation,
                            sourceFile: fileName
                        });
                    }
                });

                // Merge updating programs
                fileLifecycle.updating.forEach(op => {
                    if (op.program && !lifecycleFlow.updatePrograms.find(p => p.program === op.program)) {
                        lifecycleFlow.updatePrograms.push({
                            program: op.program,
                            operation: op.operation,
                            sourceFile: fileName
                        });
                    }
                });

                // Merge CICS screens
                fileLifecycle.cicsOps.forEach(op => {
                    if (!lifecycleFlow.cicsScreens.find(s => s.target === op.target)) {
                        lifecycleFlow.cicsScreens.push({
                            screen: op.target,
                            operation: op.operation,
                            program: op.program,
                            sourceFile: fileName
                        });
                    }
                });

                // Merge batch jobs
                fileLifecycle.batchOps.forEach(op => {
                    if (!lifecycleFlow.batchJobs.find(j => j.target === op.target)) {
                        lifecycleFlow.batchJobs.push({
                            job: op.target,
                            operation: op.operation,
                            sourceFile: fileName
                        });
                    }
                });

                // Merge field operations
                Object.keys(fileLifecycle.fieldOps).forEach(field => {
                    if (!lifecycleFlow.fieldUpdateTracking[field]) {
                        lifecycleFlow.fieldUpdateTracking[field] = [];
                    }
                    lifecycleFlow.fieldUpdateTracking[field] = lifecycleFlow.fieldUpdateTracking[field].concat(
                        fileLifecycle.fieldOps[field].map(op => ({
                            ...op,
                            sourceFile: fileName
                        }))
                    );
                });
            }

            determineUsagePattern(lifecycleFlow) {
                const hasCreation = lifecycleFlow.creationSources.length > 0;
                const hasReading = lifecycleFlow.inputPrograms.length > 0;
                const hasUpdating = lifecycleFlow.updatePrograms.length > 0;
                const hasCics = lifecycleFlow.cicsScreens.length > 0;
                const hasBatch = lifecycleFlow.batchJobs.length > 0;

                if (hasCreation && hasUpdating && hasCics) {
                    return 'ONLINE_TRANSACTIONAL';
                } else if (hasCreation && hasUpdating && hasBatch) {
                    return 'BATCH_PROCESSING';
                } else if (hasReading && !hasUpdating && !hasCreation) {
                    return 'READ_ONLY';
                } else if (hasCreation && !hasUpdating) {
                    return 'CREATION_ONLY';
                } else if (hasUpdating && !hasCreation) {
                    return 'UPDATE_ONLY';
                } else if (hasCreation && hasUpdating) {
                    return 'FULL_LIFECYCLE';
                } else {
                    return 'REFERENCE_ONLY';
                }
            }

            extractFieldUpdateTracking(relevantFiles, componentName) {
                const fieldTracking = {};
                
                relevantFiles.forEach(file => {
                    const lines = file.content.split('\n');
                    let currentProgram = '';
                    
                    lines.forEach((line, lineNum) => {
                        const trimmed = line.trim().toUpperCase();
                        
                        // Track current program
                        const programMatch = trimmed.match(/PROGRAM-ID\.?\s+([A-Z][A-Z0-9\-_]+)/);
                        if (programMatch) {
                            currentProgram = programMatch[1];
                        }

                        // Track field updates via MOVE statements
                        const moveMatch = trimmed.match(/MOVE\s+([A-Z][A-Z0-9\-_]+)\s+TO\s+([A-Z][A-Z0-9\-_]+)/);
                        if (moveMatch) {
                            const sourceField = moveMatch[1];
                            const targetField = moveMatch[2];
                            
                            if (!fieldTracking[targetField]) {
                                fieldTracking[targetField] = {
                                    updatedBy: [],
                                    sources: [],
                                    usageType: 'DERIVED'
                                };
                            }
                            
                            if (currentProgram && !fieldTracking[targetField].updatedBy.includes(currentProgram)) {
                                fieldTracking[targetField].updatedBy.push(currentProgram);
                            }
                            
                            if (!fieldTracking[targetField].sources.includes(sourceField)) {
                                fieldTracking[targetField].sources.push(sourceField);
                            }
                        }

                        // Track field validation
                        const ifMatch = trimmed.match(/IF\s+([A-Z][A-Z0-9\-_]+)\s+(?:=|NOT|>|<|EQUAL)/);
                        if (ifMatch) {
                            const field = ifMatch[1];
                            if (!fieldTracking[field]) {
                                fieldTracking[field] = {
                                    updatedBy: [],
                                    sources: [],
                                    usageType: 'CONDITION'
                                };
                            }
                            fieldTracking[field].usageType = 'CONDITION';
                        }

                        // Track field input from screens
                        const acceptMatch = trimmed.match(/ACCEPT\s+([A-Z][A-Z0-9\-_]+)/);
                        if (acceptMatch) {
                            const field = acceptMatch[1];
                            if (!fieldTracking[field]) {
                                fieldTracking[field] = {
                                    updatedBy: [],
                                    sources: ['USER_INPUT'],
                                    usageType: 'INPUT'
                                };
                            } else {
                                fieldTracking[field].usageType = 'INPUT';
                                if (!fieldTracking[field].sources.includes('USER_INPUT')) {
                                    fieldTracking[field].sources.push('USER_INPUT');
                                }
                            }
                        }

                        // Track field output to screens
                        const displayMatch = trimmed.match(/DISPLAY\s+([A-Z][A-Z0-9\-_]+)/);
                        if (displayMatch) {
                            const field = displayMatch[1];
                            if (!fieldTracking[field]) {
                                fieldTracking[field] = {
                                    updatedBy: [],
                                    sources: [],
                                    usageType: 'OUTPUT'
                                };
                            } else {
                                if (fieldTracking[field].usageType === 'UNKNOWN') {
                                    fieldTracking[field].usageType = 'OUTPUT';
                                }
                            }
                        }
                    });
                });

                return fieldTracking;
            }

            // === ENHANCED LLM ANALYSIS WITH LIFECYCLE ===
            async analyzeCopybookWithLLMAndLifecycle(copybookName, relevantFiles, basicDependencies, lifecycleFlow) {
                console.log(`LLM analyzing copybook with lifecycle: ${copybookName}`);
                
                const copybookFile = relevantFiles.find(f => 
                    f.type === 'Copybook' && 
                    (f.name.toUpperCase().includes(copybookName.toUpperCase()) || 
                     f.content.toUpperCase().includes(copybookName.toUpperCase()))
                );

                if (!copybookFile) {
                    throw new Error(`Copybook file for ${copybookName} not found`);
                }

                const copybookContent = this.prepareContentForLLM(copybookFile.content, 'copybook');
                const usingPrograms = this.findProgramsUsingCopybook(copybookName);
                
                const llmPrompt = `MAINFRAME COPYBOOK LIFECYCLE ANALYSIS

TASK: Analyze the copybook "${copybookName}" with complete file lifecycle context and provide detailed field lifecycle information.

COPYBOOK CONTENT:
${copybookContent}

PROGRAMS USING THIS COPYBOOK:
${usingPrograms.map(p => p.name).join(', ')}

FILE LIFECYCLE CONTEXT:
Usage Pattern: ${lifecycleFlow.usagePattern}
Input Programs: ${lifecycleFlow.inputPrograms.map(p => p.program).join(', ')}
Update Programs: ${lifecycleFlow.updatePrograms.map(p => p.program).join(', ')}
CICS Screens: ${lifecycleFlow.cicsScreens.map(s => s.screen).join(', ')}
Batch Jobs: ${lifecycleFlow.batchJobs.map(j => j.job).join(', ')}

FIELD UPDATE TRACKING:
${Object.keys(lifecycleFlow.fieldUpdateTracking).slice(0, 10).map(field => 
    `${field}: Updated by [${lifecycleFlow.fieldUpdateTracking[field].updatedBy.join(', ')}]`
).join('\n')}

DEPENDENCIES FOUND:
Copy Statements: ${basicDependencies.copyStatements.join(', ')}
Call Statements: ${basicDependencies.callStatements.join(', ')}

INSTRUCTIONS:
1. Extract ALL fields from the copybook with their levels, pictures, and values
2. Categorize each field based on lifecycle context: INPUT, OUTPUT, DERIVED, CONDITION, UNUSED, STATIC
3. For each field, analyze its usage pattern across the complete file lifecycle
4. Identify business rules and validation logic in context of the lifecycle flow
5. Provide field-level lifecycle recommendations based on usage patterns
6. Identify fields that participate in the file creation, update, and purge processes

OUTPUT FORMAT:
{
  "totalFields": <number>,
  "fieldCategories": {
    "INPUT_FIELDS": [<fields_from_user_screens_or_input_files>],
    "OUTPUT_FIELDS": [<fields_displayed_or_written_to_output>],
    "DERIVED_FIELDS": [<fields_calculated_from_other_fields>],
    "CONDITION_FIELDS": [<fields_used_in_if_when_conditions>],
    "UNUSED_FIELDS": [<fields_never_referenced>],
    "STATIC_FIELDS": [<fields_with_fixed_values>]
  },
  "fieldDetails": {
    "<field_name>": {
      "level": <number>,
      "picture": "<pic_clause>",
      "value": "<value_clause>",
      "category": "<category>",
      "usagePattern": "<detailed_usage_in_lifecycle>",
      "businessRole": "<business_purpose_in_context>",
      "lifecycleStage": "<creation|processing|output|purge>",
      "updatingPrograms": [<programs_that_modify_this_field>],
      "readingPrograms": [<programs_that_only_read_this_field>]
    }
  },
  "businessRules": [<extracted_business_rules_with_lifecycle_context>],
  "lifecycleRecommendations": [<field_lifecycle_optimization_suggestions>],
  "usagePatternAnalysis": {
    "creationFields": [<fields_set_during_creation>],
    "updateFields": [<fields_modified_during_updates>],
    "outputFields": [<fields_used_in_reports_or_displays>],
    "purgeFields": [<fields_checked_during_purge_process>]
  },
  "qualityScore": <1-10>
}

Respond with valid JSON only.`;

                return await this.callLLMAPI(llmPrompt);
            }

            async analyzeProgramWithLLMAndLifecycle(programName, relevantFiles, basicDependencies, lifecycleFlow) {
                console.log(`LLM analyzing program with lifecycle: ${programName}`);
                
                const programFile = relevantFiles.find(f => 
                    f.type === 'COBOL Program' && 
                    (f.name.toUpperCase().includes(programName.toUpperCase()) || 
                     f.content.toUpperCase().includes(`PROGRAM-ID. ${programName.toUpperCase()}`))
                );

                if (!programFile) {
                    throw new Error(`Program file for ${programName} not found`);
                }

                const programContent = this.prepareContentForLLM(programFile.content, 'program');

                const llmPrompt = `MAINFRAME COBOL PROGRAM LIFECYCLE ANALYSIS - JSON RESPONSE REQUIRED

CRITICAL: Respond with ONLY valid JSON. No explanatory text before or after the JSON.

TASK: Analyze COBOL program "${programName}" with complete lifecycle context.

PROGRAM CONTENT:
${programContent}

LIFECYCLE CONTEXT:
- Usage Pattern: ${lifecycleFlow.usagePattern}
- Program Role: ${this.determineProgramRole(programName, lifecycleFlow)}
- Dependencies: COPY: ${basicDependencies.copyStatements.slice(0,5).join(', ')}, CALL: ${basicDependencies.callStatements.slice(0,5).join(', ')}

REQUIRED JSON OUTPUT (complete this exact structure):
{
  "programStructure": {
    "divisions": [],
    "paragraphs": [],
    "sections": []
  },
  "lifecycleRole": {
    "primaryFunction": "PROCESS",
    "lifecycleStage": "processing",
    "dataFlowDirection": "BIDIRECTIONAL",
    "processingType": "BATCH"
  },
  "businessLogic": {
    "validationRules": [],
    "calculations": [],
    "decisionPoints": [],
    "fileOperations": []
  },
  "dataFlow": {
    "inputFiles": [],
    "outputFiles": [],
    "fieldTransformations": []
  },
  "dependencies": {
    "copybooks": [],
    "calledPrograms": [],
    "files": []
  },
  "lifecycleRecommendations": [],
  "complexity": "MEDIUM",
  "qualityScore": 7
}

RESPOND WITH VALID JSON ONLY:`;

                return await this.callLLMAPI(llmPrompt);
            } 

            determineProgramRole(programName, lifecycleFlow) {
                const isInputProgram = lifecycleFlow.inputPrograms.find(p => p.program === programName);
                const isUpdateProgram = lifecycleFlow.updatePrograms.find(p => p.program === programName);
                const isCreationSource = lifecycleFlow.creationSources.find(s => s.program === programName);
                
                if (isCreationSource) return 'CREATOR';
                if (isUpdateProgram) return 'UPDATER';
                if (isInputProgram) return 'READER';
                return 'PROCESSOR';
            }
            // === FIELD USAGE PATTERNS GENERATION ===
            async generateFieldUsagePatterns(llmAnalysis, lifecycleFlow) {
                console.log('Generating field usage patterns...');
                
                const usagePatterns = {
                    totalFields: 0,
                    inputFieldCount: 0,
                    outputFieldCount: 0,
                    derivedFieldCount: 0,
                    unusedFieldCount: 0,
                    staticFieldCount: 0,
                    conditionFieldCount: 0,
                    fieldsByLifecycleStage: {
                        creation: [],
                        processing: [],
                        output: [],
                        purge: []
                    },
                    fieldsByUsageType: {
                        highUsage: [],
                        mediumUsage: [],
                        lowUsage: [],
                        noUsage: []
                    },
                    programFieldMapping: {},
                    lifecycleFieldFlow: []
                };

                if (llmAnalysis && llmAnalysis.fieldCategories) {
                    // Count fields by category
                    usagePatterns.inputFieldCount = (llmAnalysis.fieldCategories.INPUT_FIELDS || []).length;
                    usagePatterns.outputFieldCount = (llmAnalysis.fieldCategories.OUTPUT_FIELDS || []).length;
                    usagePatterns.derivedFieldCount = (llmAnalysis.fieldCategories.DERIVED_FIELDS || []).length;
                    usagePatterns.unusedFieldCount = (llmAnalysis.fieldCategories.UNUSED_FIELDS || []).length;
                    usagePatterns.staticFieldCount = (llmAnalysis.fieldCategories.STATIC_FIELDS || []).length;
                    usagePatterns.conditionFieldCount = (llmAnalysis.fieldCategories.CONDITION_FIELDS || []).length;
                    
                    usagePatterns.totalFields = usagePatterns.inputFieldCount + 
                                              usagePatterns.outputFieldCount + 
                                              usagePatterns.derivedFieldCount + 
                                              usagePatterns.unusedFieldCount + 
                                              usagePatterns.staticFieldCount + 
                                              usagePatterns.conditionFieldCount;

                    // Map fields to lifecycle stages if available
                    if (llmAnalysis.usagePatternAnalysis) {
                        usagePatterns.fieldsByLifecycleStage.creation = llmAnalysis.usagePatternAnalysis.creationFields || [];
                        usagePatterns.fieldsByLifecycleStage.processing = llmAnalysis.usagePatternAnalysis.updateFields || [];
                        usagePatterns.fieldsByLifecycleStage.output = llmAnalysis.usagePatternAnalysis.outputFields || [];
                        usagePatterns.fieldsByLifecycleStage.purge = llmAnalysis.usagePatternAnalysis.purgeFields || [];
                    }
                }

                // Generate program-field mapping from lifecycle flow
                Object.keys(lifecycleFlow.fieldUpdateTracking).forEach(field => {
                    const fieldTracking = lifecycleFlow.fieldUpdateTracking[field];
                    usagePatterns.programFieldMapping[field] = {
                        updatingPrograms: fieldTracking.updatedBy || [],
                        sources: fieldTracking.sources || [],
                        usageType: fieldTracking.usageType || 'UNKNOWN'
                    };
                });

                // Generate lifecycle field flow
                usagePatterns.lifecycleFieldFlow = this.generateLifecycleFieldFlow(llmAnalysis, lifecycleFlow);

                console.log('Field usage patterns generated:', usagePatterns);
                return usagePatterns;
            }

            generateLifecycleFieldFlow(llmAnalysis, lifecycleFlow) {
                const lifecycleFlow_fields = [];
                
                // Creation stage
                if (lifecycleFlow.creationSources.length > 0) {
                    lifecycleFlow_fields.push({
                        stage: 'CREATION',
                        icon: 'üå±',
                        title: 'Data Creation',
                        description: 'Fields are initially populated',
                        programs: lifecycleFlow.creationSources.map(s => s.program).filter(Boolean),
                        fields: llmAnalysis?.usagePatternAnalysis?.creationFields || [],
                        active: true
                    });
                }

                // Processing stage
                if (lifecycleFlow.updatePrograms.length > 0) {
                    lifecycleFlow_fields.push({
                        stage: 'PROCESSING',
                        icon: '‚öôÔ∏è',
                        title: 'Data Processing',
                        description: 'Fields are calculated, validated, and transformed',
                        programs: lifecycleFlow.updatePrograms.map(p => p.program).filter(Boolean),
                        fields: llmAnalysis?.usagePatternAnalysis?.updateFields || [],
                        active: lifecycleFlow.updatePrograms.length > 0
                    });
                }

                // CICS interaction stage
                if (lifecycleFlow.cicsScreens.length > 0) {
                    lifecycleFlow_fields.push({
                        stage: 'INTERACTION',
                        icon: 'üñ•Ô∏è',
                        title: 'User Interaction',
                        description: 'Data displayed to users and input collected',
                        programs: [...new Set(lifecycleFlow.cicsScreens.map(s => s.program).filter(Boolean))],
                        screens: lifecycleFlow.cicsScreens.map(s => s.screen),
                        fields: llmAnalysis?.fieldCategories?.INPUT_FIELDS || [],
                        active: lifecycleFlow.cicsScreens.length > 0
                    });
                }

                // Output stage
                if (lifecycleFlow.inputPrograms.length > 0) {
                    lifecycleFlow_fields.push({
                        stage: 'OUTPUT',
                        icon: 'üì§',
                        title: 'Data Output',
                        description: 'Data is read and output to reports or files',
                        programs: lifecycleFlow.inputPrograms.map(p => p.program).filter(Boolean),
                        fields: llmAnalysis?.usagePatternAnalysis?.outputFields || [],
                        active: lifecycleFlow.inputPrograms.length > 0
                    });
                }

                // Batch processing stage
                if (lifecycleFlow.batchJobs.length > 0) {
                    lifecycleFlow_fields.push({
                        stage: 'BATCH',
                        icon: 'üîÑ',
                        title: 'Batch Processing',
                        description: 'Data processed in batch jobs',
                        programs: lifecycleFlow.batchJobs.map(j => j.job).filter(Boolean),
                        fields: [],
                        active: lifecycleFlow.batchJobs.length > 0
                    });
                }

                // Purge stage (if detected)
                const hasPurgeOps = lifecycleFlow.purgeProcesses.length > 0;
                if (hasPurgeOps) {
                    lifecycleFlow_fields.push({
                        stage: 'PURGE',
                        icon: 'üóëÔ∏è',
                        title: 'Data Purge',
                        description: 'Data is archived or deleted',
                        programs: lifecycleFlow.purgeProcesses.map(p => p.program).filter(Boolean),
                        fields: llmAnalysis?.usagePatternAnalysis?.purgeFields || [],
                        active: hasPurgeOps
                    });
                }

                return lifecycleFlow_fields;
            }

            // === BASIC DEPENDENCY EXTRACTION (Using regex for performance) ===
            async extractBasicDependencies() {
                console.log('Extracting basic dependencies using regex patterns...');
                
                const dependencies = {
                    copyStatements: new Set(),
                    callStatements: new Set(),
                    execStatements: new Set(),
                    jclDatasets: new Set(),
                    programIds: new Set(),
                    sqlTables: new Set(),
                    fileReferences: new Set()
                };

                for (const file of this.uploadedFiles) {
                    const fileDeps = this.extractDependenciesFromFile(file);
                    
                    Object.keys(fileDeps).forEach(depType => {
                        if (dependencies[depType]) {
                            fileDeps[depType].forEach(dep => dependencies[depType].add(dep));
                        }
                    });
                }

                const cleanDependencies = {};
                Object.keys(dependencies).forEach(key => {
                    cleanDependencies[key] = Array.from(dependencies[key])
                        .filter(dep => dep && dep.length > 1)
                        .slice(0, 50);
                });

                console.log('Basic dependencies extracted:', cleanDependencies);
                return cleanDependencies;
            }

            extractDependenciesFromFile(file) {
                const dependencies = {
                    copyStatements: [],
                    callStatements: [],
                    execStatements: [],
                    jclDatasets: [],
                    programIds: [],
                    sqlTables: [],
                    fileReferences: []
                };

                const lines = file.content.split('\n');
                
                lines.forEach((line, lineNum) => {
                    const trimmed = line.trim().toUpperCase();
                    
                    // COPY statements
                    let copyMatch = trimmed.match(/COPY\s+(['"]*[A-Z][A-Z0-9\-_]{1,}['"]*)/);
                    if (copyMatch) {
                        const copyName = copyMatch[1].replace(/['"]/g, '');
                        dependencies.copyStatements.push(copyName);
                    }

                    // CALL statements
                    let callMatch = trimmed.match(/CALL\s+['"]*([A-Z][A-Z0-9\-_]{1,})['"]*/) ||
                                   trimmed.match(/LINK\s+['"]*([A-Z][A-Z0-9\-_]{1,})['"]*/) ||
                                   trimmed.match(/XCTL\s+['"]*([A-Z][A-Z0-9\-_]{1,})['"]*/);
                    if (callMatch) {
                        dependencies.callStatements.push(callMatch[1]);
                    }

                    // JCL EXEC statements
                    let execMatch = trimmed.match(/EXEC\s+PGM=([A-Z][A-Z0-9\-_]{1,})/) ||
                                   trimmed.match(/\/\/\w+\s+EXEC\s+([A-Z][A-Z0-9\-_]{1,})/);
                    if (execMatch) {
                        dependencies.execStatements.push(execMatch[1]);
                    }

                    // PROGRAM-ID
                    let programMatch = trimmed.match(/PROGRAM-ID\.?\s+([A-Z][A-Z0-9\-_]{1,})/);
                    if (programMatch) {
                        dependencies.programIds.push(programMatch[1]);
                    }

                    // File references
                    let fileMatch = trimmed.match(/FD\s+([A-Z][A-Z0-9\-_]{1,})/) ||
                                   trimmed.match(/SELECT\s+([A-Z][A-Z0-9\-_]{1,})\s+ASSIGN/) ||
                                   trimmed.match(/OPEN\s+(?:INPUT|OUTPUT|I-O)\s+([A-Z][A-Z0-9\-_]{1,})/);
                    if (fileMatch) {
                        dependencies.fileReferences.push(fileMatch[1]);
                    }
                });

                return dependencies;
            }

            // === LLM UTILITY METHODS ===
            prepareContentForLLM(content, type) {
                const maxChars = this.maxTokens * this.averageCharsPerToken * 0.7;
                
                if (content.length <= maxChars) {
                    return content;
                }
                
                if (type === 'copybook') {
                    const lines = content.split('\n');
                    const importantLines = lines.filter(line => {
                        const trimmed = line.trim().toUpperCase();
                        return trimmed.match(/^\s*\d{2}\s+/) || 
                               trimmed.includes('PIC ') ||      
                               trimmed.includes('VALUE ') ||    
                               trimmed.includes('REDEFINES ');  
                    });
                    
                    let result = importantLines.join('\n');
                    if (result.length > maxChars) {
                        result = result.substring(0, maxChars);
                    }
                    return result;
                    
                } else if (type === 'program') {
                    const procedureIndex = content.toUpperCase().indexOf('PROCEDURE DIVISION');
                    if (procedureIndex > -1) {
                        const procedureContent = content.substring(procedureIndex);
                        if (procedureContent.length <= maxChars) {
                            return procedureContent;
                        }
                        return procedureContent.substring(0, maxChars);
                    }
                }
                
                return content.substring(0, maxChars);
            }

            async callLLMAPI(prompt, retries = 0) {
                let resultText = '';
                
                try {
                    // Increase max_tokens and use adaptive token allocation
                    const adaptiveMaxTokens = Math.min(
                        Math.floor(this.maxTokens * 0.9), // Use 90% of available tokens
                        8000 // Hard cap at 8000 tokens
                    );
                    
                    console.log(`Making LLM API call with ${adaptiveMaxTokens} max tokens...`);
                    
                    const response = await fetch(`${this.vllmEndpoint}/generate`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            prompt: prompt,
                            max_tokens: adaptiveMaxTokens,
                            temperature: this.llmConfig.temperature,
                            top_p: 0.95,
                            // Remove stop sequences that might prematurely cut off JSON
                            stop: [],
                            stream: false,
                            // Add these parameters to improve completion
                            frequency_penalty: 0.1,
                            presence_penalty: 0.1
                        }),
                        signal: AbortSignal.timeout(this.llmConfig.analysisTimeout)
                    });

                    if (!response.ok) {
                        throw new Error(`LLM API request failed: ${response.status} ${response.statusText}`);
                    }

                    const data = await response.json();
                    console.log('LLM API Response keys:', Object.keys(data));
                    
                    // Extract text from different possible response formats
                    // Extract text from different possible response formats
                    if (data.text) {
                        resultText = data.text.trim();
                    } else if (data.choices && data.choices.length > 0) {
                        // Handle OpenAI-style response format
                        if (data.choices[0].text) {
                            resultText = data.choices[0].text.trim();
                        } else if (data.choices[0].message && data.choices[0].message.content) {
                            resultText = data.choices[0].message.content.trim();
                        } else {
                            resultText = JSON.stringify(data.choices[0]).trim();
                        }
                    } else if (data.generated_text) {
                        resultText = data.generated_text.trim();
                    } else if (data.response) {
                        resultText = data.response.trim();
                    } else if (data.output) {
                        resultText = data.output.trim();
                    } else if (data.content) {
                        resultText = data.content.trim();
                    } else if (typeof data === 'string') {
                        resultText = data.trim();
                    } else {
                        console.error('Unexpected LLM response format:', data);
                        // Try to extract any text content from the object
                        const textContent = this.extractTextFromObject(data);
                        resultText = textContent || JSON.stringify(data);
                    }

                    console.log(`Extracted resultText length: ${resultText.length} chars`);
                    console.log('First 200 chars:', resultText.substring(0, 200));
                    console.log('Last 200 chars:', resultText.substring(Math.max(0, resultText.length - 200)));

                    // Check if response appears to be cut off
                    const isCutOff = this.detectCutOffResponse(resultText);
                    if (isCutOff && retries < this.llmConfig.maxRetries) {
                        console.warn('Response appears to be cut off, attempting continuation...');
                        const continuedResponse = await this.continueResponse(resultText, prompt, retries);
                        if (continuedResponse) {
                            resultText = continuedResponse;
                        }
                    }

                    // Try to parse as JSON
                    const parsedResult = this.parseJSONResponse(resultText);
                    if (parsedResult.success) {
                        console.log('Successfully parsed JSON response');
                        return parsedResult.data;
                    } else {
                        console.warn('JSON parsing failed, using fallback analysis');
                        return this.createEnhancedFallback(resultText, parsedResult.error);
                    }

                } catch (error) {
                    console.error('LLM API call error:', error);
                    
                    if (retries < this.llmConfig.maxRetries) {
                        console.warn(`LLM API call failed, retrying (${retries + 1}/${this.llmConfig.maxRetries}):`, error);
                        await this.sleep(2000);
                        return this.callLLMAPI(prompt, retries + 1);
                    }
                    
                    return {
                        error: 'LLM API call failed',
                        message: error.message,
                        rawResponse: resultText,
                        fallbackAnalysis: this.createFallbackAnalysis(resultText || 'No response received')
                    };
                }
            }

            extractTextFromObject(obj) {
                if (typeof obj === 'string') return obj;
                if (!obj || typeof obj !== 'object') return null;
                
                // Common text field names in LLM responses
                const textFields = ['text', 'content', 'generated_text', 'response', 'output', 'result'];
                
                for (const field of textFields) {
                    if (obj[field] && typeof obj[field] === 'string') {
                        return obj[field].trim();
                    }
                }
                
                // If it's an array, try the first element
                if (Array.isArray(obj) && obj.length > 0) {
                    return this.extractTextFromObject(obj[0]);
                }
                
                return null;
            }

            parseJSONResponse(text) {
                if (!text || typeof text !== 'string') {
                    return { success: false, error: 'No text provided', rawText: text };
                }

                // First, try to extract JSON from the text
                const jsonMatch = text.match(/\{[\s\S]*\}/);
                let jsonText = jsonMatch ? jsonMatch[0] : text;

                const attempts = [
                    // Attempt 1: Direct parse
                    () => JSON.parse(jsonText),
                    
                    // Attempt 2: Clean and parse
                    () => {
                        const cleaned = this.aggressiveJSONClean(jsonText);
                        console.log('Cleaned JSON attempt:', cleaned.substring(0, 200));
                        return JSON.parse(cleaned);
                    },
                    
                    // Attempt 3: Extract partial structure
                    () => {
                        return this.extractValidJSONStructure(text);
                    },
                    
                    // Attempt 4: Create fallback structure
                    () => {
                        return this.createFallbackStructure(text);
                    }
                ];

                for (let i = 0; i < attempts.length; i++) {
                    try {
                        const result = attempts[i]();
                        if (result && typeof result === 'object') {
                            console.log(`JSON parse attempt ${i + 1} succeeded`);
                            return { success: true, data: result };
                        }
                    } catch (error) {
                        console.warn(`JSON parse attempt ${i + 1} failed:`, error.message);
                    }
                }

                return { 
                    success: false, 
                    error: 'All JSON parsing attempts failed',
                    rawText: text.substring(0, 1000)
                };
            }
            

            aggressiveJSONClean(text) {
                if (!text) return '{}';
                
                // Extract content between first { and last }
                const firstBrace = text.indexOf('{');
                const lastBrace = text.lastIndexOf('}');
                
                if (firstBrace === -1 || lastBrace === -1 || firstBrace >= lastBrace) {
                    return '{}';
                }
                
                let jsonText = text.substring(firstBrace, lastBrace + 1);
                
                // Remove any text that looks like error messages or validation warnings
                jsonText = jsonText.replace(/VALIDATION[^"]*?(?="|,|})/g, '"VALIDATION_ERROR"');
                
                // Fix common issues
                jsonText = jsonText
                    // Remove trailing commas
                    .replace(/,(\s*[\}\]])/g, '$1')
                    // Quote unquoted property names
                    .replace(/([{,]\s*)([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g, '$1"$2":')
                    // Fix unquoted string values (but preserve numbers, booleans, null)
                    .replace(/:\s*([^",\[\{][^,\]\}]*?)(\s*[,\]\}])/g, (match, value, ending) => {
                        const trimmed = value.trim();
                        if (!trimmed) return `: ""${ending}`;
                        if (trimmed === 'true' || trimmed === 'false' || trimmed === 'null') {
                            return `: ${trimmed}${ending}`;
                        }
                        if (/^\d+(\.\d+)?$/.test(trimmed)) {
                            return `: ${trimmed}${ending}`;
                        }
                        // Quote the value and escape any quotes inside
                        const escaped = trimmed.replace(/"/g, '\\"');
                        return `: "${escaped}"${ending}`;
                    })
                    // Fix array formatting
                    .replace(/\[\s*([^"]\w+[^"]*?)\s*\]/g, (match, content) => {
                        const items = content.split(',').map(item => {
                            const trimmed = item.trim();
                            if (trimmed === 'true' || trimmed === 'false' || trimmed === 'null' || /^\d+(\.\d+)?$/.test(trimmed)) {
                                return trimmed;
                            }
                            return `"${trimmed.replace(/"/g, '\\"')}"`;
                        });
                        return `[${items.join(', ')}]`;
                    });
                
                return jsonText;
            }
            
           extractValidJSONStructure(text) {
                const structure = {
                    analysisMethod: 'Extracted Structure',
                    status: 'Partial extraction successful'
                };
                
                // Extract field categories
                const fieldCategoriesMatch = text.match(/"fieldCategories":\s*\{([^}]+)\}/);
                if (fieldCategoriesMatch) {
                    structure.fieldCategories = this.parseFieldCategories(fieldCategoriesMatch[1]);
                }
                
                // Extract total fields
                const totalFieldsMatch = text.match(/"totalFields":\s*(\d+)/);
                if (totalFieldsMatch) {
                    structure.totalFields = parseInt(totalFieldsMatch[1]);
                }
                
                // Extract quality score
                const qualityMatch = text.match(/"qualityScore":\s*(\d+)/);
                if (qualityMatch) {
                    structure.qualityScore = parseInt(qualityMatch[1]);
                }
                
                // Extract recommendations
                const recMatch = text.match(/"recommendations":\s*\[(.*?)\]/s);
                if (recMatch) {
                    structure.recommendations = this.parseArrayContent(recMatch[1]);
                }
                
                // Extract business rules
                const rulesMatch = text.match(/"businessRules":\s*\[(.*?)\]/s);
                if (rulesMatch) {
                    structure.businessRules = this.parseArrayContent(rulesMatch[1]);
                }
                
                return structure;
            }
           
            parseFieldCategories(categoriesText) {
                const categories = {};
                
                // Match category patterns like "INPUT_FIELDS": [...]
                const categoryPattern = /"([A-Z_]+)":\s*\[(.*?)\]/g;
                let match;
                
                while ((match = categoryPattern.exec(categoriesText)) !== null) {
                    const categoryName = match[1];
                    const itemsText = match[2];
                    categories[categoryName] = this.parseArrayContent(itemsText);
                }
                
                return categories;
            }

            parseArrayContent(arrayText) {
                if (!arrayText || !arrayText.trim()) return [];
                
                const items = [];
                // Match quoted strings
                const quotedPattern = /"([^"]+)"/g;
                let match;
                
                while ((match = quotedPattern.exec(arrayText)) !== null) {
                    items.push(match[1]);
                }
                
                // If no quoted items found, try splitting by comma
                if (items.length === 0) {
                    const splitItems = arrayText.split(',');
                    for (const item of splitItems) {
                        const cleaned = item.trim().replace(/['"]/g, '');
                        if (cleaned && cleaned !== 'null' && cleaned !== 'undefined') {
                            items.push(cleaned);
                        }
                    }
                }
                
                return items;
            }

            createFallbackStructure(text) {
                return {
                    analysisMethod: 'Fallback Structure',
                    status: 'JSON parsing failed, using text analysis',
                    textContent: text.substring(0, 500),
                    recommendations: [
                        'Review the raw LLM response for detailed analysis',
                        'Check LLM response format configuration',
                        'Consider adjusting prompt for better JSON output'
                    ],
                    qualityScore: 4,
                    hasContent: text && text.length > 0,
                    extractedInfo: this.extractBasicInfo(text)
                };
            }

            extractBasicInfo(text) {
                const info = {};
                
                // Look for common patterns
                if (text.includes('field') || text.includes('FIELD')) {
                    info.hasFieldInfo = true;
                }
                if (text.includes('business') || text.includes('BUSINESS')) {
                    info.hasBusinessInfo = true;
                }
                if (text.includes('recommend') || text.includes('RECOMMEND')) {
                    info.hasRecommendations = true;
                }
                
                return info;
            }
           
           
            cleanJSONText(text) {
                    if (!text || typeof text !== 'string') return '{}';
                    
                    // Remove any text before the first {
                    let startIndex = text.indexOf('{');
                    if (startIndex === -1) {
                        // No JSON object found, try to create one from key-value pairs
                        return this.createJSONFromText(text);
                    }
                    
                    if (startIndex > 0) {
                        text = text.substring(startIndex);
                    }
                    
                    // Find the last complete } that balances the braces
                    let braceCount = 0;
                    let lastValidIndex = -1;
                    
                    for (let i = 0; i < text.length; i++) {
                        if (text[i] === '{') {
                            braceCount++;
                        } else if (text[i] === '}') {
                            braceCount--;
                            if (braceCount === 0) {
                                lastValidIndex = i;
                                break;
                            }
                        }
                    }
                    
                    if (lastValidIndex > 0) {
                        text = text.substring(0, lastValidIndex + 1);
                    }
                    
                    // Fix common JSON formatting issues
                    text = text
                        .replace(/,(\s*[\}\]])/g, '$1')  // Remove trailing commas
                        .replace(/([{,]\s*)(\w+):/g, '$1"$2":')  // Quote unquoted keys
                        .replace(/:\s*([^",\[\{][^,\]\}]*?)(\s*[,\]\}])/g, (match, value, ending) => {
                            // Quote unquoted string values, but not numbers or booleans
                            const trimmedValue = value.trim();
                            if (trimmedValue === 'true' || trimmedValue === 'false' || 
                                trimmedValue === 'null' || /^\d+(\.\d+)?$/.test(trimmedValue)) {
                                return `: ${trimmedValue}${ending}`;
                            }
                            return `: "${trimmedValue}"${ending}`;
                        });
                    
                    return text;
                }

            extractPartialObject(text) {
                const result = {};
                
                // Extract field categories
                const fieldCategoriesMatch = text.match(/"fieldCategories":\s*\{([^}]+)\}/);
                if (fieldCategoriesMatch) {
                    try {
                        result.fieldCategories = JSON.parse(`{${fieldCategoriesMatch[1]}}`);
                    } catch (e) {
                        result.fieldCategories = this.parseFieldCategories(fieldCategoriesMatch[1]);
                    }
                }
                
                // Extract other common fields
                const commonFields = ['totalFields', 'qualityScore', 'complexity', 'componentType'];
                commonFields.forEach(field => {
                    const regex = new RegExp(`"${field}":\\s*([^,\\n\\}]+)`);
                    const match = text.match(regex);
                    if (match) {
                        try {
                            result[field] = JSON.parse(match[1]);
                        } catch (e) {
                            result[field] = match[1].replace(/"/g, '');
                        }
                    }
                });
                
                // Extract recommendations
                const recommendationsMatch = text.match(/"recommendations":\s*\[(.*?)\]/s);
                if (recommendationsMatch) {
                    try {
                        result.recommendations = JSON.parse(`[${recommendationsMatch[1]}]`);
                    } catch (e) {
                        result.recommendations = this.extractArrayItems(recommendationsMatch[1]);
                    }
                }
                
                return result;
            }

            parseFieldCategories(categoriesText) {
                const categories = {};
                const categoryMatches = categoriesText.match(/"(\w+)":\s*\[(.*?)\]/g);
                
                if (categoryMatches) {
                    categoryMatches.forEach(match => {
                        const parts = match.match(/"(\w+)":\s*\[(.*?)\]/);
                        if (parts) {
                            const categoryName = parts[1];
                            const itemsText = parts[2];
                            categories[categoryName] = this.extractArrayItems(itemsText);
                        }
                    });
                }
                
                return categories;
            }

            extractArrayItems(arrayText) {
                const items = [];
                const itemMatches = arrayText.match(/"([^"]+)"/g);
                
                if (itemMatches) {
                    itemMatches.forEach(match => {
                        items.push(match.replace(/"/g, ''));
                    });
                }
                
                return items;
            }

            createEnhancedFallback(rawText, parseError) {
                console.log('Creating enhanced fallback analysis...');
                
                // Ensure we have valid text to work with
                const safeRawText = rawText || 'No response content available';
                
                const fallback = {
                    analysisMethod: 'Enhanced Fallback Analysis',
                    status: 'Partial - JSON parsing failed but content extracted',
                    parseError: parseError,
                    extractedData: this.extractPartialObject(safeRawText),
                    rawResponse: safeRawText.substring(0, 2000) + (safeRawText.length > 2000 ? '...' : ''),
                    recommendations: this.extractRecommendationsFromText(safeRawText),
                    qualityScore: 6,
                    completeness: 'Partial'
                };
                
                // Try to extract additional structured information
                if (safeRawText.includes('fieldCategories') || safeRawText.includes('FIELD')) {
                    fallback.hasFieldAnalysis = true;
                }
                
                if (safeRawText.includes('businessLogic') || safeRawText.includes('BUSINESS')) {
                    fallback.hasBusinessLogic = true;
                }
                
                return fallback;
            }

            extractRecommendationsFromText(text) {
                const recommendations = [];
                const lines = text.split('\n');
                
                lines.forEach(line => {
                    if (line.includes('recommend') || line.includes('RECOMMEND') || 
                        line.includes('suggest') || line.includes('SUGGEST') ||
                        line.includes('consider') || line.includes('CONSIDER')) {
                        const cleaned = line.replace(/[\[\]"{}]/g, '').trim();
                        if (cleaned.length > 10) {
                            recommendations.push(cleaned);
                        }
                    }
                });
                
                return recommendations.slice(0, 5); // Limit to 5 recommendations
            }

            createFallbackAnalysis(rawResponse) {
                // Ensure rawResponse is a string
                const responseText = typeof rawResponse === 'string' ? rawResponse : String(rawResponse || 'No response received');
                
                return {
                    analysisType: 'Fallback Analysis',
                    summary: responseText.substring(0, 500),
                    recommendations: [
                        'Review raw LLM response for detailed analysis',
                        'Check LLM server configuration and response format',
                        'Try adjusting max_tokens or temperature settings'
                    ],
                    qualityScore: 3,
                    status: 'Partial - JSON parsing failed but response received',
                    rawContent: responseText
                };
            }     
            
            detectCutOffResponse(text) {
                if (!text || text.length < 100) return true;
                
                // Check for incomplete JSON structure
                const openBraces = (text.match(/\{/g) || []).length;
                const closeBraces = (text.match(/\}/g) || []).length;
                const openBrackets = (text.match(/\[/g) || []).length;
                const closeBrackets = (text.match(/\]/g) || []).length;
                
                // If braces/brackets don't match, likely cut off
                if (openBraces !== closeBraces || openBrackets !== closeBrackets) {
                    return true;
                }
                
                // Check for incomplete field endings
                const incompletePatterns = [
                    /,\s*$/,  // Ends with comma
                    /:\s*$/,  // Ends with colon
                    /"\s*$/,  // Ends with quote
                    /\[\s*$/  // Ends with open bracket
                ];
                
                return incompletePatterns.some(pattern => pattern.test(text.trim()));
            }

             async continueResponse(partialResponse, originalPrompt, retries) {
                try {
                    console.log('Attempting to continue incomplete response...');
                    
                    const continuationPrompt = `CONTINUE RESPONSE FROM WHERE IT LEFT OFF

ORIGINAL PROMPT: ${originalPrompt.substring(0, 500)}...

PARTIAL RESPONSE SO FAR:
${partialResponse}

INSTRUCTIONS:
Continue the JSON response from exactly where it left off. Do not repeat any content from the partial response above. Just continue with the missing parts to complete the JSON structure. Start immediately with the continuation (no explanatory text).

Continue from here:`;

                    const response = await fetch(`${this.vllmEndpoint}/generate`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            prompt: continuationPrompt,
                            max_tokens: Math.floor(this.maxTokens * 0.3), // Use fewer tokens for continuation
                            temperature: 0.1, // Lower temperature for consistency
                            top_p: 0.8,
                            stop: [],
                            stream: false
                        }),
                        signal: AbortSignal.timeout(60000)
                    });

                    if (!response.ok) {
                        console.warn('Continuation request failed');
                        return null;
                    }

                    const data = await response.json();
                    let continuationText = '';
                    
                    if (data.text) {
                        continuationText = data.text.trim();
                    } else if (data.choices && data.choices[0] && data.choices[0].text) {
                        continuationText = data.choices[0].text.trim();
                    } else if (data.generated_text) {
                        continuationText = data.generated_text.trim();
                    }

                    if (continuationText) {
                        console.log('Got continuation text, combining responses...');
                        return this.combineResponses(partialResponse, continuationText);
                    }

                    return null;

                } catch (error) {
                    console.error('Continuation request failed:', error);
                    return null;
                }
            }

            combineResponses(partial, continuation) {
                // Remove any duplicate opening braces or structure
                let cleanContinuation = continuation;
                
                // If continuation starts with JSON structure, merge carefully
                if (cleanContinuation.startsWith('{')) {
                    // This means the continuation started a new JSON object
                    // We need to merge the content intelligently
                    return this.mergePartialJSON(partial, cleanContinuation);
                }
                
                // Simple concatenation for most cases
                let combined = partial + cleanContinuation;
                
                // Try to fix common structural issues
                combined = this.fixJSONStructure(combined);
                
                console.log('Combined response length:', combined.length);
                return combined;
            }

            mergePartialJSON(partial, continuation) {
                try {
                    // Extract content from the continuation JSON
                    const continuationData = JSON.parse(continuation);
                    
                    // Try to parse partial response up to the last valid structure
                    let partialData = {};
                    const lastBrace = partial.lastIndexOf('}');
                    if (lastBrace > 0) {
                        const partialToLastBrace = partial.substring(0, lastBrace + 1);
                        try {
                            partialData = JSON.parse(partialToLastBrace);
                        } catch (e) {
                            // If that fails, try to build partial object
                            partialData = this.extractPartialObject(partial);
                        }
                    }
                    
                    // Merge the objects
                    const merged = { ...partialData, ...continuationData };
                    return JSON.stringify(merged, null, 2);
                    
                } catch (error) {
                    console.warn('Smart merge failed, using simple concatenation');
                    return partial + continuation;
                }
            }

            fixJSONStructure(text) {
                // Remove any text before the first {
                const firstBrace = text.indexOf('{');
                if (firstBrace > 0) {
                    text = text.substring(firstBrace);
                }
                
                // Try to balance braces
                const openBraces = (text.match(/\{/g) || []).length;
                const closeBraces = (text.match(/\}/g) || []).length;
                
                if (openBraces > closeBraces) {
                    // Add missing closing braces
                    text += '}}'.repeat(openBraces - closeBraces);
                }
                
                // Remove trailing commas before closing braces
                text = text.replace(/,(\s*[\}\]])/g, '$1');
                
                return text;
            }

            parseRawLLMResponse(rawText) {
                const lines = rawText.split('\n');
                const analysis = {
                    fields: [],
                    recommendations: [],
                    businessRules: []
                };

                lines.forEach(line => {
                    const trimmed = line.trim();
                    if (trimmed.includes('field') || trimmed.includes('FIELD')) {
                        analysis.fields.push(trimmed);
                    } else if (trimmed.includes('recommend') || trimmed.includes('RECOMMEND')) {
                        analysis.recommendations.push(trimmed);
                    } else if (trimmed.includes('rule') || trimmed.includes('RULE')) {
                        analysis.businessRules.push(trimmed);
                    }
                });

                return analysis;
            }

            // === DEPENDENCY VALIDATION ===
            async validateDependenciesWithLLM(basicDependencies, relevantFiles) {
                console.log('LLM validating dependencies...');
                
                const fileContext = relevantFiles.map(f => 
                    `FILE: ${f.name} (${f.type})\nCONTENT_SAMPLE: ${f.content.substring(0, 500)}...`
                ).join('\n\n');

                const llmPrompt = `MAINFRAME DEPENDENCY VALIDATION

TASK: Validate and enhance the discovered dependencies using context from the actual files.

BASIC DEPENDENCIES FOUND:
Copy Statements: ${basicDependencies.copyStatements.join(', ')}
Call Statements: ${basicDependencies.callStatements.join(', ')}
Exec Statements: ${basicDependencies.execStatements.join(', ')}
Program IDs: ${basicDependencies.programIds.join(', ')}
File References: ${basicDependencies.fileReferences.join(', ')}

FILE CONTEXT:
${fileContext}

INSTRUCTIONS:
1. Validate each dependency against the actual file content
2. Remove false positives and add any missed dependencies
3. Categorize dependencies by type and criticality
4. Identify dependency chains and relationships
5. Assess impact and coupling levels

OUTPUT FORMAT:
{
  "validatedDependencies": {
    "copyStatements": [<validated_copies>],
    "callStatements": [<validated_calls>],
    "execStatements": [<validated_execs>],
    "programIds": [<validated_programs>],
    "fileReferences": [<validated_files>]
  },
  "dependencyChains": [<dependency_relationships>],
  "couplingLevel": "<LOW|MEDIUM|HIGH>",
  "impactAssessment": [<impact_descriptions>],
  "recommendations": [<dependency_recommendations>]
}

Respond with valid JSON only.`;

                return await this.callLLMAPI(llmPrompt);
            }

            // === ANALYSIS HELPER METHODS ===
            findRelevantFiles(componentName) {
                return this.uploadedFiles.filter(file => 
                    file.content.toUpperCase().includes(componentName.toUpperCase()) ||
                    file.name.toUpperCase().includes(componentName.toUpperCase())
                );
            }

            detectComponentType(componentName, files) {
                const copybookFile = files.find(f => f.type === 'Copybook');
                if (copybookFile) return 'Copybook';
                
                const programFile = files.find(f => f.type === 'COBOL Program');
                if (programFile) return 'COBOL Program';
                
                return 'Component';
            }

            findProgramsUsingCopybook(copybookName) {
                const usingPrograms = [];
                
                this.uploadedFiles.forEach(file => {
                    if (file.type === 'COBOL Program') {
                        const content = file.content.toUpperCase();
                        const copyPattern = new RegExp(`COPY\\s+['"]*${copybookName.toUpperCase()}['"]*`, 'g');
                        if (copyPattern.test(content)) {
                            usingPrograms.push(file);
                        }
                    }
                });
                
                return usingPrograms;
            }

            calculateQualityScore(analysisResult) {
                if (!analysisResult) return 5;
                
                if (analysisResult.qualityScore) {
                    return analysisResult.qualityScore;
                }
                
                let score = 5;
                
                if (analysisResult.fieldCategories) score += 2;
                if (analysisResult.businessLogic) score += 2;
                if (analysisResult.recommendations) score += 1;
                
                return Math.min(Math.max(score, 1), 10);
            }

            assessCompleteness(analysisResult) {
                if (!analysisResult) {
                    return { score: 0, checkpoints: {}, completed: 0, total: 6 };
                }
                
                const checkpoints = {
                    'LLM Analysis': !!analysisResult,
                    'Field Analysis': !!(analysisResult.fieldCategories || analysisResult.fieldDetails),
                    'Business Logic': !!(analysisResult.businessLogic || analysisResult.businessRules),
                    'Dependencies': !!(analysisResult.dependencies || analysisResult.validatedDependencies),
                    'Lifecycle Flow': !!(analysisResult.lifecycleRole || analysisResult.usagePatternAnalysis),
                    'Recommendations': !!(analysisResult.recommendations && analysisResult.recommendations.length > 0)
                };
                
                const completed = Object.values(checkpoints).filter(Boolean).length;
                const total = Object.keys(checkpoints).length;
                
                return {
                    score: Math.round((completed / total) * 100),
                    checkpoints: checkpoints,
                    completed: completed,
                    total: total
                };
            }

            // === GENERIC COMPONENT ANALYSIS ===
            async analyzeGenericComponentWithLLM(componentName, relevantFiles, basicDependencies) {
                console.log(`LLM analyzing generic component: ${componentName}`);
                
                const componentFile = relevantFiles[0];
                const componentContent = this.prepareContentForLLM(componentFile.content, 'generic');

                const llmPrompt = `MAINFRAME COMPONENT ANALYSIS

TASK: Analyze the mainframe component "${componentName}" and provide general analysis.

COMPONENT CONTENT:
${componentContent}

COMPONENT TYPE: ${componentFile.type}
FILE SIZE: ${componentFile.size} bytes

DEPENDENCIES FOUND:
${Object.keys(basicDependencies).map(key => 
    `${key}: ${basicDependencies[key].join(', ')}`
).join('\n')}

INSTRUCTIONS:
1. Identify the component type and purpose
2. Extract key elements and structures
3. Identify any patterns or notable features
4. Provide general recommendations

OUTPUT FORMAT:
{
  "componentType": "${componentFile.type}",
  "purpose": "<identified_purpose>",
  "keyElements": [<important_elements>],
  "patterns": [<identified_patterns>],
  "recommendations": [<general_recommendations>],
  "qualityScore": <1-10>
}

Respond with valid JSON only.`;

                return await this.callLLMAPI(llmPrompt);
            }

            // === UTILITY METHODS ===
            showLoading() { 
                document.getElementById('loadingIndicator').classList.add('show'); 
            }
            
            hideLoading() { 
                document.getElementById('loadingIndicator').classList.remove('show'); 
            }
            
            updateLoadingStatus(status) { 
                document.getElementById('loadingStatus').textContent = status; 
            }

            updateProgress(percentage) {
                const progressFill = document.getElementById('progressFill');
                if (progressFill) {
                    progressFill.style.width = `${percentage}%`;
                }
            }

            showMessage(type, message, duration = 3000) {
                const messageDiv = document.createElement('div');
                messageDiv.className = type;
                messageDiv.textContent = message;
                document.body.appendChild(messageDiv);
                
                setTimeout(() => {
                    if (messageDiv.parentNode) {
                        messageDiv.parentNode.removeChild(messageDiv);
                    }
                }, duration);
            }
            
            showError(message) { this.showMessage('error', message, 5000); }
            showSuccess(message) { this.showMessage('success', message, 3000); }
            showWarning(message) { this.showMessage('warning', message, 4000); }
            
            sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

            // === ENHANCED CHAT FUNCTIONALITY ===
            initializeChat() {
                this.initializeChatEventListeners();
            }

            initializeChatEventListeners() {
                const chatSendBtn = document.getElementById('chatSendBtn');
                const chatInput = document.getElementById('chatInput');
                
                if (chatSendBtn && chatInput) {
                    chatSendBtn.addEventListener('click', () => this.sendChatMessage());
                    
                    chatInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' && !e.shiftKey) {
                            e.preventDefault();
                            this.sendChatMessage();
                        }
                    });
                }

                // Chat suggestions
                document.querySelectorAll('.chat-suggestion-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const question = e.target.dataset.question;
                        if (chatInput) {
                            chatInput.value = question;
                            this.sendChatMessage();
                        }
                    });
                });
            }

            enableChat() {
                const chatInput = document.getElementById('chatInput');
                const chatSendBtn = document.getElementById('chatSendBtn');
                const chatSuggestions = document.getElementById('chatSuggestions');
                
                if (chatInput && chatSendBtn) {
                    chatInput.disabled = false;
                    chatSendBtn.disabled = false;
                    
                    if (chatSuggestions) {
                        chatSuggestions.style.display = 'block';
                    }
                    
                    this.addChatMessage('assistant', 
                        `üéØ **LLM-Enhanced lifecycle analysis complete for ${this.currentAnalyzedComponent}!**
                        
I can now provide detailed insights using advanced language model analysis with file lifecycle tracking:

üß† **Smart Field Analysis:** Context-aware categorization with lifecycle stage mapping
‚öñÔ∏è **Business Logic:** Extracted validation rules with creation/update/purge context  
üîó **Dependency Analysis:** Comprehensive relationship mapping with lifecycle impact
üåä **File Lifecycle Flow:** Complete creation-to-purge tracking with program mapping
üí° **Optimization:** AI-powered modernization recommendations with lifecycle awareness

**Try these enhanced questions:**
‚Ä¢ "Explain the complete file lifecycle flow for this component"
‚Ä¢ "What fields are created vs updated and by which programs?"
‚Ä¢ "Show me the CICS screen interactions and data flow"
‚Ä¢ "Which fields are unused and can be optimized?"
‚Ä¢ "How can we modernize this component's lifecycle management?"`
                    );
                }
            }

            async sendChatMessage() {
                const input = document.getElementById('chatInput');
                const sendBtn = document.getElementById('chatSendBtn');
                const message = input.value.trim();
                
                if (!message) {
                    this.showError('Please enter a message');
                    return;
                }
                
                if (!this.currentAnalyzedComponent) {
                    this.showError('Please analyze a component first');
                    return;
                }
                
                input.disabled = true;
                sendBtn.disabled = true;
                sendBtn.textContent = 'Processing...';
                
                this.addChatMessage('user', message);
                input.value = '';
                
                this.showChatTyping();
                
                try {
                    const response = await this.processEnhancedChatQueryWithLifecycle(message);
                    this.hideChatTyping();
                    this.addChatMessage('assistant', response);
                } catch (error) {
                    console.error('Enhanced chat error:', error);
                    this.hideChatTyping();
                    this.addChatMessage('assistant', `I apologize, but I encountered an error processing your question: ${error.message}. Please try rephrasing your question or check the LLM connection.`);
                } finally {
                    input.disabled = false;
                    sendBtn.disabled = false;
                    sendBtn.textContent = 'Send';
                    input.focus();
                }
            }

            addChatMessage(sender, content) {
                const messagesContainer = document.getElementById('chatMessages');
                if (!messagesContainer) return;
                
                const messageId = 'msg_' + Date.now();
                const messageDiv = document.createElement('div');
                messageDiv.className = `chat-message ${sender}`;
                messageDiv.id = messageId;
                
                messageDiv.innerHTML = `
                    <div class="sender">${sender === 'user' ? 'You' : 'LLM Analysis Assistant'}</div>
                    <div class="content">${this.formatChatMessage(content)}</div>
                    <div class="timestamp">${new Date().toLocaleTimeString()}</div>
                    ${sender === 'assistant' ? `<button class="export-btn" onclick="analyzer.exportChatMessage('${messageId}')">üíæ</button>` : ''}
                `;
                
                messagesContainer.appendChild(messageDiv);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                
                this.chatHistory.push({
                    id: messageId,
                    sender: sender,
                    content: content,
                    timestamp: new Date().toISOString()
                });
            }

            formatChatMessage(content) {
                return content
                    .replace(/\n/g, '<br>')
                    .replace(/\*\*([^*]+)\*\*/g, '<strong style="color: #FFD700;">$1</strong>')
                    .replace(/`([^`]+)`/g, '<code style="background: rgba(0,0,0,0.3); padding: 2px 4px; border-radius: 3px; color: #4CAF50; font-family: monospace;">$1</code>')
                    .replace(/^- /gm, '‚Ä¢ ')
                    .replace(/^‚Ä¢ /gm, '<span style="color: #4CAF50;">‚Ä¢</span> ')
                    .replace(/üß†|‚öñÔ∏è|üîó|üí°|üéØ|üìä|üîç|üöÄ|üåä|‚öôÔ∏è|üñ•Ô∏è|üì§/g, '<span style="font-size: 1.2em;">$&</span>')
                    .replace(/(\d+\.\s)/g, '<strong style="color: #2196F3;">$1</strong>');
            }

            showChatTyping() {
                const messagesContainer = document.getElementById('chatMessages');
                if (!messagesContainer) return;
                
                this.hideChatTyping();
                
                const typingDiv = document.createElement('div');
                typingDiv.id = 'typingIndicator';
                typingDiv.className = 'chat-message assistant';
                
                typingDiv.innerHTML = `
                    <div class="sender">LLM Analysis Assistant</div>
                    <div class="content">
                        <span style="opacity: 0.7;">ü§ñ Processing with LLM lifecycle analysis...</span>
                        <span style="animation: blink 1s infinite; margin-left: 5px;">‚óè‚óè‚óè</span>
                    </div>
                `;
                
                messagesContainer.appendChild(typingDiv);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }

            hideChatTyping() {
                const typingIndicator = document.getElementById('typingIndicator');
                if (typingIndicator && typingIndicator.parentNode) {
                    typingIndicator.parentNode.removeChild(typingIndicator);
                }
            }

            async processEnhancedChatQueryWithLifecycle(question) {
                const analysisData = this.analysisResults[this.currentAnalyzedComponent];
                
                let context = `ENHANCED LLM MAINFRAME ANALYSIS WITH LIFECYCLE CONTEXT

COMPONENT: ${this.currentAnalyzedComponent}
COMPONENT TYPE: ${analysisData.componentType}
ANALYSIS METHOD: ${analysisData.analysisMethod}
FILES ANALYZED: ${analysisData.filesAnalyzed.join(', ')}
QUALITY SCORE: ${analysisData.qualityScore}/10
COMPLETENESS: ${analysisData.completeness.score}%

`;

                // Add LLM analysis results
                if (analysisData.llmAnalysis) {
                    context += `LLM ANALYSIS RESULTS:
${JSON.stringify(analysisData.llmAnalysis, null, 2)}

`;
                }

                // Add lifecycle flow context
                if (analysisData.lifecycleFlow) {
                    context += `FILE LIFECYCLE FLOW:
Usage Pattern: ${analysisData.lifecycleFlow.usagePattern}
Creation Sources: ${JSON.stringify(analysisData.lifecycleFlow.creationSources, null, 2)}
Input Programs: ${JSON.stringify(analysisData.lifecycleFlow.inputPrograms, null, 2)}
Update Programs: ${JSON.stringify(analysisData.lifecycleFlow.updatePrograms, null, 2)}
CICS Screens: ${JSON.stringify(analysisData.lifecycleFlow.cicsScreens, null, 2)}
Batch Jobs: ${JSON.stringify(analysisData.lifecycleFlow.batchJobs, null, 2)}

`;
                }

                // Add field usage patterns
                if (analysisData.fieldUsagePatterns) {
                    context += `FIELD USAGE PATTERNS:
${JSON.stringify(analysisData.fieldUsagePatterns, null, 2)}

`;
                }

                const enhancedChatPrompt = `ENHANCED MAINFRAME LIFECYCLE ANALYSIS CHAT ASSISTANT

CONTEXT:
${context}

USER QUESTION: "${question}"

INSTRUCTIONS:
You are an expert mainframe analyst with deep knowledge of COBOL, copybooks, legacy system modernization, and complete file lifecycle management. 

Based on the LLM analysis results and lifecycle flow data above, provide a detailed, insightful response that:

1. **Addresses the specific question** with concrete examples from both the analysis AND lifecycle data
2. **Uses rich formatting** with headers, bullets, and emphasis for readability
3. **Provides actionable insights** based on the complete lifecycle context
4. **References specific fields, programs, screens, or lifecycle stages** when relevant
5. **Explains business context** and technical implications within the lifecycle flow
6. **Offers practical recommendations** for lifecycle optimization and modernization

For lifecycle-related questions, focus on:
- Complete file journey from creation through purge
- Program roles in different lifecycle stages (creation, processing, output, purge)
- Field-level lifecycle tracking and update patterns
- CICS vs batch processing interactions
- Cross-program data flow and dependencies
- Lifecycle optimization opportunities and modernization strategies

For copybook questions with lifecycle context, focus on:
- Field lifecycle stages and business purpose within the complete flow
- Cross-program usage patterns with specific lifecycle stage examples
- Field optimization opportunities with lifecycle impact analysis
- Business rule extraction within creation/update/purge context
- Modernization strategies considering the complete lifecycle

For program questions with lifecycle context, focus on:
- Program's role in the complete file lifecycle (creator/reader/updater/purger)
- Business logic analysis within lifecycle stage context
- Dependency relationships and coupling within the lifecycle flow
- Performance and maintainability recommendations considering lifecycle position

Format your response with:
- **Bold headers** for major sections
- Code snippets for field names and technical terms
- üåä **Lifecycle Flow** sections for flow-related content
- ‚öôÔ∏è **Processing** sections for business logic
- üñ•Ô∏è **Interaction** sections for CICS/user interface content
- ‚Ä¢ Bullet points for lists
- Clear explanations of business impact within lifecycle context

If specific lifecycle information isn't available in the analysis, clearly state what additional lifecycle analysis would be helpful.

Provide a comprehensive, well-formatted response that demonstrates deep understanding of both the analysis results AND the complete file lifecycle context.`;

                const response = await this.callLLMAPI(enhancedChatPrompt);
                
                // Handle different response formats
                if (typeof response === 'string') {
                    return response;
                } else if (response.rawAnalysis) {
                    return response.rawAnalysis;
                } else if (response.error) {
                    return `I encountered an issue processing your question, but here's what I can tell you based on the available analysis: ${response.rawResponse || 'Please try rephrasing your question.'}`;
                } else {
                    // If we get a JSON object, try to format it nicely
                    return this.formatJSONResponseForChat(response);
                }
            }

            formatJSONResponseForChat(jsonResponse) {
                let formatted = "**Analysis Results:**\n\n";
                
                Object.keys(jsonResponse).forEach(key => {
                    const value = jsonResponse[key];
                    const formattedKey = key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                    
                    if (Array.isArray(value)) {
                        formatted += `**${formattedKey}:**\n`;
                        value.forEach(item => {
                            formatted += `‚Ä¢ ${item}\n`;
                        });
                        formatted += '\n';
                    } else if (typeof value === 'object') {
                        formatted += `**${formattedKey}:**\n`;
                        Object.keys(value).forEach(subKey => {
                            formatted += `‚Ä¢ **${subKey}:** ${value[subKey]}\n`;
                        });
                        formatted += '\n';
                    } else {
                        formatted += `**${formattedKey}:** ${value}\n\n`;
                    }
                });
                
                return formatted;
            }

            exportChatMessage(messageId) {
                const messageElement = document.getElementById(messageId);
                if (!messageElement) return;
                
                const chatData = this.chatHistory.find(msg => msg.id === messageId);
                if (!chatData) return;
                
                const timestamp = new Date(chatData.timestamp).toLocaleString();
                const filename = `chat-response-${this.currentAnalyzedComponent}-${Date.now()}.txt`;
                
                const exportContent = `MAINFRAME LIFECYCLE ANALYSIS CHAT RESPONSE
=============================================

Component: ${this.currentAnalyzedComponent}
Timestamp: ${timestamp}
Question: ${chatData.content.split('\n')[0]}

Response:
${chatData.content.replace(/<[^>]*>/g, '').replace(/&nbsp;/g, ' ')}

Generated by: Enhanced Mainframe Analyzer with LLM Integration and Lifecycle Flow
Analysis Date: ${new Date().toLocaleString()}
`;

                this.downloadTextFile(exportContent, filename);
                this.showSuccess(`üíæ Chat response exported as ${filename}`);
            }

            downloadTextFile(content, filename) {
                const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
            // === DISPLAY METHODS ===
            displayAnalysisResults(componentName, results) {
                console.log('Displaying LLM analysis results with lifecycle for:', componentName);
                
                this.displayMainAnalysis(componentName, results);
                this.displayFieldMatrix(componentName, results);
                this.displayUsagePatterns(componentName, results);
                this.displayDependencies(componentName, results);
                this.displayFileLifecycleFlow(componentName, results);
                
                this.switchTab({ target: { dataset: { tab: 'lifecycle' } } });
            }

            displayMainAnalysis(componentName, results) {
                const container = document.getElementById('lifecycleContent');
                
                let html = `
                    <h3>ü§ñ LLM-Enhanced Analysis Results: ${componentName}</h3>
                    <p style="margin-bottom: 20px;">
                        Component type: <strong>${results.componentType}</strong> ‚Ä¢ 
                        Analysis method: <strong>${results.analysisMethod}</strong> ‚Ä¢ 
                        Files analyzed: <strong>${results.filesAnalyzed.length}</strong> ‚Ä¢ 
                        Completed: <strong>${new Date(results.timestamp).toLocaleString()}</strong>
                    </p>
                    
                    <!-- Enhanced Quality Metrics -->
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 15px; margin-bottom: 25px;">
                        <div style="background: rgba(76, 175, 80, 0.1); padding: 15px; border-radius: 8px; text-align: center; border-left: 4px solid #4CAF50;">
                            <div style="font-size: 1.5rem; font-weight: bold; color: #FFD700;">${results.qualityScore}/10</div>
                            <div style="font-size: 11px;">LLM Quality Score</div>
                        </div>
                        <div style="background: rgba(33, 150, 243, 0.1); padding: 15px; border-radius: 8px; text-align: center; border-left: 4px solid #2196F3;">
                            <div style="font-size: 1.5rem; font-weight: bold; color: #FFD700;">${results.completeness.score}%</div>
                            <div style="font-size: 11px;">Completeness</div>
                        </div>
                        <div style="background: rgba(255, 152, 0, 0.1); padding: 15px; border-radius: 8px; text-align: center; border-left: 4px solid #FF9800;">
                            <div style="font-size: 1.5rem; font-weight: bold; color: #FFD700;">${results.filesAnalyzed.length}</div>
                            <div style="font-size: 11px;">Files Analyzed</div>
                        </div>
                        <div style="background: rgba(139, 92, 246, 0.1); padding: 15px; border-radius: 8px; text-align: center; border-left: 4px solid #8b5cf6;">
                            <div style="font-size: 1.5rem; font-weight: bold; color: #FFD700;">${results.lifecycleFlow ? results.lifecycleFlow.usagePattern : 'N/A'}</div>
                            <div style="font-size: 11px;">Usage Pattern</div>
                        </div>
                    </div>
                `;

                // Display lifecycle flow summary
                if (results.lifecycleFlow) {
                    html += this.displayLifecycleSummary(results.lifecycleFlow);
                }

                // Display LLM analysis based on component type
                if (results.componentType === 'Copybook' && results.llmAnalysis) {
                    html += this.displayLLMCopybookAnalysisWithLifecycle(results.llmAnalysis, results.lifecycleFlow);
                } else if (results.componentType === 'COBOL Program' && results.llmAnalysis) {
                    html += this.displayLLMProgramAnalysisWithLifecycle(results.llmAnalysis, results.lifecycleFlow);
                } else {
                    html += this.displayLLMGenericAnalysis(results.llmAnalysis);
                }

                // Display LLM recommendations
                if (results.llmAnalysis && results.llmAnalysis.recommendations) {
                    html += this.displayLLMRecommendations(results.llmAnalysis.recommendations);
                }

                // Display lifecycle recommendations
                if (results.llmAnalysis && results.llmAnalysis.lifecycleRecommendations) {
                    html += this.displayLifecycleRecommendations(results.llmAnalysis.lifecycleRecommendations);
                }
                
                container.innerHTML = html;
            }

            displayLifecycleSummary(lifecycleFlow) {
                return `
                    <div style="background: rgba(139, 92, 246, 0.1); padding: 20px; border-radius: 10px; border-left: 4px solid #8b5cf6; margin-bottom: 20px;">
                        <h4 style="color: #8b5cf6; margin-bottom: 15px;">üåä File Lifecycle Summary</h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 12px;">
                            <div style="text-align: center; background: rgba(34, 197, 94, 0.1); padding: 10px; border-radius: 5px;">
                                <div style="font-size: 1.2rem; font-weight: bold; color: #22c55e;">${lifecycleFlow.creationSources.length}</div>
                                <div style="font-size: 11px;">Creation Sources</div>
                            </div>
                            <div style="text-align: center; background: rgba(59, 130, 246, 0.1); padding: 10px; border-radius: 5px;">
                                <div style="font-size: 1.2rem; font-weight: bold; color: #3b82f6;">${lifecycleFlow.inputPrograms.length}</div>
                                <div style="font-size: 11px;">Input Programs</div>
                            </div>
                            <div style="text-align: center; background: rgba(245, 158, 11, 0.1); padding: 10px; border-radius: 5px;">
                                <div style="font-size: 1.2rem; font-weight: bold; color: #f59e0b;">${lifecycleFlow.updatePrograms.length}</div>
                                <div style="font-size: 11px;">Update Programs</div>
                            </div>
                            <div style="text-align: center; background: rgba(156, 39, 176, 0.1); padding: 10px; border-radius: 5px;">
                                <div style="font-size: 1.2rem; font-weight: bold; color: #9c27b0;">${lifecycleFlow.cicsScreens.length}</div>
                                <div style="font-size: 11px;">CICS Screens</div>
                            </div>
                            <div style="text-align: center; background: rgba(100, 116, 139, 0.1); padding: 10px; border-radius: 5px;">
                                <div style="font-size: 1.2rem; font-weight: bold; color: #64748b;">${lifecycleFlow.batchJobs.length}</div>
                                <div style="font-size: 11px;">Batch Jobs</div>
                            </div>
                        </div>
                        <div style="margin-top: 15px; text-align: center;">
                            <span style="background: ${this.getUsagePatternColor(lifecycleFlow.usagePattern)}; color: white; padding: 6px 12px; border-radius: 6px; font-weight: bold;">
                                ${lifecycleFlow.usagePattern.replace(/_/g, ' ')}
                            </span>
                        </div>
                    </div>
                `;
            }

            getUsagePatternColor(pattern) {
                const colors = {
                    'ONLINE_TRANSACTIONAL': '#22c55e',
                    'BATCH_PROCESSING': '#3b82f6',
                    'READ_ONLY': '#64748b',
                    'CREATION_ONLY': '#f59e0b',
                    'UPDATE_ONLY': '#ef4444',
                    'FULL_LIFECYCLE': '#8b5cf6',
                    'REFERENCE_ONLY': '#6b7280'
                };
                return colors[pattern] || '#6b7280';
            }

            displayLLMCopybookAnalysisWithLifecycle(llmAnalysis, lifecycleFlow) {
    if (!llmAnalysis || llmAnalysis.error) {
        return `
            <div style="background: rgba(244, 67, 54, 0.1); padding: 20px; border-radius: 10px; border-left: 4px solid #f44336;">
                <h4 style="color: #f44336; margin-bottom: 15px;">‚ö†Ô∏è LLM Analysis Issue</h4>
                ${llmAnalysis?.error ? `
                    <p style="margin-bottom: 15px;">LLM analysis encountered an issue: ${llmAnalysis.error}</p>
                    ${llmAnalysis.extractedData ? `
                        <div style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px; margin-top: 15px;">
                            <h5 style="color: #FFD700; margin-bottom: 10px;">üîß Extracted Information:</h5>
                            ${this.displayExtractedData(llmAnalysis.extractedData)}
                        </div>
                    ` : ''}
                    ${llmAnalysis.rawResponse ? `
                        <details style="margin-top: 15px;">
                            <summary style="cursor: pointer; color: #FFD700;">üìÑ View Raw LLM Response</summary>
                            <pre style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; font-size: 11px; max-height: 200px; overflow-y: auto; margin-top: 10px;">${llmAnalysis.rawResponse.substring(0, 1000)}${llmAnalysis.rawResponse.length > 1000 ? '...\n\n[Truncated - Full response available in export]' : ''}</pre>
                        </details>
                    ` : ''}
                ` : `
                    <p>LLM analysis data not available. Raw response may be accessible through export.</p>
                `}
            </div>
        `;
    }

    let html = `
        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px; border-left: 4px solid #FFD700; margin-bottom: 20px;">
            <h4 style="color: #FFD700; margin-bottom: 15px;">ü§ñ LLM Copybook Analysis with Lifecycle Context</h4>
    `;

    // Display field categories if available
    if (llmAnalysis.fieldCategories || llmAnalysis.extractedData?.fieldCategories) {
        const fieldCategories = llmAnalysis.fieldCategories || llmAnalysis.extractedData.fieldCategories;
        const totalFields = llmAnalysis.totalFields || llmAnalysis.extractedData?.totalFields || 0;
        
        html += `
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 15px; margin-bottom: 20px;">
                <div style="text-align: center; background: rgba(76, 175, 80, 0.1); padding: 10px; border-radius: 5px;">
                    <div style="font-size: 1.2rem; font-weight: bold; color: #4CAF50;">${totalFields}</div>
                    <div style="font-size: 11px;">Total Fields</div>
                </div>
        `;

        Object.entries(fieldCategories).forEach(([category, fields]) => {
            if (fields && fields.length > 0) {
                const color = this.getCategoryColor(category);
                html += `
                    <div style="text-align: center; background: rgba(${this.hexToRgb(color)}, 0.1); padding: 10px; border-radius: 5px;">
                        <div style="font-size: 1.2rem; font-weight: bold; color: ${color};">${fields.length}</div>
                        <div style="font-size: 11px;">${this.formatCategoryName(category)}</div>
                    </div>
                `;
            }
        });

        html += `</div>`;

        // Display lifecycle-aware field categorization
        if (llmAnalysis.usagePatternAnalysis) {
            html += this.displayLifecycleFieldAnalysis(llmAnalysis.usagePatternAnalysis);
        }

        // Display detailed field categories
        html += `
            <div style="margin-bottom: 20px;">
                <h5 style="color: #FFD700; margin-bottom: 15px;">üè∑Ô∏è LLM Field Categorization with Lifecycle Context:</h5>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
        `;

        Object.entries(fieldCategories).forEach(([category, fields]) => {
            if (fields && fields.length > 0) {
                const color = this.getCategoryColor(category);
                const icon = this.getCategoryIcon(category);
                
                html += `
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 12px; border-radius: 8px; border-left: 3px solid ${color};">
                        <h6 style="color: ${color}; margin-bottom: 8px; font-size: 13px;">${icon} ${this.formatCategoryName(category)} (${fields.length})</h6>
                        <div style="max-height: 120px; overflow-y: auto;">
                            ${fields.slice(0, 10).map(field => `
                                <div style="margin: 3px 0; padding: 3px 6px; background: rgba(0,0,0,0.2); border-radius: 3px; font-family: monospace; font-size: 11px;">
                                    ${field}
                                </div>
                            `).join('')}
                            ${fields.length > 10 ? `<div style="font-size: 10px; opacity: 0.7; text-align: center; margin-top: 5px;">... and ${fields.length - 10} more</div>` : ''}
                        </div>
                    </div>
                `;
            }
        });

        html += `</div></div>`;
    }

    // Display business rules if available
    if (llmAnalysis.businessRules && llmAnalysis.businessRules.length > 0) {
        html += `
            <div style="margin-bottom: 20px;">
                <h5 style="color: #9C27B0; margin-bottom: 15px;">‚öñÔ∏è Business Rules with Lifecycle Context:</h5>
                <div style="background: rgba(156, 39, 176, 0.1); padding: 15px; border-radius: 8px; border-left: 3px solid #9C27B0;">
                    ${llmAnalysis.businessRules.slice(0, 5).map((rule, index) => `
                        <div style="margin-bottom: 12px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 6px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                                <strong style="color: #c084fc;">Business Rule ${index + 1}</strong>
                                <span style="font-size: 10px; background: #9C27B0; color: white; padding: 2px 6px; border-radius: 3px;">LIFECYCLE</span>
                            </div>
                            <div style="font-size: 12px; line-height: 1.5;">${rule}</div>
                        </div>
                    `).join('')}
                    ${llmAnalysis.businessRules.length > 5 ? `
                        <div style="text-align: center; margin-top: 10px; opacity: 0.7; font-size: 11px;">
                            ... and ${llmAnalysis.businessRules.length - 5} more business rules
                        </div>
                    ` : ''}
                </div>
            </div>
        `;
    }

    // Display field details if available
    if (llmAnalysis.fieldDetails && Object.keys(llmAnalysis.fieldDetails).length > 0) {
        const fieldCount = Object.keys(llmAnalysis.fieldDetails).length;
        html += `
            <div style="margin-bottom: 20px;">
                <h5 style="color: #00bcd4; margin-bottom: 15px;">üìä Detailed Field Analysis (${fieldCount} fields):</h5>
                <div style="background: rgba(0, 188, 212, 0.1); padding: 15px; border-radius: 8px; border-left: 3px solid #00bcd4; max-height: 300px; overflow-y: auto;">
                    ${Object.entries(llmAnalysis.fieldDetails).slice(0, 10).map(([fieldName, details]) => `
                        <div style="margin-bottom: 10px; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 4px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                                <strong style="color: #4dd0e1; font-family: monospace;">${fieldName}</strong>
                                <div style="display: flex; gap: 5px;">
                                    ${details.level ? `<span style="font-size: 9px; background: #00bcd4; color: white; padding: 1px 4px; border-radius: 2px;">L${details.level}</span>` : ''}
                                    ${details.category ? `<span style="font-size: 9px; background: ${this.getCategoryColor(details.category)}; color: white; padding: 1px 4px; border-radius: 2px;">${details.category}</span>` : ''}
                                </div>
                            </div>
                            <div style="font-size: 10px; display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 5px;">
                                ${details.picture ? `<div><span style="color: #90caf9;">PIC:</span> ${details.picture}</div>` : ''}
                                ${details.value ? `<div><span style="color: #90caf9;">VALUE:</span> ${details.value}</div>` : ''}
                                ${details.lifecycleStage ? `<div><span style="color: #90caf9;">STAGE:</span> ${details.lifecycleStage}</div>` : ''}
                            </div>
                            ${details.businessRole ? `
                                <div style="font-size: 10px; margin-top: 5px; color: #e1f5fe;">${details.businessRole}</div>
                            ` : ''}
                        </div>
                    `).join('')}
                    ${fieldCount > 10 ? `
                        <div style="text-align: center; margin-top: 10px; opacity: 0.7; font-size: 11px;">
                            ... and ${fieldCount - 10} more fields available in Field Matrix tab
                        </div>
                    ` : ''}
                </div>
            </div>
        `;
    }

    // Display lifecycle recommendations if available
    if (llmAnalysis.lifecycleRecommendations && llmAnalysis.lifecycleRecommendations.length > 0) {
        html += `
            <div style="margin-bottom: 20px;">
                <h5 style="color: #8b5cf6; margin-bottom: 15px;">üåä Lifecycle Optimization Recommendations:</h5>
                <div style="background: rgba(139, 92, 246, 0.1); padding: 15px; border-radius: 8px; border-left: 3px solid #8b5cf6;">
                    ${llmAnalysis.lifecycleRecommendations.slice(0, 5).map((rec, index) => `
                        <div style="margin-bottom: 12px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 6px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                                <strong style="color: #a78bfa;">Lifecycle Recommendation ${index + 1}</strong>
                                <span style="font-size: 10px; background: #8b5cf6; color: white; padding: 2px 6px; border-radius: 3px;">OPTIMIZATION</span>
                            </div>
                            <div style="font-size: 12px; line-height: 1.5;">${rec}</div>
                        </div>
                    `).join('')}
                    ${llmAnalysis.lifecycleRecommendations.length > 5 ? `
                        <div style="text-align: center; margin-top: 10px; opacity: 0.7; font-size: 11px;">
                            ... and ${llmAnalysis.lifecycleRecommendations.length - 5} more recommendations
                        </div>
                    ` : ''}
                </div>
            </div>
        `;
    }

    // Display usage pattern analysis if available
    if (llmAnalysis.usagePatternAnalysis && Object.keys(llmAnalysis.usagePatternAnalysis).length > 0) {
        html += `
            <div style="margin-bottom: 20px;">
                <h5 style="color: #f59e0b; margin-bottom: 15px;">üìà Usage Pattern Analysis:</h5>
                <div style="background: rgba(245, 158, 11, 0.1); padding: 15px; border-radius: 8px; border-left: 3px solid #f59e0b;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 12px;">
                        ${llmAnalysis.usagePatternAnalysis.creationFields ? `
                            <div style="text-align: center; background: rgba(34, 197, 94, 0.1); padding: 10px; border-radius: 6px;">
                                <div style="font-size: 1.1rem; font-weight: bold; color: #22c55e;">${llmAnalysis.usagePatternAnalysis.creationFields.length}</div>
                                <div style="font-size: 10px;">üå± Creation Fields</div>
                            </div>
                        ` : ''}
                        ${llmAnalysis.usagePatternAnalysis.updateFields ? `
                            <div style="text-align: center; background: rgba(245, 158, 11, 0.1); padding: 10px; border-radius: 6px;">
                                <div style="font-size: 1.1rem; font-weight: bold; color: #f59e0b;">${llmAnalysis.usagePatternAnalysis.updateFields.length}</div>
                                <div style="font-size: 10px;">‚öôÔ∏è Update Fields</div>
                            </div>
                        ` : ''}
                        ${llmAnalysis.usagePatternAnalysis.outputFields ? `
                            <div style="text-align: center; background: rgba(59, 130, 246, 0.1); padding: 10px; border-radius: 6px;">
                                <div style="font-size: 1.1rem; font-weight: bold; color: #3b82f6;">${llmAnalysis.usagePatternAnalysis.outputFields.length}</div>
                                <div style="font-size: 10px;">üì§ Output Fields</div>
                            </div>
                        ` : ''}
                        ${llmAnalysis.usagePatternAnalysis.purgeFields ? `
                            <div style="text-align: center; background: rgba(239, 68, 68, 0.1); padding: 10px; border-radius: 6px;">
                                <div style="font-size: 1.1rem; font-weight: bold; color: #ef4444;">${llmAnalysis.usagePatternAnalysis.purgeFields.length}</div>
                                <div style="font-size: 10px;">üóëÔ∏è Purge Fields</div>
                            </div>
                        ` : ''}
                    </div>
                </div>
            </div>
        `;
    }

    // Display extracted data fallback if main analysis failed but we have partial data
    if (llmAnalysis.extractedData && (!llmAnalysis.fieldCategories || Object.keys(llmAnalysis.fieldCategories || {}).length === 0)) {
        html += `
            <div style="margin-bottom: 20px;">
                <h5 style="color: #ff9800; margin-bottom: 15px;">üîß Extracted Information (Fallback Analysis):</h5>
                <div style="background: rgba(255, 152, 0, 0.1); padding: 15px; border-radius: 8px; border-left: 3px solid #ff9800;">
                    ${this.displayExtractedData(llmAnalysis.extractedData)}
                </div>
            </div>
        `;
    }

    // Display quality score and analysis metadata
    if (llmAnalysis.qualityScore || llmAnalysis.analysisMethod) {
        html += `
            <div style="margin-bottom: 20px;">
                <h5 style="color: #64748b; margin-bottom: 15px;">üìä Analysis Metadata:</h5>
                <div style="background: rgba(100, 116, 139, 0.1); padding: 15px; border-radius: 8px; border-left: 3px solid #64748b;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 12px;">
                        ${llmAnalysis.qualityScore ? `
                            <div style="text-align: center;">
                                <div style="font-size: 1.1rem; font-weight: bold; color: #FFD700;">${llmAnalysis.qualityScore}/10</div>
                                <div style="font-size: 10px; color: #94a3b8;">Quality Score</div>
                            </div>
                        ` : ''}
                        ${llmAnalysis.analysisMethod ? `
                            <div style="text-align: center;">
                                <div style="font-size: 10px; font-weight: bold; color: #94a3b8;">${llmAnalysis.analysisMethod}</div>
                                <div style="font-size: 10px; color: #94a3b8;">Analysis Method</div>
                            </div>
                        ` : ''}
                        ${llmAnalysis.status ? `
                            <div style="text-align: center;">
                                <div style="font-size: 10px; font-weight: bold; color: #94a3b8;">${llmAnalysis.status}</div>
                                <div style="font-size: 10px; color: #94a3b8;">Status</div>
                            </div>
                        ` : ''}
                    </div>
                </div>
            </div>
        `;
    }

    html += '</div>';
    return html;
}


            displayLifecycleFieldAnalysis(usagePatternAnalysis) {
                return `
                    <div style="background: rgba(139, 92, 246, 0.1); padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <h6 style="color: #8b5cf6; margin-bottom: 12px; font-size: 14px;">üåä Lifecycle Field Analysis</h6>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
                            ${usagePatternAnalysis.creationFields ? `
                                <div style="background: rgba(34, 197, 94, 0.1); padding: 8px; border-radius: 4px; text-align: center;">
                                    <div style="font-weight: bold; color: #22c55e;">üå± ${usagePatternAnalysis.creationFields.length}</div>
                                    <div style="font-size: 10px;">Creation Fields</div>
                                </div>
                            ` : ''}
                            ${usagePatternAnalysis.updateFields ? `
                                <div style="background: rgba(245, 158, 11, 0.1); padding: 8px; border-radius: 4px; text-align: center;">
                                    <div style="font-weight: bold; color: #f59e0b;">‚öôÔ∏è ${usagePatternAnalysis.updateFields.length}</div>
                                    <div style="font-size: 10px;">Update Fields</div>
                                </div>
                            ` : ''}
                            ${usagePatternAnalysis.outputFields ? `
                                <div style="background: rgba(59, 130, 246, 0.1); padding: 8px; border-radius: 4px; text-align: center;">
                                    <div style="font-weight: bold; color: #3b82f6;">üì§ ${usagePatternAnalysis.outputFields.length}</div>
                                    <div style="font-size: 10px;">Output Fields</div>
                                </div>
                            ` : ''}
                            ${usagePatternAnalysis.purgeFields ? `
                                <div style="background: rgba(239, 68, 68, 0.1); padding: 8px; border-radius: 4px; text-align: center;">
                                    <div style="font-weight: bold; color: #ef4444;">üóëÔ∏è ${usagePatternAnalysis.purgeFields.length}</div>
                                    <div style="font-size: 10px;">Purge Fields</div>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }

            displayLLMProgramAnalysisWithLifecycle(llmAnalysis, lifecycleFlow) {
                if (!llmAnalysis || llmAnalysis.error) {
                    return `
                        <div style="background: rgba(244, 67, 54, 0.1); padding: 20px; border-radius: 10px; border-left: 4px solid #f44336;">
                            <h4 style="color: #f44336; margin-bottom: 15px;">‚ö†Ô∏è LLM Analysis Error</h4>
                            <p>LLM analysis encountered an issue. Raw response available in export.</p>
                        </div>
                    `;
                }

                let html = `
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px; border-left: 4px solid #2196F3; margin-bottom: 20px;">
                        <h4 style="color: #2196F3; margin-bottom: 15px;">ü§ñ LLM Program Analysis with Lifecycle Context</h4>
                `;

                // Display lifecycle role if available
                if (llmAnalysis.lifecycleRole) {
                    html += this.displayProgramLifecycleRole(llmAnalysis.lifecycleRole);
                }

                // Program structure
                if (llmAnalysis.programStructure) {
                    const structure = llmAnalysis.programStructure;
                    html += `
                        <div style="margin-bottom: 20px;">
                            <h5 style="color: #2196F3; margin-bottom: 10px;">üìã Program Structure:</h5>
                            <div style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px;">
                    `;
                    
                    if (structure.divisions) {
                        html += `<p><strong>Divisions:</strong> ${structure.divisions.join(', ')}</p>`;
                    }
                    if (structure.paragraphs) {
                        html += `<p><strong>Paragraphs:</strong> ${Array.isArray(structure.paragraphs) ? structure.paragraphs.length : structure.paragraphs} found</p>`;
                    }
                    if (structure.sections) {
                        html += `<p><strong>Sections:</strong> ${structure.sections.join(', ')}</p>`;
                    }
                    
                    html += '</div></div>';
                }

                // Business logic with lifecycle context
                if (llmAnalysis.businessLogic) {
                    html += `
                        <div style="margin-bottom: 20px;">
                            <h5 style="color: #FF9800; margin-bottom: 10px;">‚öñÔ∏è Business Logic with Lifecycle Context:</h5>
                            <div style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px;">
                    `;
                    
                    const logic = llmAnalysis.businessLogic;
                    if (logic.fileOperations && logic.fileOperations.length > 0) {
                        html += `<p><strong>File Operations:</strong></p><ul>`;
                        logic.fileOperations.forEach(op => {
                            html += `<li style="margin-bottom: 5px;">${op}</li>`;
                        });
                        html += '</ul>';
                    }

                    if (logic.validationRules && logic.validationRules.length > 0) {
                        html += `<p><strong>Validation Rules:</strong></p><ul>`;
                        logic.validationRules.forEach(rule => {
                            html += `<li style="margin-bottom: 5px;">${rule}</li>`;
                        });
                        html += '</ul>';
                    }
                    
                    html += '</div></div>';
                }

                // Data flow with lifecycle context
                if (llmAnalysis.dataFlow) {
                    html += this.displayProgramDataFlow(llmAnalysis.dataFlow);
                }

                // Complexity
                if (llmAnalysis.complexity) {
                    const complexityColor = llmAnalysis.complexity === 'HIGH' ? '#f44336' : 
                                          llmAnalysis.complexity === 'MEDIUM' ? '#FF9800' : '#4CAF50';
                    html += `
                        <div style="margin-bottom: 20px;">
                            <h5 style="color: #9C27B0; margin-bottom: 10px;">üìä Complexity Assessment:</h5>
                            <div style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px;">
                                <span style="background: ${complexityColor}; color: white; padding: 4px 8px; border-radius: 4px; font-weight: bold;">
                                    ${llmAnalysis.complexity} COMPLEXITY
                                </span>
                            </div>
                        </div>
                    `;
                }

                html += '</div>';
                return html;
            }

            displayProgramLifecycleRole(lifecycleRole) {
                return `
                    <div style="background: rgba(139, 92, 246, 0.1); padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <h6 style="color: #8b5cf6; margin-bottom: 12px; font-size: 14px;">üåä Program Lifecycle Role</h6>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 10px;">
                            <div style="background: rgba(34, 197, 94, 0.1); padding: 8px; border-radius: 4px; text-align: center;">
                                <div style="font-weight: bold; color: #22c55e;">${lifecycleRole.primaryFunction || 'N/A'}</div>
                                <div style="font-size: 10px;">Primary Function</div>
                            </div>
                            <div style="background: rgba(59, 130, 246, 0.1); padding: 8px; border-radius: 4px; text-align: center;">
                                <div style="font-weight: bold; color: #3b82f6;">${lifecycleRole.lifecycleStage || 'N/A'}</div>
                                <div style="font-size: 10px;">Lifecycle Stage</div>
                            </div>
                            <div style="background: rgba(245, 158, 11, 0.1); padding: 8px; border-radius: 4px; text-align: center;">
                                <div style="font-weight: bold; color: #f59e0b;">${lifecycleRole.dataFlowDirection || 'N/A'}</div>
                                <div style="font-size: 10px;">Data Flow</div>
                            </div>
                            <div style="background: rgba(156, 39, 176, 0.1); padding: 8px; border-radius: 4px; text-align: center;">
                                <div style="font-weight: bold; color: #9c27b0;">${lifecycleRole.processingType || 'N/A'}</div>
                                <div style="font-size: 10px;">Processing Type</div>
                            </div>
                        </div>
                    </div>
                `;
            }

            displayProgramDataFlow(dataFlow) {
                return `
                    <div style="margin-bottom: 20px;">
                        <h5 style="color: #00bcd4; margin-bottom: 10px;">üåä Data Flow with Lifecycle Context:</h5>
                        <div style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px;">
                            ${dataFlow.inputFiles && dataFlow.inputFiles.length > 0 ? `
                                <p><strong>Input Files:</strong></p>
                                <ul>${dataFlow.inputFiles.map(file => `<li style="margin-bottom: 3px;">${file}</li>`).join('')}</ul>
                            ` : ''}
                            ${dataFlow.outputFiles && dataFlow.outputFiles.length > 0 ? `
                                <p><strong>Output Files:</strong></p>
                                <ul>${dataFlow.outputFiles.map(file => `<li style="margin-bottom: 3px;">${file}</li>`).join('')}</ul>
                            ` : ''}
                            ${dataFlow.fieldTransformations && dataFlow.fieldTransformations.length > 0 ? `
                                <p><strong>Field Transformations:</strong></p>
                                <ul>${dataFlow.fieldTransformations.map(transform => `<li style="margin-bottom: 3px;">${transform}</li>`).join('')}</ul>
                            ` : ''}
                        </div>
                    </div>
                `;
            }
            displayLLMGenericAnalysis(llmAnalysis) {
                if (!llmAnalysis) {
                    return `
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px; border-left: 4px solid #9C27B0;">
                            <h4 style="color: #9C27B0; margin-bottom: 15px;">ü§ñ LLM Component Analysis</h4>
                            <p style="text-align: center; opacity: 0.8;">
                                LLM analysis completed. Results available in chat and export.
                            </p>
                        </div>
                    `;
                }

                return `
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px; border-left: 4px solid #9C27B0;">
                        <h4 style="color: #9C27B0; margin-bottom: 15px;">ü§ñ LLM Component Analysis</h4>
                        <div style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px;">
                            <p><strong>Component Type:</strong> ${llmAnalysis.componentType || 'Generic'}</p>
                            ${llmAnalysis.purpose ? `<p><strong>Purpose:</strong> ${llmAnalysis.purpose}</p>` : ''}
                            <p style="margin-top: 15px; opacity: 0.8;">
                                Detailed analysis available through chat interface and export functionality.
                            </p>
                        </div>
                    </div>
                `;
            }

            displayLLMRecommendations(recommendations) {
                if (!recommendations || recommendations.length === 0) return '';
                
                let html = `
                    <div style="background: rgba(255, 193, 7, 0.1); padding: 20px; border-radius: 10px; border-left: 4px solid #FFC107; margin-top: 20px;">
                        <h4 style="color: #FFC107; margin-bottom: 15px;">ü§ñ LLM Recommendations</h4>
                `;

                recommendations.forEach((rec, index) => {
                    html += `
                        <div style="margin-bottom: 15px; padding: 12px; background: rgba(0,0,0,0.2); border-radius: 8px; border-left: 3px solid #FFC107;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <strong style="color: #FFC107;">üí° Recommendation ${index + 1}</strong>
                                <span style="font-size: 11px; background: #FFC107; color: #000; padding: 2px 6px; border-radius: 3px; font-weight: bold;">
                                    LLM GENERATED
                                </span>
                            </div>
                            <div style="line-height: 1.6;">${rec}</div>
                        </div>
                    `;
                });

                html += '</div>';
                return html;
            }

            displayLifecycleRecommendations(recommendations) {
                if (!recommendations || recommendations.length === 0) return '';
                
                let html = `
                    <div style="background: rgba(139, 92, 246, 0.1); padding: 20px; border-radius: 10px; border-left: 4px solid #8b5cf6; margin-top: 20px;">
                        <h4 style="color: #8b5cf6; margin-bottom: 15px;">üåä Lifecycle Optimization Recommendations</h4>
                `;

                recommendations.forEach((rec, index) => {
                    html += `
                        <div style="margin-bottom: 15px; padding: 12px; background: rgba(0,0,0,0.2); border-radius: 8px; border-left: 3px solid #8b5cf6;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <strong style="color: #8b5cf6;">üåä Lifecycle Optimization ${index + 1}</strong>
                                <span style="font-size: 11px; background: #8b5cf6; color: #fff; padding: 2px 6px; border-radius: 3px; font-weight: bold;">
                                    LIFECYCLE
                                </span>
                            </div>
                            <div style="line-height: 1.6;">${rec}</div>
                        </div>
                    `;
                });

                html += '</div>';
                return html;
            }

            // === FILE LIFECYCLE FLOW TAB ===
            displayFileLifecycleFlow(componentName, results) {
                const container = document.getElementById('fileflowContent');
                
                let html = `
                    <h3>üåä File Lifecycle Flow Analysis: ${componentName}</h3>
                    <p style="margin-bottom: 20px;">Complete file lifecycle from creation through purge, including program usage patterns and field update tracking.</p>
                `;
                
                if (results.lifecycleFlow && results.fieldUsagePatterns) {
                    html += this.displayCompleteLifecycleFlow(results.lifecycleFlow, results.fieldUsagePatterns);
                } else {
                    html += `
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px; text-align: center;">
                            <p style="opacity: 0.8;">File lifecycle flow analysis will appear here after component analysis.</p>
                        </div>
                    `;
                }
                
                container.innerHTML = html;
            }

            displayCompleteLifecycleFlow(lifecycleFlow, fieldUsagePatterns) {
                let html = `
                    <div class="lifecycle-flow">
                        <h4 style="color: #8b5cf6; margin-bottom: 20px;">üåä Complete File Lifecycle Flow</h4>
                `;

                // Generate lifecycle steps from field usage patterns if available
                if (fieldUsagePatterns.lifecycleFieldFlow && fieldUsagePatterns.lifecycleFieldFlow.length > 0) {
                    fieldUsagePatterns.lifecycleFieldFlow.forEach((step, index) => {
                        html += `
                            <div class="lifecycle-step ${step.active ? 'active' : ''}">
                                <div class="lifecycle-step-icon">${step.icon}</div>
                                <div class="lifecycle-step-content">
                                    <div class="lifecycle-step-title">${step.title}</div>
                                    <div class="lifecycle-step-description">${step.description}</div>
                                    ${step.programs && step.programs.length > 0 ? `
                                        <div class="lifecycle-step-programs">
                                            ${step.programs.map(program => `<span class="program-tag">${program}</span>`).join('')}
                                        </div>
                                    ` : ''}
                                    ${step.screens && step.screens.length > 0 ? `
                                        <div class="lifecycle-step-programs">
                                            ${step.screens.map(screen => `<span class="program-tag" style="background: rgba(156, 39, 176, 0.2); color: #c084fc;">${screen}</span>`).join('')}
                                        </div>
                                    ` : ''}
                                </div>
                            </div>
                        `;
                    })

                    if (lifecycleFlow.cicsScreens.length > 0) {
                        html += `
                            <div class="lifecycle-step active">
                                <div class="lifecycle-step-icon">üñ•Ô∏è</div>
                                <div class="lifecycle-step-content">
                                    <div class="lifecycle-step-title">User Interaction</div>
                                    <div class="lifecycle-step-description">Data display and user input collection</div>
                                    <div class="lifecycle-step-programs">
                                        ${lifecycleFlow.cicsScreens.map(s => `<span class="program-tag" style="background: rgba(156, 39, 176, 0.2); color: #c084fc;">${s.screen}</span>`).join('')}
                                    </div>
                                </div>
                            </div>
                        `;
                    }

                    if (lifecycleFlow.inputPrograms.length > 0) {
                        html += `
                            <div class="lifecycle-step active">
                                <div class="lifecycle-step-icon">üì§</div>
                                <div class="lifecycle-step-content">
                                    <div class="lifecycle-step-title">Data Output</div>
                                    <div class="lifecycle-step-description">Report generation and data extraction</div>
                                    <div class="lifecycle-step-programs">
                                        ${lifecycleFlow.inputPrograms.map(p => `<span class="program-tag">${p.program}</span>`).join('')}
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                }

                html += `</div>`;

                // Display field usage patterns
                html += this.displayFieldUsagePatternsDetailed(fieldUsagePatterns);

                return html;
            }

            displayFieldUsagePatternsDetailed(fieldUsagePatterns) {
                return `
                    <div class="field-flow-section">
                        <h4 style="color: #f59e0b; margin-bottom: 20px;">üìä Field Usage Patterns Analysis</h4>
                        
                        <!-- Field Summary -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 12px; margin-bottom: 20px;">
                            <div style="text-align: center; background: rgba(34, 197, 94, 0.1); padding: 12px; border-radius: 8px;">
                                <div style="font-size: 1.5rem; font-weight: bold; color: #22c55e;">${fieldUsagePatterns.inputFieldCount}</div>
                                <div style="font-size: 11px;">Input Fields</div>
                            </div>
                            <div style="text-align: center; background: rgba(59, 130, 246, 0.1); padding: 12px; border-radius: 8px;">
                                <div style="font-size: 1.5rem; font-weight: bold; color: #3b82f6;">${fieldUsagePatterns.outputFieldCount}</div>
                                <div style="font-size: 11px;">Output Fields</div>
                            </div>
                            <div style="text-align: center; background: rgba(245, 158, 11, 0.1); padding: 12px; border-radius: 8px;">
                                <div style="font-size: 1.5rem; font-weight: bold; color: #f59e0b;">${fieldUsagePatterns.derivedFieldCount}</div>
                                <div style="font-size: 11px;">Derived Fields</div>
                            </div>
                            <div style="text-align: center; background: rgba(239, 68, 68, 0.1); padding: 12px; border-radius: 8px;">
                                <div style="font-size: 1.5rem; font-weight: bold; color: #ef4444;">${fieldUsagePatterns.unusedFieldCount}</div>
                                <div style="font-size: 11px;">Unused Fields</div>
                            </div>
                            <div style="text-align: center; background: rgba(100, 116, 139, 0.1); padding: 12px; border-radius: 8px;">
                                <div style="font-size: 1.5rem; font-weight: bold; color: #64748b;">${fieldUsagePatterns.staticFieldCount}</div>
                                <div style="font-size: 11px;">Static Fields</div>
                            </div>
                        </div>

                        <!-- Usage Pattern Visualization -->
                        <div style="margin-bottom: 20px;">
                            <h5 style="color: #f59e0b; margin-bottom: 15px;">üìà Field Usage Distribution</h5>
                            ${this.generateUsageVisualization(fieldUsagePatterns)}
                        </div>

                        <!-- Program-Field Mapping -->
                        ${Object.keys(fieldUsagePatterns.programFieldMapping).length > 0 ? `
                            <div style="margin-bottom: 20px;">
                                <h5 style="color: #f59e0b; margin-bottom: 15px;">üîó Program-Field Mapping</h5>
                                <div style="max-height: 300px; overflow-y: auto; background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px;">
                                    ${this.displayProgramFieldMapping(fieldUsagePatterns.programFieldMapping)}
                                </div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            generateUsageVisualization(fieldUsagePatterns) {
                const total = fieldUsagePatterns.totalFields || 1;
                const categories = [
                    { name: 'Input', count: fieldUsagePatterns.inputFieldCount, color: '#22c55e' },
                    { name: 'Output', count: fieldUsagePatterns.outputFieldCount, color: '#3b82f6' },
                    { name: 'Derived', count: fieldUsagePatterns.derivedFieldCount, color: '#f59e0b' },
                    { name: 'Unused', count: fieldUsagePatterns.unusedFieldCount, color: '#ef4444' },
                    { name: 'Static', count: fieldUsagePatterns.staticFieldCount, color: '#64748b' },
                    { name: 'Condition', count: fieldUsagePatterns.conditionFieldCount, color: '#8b5cf6' }
                ];

                let html = '';
                categories.forEach(category => {
                    if (category.count > 0) {
                        const percentage = ((category.count / total) * 100).toFixed(1);
                        html += `
                            <div class="usage-pattern-visual">
                                <span class="usage-label">${category.name}</span>
                                <div class="usage-bar">
                                    <div class="usage-fill" style="width: ${percentage}%; --usage-color-start: ${category.color}; --usage-color-end: ${category.color}dd;"></div>
                                </div>
                                <span class="usage-percentage">${percentage}%</span>
                            </div>
                        `;
                    }
                });

                return html;
            }

            displayProgramFieldMapping(programFieldMapping) {
                let html = '';
                Object.keys(programFieldMapping).slice(0, 20).forEach(field => {
                    const mapping = programFieldMapping[field];
                    html += `
                        <div class="field-item">
                            <div class="field-name">${field}</div>
                            <div class="field-usage">
                                ${mapping.usageType} | Updated by: ${mapping.updatingPrograms.join(', ') || 'None'}
                            </div>
                        </div>
                    `;
                });

                if (Object.keys(programFieldMapping).length > 20) {
                    html += `<div style="text-align: center; margin-top: 10px; opacity: 0.7; font-size: 12px;">... and ${Object.keys(programFieldMapping).length - 20} more fields</div>`;
                }

                return html;
            }

            // === OTHER DISPLAY METHODS ===
            displayFieldMatrix(componentName, results) {
                const container = document.getElementById('fieldMatrixContent');
                
                let html = `
                    <h3>üìã LLM Field Matrix Analysis: ${componentName}</h3>
                    <p style="margin-bottom: 20px;">Enhanced field-level analysis with LLM-powered categorization and lifecycle context.</p>
                `;
                
                if (results.componentType === 'Copybook' && results.llmAnalysis && results.llmAnalysis.fieldDetails) {
                    html += this.displayDetailedLLMFieldMatrix(results.llmAnalysis.fieldDetails);
                } else {
                    html += `
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px; text-align: center;">
                            <p style="opacity: 0.8;">LLM field matrix analysis is available for copybook components with detailed field analysis.</p>
                        </div>
                    `;
                }
                
                container.innerHTML = html;
            }

            displayDetailedLLMFieldMatrix(fieldDetails) {
                let html = `
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px;">
                        <h4 style="color: #FFD700; margin-bottom: 15px;">ü§ñ LLM Field Analysis Matrix</h4>
                        <div style="overflow-x: auto;">
                            <table style="width: 100%; border-collapse: collapse; font-size: 12px;">
                                <thead>
                                    <tr style="background: rgba(0,0,0,0.3);">
                                        <th style="padding: 8px; text-align: left; border: 1px solid rgba(255,255,255,0.1); color: #FFD700;">Field Name</th>
                                        <th style="padding: 8px; text-align: center; border: 1px solid rgba(255,255,255,0.1); color: #4CAF50;">Level</th>
                                        <th style="padding: 8px; text-align: center; border: 1px solid rgba(255,255,255,0.1); color: #2196F3;">Picture</th>
                                        <th style="padding: 8px; text-align: center; border: 1px solid rgba(255,255,255,0.1); color: #FF9800;">Category</th>
                                        <th style="padding: 8px; text-align: left; border: 1px solid rgba(255,255,255,0.1); color: #9C27B0;">Business Role</th>
                                        <th style="padding: 8px; text-align: left; border: 1px solid rgba(255,255,255,0.1); color: #8b5cf6;">Lifecycle Stage</th>
                                    </tr>
                                </thead>
                                <tbody>
                `;

                Object.entries(fieldDetails).forEach(([fieldName, details]) => {
                    const categoryColor = this.getCategoryColor(details.category);
                    
                    html += `
                        <tr style="border-bottom: 1px solid rgba(255,255,255,0.1);">
                            <td style="padding: 6px 8px; font-family: monospace; font-weight: bold;">${fieldName}</td>
                            <td style="padding: 6px 8px; text-align: center;">${details.level || 'N/A'}</td>
                            <td style="padding: 6px 8px; text-align: center; font-family: monospace; font-size: 10px;">${details.picture || 'N/A'}</td>
                            <td style="padding: 6px 8px; text-align: center; color: ${categoryColor}; font-weight: bold; font-size: 10px;">${details.category || 'N/A'}</td>
                            <td style="padding: 6px 8px; font-size: 10px; max-width: 200px; word-wrap: break-word;">${details.businessRole || 'N/A'}</td>
                            <td style="padding: 6px 8px; font-size: 10px; max-width: 150px; word-wrap: break-word; color: #8b5cf6;">${details.lifecycleStage || 'N/A'}</td>
                        </tr>
                    `;
                });

                html += `
                                </tbody>
                            </table>
                        </div>
                    </div>
                `;

                return html;
            }

            displayUsagePatterns(componentName, results) {
                const container = document.getElementById('usageContent');
                
                let html = `
                    <h3>üìà LLM Usage Patterns Analysis: ${componentName}</h3>
                    <p style="margin-bottom: 20px;">Advanced usage pattern analysis powered by LLM insights with lifecycle context.</p>
                `;
                
                if (results.fieldUsagePatterns) {
                    html += this.displayFieldUsagePatternsDetailed(results.fieldUsagePatterns);
                } else if (results.llmAnalysis) {
                    html += this.displayLLMUsagePatterns(results.llmAnalysis, results.componentType);
                } else {
                    html += `
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px; text-align: center;">
                            <p style="opacity: 0.8;">LLM usage patterns analysis will appear here after component analysis.</p>
                        </div>
                    `;
                }
                
                container.innerHTML = html;
            }

            displayLLMUsagePatterns(llmAnalysis, componentType) {
                // Implementation from previous parts...
                return `
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px;">
                        <h4 style="color: #FFD700; margin-bottom: 15px;">ü§ñ LLM Usage Analysis</h4>
                        <p style="text-align: center; opacity: 0.8;">Detailed usage patterns available in lifecycle flow tab.</p>
                    </div>
                `;
            }

            displayDependencies(componentName, results) {
                const container = document.getElementById('dependenciesContent');
                
                let html = `
                    <h3>üîó Hybrid Dependency Analysis: ${componentName}</h3>
                    <p style="margin-bottom: 20px;">Regex discovery + LLM validation for comprehensive dependency mapping.</p>
                `;
                
                if (results.validatedDependencies) {
                    html += this.displayValidatedDependencies(results.validatedDependencies);
                } else if (results.basicDependencies) {
                    html += this.displayBasicDependencies(results.basicDependencies);
                } else {
                    html += `
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px; text-align: center;">
                            <p style="opacity: 0.8;">Dependency analysis will appear here after component analysis.</p>
                        </div>
                    `;
                }
                
                container.innerHTML = html;
            }

            displayValidatedDependencies(validatedDependencies) {
                return `
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px;">
                        <h4 style="color: #FFD700; margin-bottom: 15px;">ü§ñ LLM-Validated Dependencies</h4>
                        ${this.displayDependencyDetails(validatedDependencies.validatedDependencies || validatedDependencies)}
                    </div>
                `;
            }

            displayBasicDependencies(basicDependencies) {
                return `
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px;">
                        <h4 style="color: #FFD700; margin-bottom: 15px;">üîç Basic Dependencies (Regex)</h4>
                        ${this.displayDependencyDetails(basicDependencies)}
                    </div>
                `;
            }

            displayDependencyDetails(dependencies) {
                let html = `<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">`;

                const dependencyTypes = [
                    { key: 'copyStatements', title: 'Copy Statements', icon: 'üìö', color: '#22c55e' },
                    { key: 'callStatements', title: 'Call Statements', icon: 'üìû', color: '#3b82f6' },
                    { key: 'execStatements', title: 'Exec Statements', icon: '‚ö°', color: '#f59e0b' },
                    { key: 'programIds', title: 'Program IDs', icon: 'üíº', color: '#8b5cf6' },
                    { key: 'fileReferences', title: 'File References', icon: 'üìÅ', color: '#ec4899' }
                ];

                dependencyTypes.forEach(depType => {
                    const deps = dependencies[depType.key] || [];
                    if (deps.length > 0) {
                        html += `
                            <div style="background: rgba(30, 41, 59, 0.6); padding: 12px; border-radius: 8px; border-left: 3px solid ${depType.color};">
                                <h6 style="color: ${depType.color}; margin-bottom: 8px; font-size: 13px;">
                                    ${depType.icon} ${depType.title} (${deps.length})
                                </h6>
                                <div style="max-height: 120px; overflow-y: auto;">
                                    ${deps.slice(0, 10).map(dep => `
                                        <div style="margin: 2px 0; padding: 3px 6px; background: rgba(15, 23, 42, 0.8); border-radius: 3px; font-family: monospace; font-size: 11px;">
                                            ${dep}
                                        </div>
                                    `).join('')}
                                    ${deps.length > 10 ? `<div style="font-size: 10px; opacity: 0.7; text-align: center; margin-top: 5px;">... and ${deps.length - 10} more</div>` : ''}
                                </div>
                            </div>
                        `;
                    }
                });

                html += '</div>';
                return html;
            }

            // === UTILITY METHODS FOR DISPLAY ===
            getCategoryColor(category) {
                const colors = {
                    'INPUT_FIELDS': '#4CAF50',
                    'OUTPUT_FIELDS': '#2196F3',
                    'DERIVED_FIELDS': '#FF9800',
                    'CONDITION_FIELDS': '#9C27B0',
                    'UNUSED_FIELDS': '#f44336',
                    'STATIC_FIELDS': '#607D8B'
                };
                return colors[category] || '#FFD700';
            }

            getCategoryIcon(category) {
                const icons = {
                    'INPUT_FIELDS': 'üì•',
                    'OUTPUT_FIELDS': 'üì§',
                    'DERIVED_FIELDS': 'üîÑ',
                    'CONDITION_FIELDS': '‚ùì',
                    'UNUSED_FIELDS': 'üö´',
                    'STATIC_FIELDS': 'üîí'
                };
                return icons[category] || 'üìã';
            }

            formatCategoryName(category) {
                return category.replace(/_/g, ' ').toLowerCase()
                    .replace(/\b\w/g, l => l.toUpperCase());
            }

            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? 
                    `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : 
                    '255, 255, 255';
            }

            // === BULK ANALYSIS AND EXPORT (continued from previous parts) ===
            async bulkAnalyze() {
                if (this.uploadedFiles.length === 0) {
                    this.showError('No files uploaded for bulk analysis');
                    return;
                }

                this.showLoading();
                this.updateLoadingStatus('üîÑ Starting LLM bulk analysis with lifecycle tracking...');

                const components = this.componentSuggestions.filter(c => c.type === 'COPYBOOK' || c.type === 'PROGRAM').slice(0, 5);
                let completed = 0;

                try {
                    for (const component of components) {
                        this.updateLoadingStatus(`LLM analyzing ${component.name} with lifecycle (${completed + 1}/${components.length})...`);
                        this.updateProgress((completed / components.length) * 100);
                        
                        try {
                            document.getElementById('componentName').value = component.name;
                            const results = await this.runLLMEnhancedAnalysisWithLifecycle(component.name);
                            this.analysisResults[component.name] = results;
                            completed++;
                            
                            await this.sleep(3000);
                        } catch (error) {
                            console.warn(`Failed to analyze ${component.name}:`, error);
                        }
                    }

                    this.hideLoading();
                    this.saveToStorage();
                    this.showSuccess(`‚ú® LLM bulk analysis with lifecycle tracking complete! ${completed}/${components.length} components analyzed`);

                } catch (error) {
                    this.hideLoading();
                    this.showError(`LLM bulk analysis failed: ${error.message}`);
                }
            }

            // === EXPORT METHODS (Basic implementations) ===
            async exportResults(format) {
                if (Object.keys(this.analysisResults).length === 0) {
                    this.showError('No analysis results to export');
                    return;
                }

                try {
                    if (format === 'json') {
                        await this.exportAsJSON();
                    } else if (format === 'markdown') {
                        await this.exportAsMarkdown();
                    }
                } catch (error) {
                    this.showError(`Export failed: ${error.message}`);
                }
            }

            async exportAsJSON() {
                const exportData = {
                    metadata: {
                        timestamp: new Date().toISOString(),
                        totalComponents: Object.keys(this.analysisResults).length,
                        totalFiles: this.uploadedFiles.length,
                        analysisMethod: 'LLM-Enhanced-Lifecycle',
                        version: '4.0.0-lifecycle-enhanced'
                    },
                    analysisResults: this.analysisResults,
                    chatHistory: this.chatHistory
                };

                const dataStr = JSON.stringify(exportData, null, 2);
                const filename = `enhanced-mainframe-lifecycle-analysis-${new Date().toISOString().split('T')[0]}.json`;
                
                this.downloadTextFile(dataStr, filename);
                this.showSuccess(`üìã Enhanced lifecycle analysis results exported as ${filename}`);
            }

            async exportAsMarkdown() {
                let markdown = `# Enhanced Mainframe Lifecycle Analysis Report\n\n`;
                markdown += `**Generated:** ${new Date().toLocaleString()}\n`;
                markdown += `**Analysis Method:** LLM-Enhanced with Lifecycle Flow\n\n`;

                for (const [componentName, results] of Object.entries(this.analysisResults)) {
                    markdown += `## ${componentName}\n\n`;
                    markdown += `**Type:** ${results.componentType}\n`;
                    markdown += `**Usage Pattern:** ${results.lifecycleFlow?.usagePattern || 'N/A'}\n\n`;
                    if (results.llmAnalysis?.recommendations) {
                        markdown += `**Recommendations:**\n`;
                        results.llmAnalysis.recommendations.forEach(rec => {
                            markdown += `- ${rec}\n`;
                        });
                    }
                    markdown += '\n---\n\n';
                }
                
                const filename = `mainframe-lifecycle-analysis-report-${new Date().toISOString().split('T')[0]}.md`;
                this.downloadTextFile(markdown, filename);
                this.showSuccess(`üìù Lifecycle analysis report exported as ${filename}`);
            }

            // === STORAGE MANAGEMENT ===
            saveToStorage() {
                try {
                    const data = {
                        uploadedFiles: this.uploadedFiles,
                        analysisResults: this.analysisResults,
                        chatHistory: this.chatHistory,
                        vllmEndpoint: this.vllmEndpoint,
                        maxTokens: this.maxTokens,
                        timestamp: new Date().toISOString()
                    };
                    localStorage.setItem(this.storageKey, JSON.stringify(data));
                } catch (error) {
                    console.warn('Failed to save to storage:', error);
                }
            }

            loadStoredData() {
                try {
                    const stored = localStorage.getItem(this.storageKey);
                    if (stored) {
                        const data = JSON.parse(stored);
                        this.uploadedFiles = data.uploadedFiles || [];
                        this.analysisResults = data.analysisResults || {};
                        this.chatHistory = data.chatHistory || [];
                        
                        if (data.vllmEndpoint) {
                            document.getElementById('vllmEndpoint').value = data.vllmEndpoint;
                            this.vllmEndpoint = data.vllmEndpoint;
                        }
                        
                        if (data.maxTokens) {
                            document.getElementById('maxTokens').value = data.maxTokens;
                            this.maxTokens = data.maxTokens;
                        }
                        
                        this.displayUploadedFiles();
                        this.updateComponentSuggestions();
                        this.validateForm();
                        
                        console.log('üìÅ Stored LLM lifecycle analysis data loaded successfully');
                    }
                } catch (error) {
                    console.warn('Failed to load stored data:', error);
                }
            }

            clearAllData() {
                if (confirm('Are you sure you want to clear all LLM lifecycle analysis data? This cannot be undone.')) {
                    this.uploadedFiles = [];
                    this.analysisResults = {};
                    this.componentSuggestions = [];
                    this.currentAnalyzedComponent = null;
                    this.chatHistory = [];
                    
                    localStorage.removeItem(this.storageKey);
                    
                    this.displayUploadedFiles();
                    this.validateForm();
                    
                    // Reset chat area
                    const chatMessages = document.getElementById('chatMessages');
                    if (chatMessages) {
                        chatMessages.innerHTML = `
                            <div class="chat-message assistant">
                                <div class="sender">LLM Analysis Assistant</div>
                                <div class="content">
                                    üëã <strong>Welcome to LLM-Enhanced Mainframe Analysis with Lifecycle Flow!</strong>
                                    <br><br>
                                    Upload files and analyze a component to unlock the full power of LLM analysis with complete file lifecycle tracking!
                                </div>
                                <div class="timestamp">${new Date().toLocaleTimeString()}</div>
                            </div>
                        `;
                    }
                    
                    // Disable chat input
                    const chatInput = document.getElementById('chatInput');
                    const chatSendBtn = document.getElementById('chatSendBtn');
                    if (chatInput) chatInput.disabled = true;
                    if (chatSendBtn) chatSendBtn.disabled = true;
                    
                    this.showSuccess('üóëÔ∏è All LLM lifecycle analysis data cleared successfully');
                }
            }
        }

        // === INITIALIZATION ===
        document.addEventListener('DOMContentLoaded', function() {
            window.analyzer = new EnhancedMainframeAnalyzer();
            
            console.log('üöÄ Enhanced Mainframe Analyzer with Complete LLM Integration and Lifecycle Flow Ready!');
            console.log('‚úÖ New Lifecycle Features:');
            console.log('   ‚Ä¢ Complete file lifecycle tracking: creation ‚Üí processing ‚Üí purge');
            console.log('   ‚Ä¢ Program role identification: creator/reader/updater/purger');
            console.log('   ‚Ä¢ Field-level update tracking across lifecycle stages');
            console.log('   ‚Ä¢ CICS screen integration and batch job mapping');
            console.log('   ‚Ä¢ Enhanced usage pattern analysis with lifecycle context');
            console.log('   ‚Ä¢ Lifecycle-aware chat with contextual recommendations');
            console.log('üéØ Ready for comprehensive mainframe lifecycle analysis!');
        });

        // Fallback initialization
        if (document.readyState === 'loading') {
            // Document still loading, wait for DOMContentLoaded
        } else {
            // Document already loaded
            window.analyzer = new EnhancedMainframeAnalyzer();
            console.log('üöÄ Enhanced LLM Mainframe Analyzer with Lifecycle initialized (fallback)');
        }
    </script>
</body>
</html>);
                } else {
                    // Fallback: generate basic lifecycle steps from lifecycle flow data
                    if (lifecycleFlow.creationSources.length > 0) {
                        html += `
                            <div class="lifecycle-step active">
                                <div class="lifecycle-step-icon">üå±</div>
                                <div class="lifecycle-step-content">
                                    <div class="lifecycle-step-title">Data Creation</div>
                                    <div class="lifecycle-step-description">Initial data population and file creation</div>
                                    <div class="lifecycle-step-programs">
                                        ${lifecycleFlow.creationSources.map(s => s.program ? `<span class="program-tag">${s.program}</span>` : '').join('')}
                                    </div>
                                </div>
                            </div>
                        `;
                    }

                    if (lifecycleFlow.updatePrograms.length > 0) {
                        html += `
                            <div class="lifecycle-step active">
                                <div class="lifecycle-step-icon">‚öôÔ∏è</div>
                                <div class="lifecycle-step-content">
                                    <div class="lifecycle-step-title">Data Processing</div>
                                    <div class="lifecycle-step-description">Data validation, calculation, and transformation</div>
                                    <div class="lifecycle-step-programs">
                                        ${lifecycleFlow.updatePrograms.map(p => `<span class="program-tag">${p.program}</span>`).join('')}
                                    </div>
                                </div>
                            }
                        `;
                    }
</script>
</body>
</html>