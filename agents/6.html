<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Mainframe Analyzer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            min-height: 100vh;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 25px;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .header h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #FFD700, #FFA500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .main-grid {
            display: grid;
            grid-template-columns: 520px 1fr 400px;
            gap: 25px;
            min-height: 80vh;
        }

        .control-panel, .analysis-workspace, .chat-panel {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .control-panel {
            height: fit-content;
            max-height: 85vh;
            overflow-y: auto;
        }

        .analysis-workspace {
            min-height: 80vh;
            overflow-y: auto;
        }

        .chat-panel {
            display: flex;
            flex-direction: column;
            max-height: 85vh;
        }

        /* Component Search Section */
        .component-search-section {
            margin-bottom: 25px;
            padding: 20px;
            background: rgba(76, 175, 80, 0.2);
            border-radius: 15px;
            border-left: 4px solid #4CAF50;
        }

        .component-input {
            width: 100%;
            padding: 12px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 14px;
            margin-bottom: 10px;
            transition: all 0.3s ease;
        }

        .component-input:focus {
            outline: none;
            border-color: #FFD700;
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.3);
        }

        .component-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .component-suggestions {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            max-height: 150px;
            overflow-y: auto;
            display: none;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .suggestion-item {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
            font-size: 13px;
        }

        .suggestion-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(3px);
        }

        /* Token Management */
        .token-info {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid rgba(255, 193, 7, 0.5);
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            font-size: 12px;
        }

        .token-bar {
            background: rgba(0, 0, 0, 0.3);
            height: 6px;
            border-radius: 3px;
            margin: 8px 0;
            overflow: hidden;
        }

        .token-fill {
            height: 100%;
            transition: all 0.3s ease;
            border-radius: 3px;
        }

        .token-fill.safe { background: #4CAF50; }
        .token-fill.warning { background: #FF9800; }
        .token-fill.danger { background: #f44336; }

        /* General Form Styles */
        .section-title { 
            color: #FFD700; 
            font-size: 1.2rem; 
            margin-bottom: 15px; 
            font-weight: 600; 
            display: flex; 
            align-items: center; 
            gap: 10px; 
        }

        .form-group { 
            margin-bottom: 20px; 
        }

        .form-group input, 
        .form-group select, 
        .form-group textarea { 
            width: 100%; 
            padding: 12px; 
            border: 1px solid rgba(255, 255, 255, 0.3); 
            border-radius: 8px; 
            background: rgba(255, 255, 255, 0.1); 
            color: white; 
            font-size: 14px; 
            transition: all 0.3s ease; 
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #FFD700;
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.3);
        }

        .form-group input::placeholder,
        .form-group textarea::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .action-btn { 
            width: 100%; 
            background: linear-gradient(45deg, #FF6B6B, #FF5252); 
            color: white; 
            border: none; 
            padding: 14px; 
            border-radius: 10px; 
            cursor: pointer; 
            font-size: 15px; 
            font-weight: 600; 
            margin-bottom: 12px; 
            transition: all 0.3s ease; 
            text-transform: uppercase; 
            letter-spacing: 1px; 
        }

        .action-btn:hover:not(:disabled) { 
            transform: translateY(-2px); 
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4); 
        }

        .action-btn:disabled { 
            opacity: 0.5; 
            cursor: not-allowed; 
            transform: none; 
            box-shadow: none; 
        }

        .validate-btn { 
            background: linear-gradient(45deg, #4CAF50, #45a049); 
        }

        .component-btn { 
            background: linear-gradient(45deg, #4CAF50, #45a049); 
        }

        .secondary-btn { 
            background: linear-gradient(45deg, #2196F3, #1976D2); 
        }

        /* API Status */
        .api-status {
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .api-status.connected {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid rgba(76, 175, 80, 0.5);
            color: #4CAF50;
        }

        .api-status.connecting {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid rgba(255, 193, 7, 0.5);
            color: #FFC107;
        }

        .api-status.disconnected {
            background: rgba(244, 67, 54, 0.2);
            border: 1px solid rgba(244, 67, 54, 0.5);
            color: #f44336;
        }

        /* Upload Area */
        .upload-area {
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 15px;
        }

        .upload-area:hover {
            border-color: #FFD700;
            background: rgba(255, 215, 0, 0.05);
        }

        .upload-area.drag-over {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.1);
        }

        .file-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .file-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .file-info {
            flex: 1;
        }

        .file-name {
            font-weight: bold;
            margin-bottom: 2px;
        }

        .file-details {
            font-size: 11px;
            opacity: 0.8;
        }

        .file-remove {
            background: #f44336;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .file-remove:hover {
            background: #d32f2f;
        }

        /* Loading Indicator */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 9999;
        }

        .loading.show {
            display: flex;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #FFD700;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading h3 {
            color: #FFD700;
            margin-bottom: 10px;
        }

        .loading p {
            color: rgba(255, 255, 255, 0.8);
            text-align: center;
            max-width: 400px;
        }

        /* Tabs */
        .tabs {
            display: flex;
            margin-bottom: 25px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 5px;
        }

        .tab {
            flex: 1;
            background: transparent;
            color: rgba(255, 255, 255, 0.7);
            border: none;
            padding: 12px 8px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .tab.active {
            background: linear-gradient(45deg, #FFD700, #FFA500);
            color: #000;
        }

        .tab:hover:not(.active) {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Message Types */
        .error, .success, .warning {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 8px;
            font-weight: bold;
            z-index: 10000;
            animation: slideInRight 0.3s ease;
        }

        .error {
            background: #f44336;
            color: white;
        }

        .success {
            background: #4CAF50;
            color: white;
        }

        .warning {
            background: #FF9800;
            color: white;
        }

        @keyframes slideInRight {
            from { transform: translateX(100%); }
            to { transform: translateX(0); }
        }

        /* Responsive Design */
        @media (max-width: 1600px) { 
            .main-grid { 
                grid-template-columns: 450px 1fr 350px; 
            } 
        }

        @media (max-width: 1400px) { 
            .main-grid { 
                grid-template-columns: 400px 1fr 300px; 
            } 
        }

        @media (max-width: 1200px) { 
            .main-grid { 
                grid-template-columns: 1fr; 
                gap: 20px; 
            }
            
            .control-panel, 
            .analysis-workspace, 
            .chat-panel {
                max-height: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🔬 Enhanced Mainframe Analyzer</h1>
            <p>Advanced mainframe analysis with field flow tracking, business rules, and dependency mapping</p>
        </div>

        <div class="main-grid">
            <!-- Control Panel -->
            <div class="control-panel">
                <!-- Component Search Section -->
                <div class="component-search-section">
                    <h2 class="section-title">🎯 Component Analysis</h2>
                    <div class="form-group">
                        <label for="componentName">Enter Component Name:</label>
                        <input type="text" id="componentName" class="component-input" 
                               placeholder="e.g., CUSTOMER-RECORD, ACCOUNT-COPY, PAYROLL-PROC">
                        <div id="componentSuggestions" class="component-suggestions"></div>
                    </div>
                    
                    <!-- Token Usage Display -->
                    <div id="tokenInfo" class="token-info" style="display: none;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                            <span style="font-weight: bold;">Token Management</span>
                            <span id="tokenCount">0 / 4000</span>
                        </div>
                        <div class="token-bar">
                            <div id="tokenFill" class="token-fill safe" style="width: 0%"></div>
                        </div>
                        <div id="tokenWarning" style="font-size: 11px; margin-top: 5px;"></div>
                    </div>
                    
                    <button class="action-btn component-btn" id="analyzeComponentBtn" disabled>
                        🔍 Analyze Component
                    </button>
                </div>

                <!-- vLLM API Setup -->
                <div style="margin-bottom: 25px; padding: 20px; background: rgba(0, 0, 0, 0.2); border-radius: 15px; border-left: 4px solid #4CAF50;">
                    <h2 class="section-title">🚀 vLLM Server Setup</h2>
                    <div class="form-group">
                        <label for="vllmEndpoint">Server Endpoint:</label>
                        <input type="text" id="vllmEndpoint" placeholder="http://localhost:8000" value="http://localhost:8000">
                    </div>
                    <div class="form-group">
                        <label for="maxTokens">Max Tokens:</label>
                        <input type="number" id="maxTokens" value="4000" min="1000" max="8000">
                    </div>
                    <button class="action-btn validate-btn" id="validateApiBtn">
                        🔐 Test Connection
                    </button>
                    <div class="api-status disconnected" id="apiStatus">
                        <span>🔴</span> Enter server details and test connection
                    </div>
                </div>

                <!-- File Upload Section -->
                <div style="margin-bottom: 25px;">
                    <h2 class="section-title">📁 Upload Mainframe Files</h2>
                    <div class="upload-area" id="uploadArea">
                        <div>
                            <h3 style="margin-bottom: 8px;">📤 Drop files here</h3>
                            <p style="font-size: 14px;">COBOL (.cbl), Copybooks (.cpy), JCL (.jcl)</p>
                        </div>
                        <input type="file" id="fileInput" multiple accept=".cbl,.cob,.cpy,.copybook,.jcl,.txt,.proc" style="display: none;">
                    </div>
                    <div id="uploadedFiles" class="file-list"></div>
                </div>

                <!-- Quick Actions -->
                <div>
                    <h3 class="section-title">⚡ Actions</h3>
                    <button class="action-btn secondary-btn" id="bulkAnalyzeBtn" disabled>
                        📊 Bulk Analyze
                    </button>
                    <button class="action-btn secondary-btn" id="exportBtn" disabled>
                        📤 Export Results
                    </button>
                    <button class="action-btn secondary-btn" id="clearBtn">
                        🗑️ Clear All Data
                    </button>
                </div>
            </div>

            <!-- Analysis Workspace -->
            <div class="analysis-workspace">
                <div class="tabs">
                    <button class="tab active" data-tab="lifecycle">🔄 Analysis Results</button>
                    <button class="tab" data-tab="fieldmatrix">📋 Field Matrix</button>
                    <button class="tab" data-tab="usage">📈 Usage Patterns</button>
                    <button class="tab" data-tab="dependencies">🔗 Dependencies</button>
                </div>

                <!-- Tab Contents -->
                <div id="lifecycle" class="tab-content active">
                    <div id="lifecycleContent">
                        <h3>🎯 Component Analysis Results</h3>
                        <p style="margin-bottom: 20px; line-height: 1.6;">
                            Upload files, test your connection, and analyze components for detailed field flows and business rules.
                        </p>
                        
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px; border-left: 4px solid #FFD700;">
                            <h4 style="color: #FFD700; margin-bottom: 15px;">🚀 Analysis Features:</h4>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                                <div>
                                    <strong style="color: #4CAF50;">📊 Field Flow Analysis:</strong>
                                    <ul style="list-style: none; margin-left: 10px; line-height: 1.8;">
                                        <li>• Input/Output field tracking</li>
                                        <li>• Derived and calculated fields</li>
                                        <li>• Unused field identification</li>
                                        <li>• Field transformation paths</li>
                                    </ul>
                                </div>
                                <div>
                                    <strong style="color: #2196F3;">⚖️ Business Rules:</strong>
                                    <ul style="list-style: none; margin-left: 10px; line-height: 1.8;">
                                        <li>• Validation logic extraction</li>
                                        <li>• Decision point mapping</li>
                                        <li>• Conditional processing</li>
                                        <li>• Business calculation rules</li>
                                    </ul>
                                </div>
                                <div>
                                    <strong style="color: #FF9800;">🔗 Dependencies:</strong>
                                    <ul style="list-style: none; margin-left: 10px; line-height: 1.8;">
                                        <li>• Copybook dependencies</li>
                                        <li>• Program call chains</li>
                                        <li>• File references</li>
                                        <li>• Database table usage</li>
                                    </ul>
                                </div>
                                <div>
                                    <strong style="color: #9C27B0;">🧠 Smart Processing:</strong>
                                    <ul style="list-style: none; margin-left: 10px; line-height: 1.8;">
                                        <li>• Token-aware chunking</li>
                                        <li>• Progressive analysis</li>
                                        <li>• Context preservation</li>
                                        <li>• Quality validation</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="fieldmatrix" class="tab-content">
                    <div id="fieldMatrixContent">
                        <h3>📋 Field Matrix Analysis</h3>
                        <p style="margin-bottom: 20px;">Field-level analysis with categorization will appear here after component analysis.</p>
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px;">
                            <p style="text-align: center; opacity: 0.8;">Field matrix will appear here after analysis.</p>
                        </div>
                    </div>
                </div>

                <div id="usage" class="tab-content">
                    <div id="usageContent">
                        <h3>📈 Usage Patterns Analysis</h3>
                        <p style="margin-bottom: 20px;">Usage pattern analysis will appear here after component analysis.</p>
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px;">
                            <p style="text-align: center; opacity: 0.8;">Usage patterns will appear here after analysis.</p>
                        </div>
                    </div>
                </div>

                <div id="dependencies" class="tab-content">
                    <div id="dependenciesContent">
                        <h3>🔗 Dependency Analysis</h3>
                        <p style="margin-bottom: 20px;">Dependency mapping will appear here after component analysis.</p>
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px;">
                            <p style="text-align: center; opacity: 0.8;">Dependency graph will appear here after analysis.</p>
                        </div>
                    </div>
                </div>

                <!-- Loading Indicator -->
                <div class="loading" id="loadingIndicator">
                    <div class="spinner"></div>
                    <h3>🤖 Analyzing Component</h3>
                    <p id="loadingStatus">Processing component analysis...</p>
                    <div id="progressBar" style="background: rgba(255,255,255,0.2); height: 6px; border-radius: 3px; margin: 15px 0; overflow: hidden;">
                        <div id="progressFill" style="height: 100%; background: #4CAF50; width: 0%; transition: width 0.3s ease;"></div>
                    </div>
                </div>
            </div>

            <!-- Chat Panel - Will be added in next part -->
            <div class="chat-panel">
                <div style="background: rgba(76, 175, 80, 0.2); border-radius: 10px; padding: 15px; margin-bottom: 15px; border-left: 4px solid #4CAF50;">
                    <h3 style="margin-bottom: 8px; color: #FFD700;">💬 Analysis Chat</h3>
                    <p style="font-size: 12px; opacity: 0.8;">Interactive chat will be enabled in Part 2</p>
                </div>
                
                <div style="flex: 1; display: flex; align-items: center; justify-content: center; background: rgba(255, 255, 255, 0.05); border-radius: 10px;">
                    <p style="opacity: 0.6;">Chat functionality coming in Part 2...</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Part 1: Basic Setup and Core Functionality
        class EnhancedMainframeAnalyzer {
            constructor() {
                // Core properties
                this.uploadedFiles = [];
                this.analysisResults = {};
                this.componentSuggestions = [];
                this.serverValidated = false;
                this.vllmEndpoint = 'http://localhost:8000';
                this.maxTokens = 4000;
                this.storageKey = 'enhanced_mainframe_analysis';
                this.currentAnalyzedComponent = null;
                
                // Token management
                this.averageCharsPerToken = 4;
                this.tokenSafetyMargin = 0.8;
                
                this.initializeBasicEventListeners();
                this.loadStoredData();
                this.initializeTokenManagement();
                
                console.log('🚀 Enhanced Mainframe Analyzer - Part 1 Initialized');
            }

            initializeBasicEventListeners() {
                // API validation
                document.getElementById('validateApiBtn').addEventListener('click', () => this.validateConnection());
                document.getElementById('vllmEndpoint').addEventListener('input', () => this.onEndpointChange());
                document.getElementById('maxTokens').addEventListener('input', () => this.onSettingsChange());
                
                // File upload handlers
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');
                
                uploadArea.addEventListener('click', () => {
                    if (this.serverValidated) fileInput.click();
                });
                uploadArea.addEventListener('drop', (e) => this.handleFileDrop(e));
                uploadArea.addEventListener('dragover', (e) => this.handleDragOver(e));
                uploadArea.addEventListener('dragleave', (e) => this.handleDragLeave(e));
                fileInput.addEventListener('change', (e) => this.handleFileSelect(e));

                // Component analysis
                document.getElementById('componentName').addEventListener('input', () => this.onComponentInput());
                document.getElementById('analyzeComponentBtn').addEventListener('click', () => this.analyzeComponent());
                
                // Quick actions
                document.getElementById('bulkAnalyzeBtn').addEventListener('click', () => this.bulkAnalyze());
                document.getElementById('exportBtn').addEventListener('click', () => this.exportResults());
                document.getElementById('clearBtn').addEventListener('click', () => this.clearAllData());

                // Tab navigation
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', (e) => this.switchTab(e));
                });

                // Hide suggestions when clicking outside
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.component-search-section')) {
                        document.getElementById('componentSuggestions').style.display = 'none';
                    }
                });
            }

            initializeTokenManagement() {
                this.updateTokenDisplay(0);
                this.showSuccess('🚀 Enhanced Mainframe Analyzer Ready!');
            }

            // === TOKEN MANAGEMENT ===
            estimateTokenCount(text) {
                if (!text) return 0;
                return Math.ceil(text.length / 3);
            }

            updateTokenDisplay(currentTokens) {
                const tokenInfo = document.getElementById('tokenInfo');
                const tokenCount = document.getElementById('tokenCount');
                const tokenFill = document.getElementById('tokenFill');
                const tokenWarning = document.getElementById('tokenWarning');

                tokenInfo.style.display = 'block';
                tokenCount.textContent = `${currentTokens} / ${this.maxTokens}`;
                
                const percentage = (currentTokens / this.maxTokens) * 100;
                tokenFill.style.width = `${Math.min(percentage, 100)}%`;
                
                tokenFill.className = 'token-fill';
                if (percentage <= 60) {
                    tokenFill.classList.add('safe');
                    tokenWarning.textContent = '🟢 Optimal token usage - full analysis available';
                } else if (percentage <= 85) {
                    tokenFill.classList.add('warning');
                    tokenWarning.textContent = '🟡 Moderate usage - intelligent chunking active';
                } else {
                    tokenFill.classList.add('danger');
                    tokenWarning.textContent = '🔴 High usage - optimization required';
                }
            }

            // === API CONNECTION ===
            async validateConnection() {
                const endpoint = document.getElementById('vllmEndpoint').value.trim();
                if (!endpoint) {
                    this.showError('Please enter vLLM endpoint');
                    return;
                }

                this.updateConnectionStatus('connecting', 'Testing connection...');

                try {
                    const response = await fetch(`${endpoint}/generate`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            prompt: "Test connection. Respond with 'Connected'",
                            max_tokens: 10,
                            temperature: 0.1
                        }),
                        signal: AbortSignal.timeout(10000)
                    });

                    if (response.ok) {
                        this.serverValidated = true;
                        this.vllmEndpoint = endpoint;
                        this.updateConnectionStatus('connected', `✅ Connection verified`);
                        this.showSuccess('🚀 vLLM server connected successfully!');
                    } else {
                        throw new Error(`HTTP ${response.status}`);
                    }
                } catch (error) {
                    this.serverValidated = false;
                    this.updateConnectionStatus('disconnected', `❌ Connection failed: ${error.message}`);
                    this.showError(`Connection failed: ${error.message}`);
                }
                
                this.validateForm();
            }

            updateConnectionStatus(status, message) {
                const statusElement = document.getElementById('apiStatus');
                statusElement.className = `api-status ${status}`;
                statusElement.innerHTML = message;
            }

            // === FILE UPLOAD ===
            handleFileDrop(e) {
                e.preventDefault();
                e.stopPropagation();
                
                const uploadArea = document.getElementById('uploadArea');
                uploadArea.classList.remove('drag-over');
                
                if (!this.serverValidated) {
                    this.showError('Please validate API connection first');
                    return;
                }
                
                const files = Array.from(e.dataTransfer.files);
                this.processFiles(files);
            }

            handleDragOver(e) {
                e.preventDefault();
                e.stopPropagation();
                document.getElementById('uploadArea').classList.add('drag-over');
            }

            handleDragLeave(e) {
                e.preventDefault();
                e.stopPropagation();
                document.getElementById('uploadArea').classList.remove('drag-over');
            }

            handleFileSelect(e) {
                if (!this.serverValidated) {
                    this.showError('Please validate API connection first');
                    return;
                }
                
                const files = Array.from(e.target.files);
                this.processFiles(files);
            }

            async processFiles(files) {
                for (const file of files) {
                    try {
                        const content = await this.readFile(file);
                        const fileType = this.detectFileType(file.name, content);
                        
                        const fileObj = {
                            name: file.name,
                            content: content,
                            size: file.size,
                            type: fileType,
                            uploadDate: new Date().toISOString(),
                            id: Date.now() + Math.random()
                        };
                        
                        this.uploadedFiles.push(fileObj);
                        this.updateComponentSuggestions();
                        
                    } catch (error) {
                        this.showError(`Failed to read ${file.name}: ${error.message}`);
                    }
                }
                
                this.displayUploadedFiles();
                this.validateForm();
                this.saveToStorage();
                this.showSuccess(`📁 ${files.length} files uploaded successfully!`);
            }

            readFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = e => resolve(e.target.result);
                    reader.onerror = e => reject(new Error('File read failed'));
                    reader.readAsText(file);
                });
            }

            detectFileType(fileName, content) {
                const name = fileName.toLowerCase();
                const upperContent = content.toUpperCase();
                
                if (name.includes('.cpy') || name.includes('copybook')) {
                    return 'Copybook';
                } else if (name.includes('.jcl') || upperContent.includes('//JOB ')) {
                    return 'JCL Job';
                } else if (name.includes('.cbl') || name.includes('.cob') || 
                          upperContent.includes('IDENTIFICATION DIVISION') ||
                          upperContent.includes('PROGRAM-ID')) {
                    return 'COBOL Program';
                } else if (name.includes('.proc')) {
                    return 'JCL Procedure';
                } else {
                    return 'Text File';
                }
            }

            displayUploadedFiles() {
                const container = document.getElementById('uploadedFiles');
                if (this.uploadedFiles.length === 0) {
                    container.innerHTML = '';
                    return;
                }
                
                let html = '';
                this.uploadedFiles.forEach(file => {
                    html += `
                        <div class="file-item">
                            <div class="file-info">
                                <div class="file-name">${file.name}</div>
                                <div class="file-details">${file.type} • ${Math.round(file.size/1024)}KB</div>
                            </div>
                            <button class="file-remove" onclick="analyzer.removeFile('${file.id}')">🗑️</button>
                        </div>
                    `;
                });
                
                container.innerHTML = html;
            }

            removeFile(fileId) {
                this.uploadedFiles = this.uploadedFiles.filter(f => f.id != fileId);
                this.displayUploadedFiles();
                this.updateComponentSuggestions();
                this.validateForm();
                this.saveToStorage();
            }

            // === COMPONENT SUGGESTIONS ===
            updateComponentSuggestions() {
                this.componentSuggestions = [];
                
                this.uploadedFiles.forEach(file => {
                    const content = file.content.toUpperCase();
                    const lines = content.split('\n');
                    
                    lines.forEach(line => {
                        const trimmed = line.trim();
                        
                        // Extract COBOL field names
                        const fieldMatch = trimmed.match(/^\s*\d{2}\s+([A-Z][A-Z0-9\-_]{2,})/);
                        if (fieldMatch) {
                            this.componentSuggestions.push({
                                name: fieldMatch[1],
                                type: 'FIELD',
                                file: file.name
                            });
                        }
                        
                        // Extract copybook names
                        const copyMatch = trimmed.match(/COPY\s+([A-Z][A-Z0-9\-_]{2,})/);
                        if (copyMatch) {
                            this.componentSuggestions.push({
                                name: copyMatch[1],
                                type: 'COPYBOOK',
                                file: file.name
                            });
                        }
                        
                        // Extract program names
                        const programMatch = trimmed.match(/PROGRAM-ID\.?\s+([A-Z][A-Z0-9\-_]{2,})/);
                        if (programMatch) {
                            this.componentSuggestions.push({
                                name: programMatch[1],
                                type: 'PROGRAM',
                                file: file.name
                            });
                        }
                    });
                });
                
                // Remove duplicates
                this.componentSuggestions = this.componentSuggestions.filter((item, index, self) => 
                    index === self.findIndex(t => t.name === item.name && t.type === item.type)
                );
            }

            onComponentInput() {
                const input = document.getElementById('componentName');
                const value = input.value.trim().toUpperCase();
                const suggestions = document.getElementById('componentSuggestions');
                
                if (value.length < 2) {
                    suggestions.style.display = 'none';
                    this.validateForm();
                    return;
                }
                
                const filtered = this.componentSuggestions.filter(item => 
                    item.name.includes(value)
                ).slice(0, 8);
                
                if (filtered.length > 0) {
                    let html = '';
                    filtered.forEach(item => {
                        html += `
                            <div class="suggestion-item" onclick="analyzer.selectSuggestion('${item.name}')">
                                <strong>${item.name}</strong> 
                                <span style="opacity: 0.7;">(${item.type} in ${item.file})</span>
                            </div>
                        `;
                    });
                    suggestions.innerHTML = html;
                    suggestions.style.display = 'block';
                } else {
                    suggestions.style.display = 'none';
                }
                
                this.validateForm();
            }

            selectSuggestion(componentName) {
                document.getElementById('componentName').value = componentName;
                document.getElementById('componentSuggestions').style.display = 'none';
                this.validateForm();
            }

            // === FORM VALIDATION ===
            validateForm() {
                const hasFiles = this.uploadedFiles.length > 0;
                const hasComponent = document.getElementById('componentName').value.trim().length > 0;
                const hasConnection = this.serverValidated;
                
                document.getElementById('analyzeComponentBtn').disabled = !(hasFiles && hasComponent && hasConnection);
                document.getElementById('bulkAnalyzeBtn').disabled = !(hasFiles && hasConnection);
                document.getElementById('exportBtn').disabled = Object.keys(this.analysisResults).length === 0;
            }

            // === EVENT HANDLERS ===
            onEndpointChange() {
                this.serverValidated = false;
                this.updateConnectionStatus('disconnected', '🔴 Connection not validated');
                this.validateForm();
            }

            onSettingsChange() {
                this.maxTokens = parseInt(document.getElementById('maxTokens').value) || 4000;
                this.saveToStorage();
            }

            switchTab(e) {
                const targetTab = e.target?.dataset?.tab || e.dataset?.tab;
                if (!targetTab) return;
                
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                
                const clickedTab = e.target || e;
                if (clickedTab.classList) {
                    clickedTab.classList.add('active');
                }
                
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                
                const targetContent = document.getElementById(targetTab);
                if (targetContent) {
                    targetContent.classList.add('active');
                }
            }

            // === PLACEHOLDER METHODS FOR PART 2 ===
            async analyzeComponent() {
                this.showWarning('Analysis functionality will be added in Part 2');
            }

            async bulkAnalyze() {
                this.showWarning('Bulk analysis functionality will be added in Part 2');
            }

            exportResults() {
                this.showWarning('Export functionality will be added in Part 2');
            }

            // === UTILITY METHODS ===
            showLoading() { 
                document.getElementById('loadingIndicator').classList.add('show'); 
            }
            
            hideLoading() { 
                document.getElementById('loadingIndicator').classList.remove('show'); 
            }
            
            updateLoadingStatus(status) { 
                document.getElementById('loadingStatus').textContent = status; 
            }

            updateProgress(percentage) {
                const progressFill = document.getElementById('progressFill');
                if (progressFill) {
                    progressFill.style.width = `${percentage}%`;
                }
            }

            showMessage(type, message, duration = 3000) {
                const messageDiv = document.createElement('div');
                messageDiv.className = type;
                messageDiv.textContent = message;
                document.body.appendChild(messageDiv);
                
                setTimeout(() => {
                    if (messageDiv.parentNode) {
                        messageDiv.parentNode.removeChild(messageDiv);
                    }
                }, duration);
            }
            
            showError(message) { this.showMessage('error', message, 5000); }
            showSuccess(message) { this.showMessage('success', message, 3000); }
            showWarning(message) { this.showMessage('warning', message, 4000); }
            
            sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

            // === STORAGE MANAGEMENT ===
            saveToStorage() {
                try {
                    const data = {
                        uploadedFiles: this.uploadedFiles,
                        analysisResults: this.analysisResults,
                        vllmEndpoint: this.vllmEndpoint,
                        maxTokens: this.maxTokens,
                        timestamp: new Date().toISOString()
                    };
                    localStorage.setItem(this.storageKey, JSON.stringify(data));
                } catch (error) {
                    console.warn('Failed to save to storage:', error);
                }
            }

            loadStoredData() {
                try {
                    const stored = localStorage.getItem(this.storageKey);
                    if (stored) {
                        const data = JSON.parse(stored);
                        this.uploadedFiles = data.uploadedFiles || [];
                        this.analysisResults = data.analysisResults || {};
                        
                        if (data.vllmEndpoint) {
                            document.getElementById('vllmEndpoint').value = data.vllmEndpoint;
                            this.vllmEndpoint = data.vllmEndpoint;
                        }
                        
                        if (data.maxTokens) {
                            document.getElementById('maxTokens').value = data.maxTokens;
                            this.maxTokens = data.maxTokens;
                        }
                        
                        this.displayUploadedFiles();
                        this.updateComponentSuggestions();
                        this.validateForm();
                        
                        console.log('📁 Stored data loaded successfully');
                    }
                } catch (error) {
                    console.warn('Failed to load stored data:', error);
                }
            }

            clearAllData() {
                if (confirm('Are you sure you want to clear all data? This cannot be undone.')) {
                    this.uploadedFiles = [];
                    this.analysisResults = {};
                    this.componentSuggestions = [];
                    this.currentAnalyzedComponent = null;
                    
                    localStorage.removeItem(this.storageKey);
                    
                    this.displayUploadedFiles();
                    this.validateForm();
                    
                    document.getElementById('lifecycleContent').innerHTML = `
                        <h3>🎯 Component Analysis Results</h3>
                        <p style="margin-bottom: 20px;">Upload files and analyze components to get started.</p>
                    `;
                    
                    this.showSuccess('🗑️ All data cleared successfully');
                }
            }
        }

        // Initialize the analyzer
        const analyzer = new EnhancedMainframeAnalyzer();
        
        console.log('🚀 Enhanced Mainframe Analyzer - Part 1 Ready!');
        console.log('✅ Features active: File upload, API connection, component suggestions, token management');
        console.log('⏳ Coming in Part 2: Analysis engine, chat functionality, field matrix, dependencies');

        // Part 2: Analysis Engine and Chat Functionality
// This extends the analyzer from Part 1

// === ANALYSIS ENGINE ===
EnhancedMainframeAnalyzer.prototype.analyzeComponent = async function() {
    const componentName = document.getElementById('componentName').value.trim();
    if (!componentName) return;

    this.showLoading();
    this.updateProgress(0);

    try {
        const results = await this.runFocusedAnalysis(componentName);
        
        this.analysisResults[componentName] = results;
        this.currentAnalyzedComponent = componentName;
        
        this.displayAnalysisResults(componentName, results);
        this.enableChat();
        this.saveToStorage();
        
        this.hideLoading();
        this.showSuccess(`✅ Analysis complete for ${componentName}!`);
        
    } catch (error) {
        this.hideLoading();
        this.showError(`Analysis failed: ${error.message}`);
        console.error('Analysis error:', error);
    }
};

EnhancedMainframeAnalyzer.prototype.createOverlappingChunks = function(files, componentInfo) {
    const chunks = [];
    const maxTokensPerChunk = Math.floor(this.maxTokens * 0.25); // Very conservative - 25% max
    
    console.log(`Creating aggressive chunks with max ${maxTokensPerChunk} tokens each`);
    
    // Sort files by size (smallest first for better packing)
    const sortedFiles = files.sort((a, b) => 
        this.estimateTokenCount(a.content) - this.estimateTokenCount(b.content)
    );
    
    let currentChunk = [];
    let currentTokens = 0;
    let overlapContent = '';
    
    sortedFiles.forEach((file, index) => {
        const fileTokens = this.estimateTokenCount(file.content);
        
        console.log(`Processing file ${file.name}: ${fileTokens} tokens for chunking`);
        
        // If single file is too large, split it
        if (fileTokens > maxTokensPerChunk) {
            console.log(`File ${file.name} too large (${fileTokens} tokens), splitting...`);
            
            // Finish current chunk first
            if (currentChunk.length > 0) {
                chunks.push({
                    files: [...currentChunk],
                    totalTokens: currentTokens,
                    overlapContext: overlapContent,
                    chunkIndex: chunks.length
                });
                currentChunk = [];
                currentTokens = 0;
            }
            
            // Split large file into multiple chunks
            const fileParts = this.splitLargeFile(file, maxTokensPerChunk);
            fileParts.forEach(part => {
                chunks.push({
                    files: [part],
                    totalTokens: this.estimateTokenCount(part.content),
                    overlapContext: this.extractFileOverlap(part),
                    chunkIndex: chunks.length
                });
            });
            
            overlapContent = this.extractFileOverlap(fileParts[fileParts.length - 1]);
        }
        // If adding this file would exceed limit, start new chunk
        else if (currentTokens + fileTokens > maxTokensPerChunk && currentChunk.length > 0) {
            console.log(`Starting new chunk. Current: ${currentTokens}, adding: ${fileTokens} would exceed ${maxTokensPerChunk}`);
            
            chunks.push({
                files: [...currentChunk],
                totalTokens: currentTokens,
                overlapContext: overlapContent,
                chunkIndex: chunks.length
            });
            
            // Create overlap from previous chunk
            overlapContent = this.extractOverlapContent(currentChunk);
            const overlapTokens = this.estimateTokenCount(overlapContent);
            
            currentChunk = [file];
            currentTokens = fileTokens + overlapTokens;
        }
        // Add file to current chunk
        else {
            currentChunk.push(file);
            currentTokens += fileTokens;
            console.log(`Added ${file.name} to chunk. Total: ${currentTokens} tokens`);
        }
    });
    
    // Add final chunk
    if (currentChunk.length > 0) {
        chunks.push({
            files: currentChunk,
            totalTokens: currentTokens,
            overlapContext: overlapContent,
            chunkIndex: chunks.length
        });
    }
    
    console.log(`Created ${chunks.length} aggressive chunks with max ${Math.max(...chunks.map(c => c.totalTokens))} tokens`);
    return chunks;
};

EnhancedMainframeAnalyzer.prototype.extractFileOverlap = function(file) {
    const lines = file.content.split('\n');
    const importantLines = lines.filter(line => {
        const upper = line.toUpperCase().trim();
        return upper.includes('COPY ') ||
               upper.includes('CALL ') ||
               upper.includes('PROGRAM-ID') ||
               upper.match(/^\s*\d{2}\s+[A-Z]/);
    });
    
    const overlap = importantLines.slice(0, 10).join('\n'); // Max 10 lines
    return overlap ? `\n=== CONTEXT from ${file.name} ===\n${overlap}` : '';
};

// Override dependency chunking to be more aggressive too


EnhancedMainframeAnalyzer.prototype.splitLargeFile = function(file, maxTokens) {
    const parts = [];
    const lines = file.content.split('\n');
    const maxCharsPerPart = maxTokens * 3; // Conservative char-to-token ratio
    
    console.log(`Splitting large file ${file.name} into parts of max ${maxTokens} tokens each`);
    
    let currentPart = [];
    let currentChars = 0;
    let partIndex = 0;
    
    // Group lines that should stay together
    const lineGroups = this.groupRelatedLines(lines);
    
    for (const group of lineGroups) {
        const groupContent = group.join('\n');
        const groupChars = groupContent.length;
        
        // If this group alone exceeds limit, truncate it
        if (groupChars > maxCharsPerPart) {
            if (currentPart.length > 0) {
                // Save current part first
                parts.push({
                    ...file,
                    name: `${file.name}-part-${partIndex + 1}`,
                    content: currentPart.join('\n'),
                    originalFile: file.name,
                    partIndex: partIndex
                });
                partIndex++;
                currentPart = [];
                currentChars = 0;
            }
            
            // Truncate this large group
            const truncatedGroup = this.aggressiveTruncate(groupContent, maxTokens);
            parts.push({
                ...file,
                name: `${file.name}-part-${partIndex + 1}`,
                content: truncatedGroup,
                originalFile: file.name,
                partIndex: partIndex,
                truncated: true
            });
            partIndex++;
        }
        // If adding this group would exceed limit, start new part
        else if (currentChars + groupChars > maxCharsPerPart && currentPart.length > 0) {
            parts.push({
                ...file,
                name: `${file.name}-part-${partIndex + 1}`,
                content: currentPart.join('\n'),
                originalFile: file.name,
                partIndex: partIndex
            });
            partIndex++;
            
            currentPart = [...group];
            currentChars = groupChars;
        }
        // Add group to current part
        else {
            currentPart.push(...group);
            currentChars += groupChars + 1; // +1 for newline
        }
    }
    
    // Add final part
    if (currentPart.length > 0) {
        parts.push({
            ...file,
            name: `${file.name}-part-${partIndex + 1}`,
            content: currentPart.join('\n'),
            originalFile: file.name,
            partIndex: partIndex
        });
    }
    
    console.log(`Split ${file.name} into ${parts.length} parts`);
    return parts;
};

EnhancedMainframeAnalyzer.prototype.groupRelatedLines = function(lines) {
    const groups = [];
    let currentGroup = [];
    
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const trimmed = line.trim().toUpperCase();
        
        // Start new group for major sections
        if (trimmed.includes('IDENTIFICATION DIVISION') ||
            trimmed.includes('ENVIRONMENT DIVISION') ||
            trimmed.includes('DATA DIVISION') ||
            trimmed.includes('PROCEDURE DIVISION') ||
            trimmed.includes('WORKING-STORAGE SECTION') ||
            trimmed.includes('LINKAGE SECTION')) {
            
            if (currentGroup.length > 0) {
                groups.push([...currentGroup]);
                currentGroup = [];
            }
        }
        
        currentGroup.push(line);
        
        // Keep groups reasonably sized (max 50 lines)
        if (currentGroup.length >= 50) {
            groups.push([...currentGroup]);
            currentGroup = [];
        }
    }
    
    if (currentGroup.length > 0) {
        groups.push(currentGroup);
    }
    
    return groups;
};



EnhancedMainframeAnalyzer.prototype.runFocusedAnalysis = async function(componentName) {
    console.log(`Starting focused analysis for: ${componentName}`);
    
    // Stage 1: Find relevant files
    this.updateLoadingStatus('🔍 Stage 1: Finding relevant files...');
    this.updateProgress(20);
    
    const relevantFiles = this.findRelevantFiles(componentName);
    if (relevantFiles.length === 0) {
        throw new Error(`Component "${componentName}" not found in uploaded files`);
    }

    // Stage 2: Optimize content for tokens
    this.updateLoadingStatus('🧠 Stage 2: Optimizing content...');
    this.updateProgress(40);
    
    const optimizedContent = this.optimizeContentForTokens(relevantFiles);
    this.updateTokenDisplay(optimizedContent.totalTokens);

    // Stage 3: Perform analysis
    this.updateLoadingStatus('⚡ Stage 3: Analyzing component...');
    this.updateProgress(70);
    
    const analysisPrompt = this.buildFocusedPrompt(componentName, optimizedContent.files);
    const analysisResult = await this.callvLLMAPI(analysisPrompt);
    
    this.updateProgress(100);
    
    return {
        componentName: componentName,
        timestamp: new Date().toISOString(),
        filesAnalyzed: relevantFiles.map(f => f.name),
        analysis: analysisResult,
        componentType: this.detectComponentType(componentName, relevantFiles),
        qualityScore: this.calculateQualityScore(analysisResult),
        completeness: this.assessCompleteness(analysisResult)
    };
};

EnhancedMainframeAnalyzer.prototype.findRelevantFiles = function(componentName) {
    const upperComponentName = componentName.toUpperCase();
    
    return this.uploadedFiles.filter(file => {
        const content = file.content.toUpperCase();
        const fileName = file.name.toUpperCase();
        
        return content.includes(upperComponentName) || 
               fileName.includes(upperComponentName) ||
               this.hasRelatedContent(content, upperComponentName);
    });
};

EnhancedMainframeAnalyzer.prototype.hasRelatedContent = function(content, componentName) {
    const patterns = [
        `COPY\\s+${componentName}`,
        `CALL\\s+['"]?${componentName}['"]?`,
        `\\b${componentName}\\b`,
        componentName.replace(/-/g, '[\\-_]')
    ];
    
    return patterns.some(pattern => new RegExp(pattern, 'i').test(content));
};

EnhancedMainframeAnalyzer.prototype.optimizeContentForTokens = function(files) {
    const maxSafeTokens = Math.floor(this.maxTokens * 0.3); // Much more conservative - use only 30%
    console.log(`Aggressive optimization: Target max tokens: ${maxSafeTokens}`);
    
    const optimized = [];
    let currentTokens = 0;

    // Sort files by relevance and size
    const sortedFiles = files.sort((a, b) => {
        // Prioritize smaller, more relevant files
        const aRelevance = this.calculateFileRelevance(a);
        const bRelevance = this.calculateFileRelevance(b);
        const aSize = this.estimateTokenCount(a.content);
        const bSize = this.estimateTokenCount(b.content);
        
        // Higher relevance and smaller size = higher priority
        return (bRelevance - aRelevance) || (aSize - bSize);
    });

    for (const file of sortedFiles) {
        const fileTokens = this.estimateTokenCount(file.content);
        
        console.log(`Processing file ${file.name}: ${fileTokens} tokens`);
        
        if (fileTokens <= 500) {
            // Small file - include if space allows
            if (currentTokens + fileTokens <= maxSafeTokens) {
                optimized.push({
                    ...file,
                    content: file.content,
                    truncated: false,
                    originalTokens: fileTokens
                });
                currentTokens += fileTokens;
                console.log(`Added small file ${file.name}: ${fileTokens} tokens`);
            }
        } else {
            // Large file - aggressively truncate
            const remainingTokens = maxSafeTokens - currentTokens;
            if (remainingTokens > 200) { // Only include if meaningful space left
                const targetTokens = Math.min(800, remainingTokens); // Max 800 tokens per file
                const truncatedContent = this.aggressiveTruncate(file.content, targetTokens);
                const actualTokens = this.estimateTokenCount(truncatedContent);
                
                optimized.push({
                    ...file,
                    content: truncatedContent,
                    truncated: true,
                    originalTokens: fileTokens,
                    optimizedTokens: actualTokens
                });
                currentTokens += actualTokens;
                console.log(`Truncated large file ${file.name}: ${fileTokens} → ${actualTokens} tokens`);
            }
        }
        
        // Stop if we're getting close to limit
        if (currentTokens >= maxSafeTokens * 0.9) {
            console.log(`Stopping file processing at ${currentTokens} tokens`);
            break;
        }
    }

    console.log(`Final optimization result: ${currentTokens} tokens from ${optimized.length} files`);
    return { files: optimized, totalTokens: currentTokens };
};


EnhancedMainframeAnalyzer.prototype.aggressiveTruncate = function(content, targetTokens) {
    const targetChars = targetTokens * 3; // Conservative char-to-token ratio
    console.log(`Aggressive truncation: target ${targetTokens} tokens (${targetChars} chars)`);
    
    if (content.length <= targetChars) {
        return content;
    }
    
    const lines = content.split('\n');
    const prioritizedSections = {
        critical: [],
        important: [],
        regular: []
    };

    // More aggressive prioritization
    lines.forEach(line => {
        const upperLine = line.toUpperCase().trim();
        
        // Critical: Only the most essential lines
        if (upperLine.includes('COPY ') || 
            upperLine.includes('CALL ') || 
            upperLine.includes('PROGRAM-ID') ||
            upperLine.includes('PROCEDURE DIVISION') ||
            upperLine.includes('DATA DIVISION') ||
            upperLine.match(/^\s*\d{2}\s+[A-Z][A-Z0-9\-_]+\s+PIC/)) { // Field definitions with PIC
            prioritizedSections.critical.push(line);
        }
        // Important: Somewhat useful
        else if (upperLine.includes('WORKING-STORAGE') ||
                 upperLine.includes('LINKAGE') ||
                 upperLine.includes('IF ') ||
                 upperLine.includes('PERFORM ') ||
                 upperLine.includes('EXEC ') ||
                 upperLine.match(/^\s*\d{2}\s+[A-Z]/)) { // Other field definitions
            prioritizedSections.important.push(line);
        }
        // Regular: Everything else
        else if (upperLine.length > 0) { // Skip empty lines
            prioritizedSections.regular.push(line);
        }
    });

    // Build result with strict limits
    let result = '';
    let usedChars = 0;
    
    // Add critical lines (up to 50% of budget)
    const criticalBudget = Math.floor(targetChars * 0.5);
    for (const line of prioritizedSections.critical) {
        if (usedChars + line.length + 1 <= criticalBudget) {
            result += (result ? '\n' : '') + line;
            usedChars += line.length + 1;
        } else {
            break;
        }
    }
    
    // Add important lines (up to 35% of budget)
    const importantBudget = Math.floor(targetChars * 0.35);
    let importantUsed = 0;
    for (const line of prioritizedSections.important) {
        if (importantUsed + line.length + 1 <= importantBudget && 
            usedChars + line.length + 1 <= targetChars * 0.85) {
            result += '\n' + line;
            usedChars += line.length + 1;
            importantUsed += line.length + 1;
        } else {
            break;
        }
    }
    
    // Add regular lines only if significant space remains (up to 15% of budget)
    const regularBudget = Math.floor(targetChars * 0.15);
    let regularUsed = 0;
    for (const line of prioritizedSections.regular) {
        if (regularUsed + line.length + 1 <= regularBudget && 
            usedChars + line.length + 1 <= targetChars * 0.9) {
            result += '\n' + line;
            usedChars += line.length + 1;
            regularUsed += line.length + 1;
        } else {
            break;
        }
    }
    
    // Add truncation notice if we had to cut content
    if (usedChars < content.length * 0.8) {
        result += '\n... [AGGRESSIVELY TRUNCATED FOR TOKEN OPTIMIZATION]';
    }
    
    console.log(`Truncation result: ${content.length} → ${result.length} chars (${Math.round(result.length/content.length*100)}% retained)`);
    return result;
};



EnhancedMainframeAnalyzer.prototype.calculateFileRelevance = function(file) {
    let relevance = 0;
    const content = file.content.toUpperCase();
    
    // Higher relevance for files with important keywords
    if (content.includes('COPY ')) relevance += 10;
    if (content.includes('CALL ')) relevance += 8;
    if (content.includes('PROCEDURE DIVISION')) relevance += 15;
    if (content.includes('DATA DIVISION')) relevance += 12;
    if (content.includes('WORKING-STORAGE')) relevance += 10;
    if (file.type === 'Copybook') relevance += 20;
    if (file.type === 'COBOL Program') relevance += 15;
    
    return relevance;
};

EnhancedMainframeAnalyzer.prototype.intelligentTruncate = function(content, targetTokens) {
    const targetChars = targetTokens * this.averageCharsPerToken;
    const lines = content.split('\n');
    
    // Prioritize important lines
    const prioritizedLines = {
        critical: [],
        important: [],
        regular: []
    };

    lines.forEach(line => {
        const upperLine = line.toUpperCase().trim();
        
        if (upperLine.includes('COPY ') || 
            upperLine.includes('CALL ') || 
            upperLine.includes('EXEC ') ||
            upperLine.match(/^\s*\d{2}\s+[A-Z]/) || 
            upperLine.includes('PROCEDURE DIVISION') ||
            upperLine.includes('DATA DIVISION')) {
            prioritizedLines.critical.push(line);
        }
        else if (upperLine.includes('WORKING-STORAGE') ||
                 upperLine.includes('LINKAGE') ||
                 upperLine.includes('//') || 
                 upperLine.includes('IF ') ||
                 upperLine.includes('PERFORM ')) {
            prioritizedLines.important.push(line);
        }
        else {
            prioritizedLines.regular.push(line);
        }
    });

    // Build optimized content
    let result = prioritizedLines.critical.join('\n');
    let remainingChars = targetChars - result.length;

    // Add important lines if space allows
    for (const line of prioritizedLines.important) {
        if (result.length + line.length + 1 < remainingChars * 0.8) {
            result += '\n' + line;
        } else break;
    }

    // Fill remaining space with regular content
    remainingChars = targetChars - result.length;
    for (const line of prioritizedLines.regular) {
        if (result.length + line.length + 1 < remainingChars) {
            result += '\n' + line;
        } else break;
    }

    return result;
};

EnhancedMainframeAnalyzer.prototype.detectComponentType = function(componentName, files) {
    const mainFile = files.find(f => 
        f.name.toUpperCase().includes(componentName.toUpperCase())
    );
    
    if (mainFile) {
        return mainFile.type;
    }
    
    // Check if it's a field in a copybook
    const copybookFile = files.find(f => f.type === 'Copybook');
    if (copybookFile) {
        const fieldPattern = new RegExp(`^\\s*\\d{2}\\s+${componentName}`, 'im');
        if (fieldPattern.test(copybookFile.content)) {
            return 'Field';
        }
    }
    
    return 'Component';
};

// OPTIMIZED PROMPT - FOCUSED AND CONCISE
EnhancedMainframeAnalyzer.prototype.buildFocusedPrompt = function(componentName, files) {
    return `ANALYZE COMPONENT: ${componentName}

FILES:
${files.map(f => `=== ${f.name} (${f.type}) ===\n${f.content}`).join('\n')}

REQUIRED ANALYSIS:

**1. FIELD FLOW TRACKING**
For each field found:
- INPUT: How field gets data (file/screen/calculation)
- PROCESSING: How field is transformed/used
- OUTPUT: Where field data goes
- UNUSED: Fields defined but never used

**2. BUSINESS RULES**  
- Validation logic (IF statements, conditions)
- Calculation rules (COMPUTE, ADD, etc.)
- Decision points (EVALUATE, WHEN)

**3. FIELD CATEGORIES**
List fields under each category:
- INPUT_FIELDS: [field1, field2, ...]
- DERIVED_FIELDS: [field1, field2, ...]  
- OUTPUT_FIELDS: [field1, field2, ...]
- UNUSED_FIELDS: [field1, field2, ...]

**4. PROGRAM FLOW** (if program)
- Main processing steps
- Called programs/modules
- File operations

FORMAT: Use ** headers, be specific, include field names and line references where possible.`;
};

// === API COMMUNICATION ===
EnhancedMainframeAnalyzer.prototype.callvLLMAPI = async function(prompt) {
    const response = await fetch(`${this.vllmEndpoint}/generate`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            prompt: prompt,
            max_tokens: Math.floor(this.maxTokens * 0.6),
            temperature: 0.3,
            top_p: 0.95,
            stop: ["Human:", "Assistant:"],
            stream: false
        }),
        signal: AbortSignal.timeout(60000)
    });

    if (!response.ok) {
        throw new Error(`API request failed: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();
    
    if (data.text) {
        return data.text.trim();
    } else if (data.choices && data.choices[0]) {
        return data.choices[0].text.trim();
    } else {
        throw new Error('Invalid API response format');
    }
};

EnhancedMainframeAnalyzer.prototype.calculateQualityScore = function(analysisText) {
    let score = 0;
    
    // Structure score
    const hasHeaders = analysisText.includes('**');
    score += hasHeaders ? 30 : 0;
    
    // Content depth score
    const analysisLength = analysisText.length;
    score += Math.min(analysisLength / 1000, 1) * 40;
    
    // Field categories score
    const hasFieldCategories = analysisText.includes('INPUT_FIELDS:') || 
                              analysisText.includes('DERIVED_FIELDS:');
    score += hasFieldCategories ? 30 : 0;
    
    return Math.min(Math.round(score / 10), 10);
};

EnhancedMainframeAnalyzer.prototype.assessCompleteness = function(analysisText) {
    const checkpoints = {
        'Field Flow': analysisText.includes('FIELD FLOW') || analysisText.includes('INPUT:'),
        'Business Rules': analysisText.includes('BUSINESS RULES') || analysisText.includes('VALIDATION'),
        'Field Categories': analysisText.includes('INPUT_FIELDS:') || analysisText.includes('DERIVED_FIELDS:'),
        'Program Flow': analysisText.includes('PROGRAM FLOW') || analysisText.includes('PROCESSING'),
        'Detailed Analysis': analysisText.length > 500
    };
    
    const completed = Object.values(checkpoints).filter(Boolean).length;
    const total = Object.keys(checkpoints).length;
    
    return {
        score: Math.round((completed / total) * 100),
        checkpoints: checkpoints,
        completed: completed,
        total: total
    };
};

// === DISPLAY METHODS ===
EnhancedMainframeAnalyzer.prototype.displayAnalysisResults = function(componentName, results) {
    // Update main analysis tab
    this.displayMainAnalysis(componentName, results);
    
    // Update field matrix tab
    this.displayFieldMatrix(componentName, results);
    
    // Update usage patterns tab
    this.displayUsagePatterns(componentName, results);
    
    // Switch to analysis tab
    this.switchTab({ target: { dataset: { tab: 'lifecycle' } } });
};

EnhancedMainframeAnalyzer.prototype.displayMainAnalysis = function(componentName, results) {
    const container = document.getElementById('lifecycleContent');
    
    const html = `
        <h3>🔄 Analysis Results: ${componentName}</h3>
        <p style="margin-bottom: 20px;">
            Component type: <strong>${results.componentType}</strong> • 
            Files analyzed: <strong>${results.filesAnalyzed.length}</strong> • 
            Completed: <strong>${new Date(results.timestamp).toLocaleString()}</strong>
        </p>
        
        <!-- Quality Metrics -->
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 15px; margin-bottom: 25px;">
            <div style="background: rgba(76, 175, 80, 0.1); padding: 15px; border-radius: 8px; text-align: center; border-left: 4px solid #4CAF50;">
                <div style="font-size: 1.5rem; font-weight: bold; color: #FFD700;">${results.qualityScore}/10</div>
                <div style="font-size: 11px;">Quality Score</div>
            </div>
            <div style="background: rgba(33, 150, 243, 0.1); padding: 15px; border-radius: 8px; text-align: center; border-left: 4px solid #2196F3;">
                <div style="font-size: 1.5rem; font-weight: bold; color: #FFD700;">${results.completeness.score}%</div>
                <div style="font-size: 11px;">Completeness</div>
            </div>
            <div style="background: rgba(255, 152, 0, 0.1); padding: 15px; border-radius: 8px; text-align: center; border-left: 4px solid #FF9800;">
                <div style="font-size: 1.5rem; font-weight: bold; color: #FFD700;">${results.filesAnalyzed.length}</div>
                <div style="font-size: 11px;">Files Analyzed</div>
            </div>
        </div>

        <!-- Analysis Results -->
        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px; border-left: 4px solid #FFD700;">
            <h4 style="color: #FFD700; margin-bottom: 15px;">🔍 Analysis Results</h4>
            <div style="background: rgba(0, 0, 0, 0.2); padding: 20px; border-radius: 8px; font-family: monospace; font-size: 13px; line-height: 1.6; max-height: 600px; overflow-y: auto;">
                ${this.formatAnalysisText(results.analysis)}
            </div>
        </div>
    `;
    
    container.innerHTML = html;
};

EnhancedMainframeAnalyzer.prototype.displayFieldMatrix = function(componentName, results) {
    const container = document.getElementById('fieldMatrixContent');
    const fieldInfo = this.extractFieldInformation(results.analysis);
    
    let html = `
        <h3>📋 Field Matrix: ${componentName}</h3>
        <p style="margin-bottom: 20px;">Field-level flow tracking and categorization.</p>
    `;
    
    if (fieldInfo.categories && Object.keys(fieldInfo.categories).some(cat => fieldInfo.categories[cat].length > 0)) {
        html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">';
        
        Object.keys(fieldInfo.categories).forEach(category => {
            const fields = fieldInfo.categories[category];
            if (fields.length > 0) {
                const color = this.getCategoryColor(category);
                html += `
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 15px; border-radius: 8px; border-left: 4px solid ${color};">
                        <h4 style="color: ${color}; margin-bottom: 10px;">${this.formatCategoryName(category)}</h4>
                        <div style="font-family: monospace; font-size: 12px;">
                            ${fields.map(field => `<div style="margin: 5px 0; padding: 5px; background: rgba(0,0,0,0.2); border-radius: 3px;">• ${field}</div>`).join('')}
                        </div>
                    </div>
                `;
            }
        });
        
        html += '</div>';
    } else {
        html += `
            <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px;">
                <p style="text-align: center; opacity: 0.8;">No structured field information found. Check the main analysis tab for details.</p>
            </div>
        `;
    }
    
    container.innerHTML = html;
};

EnhancedMainframeAnalyzer.prototype.displayUsagePatterns = function(componentName, results) {
    const container = document.getElementById('usageContent');
    const usageStats = this.extractUsageStatistics(results.analysis, results.componentType);
    
    let html = `
        <h3>📈 Usage Patterns: ${componentName}</h3>
        <p style="margin-bottom: 20px;">Usage pattern analysis for ${results.componentType}.</p>
    `;
    
    if (usageStats.length > 0) {
        html += `
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 25px;">
                ${usageStats.map(stat => `
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 15px; border-radius: 8px; border-left: 4px solid ${stat.color};">
                        <div style="font-size: 1.2rem; font-weight: bold; color: #FFD700; margin-bottom: 5px;">
                            ${stat.value}
                        </div>
                        <div style="font-size: 12px; opacity: 0.8;">
                            ${stat.label}
                        </div>
                        <div style="font-size: 10px; margin-top: 5px; opacity: 0.6;">
                            ${stat.description}
                        </div>
                    </div>
                `).join('')}
            </div>
        `;
    }

    html += `
        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px;">
            <h4 style="color: #FFD700; margin-bottom: 15px;">📊 Usage Patterns</h4>
            <div style="background: rgba(0, 0, 0, 0.2); padding: 20px; border-radius: 8px;">
                ${this.generateUsagePatternDisplay(results.analysis, results.componentType)}
            </div>
        </div>
    `;

    container.innerHTML = html;
};

// === UTILITY HELPER METHODS ===
EnhancedMainframeAnalyzer.prototype.formatAnalysisText = function(text) {
    return text
        .replace(/\*\*([^*]+)\*\*/g, '<strong style="color: #FFD700;">$1</strong>')
        .replace(/\n/g, '<br>')
        .replace(/^- /gm, '• ');
};

EnhancedMainframeAnalyzer.prototype.extractFieldInformation = function(analysisText) {
    const fieldInfo = { categories: {} };
    
    // Look for field categories in the analysis
    const categoryPatterns = {
        'INPUT_FIELDS': /INPUT_FIELDS:\s*\[(.*?)\]/s,
        'DERIVED_FIELDS': /DERIVED_FIELDS:\s*\[(.*?)\]/s,
        'OUTPUT_FIELDS': /OUTPUT_FIELDS:\s*\[(.*?)\]/s,
        'UNUSED_FIELDS': /UNUSED_FIELDS:\s*\[(.*?)\]/s
    };

    Object.keys(categoryPatterns).forEach(category => {
        const match = analysisText.match(categoryPatterns[category]);
        if (match) {
            const fieldsStr = match[1];
            const fields = fieldsStr.split(',')
                .map(f => f.trim().replace(/['"]/g, ''))
                .filter(f => f && f !== '...' && f !== 'none');
            fieldInfo.categories[category] = fields;
        } else {
            fieldInfo.categories[category] = [];
        }
    });

    return fieldInfo;
};

EnhancedMainframeAnalyzer.prototype.getCategoryColor = function(category) {
    const colors = {
        'INPUT_FIELDS': '#4CAF50',
        'DERIVED_FIELDS': '#2196F3',
        'OUTPUT_FIELDS': '#FF9800',
        'UNUSED_FIELDS': '#f44336'
    };
    return colors[category] || '#FFD700';
};

EnhancedMainframeAnalyzer.prototype.formatCategoryName = function(category) {
    return category.replace(/_/g, ' ').toLowerCase()
        .replace(/\b\w/g, l => l.toUpperCase());
};

EnhancedMainframeAnalyzer.prototype.extractUsageStatistics = function(analysisText, componentType) {
    const stats = [];
    
    switch (componentType) {
        case 'Copybook':
            stats.push(
                { label: 'Fields Defined', value: this.countMatches(analysisText, /\d{2}\s+[A-Z]/g), color: '#4CAF50', description: 'Total field definitions' },
                { label: 'Programs Using', value: this.countMatches(analysisText, /PROGRAM|COPY/gi), color: '#2196F3', description: 'Programs referencing' },
                { label: 'Usage Frequency', value: 'Active', color: '#FF9800', description: 'Access pattern analysis' }
            );
            break;
        case 'COBOL Program':
            stats.push(
                { label: 'Call Operations', value: this.countMatches(analysisText, /CALL/gi), color: '#4CAF50', description: 'External program calls' },
                { label: 'File Operations', value: this.countMatches(analysisText, /READ|WRITE|OPEN|CLOSE/gi), color: '#2196F3', description: 'File I/O operations' },
                { label: 'Business Rules', value: this.countMatches(analysisText, /IF|WHEN|EVALUATE/gi), color: '#FF9800', description: 'Decision points' }
            );
            break;
        case 'Field':
            stats.push(
                { label: 'Read Operations', value: this.countMatches(analysisText, /READ|MOVE.*TO/gi), color: '#4CAF50', description: 'Field access count' },
                { label: 'Write Operations', value: this.countMatches(analysisText, /MOVE.*TO|COMPUTE/gi), color: '#2196F3', description: 'Field modification count' },
                { label: 'Validation Rules', value: this.countMatches(analysisText, /VALIDATE|CHECK|IF/gi), color: '#FF9800', description: 'Data validation points' }
            );
            break;
    }
    
    return stats;
};

EnhancedMainframeAnalyzer.prototype.countMatches = function(text, regex) {
    const matches = text.match(regex);
    return matches ? matches.length : 0;
};

EnhancedMainframeAnalyzer.prototype.generateUsagePatternDisplay = function(analysisText, componentType) {
    const patterns = this.extractUsagePatterns(analysisText, componentType);
    
    if (patterns.length === 0) {
        return '<p style="text-align: center; opacity: 0.7;">Usage patterns extracted from analysis</p>';
    }
    
    return patterns.map(pattern => `
        <div style="margin-bottom: 15px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 5px; border-left: 3px solid ${pattern.color};">
            <strong style="color: ${pattern.color};">${pattern.type}:</strong> ${pattern.description}
            <div style="font-size: 11px; opacity: 0.8; margin-top: 5px;">${pattern.details}</div>
        </div>
    `).join('');
};

EnhancedMainframeAnalyzer.prototype.extractUsagePatterns = function(text, componentType) {
    const patterns = [];
    
    if (text.toLowerCase().includes('read') || text.includes('INPUT')) {
        patterns.push({
            type: 'Read Pattern',
            color: '#4CAF50',
            description: 'Data access and retrieval operations',
            details: 'Input operations detected in analysis'
        });
    }
    
    if (text.toLowerCase().includes('write') || text.includes('MOVE') || text.includes('OUTPUT')) {
        patterns.push({
            type: 'Write Pattern',
            color: '#2196F3',
            description: 'Data modification and update operations',
            details: 'Output operations detected in analysis'
        });
    }
    
    if (text.includes('CALL') || text.toLowerCase().includes('program')) {
        patterns.push({
            type: 'Integration Pattern',
            color: '#FF9800',
            description: 'External program and system integration',
            details: 'Cross-component integration detected'
        });
    }
    
    if (text.includes('UNUSED') || text.includes('unused')) {
        patterns.push({
            type: 'Unused Elements',
            color: '#f44336',
            description: 'Unused fields or components identified',
            details: 'Cleanup opportunities detected'
        });
    }
    
    return patterns;
};

// === BULK ANALYSIS ===
EnhancedMainframeAnalyzer.prototype.bulkAnalyze = async function() {
    if (this.uploadedFiles.length === 0) {
        this.showError('No files uploaded for bulk analysis');
        return;
    }

    this.showLoading();
    this.updateLoadingStatus('🔄 Starting bulk analysis...');

    const components = this.componentSuggestions.slice(0, 5); // Limit to 5 components
    let completed = 0;

    try {
        for (const component of components) {
            this.updateLoadingStatus(`Analyzing ${component.name} (${completed + 1}/${components.length})...`);
            this.updateProgress((completed / components.length) * 100);
            
            try {
                const results = await this.runFocusedAnalysis(component.name);
                this.analysisResults[component.name] = results;
                completed++;
                
                await this.sleep(2000); // Brief pause between analyses
            } catch (error) {
                console.warn(`Failed to analyze ${component.name}:`, error);
            }
        }

        this.hideLoading();
        this.saveToStorage();
        this.showSuccess(`✨ Bulk analysis complete! ${completed}/${components.length} components analyzed`);

    } catch (error) {
        this.hideLoading();
        this.showError(`Bulk analysis failed: ${error.message}`);
    }
};

// === EXPORT FUNCTIONALITY ===
EnhancedMainframeAnalyzer.prototype.exportResults = function() {
    if (Object.keys(this.analysisResults).length === 0) {
        this.showError('No analysis results to export');
        return;
    }

    try {
        const exportData = {
            timestamp: new Date().toISOString(),
            totalComponents: Object.keys(this.analysisResults).length,
            totalFiles: this.uploadedFiles.length,
            analysisResults: this.analysisResults,
            fileInfo: this.uploadedFiles.map(f => ({
                name: f.name,
                type: f.type,
                size: f.size,
                uploadDate: f.uploadDate
            })),
            systemInfo: {
                vllmEndpoint: this.vllmEndpoint,
                maxTokens: this.maxTokens,
                version: '2.0.0-focused'
            }
        };

        const dataStr = JSON.stringify(exportData, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        
        const link = document.createElement('a');
        link.href = URL.createObjectURL(dataBlob);
        link.download = `mainframe-analysis-${new Date().toISOString().split('T')[0]}.json`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        this.showSuccess('📤 Analysis results exported successfully!');
        
    } catch (error) {
        this.showError(`Export failed: ${error.message}`);
    }
};

// === ENHANCED CHAT FUNCTIONALITY ===
EnhancedMainframeAnalyzer.prototype.initializeChat = function() {
    // Update chat panel HTML
    const chatPanel = document.querySelector('.chat-panel');
    chatPanel.innerHTML = `
        <div style="background: rgba(76, 175, 80, 0.2); border-radius: 10px; padding: 15px; margin-bottom: 15px; border-left: 4px solid #4CAF50;">
            <h3 style="margin-bottom: 8px; color: #FFD700;">💬 Analysis Chat</h3>
            <p style="font-size: 12px; opacity: 0.8;">Ask detailed questions about your analysis</p>
        </div>

        <div style="margin-bottom: 15px;">
            <div style="font-size: 11px; margin-bottom: 8px; opacity: 0.7;">Quick questions:</div>
            <button class="chat-suggestion-btn" data-question="What fields are unused in this component?">Unused fields?</button>
            <button class="chat-suggestion-btn" data-question="Show me the complete field flow">Field flow?</button>
            <button class="chat-suggestion-btn" data-question="What business rules are implemented?">Business rules?</button>
            <button class="chat-suggestion-btn" data-question="Which fields come from input files?">Input fields?</button>
        </div>

        <div id="chatMessages" style="flex: 1; overflow-y: auto; margin-bottom: 15px; max-height: 400px; padding-right: 10px;">
            <div style="margin-bottom: 15px; padding: 12px; border-radius: 10px; max-width: 85%; background: rgba(76, 175, 80, 0.3); border-left: 4px solid #4CAF50;">
                <div style="font-weight: bold; font-size: 12px; opacity: 0.8; margin-bottom: 5px;">Analysis Assistant</div>
                <div style="font-size: 14px; line-height: 1.5;">
                    👋 Welcome! I can help analyze your mainframe components.
                    <br><br>
                    Once you analyze a component, I can answer questions about:
                    <br>• Field flows and transformations
                    <br>• Business rules and validations
                    <br>• Unused or static fields
                    <br>• Input/output patterns
                    <br><br>
                    Upload files and analyze a component to get started!
                </div>
            </div>
        </div>

        <div style="display: flex; gap: 10px; align-items: flex-start;">
            <textarea 
                id="chatInput" 
                style="flex: 1; padding: 12px; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 8px; background: rgba(255, 255, 255, 0.1); color: white; font-size: 14px; resize: vertical; min-height: 40px; max-height: 100px; font-family: inherit;"
                placeholder="Ask about field flows, business rules, unused fields..."
                disabled
                rows="2"
            ></textarea>
            <button id="chatSendBtn" style="background: linear-gradient(45deg, #4CAF50, #45a049); color: white; border: none; padding: 12px 16px; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 600; transition: all 0.3s ease; white-space: nowrap; min-width: 80px;" disabled>
                Send
            </button>
        </div>

        <div style="font-size: 10px; opacity: 0.6; margin-top: 8px; text-align: center;">
            Chat enabled after component analysis
        </div>
    `;

    // Add chat styles
    const chatStyles = document.createElement('style');
    chatStyles.textContent = `
        .chat-suggestion-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 6px 10px;
            border-radius: 15px;
            font-size: 11px;
            cursor: pointer;
            margin: 3px;
            transition: all 0.3s ease;
            display: inline-block;
        }

        .chat-suggestion-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        #chatMessages::-webkit-scrollbar {
            width: 6px;
        }

        #chatMessages::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        #chatMessages::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }

        #chatInput:focus {
            outline: none;
            border-color: #FFD700;
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.3);
        }

        #chatInput::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        #chatSendBtn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
        }

        #chatSendBtn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
    `;
    document.head.appendChild(chatStyles);

    // Initialize chat event listeners
    this.initializeChatEventListeners();
};

EnhancedMainframeAnalyzer.prototype.initializeChatEventListeners = function() {
    const chatSendBtn = document.getElementById('chatSendBtn');
    const chatInput = document.getElementById('chatInput');
    
    if (chatSendBtn && chatInput) {
        chatSendBtn.addEventListener('click', () => {
            console.log('Chat send button clicked');
            this.sendChatMessage();
        });
        
        chatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                console.log('Enter pressed in chat');
                this.sendChatMessage();
            }
        });
    }

    // Chat suggestions
    document.querySelectorAll('.chat-suggestion-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const question = e.target.dataset.question;
            console.log('Suggestion clicked:', question);
            if (chatInput) {
                chatInput.value = question;
                this.sendChatMessage();
            }
        });
    });
};

EnhancedMainframeAnalyzer.prototype.sendChatMessage = async function() {
    const input = document.getElementById('chatInput');
    const sendBtn = document.getElementById('chatSendBtn');
    const message = input.value.trim();
    
    console.log('Send chat message called:', message);
    
    if (!message) {
        this.showError('Please enter a message');
        return;
    }
    
    if (!this.currentAnalyzedComponent) {
        this.showError('Please analyze a component first');
        return;
    }
    
    input.disabled = true;
    sendBtn.disabled = true;
    sendBtn.textContent = 'Processing...';
    
    this.addChatMessage('user', message);
    input.value = '';
    
    this.showChatTyping();
    
    try {
        console.log('Processing chat query...');
        const response = await this.processChatQuery(message);
        console.log('Got response:', response);
        
        this.hideChatTyping();
        this.addChatMessage('assistant', response);
        
    } catch (error) {
        console.error('Chat error:', error);
        this.hideChatTyping();
        this.addChatMessage('assistant', `I apologize, but I encountered an error: ${error.message}. Please try rephrasing your question.`);
    } finally {
        input.disabled = false;
        sendBtn.disabled = false;
        sendBtn.textContent = 'Send';
        input.focus();
    }
};

EnhancedMainframeAnalyzer.prototype.processChatQuery = async function(question) {
    const analysisData = this.analysisResults[this.currentAnalyzedComponent];
    
    // OPTIMIZED CHAT PROMPT
    const chatPrompt = `ANALYSIS CHAT: ${this.currentAnalyzedComponent}

QUESTION: "${question}"

ANALYSIS RESULTS:
${analysisData.analysis}

INSTRUCTIONS:
Answer the user's question based on the analysis results above. Be specific and reference exact field names, programs, or line numbers when available. If the information isn't in the analysis, say so clearly.

Focus on:
- Field flows and transformations
- Business rules and validations
- Unused or static fields  
- Input/output patterns

Keep responses practical and use examples from the actual analysis.`;

    return await this.callvLLMAPI(chatPrompt);
};

EnhancedMainframeAnalyzer.prototype.addChatMessage = function(sender, content) {
    const messagesContainer = document.getElementById('chatMessages');
    if (!messagesContainer) {
        console.error('Chat messages container not found');
        return;
    }
    
    const messageDiv = document.createElement('div');
    messageDiv.style.cssText = `
        margin-bottom: 15px; 
        padding: 12px; 
        border-radius: 10px; 
        max-width: 85%; 
        word-wrap: break-word; 
        line-height: 1.5;
        animation: fadeInUp 0.3s ease;
        ${sender === 'user' ? 
            'background: rgba(33, 150, 243, 0.3); border-left: 4px solid #2196F3; margin-left: auto; text-align: right;' : 
            'background: rgba(76, 175, 80, 0.3); border-left: 4px solid #4CAF50;'
        }
    `;
    
    messageDiv.innerHTML = `
        <div style="font-weight: bold; font-size: 12px; opacity: 0.8; margin-bottom: 5px;">
            ${sender === 'user' ? 'You' : 'Analysis Assistant'}
        </div>
        <div style="font-size: 14px; line-height: 1.5;">
            ${this.formatChatMessage(content)}
        </div>
    `;
    
    messagesContainer.appendChild(messageDiv);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
};

EnhancedMainframeAnalyzer.prototype.formatChatMessage = function(content) {
    return content
        .replace(/\n/g, '<br>')
        .replace(/\*\*([^*]+)\*\*/g, '<strong style="color: #FFD700;">$1</strong>')
        .replace(/`([^`]+)`/g, '<code style="background: rgba(0,0,0,0.3); padding: 2px 4px; border-radius: 3px; color: #4CAF50;">$1</code>')
        .replace(/^- /gm, '• ');
};

EnhancedMainframeAnalyzer.prototype.showChatTyping = function() {
    const messagesContainer = document.getElementById('chatMessages');
    if (!messagesContainer) return;
    
    this.hideChatTyping();
    
    const typingDiv = document.createElement('div');
    typingDiv.id = 'typingIndicator';
    typingDiv.style.cssText = `
        margin-bottom: 15px; 
        padding: 12px; 
        border-radius: 10px; 
        max-width: 85%; 
        background: rgba(76, 175, 80, 0.3); 
        border-left: 4px solid #4CAF50;
    `;
    
    typingDiv.innerHTML = `
        <div style="font-weight: bold; font-size: 12px; opacity: 0.8; margin-bottom: 5px;">Analysis Assistant</div>
        <div style="font-size: 14px; line-height: 1.5;">
            <span style="opacity: 0.7;">Analyzing your question...</span>
            <span style="animation: blink 1s infinite; margin-left: 5px;">●●●</span>
        </div>
    `;
    
    messagesContainer.appendChild(typingDiv);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
};

EnhancedMainframeAnalyzer.prototype.hideChatTyping = function() {
    const typingIndicator = document.getElementById('typingIndicator');
    if (typingIndicator && typingIndicator.parentNode) {
        typingIndicator.parentNode.removeChild(typingIndicator);
    }
};

EnhancedMainframeAnalyzer.prototype.enableChat = function() {
    const chatInput = document.getElementById('chatInput');
    const chatSendBtn = document.getElementById('chatSendBtn');
    
    if (chatInput && chatSendBtn) {
        chatInput.disabled = false;
        chatSendBtn.disabled = false;
        
        this.addChatMessage('assistant', 
            `🎯 **Analysis complete for ${this.currentAnalyzedComponent}!**
            
I can now answer detailed questions about:
• Field flows and transformations
• Business rules and validation logic  
• Unused or static fields
• Input/output patterns
• Program logic and structure

**Try asking:**
• "What fields are unused?"
• "Show me the field flow"
• "What business rules are implemented?"
• "Which fields come from input files?"`
        );
    }
};

// Initialize chat when document is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function() {
        if (typeof analyzer !== 'undefined') {
            analyzer.initializeChat();
        }
    });
} else {
    // Document already loaded
    if (typeof analyzer !== 'undefined') {
        analyzer.initializeChat();
    }
}

// Add CSS animation for chat messages
const chatAnimationStyle = document.createElement('style');
chatAnimationStyle.textContent = `
    @keyframes fadeInUp {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
    }
    
    @keyframes blink {
        0%, 50% { opacity: 1; }
        51%, 100% { opacity: 0; }
    }
`;
document.head.appendChild(chatAnimationStyle);

console.log('🚀 Enhanced Mainframe Analyzer - Part 2 Ready!');
console.log('✅ Features active: Analysis engine, chat functionality, field matrix, usage patterns');
console.log('⏳ Coming in Part 3: Enhanced dependency mapping with chunking');

// Part 3: Enhanced Dependency Mapping with Chunking
// This extends the analyzer from Parts 1 & 2

// === ENHANCED DEPENDENCY ANALYSIS ===
EnhancedMainframeAnalyzer.prototype.initializeDependencyAnalysis = function() {
    // Update dependencies tab content
    const dependenciesContent = document.getElementById('dependenciesContent');
    dependenciesContent.innerHTML = `
        <h3>🔗 Enhanced Dependency Analysis</h3>
        <p style="margin-bottom: 20px;">Complete dependency mapping with intelligent chunking and availability checking.</p>
        
        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px; text-align: center;">
            <button class="action-btn secondary-btn" id="checkDependenciesBtn" style="width: auto; padding: 12px 24px; margin: 0 auto; display: block;">
                🔍 Analyze Dependencies with Chunking
            </button>
            <p style="font-size: 12px; margin-top: 15px; opacity: 0.8;">
                Uses intelligent chunking to scan all uploaded files for comprehensive dependency mapping
            </p>
        </div>
    `;
    
    // Add event listener for dependency analysis
    const checkBtn = document.getElementById('checkDependenciesBtn');
    if (checkBtn) {
        checkBtn.addEventListener('click', async () => {
            if (!this.currentAnalyzedComponent) {
                this.showError('Please analyze a component first');
                return;
            }
            
            try {
                checkBtn.disabled = true;
                checkBtn.textContent = '⏳ Analyzing Dependencies...';
                
                const dependencyReport = await this.performEnhancedDependencyAnalysis(this.currentAnalyzedComponent);
                
                // Store the results
                if (!this.analysisResults[this.currentAnalyzedComponent]) {
                    this.analysisResults[this.currentAnalyzedComponent] = {};
                }
                this.analysisResults[this.currentAnalyzedComponent].dependencyReport = dependencyReport;
                
                this.displayDependencyResults(dependenciesContent, this.currentAnalyzedComponent, dependencyReport);
                this.saveToStorage();
                
            } catch (error) {
                console.error('Dependency analysis failed:', error);
                checkBtn.disabled = false;
                checkBtn.textContent = '🔍 Analyze Dependencies with Chunking';
                this.showError(`Dependency analysis failed: ${error.message}`);
            }
        });
    }
};

EnhancedMainframeAnalyzer.prototype.performEnhancedDependencyAnalysis = async function(componentName) {
    this.showLoading();
    this.updateLoadingStatus('🔍 Starting enhanced dependency analysis with chunking...');
    
    try {
        // Stage 1: Create dependency-optimized chunks
        this.updateLoadingStatus('📊 Stage 1: Creating dependency-aware chunks...');
        this.updateProgress(20);
        
        const dependencyChunks = this.createDependencyScanChunks();
        
        // Stage 2: Scan all chunks for dependencies
        this.updateLoadingStatus('🔄 Stage 2: Scanning chunks for dependencies...');
        this.updateProgress(40);
        
        const allDependencies = await this.scanAllDependenciesWithChunking(dependencyChunks);
        
        // Stage 3: Analyze component-specific dependencies
        this.updateLoadingStatus('🎯 Stage 3: Analyzing component-specific dependencies...');
        this.updateProgress(70);
        
        const componentDeps = await this.analyzeComponentSpecificDependencies(componentName, allDependencies);
        
        // Stage 4: Generate comprehensive report
        this.updateLoadingStatus('📋 Stage 4: Generating dependency report...');
        this.updateProgress(90);
        
        const dependencyReport = this.generateEnhancedDependencyReport(componentName, componentDeps);
        
        this.updateProgress(100);
        this.hideLoading();
        this.showSuccess(`✅ Enhanced dependency analysis complete for ${componentName}!`);
        
        return dependencyReport;
        
    } catch (error) {
        this.hideLoading();
        this.showError(`Enhanced dependency analysis failed: ${error.message}`);
        throw error;
    }
};

EnhancedMainframeAnalyzer.prototype.createDependencyScanChunks = function() {
    const chunks = [];
    const targetTokensPerChunk = Math.floor(this.maxTokens * 0.2); // Very conservative - 20% max
    
    console.log(`Creating aggressive dependency chunks with target ${targetTokensPerChunk} tokens each`);
    
    // Prioritize files by type and size
    const cobolPrograms = this.uploadedFiles.filter(f => f.type === 'COBOL Program').sort((a, b) => a.size - b.size);
    const copybooks = this.uploadedFiles.filter(f => f.type === 'Copybook').sort((a, b) => a.size - b.size);
    const jclFiles = this.uploadedFiles.filter(f => f.type.includes('JCL')).sort((a, b) => a.size - b.size);
    const otherFiles = this.uploadedFiles.filter(f => 
        !cobolPrograms.includes(f) && !copybooks.includes(f) && !jclFiles.includes(f)).sort((a, b) => a.size - b.size);
    
    // Process files in priority order with aggressive chunking
    this.createAggressiveDependencyChunks([...copybooks, ...cobolPrograms, ...jclFiles, ...otherFiles], 
        targetTokensPerChunk, chunks);
    
    console.log(`Created ${chunks.length} aggressive dependency chunks`);
    return chunks;
};

EnhancedMainframeAnalyzer.prototype.createAggressiveDependencyChunks = function(files, targetTokens, chunks) {
    let currentChunk = [];
    let currentTokens = 0;
    let overlapContent = '';
    
    files.forEach(file => {
        const fileTokens = this.estimateTokenCount(file.content);
        
        // If file is too large, split it aggressively
        if (fileTokens > targetTokens) {
            console.log(`Large file ${file.name} (${fileTokens} tokens) - splitting for dependencies`);
            
            // Save current chunk first
            if (currentChunk.length > 0) {
                chunks.push({
                    files: [...currentChunk],
                    totalTokens: currentTokens,
                    overlapContext: overlapContent,
                    chunkIndex: chunks.length,
                    scanType: 'dependency'
                });
                currentChunk = [];
                currentTokens = 0;
            }
            
            // Extract only dependency-relevant content
            const dependencyContent = this.extractDependencyRelevantContent(file, targetTokens);
            if (dependencyContent.length > 0) {
                chunks.push({
                    files: [{
                        ...file,
                        content: dependencyContent,
                        name: `${file.name}-deps-extract`
                    }],
                    totalTokens: this.estimateTokenCount(dependencyContent),
                    overlapContext: '',
                    chunkIndex: chunks.length,
                    scanType: 'dependency'
                });
            }
            
            overlapContent = '';
        }
        // If adding file would exceed limit, start new chunk
        else if (currentTokens + fileTokens > targetTokens && currentChunk.length > 0) {
            chunks.push({
                files: [...currentChunk],
                totalTokens: currentTokens,
                overlapContext: overlapContent,
                chunkIndex: chunks.length,
                scanType: 'dependency'
            });
            
            overlapContent = this.createDependencyOverlap(currentChunk);
            const overlapTokens = this.estimateTokenCount(overlapContent);
            
            currentChunk = [file];
            currentTokens = fileTokens + overlapTokens;
        }
        // Add to current chunk
        else {
            currentChunk.push(file);
            currentTokens += fileTokens;
        }
    });
    
    // Add final chunk
    if (currentChunk.length > 0) {
        chunks.push({
            files: currentChunk,
            totalTokens: currentTokens,
            overlapContext: overlapContent,
            chunkIndex: chunks.length,
            scanType: 'dependency'
        });
    }
};

EnhancedMainframeAnalyzer.prototype.createDependencyAwareChunks = function(files, targetTokens, chunks) {
    let currentChunk = [];
    let currentTokens = 0;
    let overlapContent = '';
    
    files.forEach(file => {
        const fileTokens = this.estimateTokenCount(file.content);
        
        if (currentTokens + fileTokens > targetTokens && currentChunk.length > 0) {
            chunks.push({
                files: [...currentChunk],
                totalTokens: currentTokens,
                overlapContext: overlapContent,
                chunkIndex: chunks.length,
                scanType: 'dependency'
            });
            
            overlapContent = this.createDependencyOverlap(currentChunk);
            currentChunk = [];
            currentTokens = this.estimateTokenCount(overlapContent);
        }
        
        currentChunk.push(file);
        currentTokens += fileTokens;
    });
    
    if (currentChunk.length > 0) {
        chunks.push({
            files: currentChunk,
            totalTokens: currentTokens,
            overlapContext: overlapContent,
            chunkIndex: chunks.length,
            scanType: 'dependency'
        });
    }
};

EnhancedMainframeAnalyzer.prototype.createDependencyOverlap = function(files) {
    let overlapContent = '';
    
    files.forEach(file => {
        const lines = file.content.split('\n');
        
        // Extract dependency-relevant lines for overlap
        const dependencyLines = lines.filter(line => {
            const upper = line.toUpperCase().trim();
            return upper.includes('COPY ') ||
                   upper.includes('CALL ') ||
                   upper.includes('EXEC ') ||
                   upper.includes('//') ||
                   upper.includes('DSN=') ||
                   upper.includes('DD ') ||
                   upper.includes('EXEC SQL') ||
                   upper.includes('TABLE ') ||
                   upper.includes('FROM ') ||
                   upper.includes('INTO ') ||
                   upper.includes('SELECT ') ||
                   upper.includes('FD ') ||
                   upper.includes('ASSIGN');
        });
        
        if (dependencyLines.length > 0) {
            overlapContent += `\n=== DEPENDENCY CONTEXT from ${file.name} ===\n`;
            overlapContent += dependencyLines.slice(0, 20).join('\n');
        }
    });
    
    return overlapContent;
};

EnhancedMainframeAnalyzer.prototype.scanAllDependenciesWithChunking = async function(dependencyChunks) {
    let allDependencies = {
        copybooks: new Set(),
        calledPrograms: new Set(),
        callingPrograms: new Set(),
        jclDatasets: new Set(),
        dbTables: new Set(),
        fileReferences: new Set()
    };
    
    for (let i = 0; i < dependencyChunks.length; i++) {
        this.updateLoadingStatus(`Processing dependency chunk ${i + 1}/${dependencyChunks.length}...`);
        
        const chunkDeps = await this.extractDependenciesFromChunk(dependencyChunks[i]);
        
        // Merge dependencies from this chunk
        Object.keys(chunkDeps).forEach(depType => {
            if (chunkDeps[depType] && Array.isArray(chunkDeps[depType])) {
                chunkDeps[depType].forEach(dep => allDependencies[depType].add(dep));
            }
        });
        
        if (i < dependencyChunks.length - 1) {
            await this.sleep(800); // Brief pause between chunks
        }
    }
    
    // Convert Sets back to Arrays
    Object.keys(allDependencies).forEach(key => {
        allDependencies[key] = Array.from(allDependencies[key]);
    });
    
    console.log('Dependencies found:', allDependencies);
    return allDependencies;
};


EnhancedMainframeAnalyzer.prototype.parseDependencyResponse = function(response) {
    const dependencies = {
        copybooks: [],
        calledPrograms: [],
        callingPrograms: [],
        jclDatasets: [],
        dbTables: [],
        fileReferences: []
    };

    const lines = response.split('\n');
    lines.forEach(line => {
        const trimmed = line.trim();
        
        if (trimmed.startsWith('COPYBOOKS:')) {
            dependencies.copybooks = this.parseCommaSeparatedList(trimmed.split(':')[1]);
        } else if (trimmed.startsWith('CALLED_PROGRAMS:')) {
            dependencies.calledPrograms = this.parseCommaSeparatedList(trimmed.split(':')[1]);
        } else if (trimmed.startsWith('CALLING_PROGRAMS:')) {
            dependencies.callingPrograms = this.parseCommaSeparatedList(trimmed.split(':')[1]);
        } else if (trimmed.startsWith('JCL_DATASETS:')) {
            dependencies.jclDatasets = this.parseCommaSeparatedList(trimmed.split(':')[1]);
        } else if (trimmed.startsWith('DB_TABLES:')) {
            dependencies.dbTables = this.parseCommaSeparatedList(trimmed.split(':')[1]);
        } else if (trimmed.startsWith('FILE_REFERENCES:')) {
            dependencies.fileReferences = this.parseCommaSeparatedList(trimmed.split(':')[1]);
        }
    });

    return dependencies;
};

EnhancedMainframeAnalyzer.prototype.parseCommaSeparatedList = function(str) {
    if (!str) return [];
    return str.split(',')
        .map(item => item.trim())
        .filter(item => item && item.length > 0 && !item.toLowerCase().includes('none') && !item.toLowerCase().includes('n/a'))
        .map(item => item.replace(/['"`]/g, ''))
        .slice(0, 20); // Limit to reasonable number
};

EnhancedMainframeAnalyzer.prototype.analyzeComponentSpecificDependencies = async function(componentName, allDependencies) {
    this.updateLoadingStatus('🔍 Analyzing specific dependencies for ' + componentName + '...');
    
    // OPTIMIZED COMPONENT-SPECIFIC DEPENDENCY PROMPT
    const prompt = `COMPONENT DEPENDENCY ANALYSIS: ${componentName}

ALL DISCOVERED DEPENDENCIES:
Copybooks: ${allDependencies.copybooks.slice(0, 15).join(', ')}
Called Programs: ${allDependencies.calledPrograms.slice(0, 15).join(', ')}
Calling Programs: ${allDependencies.callingPrograms.slice(0, 15).join(', ')}
JCL Datasets: ${allDependencies.jclDatasets.slice(0, 15).join(', ')}
DB Tables: ${allDependencies.dbTables.slice(0, 15).join(', ')}
File References: ${allDependencies.fileReferences.slice(0, 15).join(', ')}

UPLOADED FILES:
${this.uploadedFiles.map(f => f.name + ' (' + f.type + ')').join(', ')}

ANALYZE:
1. Which dependencies are directly related to ${componentName}?
2. Which dependencies are present vs missing in uploaded files?
3. What is the risk level for each missing dependency?

Provide focused analysis for ${componentName} dependencies.`;

    const response = await this.callvLLMAPI(prompt);
    return this.parseComponentDependencyResponse(response, allDependencies);
};

EnhancedMainframeAnalyzer.prototype.parseComponentDependencyResponse = function(response, allDependencies) {
    // Enhanced parsing with actual dependency data and availability checking
    const presentDependencies = Object.values(allDependencies).flat().filter(dep => 
        this.uploadedFiles.some(f => 
            f.content.toUpperCase().includes(dep.toUpperCase()) || 
            f.name.toUpperCase().includes(dep.toUpperCase())
        )
    );
    
    return {
        directDependencies: {
            copybooks: allDependencies.copybooks.slice(0, 10),
            programs: allDependencies.calledPrograms.slice(0, 10),
            files: allDependencies.fileReferences.slice(0, 10),
            tables: allDependencies.dbTables.slice(0, 10)
        },
        reverseDependencies: {
            calledByPrograms: allDependencies.callingPrograms.slice(0, 10),
            usedInJCL: allDependencies.jclDatasets.slice(0, 10)
        },
        availabilityAnalysis: {
            present: presentDependencies,
            missing: Object.values(allDependencies).flat().filter(dep => !presentDependencies.includes(dep))
        },
        summary: {
            totalDependencies: Object.values(allDependencies).flat().length,
            presentDependencies: presentDependencies.length,
            missingDependencies: Object.values(allDependencies).flat().length - presentDependencies.length,
            completenessPercentage: Math.round((presentDependencies.length / Math.max(Object.values(allDependencies).flat().length, 1)) * 100)
        }
    };
};


EnhancedMainframeAnalyzer.prototype.generateDependencyRecommendations = function(componentDeps) {
    const recommendations = [];
    
    if (componentDeps.summary.missingDependencies > 0) {
        recommendations.push({
            priority: 'HIGH',
            category: 'Missing Dependencies',
            description: `${componentDeps.summary.missingDependencies} dependencies not found in uploaded files`,
            action: 'Upload missing copybooks, programs, or JCL files for complete analysis'
        });
    }
    
    if (componentDeps.summary.completenessPercentage < 70) {
        recommendations.push({
            priority: 'MEDIUM',
            category: 'Incomplete Analysis',
            description: `Only ${componentDeps.summary.completenessPercentage}% of dependencies are available`,
            action: 'Consider uploading additional related files'
        });
    }
    
    if (componentDeps.directDependencies.copybooks.length > 10) {
        recommendations.push({
            priority: 'LOW',
            category: 'High Coupling',
            description: 'Component has many copybook dependencies',
            action: 'Review for potential refactoring opportunities'
        });
    }
    
    return recommendations;
};


EnhancedMainframeAnalyzer.prototype.getPriorityColor = function(priority) {
    const colors = {
        'HIGH': '#f44336',
        'MEDIUM': '#FF9800',
        'LOW': '#4CAF50'
    };
    return colors[priority] || '#FFD700';
};

EnhancedMainframeAnalyzer.prototype.getPriorityIcon = function(priority) {
    const icons = {
        'HIGH': '🚨',
        'MEDIUM': '⚠️',
        'LOW': '💡'
    };
    return icons[priority] || '📌';
};

// Initialize dependency analysis when document is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function() {
        if (typeof analyzer !== 'undefined') {
            analyzer.initializeDependencyAnalysis();
        }
    });
} else {
    // Document already loaded
    if (typeof analyzer !== 'undefined') {
        analyzer.initializeDependencyAnalysis();
    }
}

EnhancedMainframeAnalyzer.prototype.extractDependencyRelevantContent = function(file, maxTokens) {
    const lines = file.content.split('\n');
    const dependencyLines = [];
    
    lines.forEach((line, index) => {
        const upper = line.toUpperCase().trim();
        
        // Only include lines that contain dependency information
        if (upper.includes('COPY ') ||
            upper.includes('CALL ') ||
            upper.includes('EXEC ') ||
            upper.includes('//') ||
            upper.includes('DSN=') ||
            upper.includes('DD ') ||
            upper.includes('EXEC SQL') ||
            upper.includes('TABLE ') ||
            upper.includes('FROM ') ||
            upper.includes('INTO ') ||
            upper.includes('SELECT ') ||
            upper.includes('FD ') ||
            upper.includes('ASSIGN') ||
            upper.includes('PROGRAM-ID')) {
            
            // Include some context around dependency lines
            const contextStart = Math.max(0, index - 1);
            const contextEnd = Math.min(lines.length, index + 2);
            
            for (let i = contextStart; i <= contextEnd; i++) {
                if (i < lines.length && !dependencyLines.includes(lines[i])) {
                    dependencyLines.push(lines[i]);
                }
            }
        }
    });
    
    // Limit to token budget
    const targetChars = maxTokens * 3;
    let result = dependencyLines.join('\n');
    
    if (result.length > targetChars) {
        result = result.substring(0, targetChars) + '\n... [TRUNCATED FOR DEPENDENCY ANALYSIS]';
    }
    
    console.log(`Extracted ${dependencyLines.length} dependency-relevant lines from ${file.name}`);
    return result;
};

console.log('🔧 Aggressive Chunking Fix Applied!');
console.log('✅ Changes made:');
console.log('   • More conservative token estimation (3 chars/token vs 4)');
console.log('   • Reduced token budget to 30% for analysis, 25% for chunks, 20% for dependencies');
console.log('   • Aggressive file truncation with strict prioritization');
console.log('   • Large file splitting with related line grouping');
console.log('   • Dependency-specific content extraction');
console.log('   • Maximum chunk size enforcement');
console.log('⚠️  This will significantly reduce content but keep chunks under token limits');

console.log('🚀 Enhanced Mainframe Analyzer - Part 3 Ready!');
console.log('✅ Features active: Enhanced dependency mapping with intelligent chunking');
console.log('🎯 Complete system now includes:');
console.log('   • File upload and management');
console.log('   • Component suggestions and validation');
console.log('   • Token-aware analysis with optimization');
console.log('   • Focused field flow and business rule analysis');
console.log('   • Interactive chat functionality');
console.log('   • Field matrix and usage patterns');
console.log('   • Enhanced dependency mapping with chunking');
console.log('   • Export and storage capabilities');
console.log('   • Bulk analysis support');

EnhancedMainframeAnalyzer.prototype.generateEnhancedDependencyReport = function(componentName, componentDeps) {
    // Categorize each dependency type by availability
    const categorizedDependencies = this.categorizeDependenciesByAvailability(componentDeps);
    
    return {
        componentName: componentName,
        timestamp: new Date().toISOString(),
        analysisMethod: 'Enhanced Chunking',
        dependencies: {
            copybooks: componentDeps.directDependencies.copybooks,
            calledPrograms: componentDeps.directDependencies.programs,
            callingPrograms: componentDeps.reverseDependencies.calledByPrograms,
            jclDatasets: componentDeps.reverseDependencies.usedInJCL,
            fileReferences: componentDeps.directDependencies.files,
            dbTables: componentDeps.directDependencies.tables
        },
        categorizedDependencies: categorizedDependencies,
        summary: componentDeps.summary,
        availabilityAnalysis: componentDeps.availabilityAnalysis,
        recommendations: this.generateDetailedDependencyRecommendations(categorizedDependencies)
    };
};

// Categorize dependencies by availability for each type
EnhancedMainframeAnalyzer.prototype.categorizeDependenciesByAvailability = function(componentDeps) {
    const categorized = {
        copybooks: { present: [], missing: [] },
        calledPrograms: { present: [], missing: [] },
        callingPrograms: { present: [], missing: [] },
        jclDatasets: { present: [], missing: [] },
        fileReferences: { present: [], missing: [] },
        dbTables: { present: [], missing: [] }
    };
    
    // Check copybooks
    componentDeps.directDependencies.copybooks.forEach(copybook => {
        if (this.isDependencyPresent(copybook)) {
            categorized.copybooks.present.push(copybook);
        } else {
            categorized.copybooks.missing.push(copybook);
        }
    });
    
    // Check called programs
    componentDeps.directDependencies.programs.forEach(program => {
        if (this.isDependencyPresent(program)) {
            categorized.calledPrograms.present.push(program);
        } else {
            categorized.calledPrograms.missing.push(program);
        }
    });
    
    // Check calling programs
    componentDeps.reverseDependencies.calledByPrograms.forEach(program => {
        if (this.isDependencyPresent(program)) {
            categorized.callingPrograms.present.push(program);
        } else {
            categorized.callingPrograms.missing.push(program);
        }
    });
    
    // Check JCL datasets
    componentDeps.reverseDependencies.usedInJCL.forEach(dataset => {
        if (this.isDependencyPresent(dataset)) {
            categorized.jclDatasets.present.push(dataset);
        } else {
            categorized.jclDatasets.missing.push(dataset);
        }
    });
    
    // Check file references
    componentDeps.directDependencies.files.forEach(file => {
        if (this.isDependencyPresent(file)) {
            categorized.fileReferences.present.push(file);
        } else {
            categorized.fileReferences.missing.push(file);
        }
    });
    
    // Check database tables
    componentDeps.directDependencies.tables.forEach(table => {
        if (this.isDependencyPresent(table)) {
            categorized.dbTables.present.push(table);
        } else {
            categorized.dbTables.missing.push(table);
        }
    });
    
    return categorized;
};

// Enhanced dependency presence check
EnhancedMainframeAnalyzer.prototype.isDependencyPresent = function(dependency) {
    const upperDep = dependency.toUpperCase();
    
    return this.uploadedFiles.some(file => {
        const upperContent = file.content.toUpperCase();
        const upperFileName = file.name.toUpperCase();
        
        // Check if dependency name appears in file content or filename
        return upperContent.includes(upperDep) || 
               upperFileName.includes(upperDep) ||
               // Additional specific patterns for better matching
               upperFileName.replace(/\.[^.]*$/, '').includes(upperDep) || // Filename without extension
               upperContent.includes(`COPY ${upperDep}`) ||
               upperContent.includes(`CALL ${upperDep}`) ||
               upperContent.includes(`EXEC ${upperDep}`) ||
               upperContent.includes(`DSN=${upperDep}`) ||
               upperContent.includes(`PROGRAM-ID. ${upperDep}`);
    });
};

// Generate detailed recommendations based on missing items
EnhancedMainframeAnalyzer.prototype.generateDetailedDependencyRecommendations = function(categorizedDeps) {
    const recommendations = [];
    
    // Check each category for missing items
    Object.keys(categorizedDeps).forEach(category => {
        const missing = categorizedDeps[category].missing;
        if (missing.length > 0) {
            recommendations.push({
                priority: this.getDependencyPriority(category, missing.length),
                category: this.getDependencyTypeTitle(category),
                description: `${missing.length} ${this.getDependencyTypeTitle(category).toLowerCase()} not found`,
                action: `Upload missing ${this.getDependencyTypeTitle(category).toLowerCase()}: ${missing.slice(0, 5).join(', ')}${missing.length > 5 ? '...' : ''}`,
                missingItems: missing
            });
        }
    });
    
    return recommendations;
};

// Determine priority based on dependency type and count
EnhancedMainframeAnalyzer.prototype.getDependencyPriority = function(category, count) {
    if (category === 'copybooks' || category === 'calledPrograms') {
        return count > 3 ? 'HIGH' : 'MEDIUM';
    } else if (category === 'dbTables' || category === 'fileReferences') {
        return count > 5 ? 'HIGH' : 'MEDIUM';
    } else {
        return count > 2 ? 'MEDIUM' : 'LOW';
    }
};

// Enhanced dependency display with clear missing items
EnhancedMainframeAnalyzer.prototype.displayDependencyResults = function(container, componentName, depReport) {
    const deps = depReport.dependencies;
    const categorized = depReport.categorizedDependencies;
    
    let html = `
        <h3>🔗 Enhanced Dependency Analysis: ${componentName}</h3>
        <p style="margin-bottom: 20px;">
            Complete dependency mapping using intelligent chunking • Completed: ${new Date(depReport.timestamp).toLocaleString()}
        </p>
        
        <!-- Dependency Summary -->
        <div style="background: rgba(76, 175, 80, 0.1); padding: 20px; border-radius: 10px; margin-bottom: 20px; border-left: 4px solid #4CAF50;">
            <h4 style="color: #FFD700; margin-bottom: 15px;">📊 Dependency Summary</h4>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 15px;">
                <div style="text-align: center;">
                    <div style="font-size: 1.5rem; font-weight: bold; color: #FFD700;">${depReport.summary.totalDependencies}</div>
                    <div style="font-size: 11px;">Total Dependencies</div>
                </div>
                <div style="text-align: center;">
                    <div style="font-size: 1.5rem; font-weight: bold; color: #4CAF50;">${depReport.summary.presentDependencies}</div>
                    <div style="font-size: 11px;">Present</div>
                </div>
                <div style="text-align: center;">
                    <div style="font-size: 1.5rem; font-weight: bold; color: #f44336;">${depReport.summary.missingDependencies}</div>
                    <div style="font-size: 11px;">Missing</div>
                </div>
                <div style="text-align: center;">
                    <div style="font-size: 1.5rem; font-weight: bold; color: #FF9800;">${depReport.summary.completenessPercentage}%</div>
                    <div style="font-size: 11px;">Completeness</div>
                </div>
            </div>
        </div>
    `;

    // Display each dependency type with clear present/missing breakdown
    let hasAnyDependencies = false;
    
    Object.keys(categorized).forEach(depType => {
        const present = categorized[depType].present;
        const missing = categorized[depType].missing;
        const total = present.length + missing.length;
        
        if (total > 0) {
            hasAnyDependencies = true;
            const title = this.getDependencyTypeTitle(depType);
            const icon = this.getDependencyTypeIcon(depType);
            
            html += `
                <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px; margin-bottom: 15px;">
                    <h4 style="color: #FFD700; margin-bottom: 15px;">${icon} ${title}</h4>
                    
                    <!-- Summary for this type -->
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 5px;">
                        <span style="font-weight: bold;">Total: ${total}</span>
                        <span style="color: #4CAF50;">✅ Present: ${present.length}</span>
                        <span style="color: #f44336;">❌ Missing: ${missing.length}</span>
                        <span style="color: #FF9800;">📊 ${Math.round((present.length/total)*100)}% Available</span>
                    </div>
            `;
            
            // Present items section
            if (present.length > 0) {
                html += `
                    <div style="margin-bottom: 15px;">
                        <h5 style="color: #4CAF50; margin-bottom: 10px; font-size: 14px;">✅ Present ${title} (${present.length})</h5>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 8px;">
                            ${present.map(dep => `
                                <div style="padding: 6px 10px; background: rgba(76, 175, 80, 0.2); border-radius: 4px; border-left: 3px solid #4CAF50;">
                                    <span style="font-family: monospace; color: white; font-size: 12px;">${dep}</span>
                                    <span style="color: #4CAF50; font-size: 10px; font-weight: bold; margin-left: 8px;">FOUND</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }
            
            // Missing items section - CLEARLY HIGHLIGHTED
            if (missing.length > 0) {
                html += `
                    <div style="margin-bottom: 15px;">
                        <h5 style="color: #f44336; margin-bottom: 10px; font-size: 14px;">❌ Missing ${title} (${missing.length})</h5>
                        <div style="background: rgba(244, 67, 54, 0.1); padding: 15px; border-radius: 8px; border-left: 4px solid #f44336;">
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 8px;">
                                ${missing.map(dep => `
                                    <div style="padding: 8px 12px; background: rgba(244, 67, 54, 0.2); border-radius: 4px; border-left: 3px solid #f44336;">
                                        <span style="font-family: monospace; color: white; font-size: 12px; font-weight: bold;">${dep}</span>
                                        <span style="color: #f44336; font-size: 10px; font-weight: bold; margin-left: 8px;">NOT FOUND</span>
                                    </div>
                                `).join('')}
                            </div>
                            <div style="margin-top: 10px; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 4px;">
                                <strong style="color: #f44336;">Upload Needed:</strong> 
                                <span style="font-size: 12px;">Please upload files containing these ${title.toLowerCase()} for complete analysis</span>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            html += '</div>'; // Close dependency type section
        }
    });
    
    // Enhanced recommendations with specific missing items
    if (depReport.recommendations && depReport.recommendations.length > 0) {
        html += `
            <div style="background: rgba(255, 193, 7, 0.1); padding: 20px; border-radius: 10px; border-left: 4px solid #FFC107;">
                <h4 style="color: #FFC107; margin-bottom: 15px;">💡 Detailed Recommendations</h4>
                ${depReport.recommendations.map(rec => `
                    <div style="margin-bottom: 15px; padding: 15px; background: rgba(0,0,0,0.2); border-radius: 8px; border-left: 3px solid ${this.getPriorityColor(rec.priority)};">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <div style="font-weight: bold; color: ${this.getPriorityColor(rec.priority)};">
                                ${this.getPriorityIcon(rec.priority)} ${rec.category} (${rec.priority} Priority)
                            </div>
                            <div style="font-size: 12px; opacity: 0.8;">${rec.description}</div>
                        </div>
                        
                        <div style="margin-bottom: 10px;">
                            <strong style="color: #FFD700;">Action Required:</strong> ${rec.action}
                        </div>
                        
                        ${rec.missingItems && rec.missingItems.length > 0 ? `
                            <div style="background: rgba(244, 67, 54, 0.1); padding: 10px; border-radius: 4px; margin-top: 10px;">
                                <strong style="color: #f44336;">Specifically Missing:</strong>
                                <div style="margin-top: 5px; font-family: monospace; font-size: 11px;">
                                    ${rec.missingItems.map(item => `<span style="display: inline-block; background: rgba(244, 67, 54, 0.2); padding: 2px 6px; margin: 2px; border-radius: 3px;">${item}</span>`).join('')}
                                </div>
                            </div>
                        ` : ''}
                    </div>
                `).join('')}
            </div>
        `;
    }
    
    if (!hasAnyDependencies || depReport.summary.totalDependencies === 0) {
        html += `
            <div style="background: rgba(255, 193, 7, 0.1); padding: 20px; border-radius: 10px; text-align: center; border-left: 4px solid #FFC107;">
                <h4 style="color: #FFC107; margin-bottom: 10px;">ℹ️ No Dependencies Found</h4>
                <p>No dependencies were detected for <strong>${componentName}</strong></p>
                <p style="font-size: 12px; opacity: 0.8; margin-top: 10px;">
                    This could indicate a standalone component or dependencies not captured in the uploaded files.
                </p>
            </div>
        `;
    }
    
    container.innerHTML = html;
    console.log('Enhanced dependency results with missing items displayed successfully');
};

// Enhanced dependency type mapping
EnhancedMainframeAnalyzer.prototype.getDependencyTypeTitle = function(depType) {
    const titles = {
        copybooks: 'Copybooks',
        calledPrograms: 'Called Programs',
        callingPrograms: 'Calling Programs', 
        jclDatasets: 'JCL Datasets',
        dbTables: 'Database Tables',
        fileReferences: 'File References'
    };
    return titles[depType] || depType.replace(/([A-Z])/g, ' $1').trim();
};

EnhancedMainframeAnalyzer.prototype.getDependencyTypeIcon = function(depType) {
    const icons = {
        copybooks: '📚',
        calledPrograms: '📞',
        callingPrograms: '📲',
        jclDatasets: '💾',
        dbTables: '🗄️',
        fileReferences: '📁'
    };
    return icons[depType] || '🔗';
};

// Enhanced dependency extraction to capture more patterns
EnhancedMainframeAnalyzer.prototype.extractDependenciesFromChunk = async function(chunk) {
    // ENHANCED DEPENDENCY EXTRACTION PROMPT - More specific patterns
    const prompt = `DEPENDENCY EXTRACTION - Chunk ${chunk.chunkIndex + 1}

FILES FOR ANALYSIS:
${chunk.files.map(f => `=== ${f.name} (${f.type}) ===\n${f.content}`).join('\n')}

${chunk.overlapContext ? `DEPENDENCY CONTEXT:\n${chunk.overlapContext}\n` : ''}

EXTRACT ALL DEPENDENCIES - BE VERY SPECIFIC:

**COPYBOOK DEPENDENCIES**
Look for: COPY statements, INCLUDE statements
Examples: COPY CUSTOMER-REC, COPY 'ACCOUNT-COPY', INCLUDE PAYROLL-COPY
Extract ONLY the copybook names

**PROGRAM CALL DEPENDENCIES**  
Look for: CALL statements, LINK statements, XCTL statements, JCL EXEC PGM=
Examples: CALL 'CUSTPROG', CALL CUSTOMER-UPDATE, EXEC PGM=PAYROLL
Extract ONLY the program names

**JCL DATASET DEPENDENCIES**
Look for: DSN= parameters, DD statements with dataset names
Examples: DSN=PROD.CUSTOMER.DATA, DSN=TEST.PAYROLL.FILE
Extract ONLY the dataset names

**DATABASE TABLE DEPENDENCIES**
Look for: EXEC SQL with table names, FROM clauses, INTO clauses
Examples: FROM CUSTOMER_TABLE, INTO ACCOUNT_MASTER, SELECT * FROM PAYROLL
Extract ONLY the table names

**FILE REFERENCE DEPENDENCIES**
Look for: FD entries, SELECT-ASSIGN statements, OPEN/CLOSE statements
Examples: FD CUSTOMER-FILE, SELECT CUST-FILE ASSIGN, OPEN INPUT PAYFILE
Extract ONLY the file names

RESPONSE FORMAT (EXACT FORMAT - NO EXTRA TEXT):
COPYBOOKS: name1, name2, name3
CALLED_PROGRAMS: prog1, prog2, prog3  
CALLING_PROGRAMS: caller1, caller2, caller3
JCL_DATASETS: dataset1, dataset2, dataset3
DB_TABLES: table1, table2, table3
FILE_REFERENCES: file1, file2, file3

If no dependencies found in a category, write: CATEGORYNAME: none
Extract actual names only - no quotes, no prefixes, no explanations.`;

    const response = await this.callvLLMAPI(prompt);
    return this.parseEnhancedDependencyResponse(response);
};

// Enhanced parsing with better error handling
EnhancedMainframeAnalyzer.prototype.parseEnhancedDependencyResponse = function(response) {
    const dependencies = {
        copybooks: [],
        calledPrograms: [],
        callingPrograms: [],
        jclDatasets: [],
        dbTables: [],
        fileReferences: []
    };

    console.log('Parsing dependency response:', response);

    const lines = response.split('\n');
    lines.forEach(line => {
        const trimmed = line.trim();
        
        if (trimmed.startsWith('COPYBOOKS:')) {
            dependencies.copybooks = this.parseEnhancedCommaSeparatedList(trimmed.split(':')[1]);
        } else if (trimmed.startsWith('CALLED_PROGRAMS:')) {
            dependencies.calledPrograms = this.parseEnhancedCommaSeparatedList(trimmed.split(':')[1]);
        } else if (trimmed.startsWith('CALLING_PROGRAMS:')) {
            dependencies.callingPrograms = this.parseEnhancedCommaSeparatedList(trimmed.split(':')[1]);
        } else if (trimmed.startsWith('JCL_DATASETS:')) {
            dependencies.jclDatasets = this.parseEnhancedCommaSeparatedList(trimmed.split(':')[1]);
        } else if (trimmed.startsWith('DB_TABLES:')) {
            dependencies.dbTables = this.parseEnhancedCommaSeparatedList(trimmed.split(':')[1]);
        } else if (trimmed.startsWith('FILE_REFERENCES:')) {
            dependencies.fileReferences = this.parseEnhancedCommaSeparatedList(trimmed.split(':')[1]);
        }
    });

    console.log('Parsed dependencies:', dependencies);
    return dependencies;
};

EnhancedMainframeAnalyzer.prototype.parseEnhancedCommaSeparatedList = function(str) {
    if (!str) return [];
    
    return str.split(',')
        .map(item => item.trim())
        .filter(item => item && 
                item.length > 0 && 
                !item.toLowerCase().includes('none') && 
                !item.toLowerCase().includes('n/a') &&
                !item.toLowerCase().includes('not found') &&
                item !== '...')
        .map(item => item.replace(/['"`]/g, '').trim())
        .filter(item => item.length > 0)
        .slice(0, 15); // Reasonable limit per category
};

console.log('🔧 Enhanced Dependency Display Fix Applied!');
console.log('✅ Improvements:');
console.log('   • Clear breakdown of present vs missing items in each category');
console.log('   • Specific lists of what copybooks/programs/datasets are missing');
console.log('   • Enhanced recommendations with exact missing items');
console.log('   • Better dependency extraction patterns');
console.log('   • Improved visual highlighting of missing dependencies');
console.log('   • Detailed upload suggestions for each missing category');

    </script>
</body>
</html>