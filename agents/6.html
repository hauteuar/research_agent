<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Mainframe Analyzer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            min-height: 100vh;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 25px;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .header h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #FFD700, #FFA500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .main-grid {
            display: grid;
            grid-template-columns: 520px 1fr 400px;
            gap: 25px;
            min-height: 80vh;
        }

        .control-panel, .analysis-workspace, .chat-panel {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .control-panel {
            height: fit-content;
            max-height: 85vh;
            overflow-y: auto;
        }

        .analysis-workspace {
            min-height: 80vh;
            overflow-y: auto;
        }

        .chat-panel {
            display: flex;
            flex-direction: column;
            max-height: 85vh;
        }

        /* Component Search Section */
        .component-search-section {
            margin-bottom: 25px;
            padding: 20px;
            background: rgba(76, 175, 80, 0.2);
            border-radius: 15px;
            border-left: 4px solid #4CAF50;
        }

        .component-input {
            width: 100%;
            padding: 12px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 14px;
            margin-bottom: 10px;
            transition: all 0.3s ease;
        }

        .component-input:focus {
            outline: none;
            border-color: #FFD700;
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.3);
        }

        .component-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .component-suggestions {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            max-height: 150px;
            overflow-y: auto;
            display: none;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .suggestion-item {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
            font-size: 13px;
        }

        .suggestion-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(3px);
        }

        /* Token Management */
        .token-info {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid rgba(255, 193, 7, 0.5);
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            font-size: 12px;
        }

        .token-bar {
            background: rgba(0, 0, 0, 0.3);
            height: 6px;
            border-radius: 3px;
            margin: 8px 0;
            overflow: hidden;
        }

        .token-fill {
            height: 100%;
            transition: all 0.3s ease;
            border-radius: 3px;
        }

        .token-fill.safe { background: #4CAF50; }
        .token-fill.warning { background: #FF9800; }
        .token-fill.danger { background: #f44336; }

        /* General Form Styles */
        .section-title { 
            color: #FFD700; 
            font-size: 1.2rem; 
            margin-bottom: 15px; 
            font-weight: 600; 
            display: flex; 
            align-items: center; 
            gap: 10px; 
        }

        .form-group { 
            margin-bottom: 20px; 
        }

        .form-group input, 
        .form-group select, 
        .form-group textarea { 
            width: 100%; 
            padding: 12px; 
            border: 1px solid rgba(255, 255, 255, 0.3); 
            border-radius: 8px; 
            background: rgba(255, 255, 255, 0.1); 
            color: white; 
            font-size: 14px; 
            transition: all 0.3s ease; 
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #FFD700;
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.3);
        }

        .form-group input::placeholder,
        .form-group textarea::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .action-btn { 
            width: 100%; 
            background: linear-gradient(45deg, #FF6B6B, #FF5252); 
            color: white; 
            border: none; 
            padding: 14px; 
            border-radius: 10px; 
            cursor: pointer; 
            font-size: 15px; 
            font-weight: 600; 
            margin-bottom: 12px; 
            transition: all 0.3s ease; 
            text-transform: uppercase; 
            letter-spacing: 1px; 
        }

        .action-btn:hover:not(:disabled) { 
            transform: translateY(-2px); 
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4); 
        }

        .action-btn:disabled { 
            opacity: 0.5; 
            cursor: not-allowed; 
            transform: none; 
            box-shadow: none; 
        }

        .validate-btn { 
            background: linear-gradient(45deg, #4CAF50, #45a049); 
        }

        .component-btn { 
            background: linear-gradient(45deg, #4CAF50, #45a049); 
        }

        .secondary-btn { 
            background: linear-gradient(45deg, #2196F3, #1976D2); 
        }

        /* API Status */
        .api-status {
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .api-status.connected {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid rgba(76, 175, 80, 0.5);
            color: #4CAF50;
        }

        .api-status.connecting {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid rgba(255, 193, 7, 0.5);
            color: #FFC107;
        }

        .api-status.disconnected {
            background: rgba(244, 67, 54, 0.2);
            border: 1px solid rgba(244, 67, 54, 0.5);
            color: #f44336;
        }

        /* Upload Area */
        .upload-area {
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 15px;
        }

        .upload-area:hover {
            border-color: #FFD700;
            background: rgba(255, 215, 0, 0.05);
        }

        .upload-area.drag-over {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.1);
        }

        .file-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .file-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .file-info {
            flex: 1;
        }

        .file-name {
            font-weight: bold;
            margin-bottom: 2px;
        }

        .file-details {
            font-size: 11px;
            opacity: 0.8;
        }

        .file-remove {
            background: #f44336;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .file-remove:hover {
            background: #d32f2f;
        }

        /* Loading Indicator */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 9999;
        }

        .loading.show {
            display: flex;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #FFD700;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading h3 {
            color: #FFD700;
            margin-bottom: 10px;
        }

        .loading p {
            color: rgba(255, 255, 255, 0.8);
            text-align: center;
            max-width: 400px;
        }

        /* Tabs */
        .tabs {
            display: flex;
            margin-bottom: 25px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 5px;
        }

        .tab {
            flex: 1;
            background: transparent;
            color: rgba(255, 255, 255, 0.7);
            border: none;
            padding: 12px 8px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .tab.active {
            background: linear-gradient(45deg, #FFD700, #FFA500);
            color: #000;
        }

        .tab:hover:not(.active) {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Message Types */
        .error, .success, .warning {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 8px;
            font-weight: bold;
            z-index: 10000;
            animation: slideInRight 0.3s ease;
        }

        .error {
            background: #f44336;
            color: white;
        }

        .success {
            background: #4CAF50;
            color: white;
        }

        .warning {
            background: #FF9800;
            color: white;
        }

        @keyframes slideInRight {
            from { transform: translateX(100%); }
            to { transform: translateX(0); }
        }

        /* Responsive Design */
        @media (max-width: 1600px) { 
            .main-grid { 
                grid-template-columns: 450px 1fr 350px; 
            } 
        }

        @media (max-width: 1400px) { 
            .main-grid { 
                grid-template-columns: 400px 1fr 300px; 
            } 
        }

        @media (max-width: 1200px) { 
            .main-grid { 
                grid-template-columns: 1fr; 
                gap: 20px; 
            }
            
            .control-panel, 
            .analysis-workspace, 
            .chat-panel {
                max-height: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üî¨ Enhanced Mainframe Analyzer</h1>
            <p>Advanced mainframe analysis with field flow tracking, business rules, and dependency mapping</p>
        </div>

        <div class="main-grid">
            <!-- Control Panel -->
            <div class="control-panel">
                <!-- Component Search Section -->
                <div class="component-search-section">
                    <h2 class="section-title">üéØ Component Analysis</h2>
                    <div class="form-group">
                        <label for="componentName">Enter Component Name:</label>
                        <input type="text" id="componentName" class="component-input" 
                               placeholder="e.g., CUSTOMER-RECORD, ACCOUNT-COPY, PAYROLL-PROC">
                        <div id="componentSuggestions" class="component-suggestions"></div>
                    </div>
                    
                    <!-- Token Usage Display -->
                    <div id="tokenInfo" class="token-info" style="display: none;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                            <span style="font-weight: bold;">Token Management</span>
                            <span id="tokenCount">0 / 4000</span>
                        </div>
                        <div class="token-bar">
                            <div id="tokenFill" class="token-fill safe" style="width: 0%"></div>
                        </div>
                        <div id="tokenWarning" style="font-size: 11px; margin-top: 5px;"></div>
                    </div>
                    
                    <button class="action-btn component-btn" id="analyzeComponentBtn" disabled>
                        üîç Analyze Component
                    </button>
                </div>

                <!-- vLLM API Setup -->
                <div style="margin-bottom: 25px; padding: 20px; background: rgba(0, 0, 0, 0.2); border-radius: 15px; border-left: 4px solid #4CAF50;">
                    <h2 class="section-title">üöÄ vLLM Server Setup</h2>
                    <div class="form-group">
                        <label for="vllmEndpoint">Server Endpoint:</label>
                        <input type="text" id="vllmEndpoint" placeholder="http://localhost:8000" value="http://localhost:8000">
                    </div>
                    <div class="form-group">
                        <label for="maxTokens">Max Tokens:</label>
                        <input type="number" id="maxTokens" value="4000" min="1000" max="8000">
                    </div>
                    <button class="action-btn validate-btn" id="validateApiBtn">
                        üîê Test Connection
                    </button>
                    <div class="api-status disconnected" id="apiStatus">
                        <span>üî¥</span> Enter server details and test connection
                    </div>
                </div>

                <!-- File Upload Section -->
                <div style="margin-bottom: 25px;">
                    <h2 class="section-title">üìÅ Upload Mainframe Files</h2>
                    <div class="upload-area" id="uploadArea">
                        <div>
                            <h3 style="margin-bottom: 8px;">üì§ Drop files here</h3>
                            <p style="font-size: 14px;">COBOL (.cbl), Copybooks (.cpy), JCL (.jcl)</p>
                        </div>
                        <input type="file" id="fileInput" multiple accept=".cbl,.cob,.cpy,.copybook,.jcl,.txt,.proc" style="display: none;">
                    </div>
                    <div id="uploadedFiles" class="file-list"></div>
                </div>

                <!-- Quick Actions -->
                <div>
                    <h3 class="section-title">‚ö° Actions</h3>
                    <button class="action-btn secondary-btn" id="bulkAnalyzeBtn" disabled>
                        üìä Bulk Analyze
                    </button>
                    <button class="action-btn secondary-btn" id="exportBtn" disabled>
                        üì§ Export Results
                    </button>
                    <button class="action-btn secondary-btn" id="clearBtn">
                        üóëÔ∏è Clear All Data
                    </button>
                </div>
            </div>

            <!-- Analysis Workspace -->
            <div class="analysis-workspace">
                <div class="tabs">
                    <button class="tab active" data-tab="lifecycle">üîÑ Analysis Results</button>
                    <button class="tab" data-tab="fieldmatrix">üìã Field Matrix</button>
                    <button class="tab" data-tab="usage">üìà Usage Patterns</button>
                    <button class="tab" data-tab="dependencies">üîó Dependencies</button>
                </div>

                <!-- Tab Contents -->
                <div id="lifecycle" class="tab-content active">
                    <div id="lifecycleContent">
                        <h3>üéØ Component Analysis Results</h3>
                        <p style="margin-bottom: 20px; line-height: 1.6;">
                            Upload files, test your connection, and analyze components for detailed field flows and business rules.
                        </p>
                        
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px; border-left: 4px solid #FFD700;">
                            <h4 style="color: #FFD700; margin-bottom: 15px;">üöÄ Analysis Features:</h4>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                                <div>
                                    <strong style="color: #4CAF50;">üìä Field Flow Analysis:</strong>
                                    <ul style="list-style: none; margin-left: 10px; line-height: 1.8;">
                                        <li>‚Ä¢ Input/Output field tracking</li>
                                        <li>‚Ä¢ Derived and calculated fields</li>
                                        <li>‚Ä¢ Unused field identification</li>
                                        <li>‚Ä¢ Field transformation paths</li>
                                    </ul>
                                </div>
                                <div>
                                    <strong style="color: #2196F3;">‚öñÔ∏è Business Rules:</strong>
                                    <ul style="list-style: none; margin-left: 10px; line-height: 1.8;">
                                        <li>‚Ä¢ Validation logic extraction</li>
                                        <li>‚Ä¢ Decision point mapping</li>
                                        <li>‚Ä¢ Conditional processing</li>
                                        <li>‚Ä¢ Business calculation rules</li>
                                    </ul>
                                </div>
                                <div>
                                    <strong style="color: #FF9800;">üîó Dependencies:</strong>
                                    <ul style="list-style: none; margin-left: 10px; line-height: 1.8;">
                                        <li>‚Ä¢ Copybook dependencies</li>
                                        <li>‚Ä¢ Program call chains</li>
                                        <li>‚Ä¢ File references</li>
                                        <li>‚Ä¢ Database table usage</li>
                                    </ul>
                                </div>
                                <div>
                                    <strong style="color: #9C27B0;">üß† Smart Processing:</strong>
                                    <ul style="list-style: none; margin-left: 10px; line-height: 1.8;">
                                        <li>‚Ä¢ Token-aware chunking</li>
                                        <li>‚Ä¢ Progressive analysis</li>
                                        <li>‚Ä¢ Context preservation</li>
                                        <li>‚Ä¢ Quality validation</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="fieldmatrix" class="tab-content">
                    <div id="fieldMatrixContent">
                        <h3>üìã Field Matrix Analysis</h3>
                        <p style="margin-bottom: 20px;">Field-level analysis with categorization will appear here after component analysis.</p>
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px;">
                            <p style="text-align: center; opacity: 0.8;">Field matrix will appear here after analysis.</p>
                        </div>
                    </div>
                </div>

                <div id="usage" class="tab-content">
                    <div id="usageContent">
                        <h3>üìà Usage Patterns Analysis</h3>
                        <p style="margin-bottom: 20px;">Usage pattern analysis will appear here after component analysis.</p>
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px;">
                            <p style="text-align: center; opacity: 0.8;">Usage patterns will appear here after analysis.</p>
                        </div>
                    </div>
                </div>

                <div id="dependencies" class="tab-content">
                    <div id="dependenciesContent">
                        <h3>üîó Dependency Analysis</h3>
                        <p style="margin-bottom: 20px;">Dependency mapping will appear here after component analysis.</p>
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px;">
                            <p style="text-align: center; opacity: 0.8;">Dependency graph will appear here after analysis.</p>
                        </div>
                    </div>
                </div>

                <!-- Loading Indicator -->
                <div class="loading" id="loadingIndicator">
                    <div class="spinner"></div>
                    <h3>ü§ñ Analyzing Component</h3>
                    <p id="loadingStatus">Processing component analysis...</p>
                    <div id="progressBar" style="background: rgba(255,255,255,0.2); height: 6px; border-radius: 3px; margin: 15px 0; overflow: hidden;">
                        <div id="progressFill" style="height: 100%; background: #4CAF50; width: 0%; transition: width 0.3s ease;"></div>
                    </div>
                </div>
            </div>

            <!-- Chat Panel - Will be added in next part -->
            <div class="chat-panel">
                <div style="background: rgba(76, 175, 80, 0.2); border-radius: 10px; padding: 15px; margin-bottom: 15px; border-left: 4px solid #4CAF50;">
                    <h3 style="margin-bottom: 8px; color: #FFD700;">üí¨ Analysis Chat</h3>
                    <p style="font-size: 12px; opacity: 0.8;">Interactive chat will be enabled in Part 2</p>
                </div>
                
                <div style="flex: 1; display: flex; align-items: center; justify-content: center; background: rgba(255, 255, 255, 0.05); border-radius: 10px;">
                    <p style="opacity: 0.6;">Chat functionality coming in Part 2...</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Part 1: Basic Setup and Core Functionality
        class EnhancedMainframeAnalyzer {
            constructor() {
                // Core properties
                this.uploadedFiles = [];
                this.analysisResults = {};
                this.componentSuggestions = [];
                this.serverValidated = false;
                this.vllmEndpoint = 'http://localhost:8000';
                this.maxTokens = 4000;
                this.storageKey = 'enhanced_mainframe_analysis';
                this.currentAnalyzedComponent = null;
                
                // Token management
                this.averageCharsPerToken = 4;
                this.tokenSafetyMargin = 0.8;
                
                this.initializeBasicEventListeners();
                this.loadStoredData();
                this.initializeTokenManagement();
                
                console.log('üöÄ Enhanced Mainframe Analyzer - Part 1 Initialized');
            }

            initializeBasicEventListeners() {
                // API validation
                document.getElementById('validateApiBtn').addEventListener('click', () => this.validateConnection());
                document.getElementById('vllmEndpoint').addEventListener('input', () => this.onEndpointChange());
                document.getElementById('maxTokens').addEventListener('input', () => this.onSettingsChange());
                
                // File upload handlers
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');
                
                uploadArea.addEventListener('click', () => {
                    if (this.serverValidated) fileInput.click();
                });
                uploadArea.addEventListener('drop', (e) => this.handleFileDrop(e));
                uploadArea.addEventListener('dragover', (e) => this.handleDragOver(e));
                uploadArea.addEventListener('dragleave', (e) => this.handleDragLeave(e));
                fileInput.addEventListener('change', (e) => this.handleFileSelect(e));

                // Component analysis
                document.getElementById('componentName').addEventListener('input', () => this.onComponentInput());
                document.getElementById('analyzeComponentBtn').addEventListener('click', () => this.analyzeComponent());
                
                // Quick actions
                document.getElementById('bulkAnalyzeBtn').addEventListener('click', () => this.bulkAnalyze());
                document.getElementById('exportBtn').addEventListener('click', () => this.exportResults());
                document.getElementById('clearBtn').addEventListener('click', () => this.clearAllData());

                // Tab navigation
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', (e) => this.switchTab(e));
                });

                // Hide suggestions when clicking outside
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.component-search-section')) {
                        document.getElementById('componentSuggestions').style.display = 'none';
                    }
                });
            }

            initializeTokenManagement() {
                this.updateTokenDisplay(0);
                this.showSuccess('üöÄ Enhanced Mainframe Analyzer Ready!');
            }

            // === TOKEN MANAGEMENT ===
            estimateTokenCount(text) {
                if (!text) return 0;
                return Math.ceil(text.length / this.averageCharsPerToken);
            }

            updateTokenDisplay(currentTokens) {
                const tokenInfo = document.getElementById('tokenInfo');
                const tokenCount = document.getElementById('tokenCount');
                const tokenFill = document.getElementById('tokenFill');
                const tokenWarning = document.getElementById('tokenWarning');

                tokenInfo.style.display = 'block';
                tokenCount.textContent = `${currentTokens} / ${this.maxTokens}`;
                
                const percentage = (currentTokens / this.maxTokens) * 100;
                tokenFill.style.width = `${Math.min(percentage, 100)}%`;
                
                tokenFill.className = 'token-fill';
                if (percentage <= 60) {
                    tokenFill.classList.add('safe');
                    tokenWarning.textContent = 'üü¢ Optimal token usage - full analysis available';
                } else if (percentage <= 85) {
                    tokenFill.classList.add('warning');
                    tokenWarning.textContent = 'üü° Moderate usage - intelligent chunking active';
                } else {
                    tokenFill.classList.add('danger');
                    tokenWarning.textContent = 'üî¥ High usage - optimization required';
                }
            }

            // === API CONNECTION ===
            async validateConnection() {
                const endpoint = document.getElementById('vllmEndpoint').value.trim();
                if (!endpoint) {
                    this.showError('Please enter vLLM endpoint');
                    return;
                }

                this.updateConnectionStatus('connecting', 'Testing connection...');

                try {
                    const response = await fetch(`${endpoint}/generate`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            prompt: "Test connection. Respond with 'Connected'",
                            max_tokens: 10,
                            temperature: 0.1
                        }),
                        signal: AbortSignal.timeout(10000)
                    });

                    if (response.ok) {
                        this.serverValidated = true;
                        this.vllmEndpoint = endpoint;
                        this.updateConnectionStatus('connected', `‚úÖ Connection verified`);
                        this.showSuccess('üöÄ vLLM server connected successfully!');
                    } else {
                        throw new Error(`HTTP ${response.status}`);
                    }
                } catch (error) {
                    this.serverValidated = false;
                    this.updateConnectionStatus('disconnected', `‚ùå Connection failed: ${error.message}`);
                    this.showError(`Connection failed: ${error.message}`);
                }
                
                this.validateForm();
            }

            updateConnectionStatus(status, message) {
                const statusElement = document.getElementById('apiStatus');
                statusElement.className = `api-status ${status}`;
                statusElement.innerHTML = message;
            }

            // === FILE UPLOAD ===
            handleFileDrop(e) {
                e.preventDefault();
                e.stopPropagation();
                
                const uploadArea = document.getElementById('uploadArea');
                uploadArea.classList.remove('drag-over');
                
                if (!this.serverValidated) {
                    this.showError('Please validate API connection first');
                    return;
                }
                
                const files = Array.from(e.dataTransfer.files);
                this.processFiles(files);
            }

            handleDragOver(e) {
                e.preventDefault();
                e.stopPropagation();
                document.getElementById('uploadArea').classList.add('drag-over');
            }

            handleDragLeave(e) {
                e.preventDefault();
                e.stopPropagation();
                document.getElementById('uploadArea').classList.remove('drag-over');
            }

            handleFileSelect(e) {
                if (!this.serverValidated) {
                    this.showError('Please validate API connection first');
                    return;
                }
                
                const files = Array.from(e.target.files);
                this.processFiles(files);
            }

            async processFiles(files) {
                for (const file of files) {
                    try {
                        const content = await this.readFile(file);
                        const fileType = this.detectFileType(file.name, content);
                        
                        const fileObj = {
                            name: file.name,
                            content: content,
                            size: file.size,
                            type: fileType,
                            uploadDate: new Date().toISOString(),
                            id: Date.now() + Math.random()
                        };
                        
                        this.uploadedFiles.push(fileObj);
                        this.updateComponentSuggestions();
                        
                    } catch (error) {
                        this.showError(`Failed to read ${file.name}: ${error.message}`);
                    }
                }
                
                this.displayUploadedFiles();
                this.validateForm();
                this.saveToStorage();
                this.showSuccess(`üìÅ ${files.length} files uploaded successfully!`);
            }

            readFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = e => resolve(e.target.result);
                    reader.onerror = e => reject(new Error('File read failed'));
                    reader.readAsText(file);
                });
            }

            detectFileType(fileName, content) {
                const name = fileName.toLowerCase();
                const upperContent = content.toUpperCase();
                
                if (name.includes('.cpy') || name.includes('copybook')) {
                    return 'Copybook';
                } else if (name.includes('.jcl') || upperContent.includes('//JOB ')) {
                    return 'JCL Job';
                } else if (name.includes('.cbl') || name.includes('.cob') || 
                          upperContent.includes('IDENTIFICATION DIVISION') ||
                          upperContent.includes('PROGRAM-ID')) {
                    return 'COBOL Program';
                } else if (name.includes('.proc')) {
                    return 'JCL Procedure';
                } else {
                    return 'Text File';
                }
            }

            displayUploadedFiles() {
                const container = document.getElementById('uploadedFiles');
                if (this.uploadedFiles.length === 0) {
                    container.innerHTML = '';
                    return;
                }
                
                let html = '';
                this.uploadedFiles.forEach(file => {
                    html += `
                        <div class="file-item">
                            <div class="file-info">
                                <div class="file-name">${file.name}</div>
                                <div class="file-details">${file.type} ‚Ä¢ ${Math.round(file.size/1024)}KB</div>
                            </div>
                            <button class="file-remove" onclick="analyzer.removeFile('${file.id}')">üóëÔ∏è</button>
                        </div>
                    `;
                });
                
                container.innerHTML = html;
            }

            removeFile(fileId) {
                this.uploadedFiles = this.uploadedFiles.filter(f => f.id != fileId);
                this.displayUploadedFiles();
                this.updateComponentSuggestions();
                this.validateForm();
                this.saveToStorage();
            }

            // === COMPONENT SUGGESTIONS ===
            updateComponentSuggestions() {
                this.componentSuggestions = [];
                
                this.uploadedFiles.forEach(file => {
                    const content = file.content.toUpperCase();
                    const lines = content.split('\n');
                    
                    lines.forEach(line => {
                        const trimmed = line.trim();
                        
                        // Extract COBOL field names
                        const fieldMatch = trimmed.match(/^\s*\d{2}\s+([A-Z][A-Z0-9\-_]{2,})/);
                        if (fieldMatch) {
                            this.componentSuggestions.push({
                                name: fieldMatch[1],
                                type: 'FIELD',
                                file: file.name
                            });
                        }
                        
                        // Extract copybook names
                        const copyMatch = trimmed.match(/COPY\s+([A-Z][A-Z0-9\-_]{2,})/);
                        if (copyMatch) {
                            this.componentSuggestions.push({
                                name: copyMatch[1],
                                type: 'COPYBOOK',
                                file: file.name
                            });
                        }
                        
                        // Extract program names
                        const programMatch = trimmed.match(/PROGRAM-ID\.?\s+([A-Z][A-Z0-9\-_]{2,})/);
                        if (programMatch) {
                            this.componentSuggestions.push({
                                name: programMatch[1],
                                type: 'PROGRAM',
                                file: file.name
                            });
                        }
                    });
                });
                
                // Remove duplicates
                this.componentSuggestions = this.componentSuggestions.filter((item, index, self) => 
                    index === self.findIndex(t => t.name === item.name && t.type === item.type)
                );
            }

            onComponentInput() {
                const input = document.getElementById('componentName');
                const value = input.value.trim().toUpperCase();
                const suggestions = document.getElementById('componentSuggestions');
                
                if (value.length < 2) {
                    suggestions.style.display = 'none';
                    this.validateForm();
                    return;
                }
                
                const filtered = this.componentSuggestions.filter(item => 
                    item.name.includes(value)
                ).slice(0, 8);
                
                if (filtered.length > 0) {
                    let html = '';
                    filtered.forEach(item => {
                        html += `
                            <div class="suggestion-item" onclick="analyzer.selectSuggestion('${item.name}')">
                                <strong>${item.name}</strong> 
                                <span style="opacity: 0.7;">(${item.type} in ${item.file})</span>
                            </div>
                        `;
                    });
                    suggestions.innerHTML = html;
                    suggestions.style.display = 'block';
                } else {
                    suggestions.style.display = 'none';
                }
                
                this.validateForm();
            }

            selectSuggestion(componentName) {
                document.getElementById('componentName').value = componentName;
                document.getElementById('componentSuggestions').style.display = 'none';
                this.validateForm();
            }

            // === FORM VALIDATION ===
            validateForm() {
                const hasFiles = this.uploadedFiles.length > 0;
                const hasComponent = document.getElementById('componentName').value.trim().length > 0;
                const hasConnection = this.serverValidated;
                
                document.getElementById('analyzeComponentBtn').disabled = !(hasFiles && hasComponent && hasConnection);
                document.getElementById('bulkAnalyzeBtn').disabled = !(hasFiles && hasConnection);
                document.getElementById('exportBtn').disabled = Object.keys(this.analysisResults).length === 0;
            }

            // === EVENT HANDLERS ===
            onEndpointChange() {
                this.serverValidated = false;
                this.updateConnectionStatus('disconnected', 'üî¥ Connection not validated');
                this.validateForm();
            }

            onSettingsChange() {
                this.maxTokens = parseInt(document.getElementById('maxTokens').value) || 4000;
                this.saveToStorage();
            }

            switchTab(e) {
                const targetTab = e.target?.dataset?.tab || e.dataset?.tab;
                if (!targetTab) return;
                
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                
                const clickedTab = e.target || e;
                if (clickedTab.classList) {
                    clickedTab.classList.add('active');
                }
                
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                
                const targetContent = document.getElementById(targetTab);
                if (targetContent) {
                    targetContent.classList.add('active');
                }
            }

            // === PLACEHOLDER METHODS FOR PART 2 ===
            async analyzeComponent() {
                this.showWarning('Analysis functionality will be added in Part 2');
            }

            async bulkAnalyze() {
                this.showWarning('Bulk analysis functionality will be added in Part 2');
            }

            exportResults() {
                this.showWarning('Export functionality will be added in Part 2');
            }

            // === UTILITY METHODS ===
            showLoading() { 
                document.getElementById('loadingIndicator').classList.add('show'); 
            }
            
            hideLoading() { 
                document.getElementById('loadingIndicator').classList.remove('show'); 
            }
            
            updateLoadingStatus(status) { 
                document.getElementById('loadingStatus').textContent = status; 
            }

            updateProgress(percentage) {
                const progressFill = document.getElementById('progressFill');
                if (progressFill) {
                    progressFill.style.width = `${percentage}%`;
                }
            }

            showMessage(type, message, duration = 3000) {
                const messageDiv = document.createElement('div');
                messageDiv.className = type;
                messageDiv.textContent = message;
                document.body.appendChild(messageDiv);
                
                setTimeout(() => {
                    if (messageDiv.parentNode) {
                        messageDiv.parentNode.removeChild(messageDiv);
                    }
                }, duration);
            }
            
            showError(message) { this.showMessage('error', message, 5000); }
            showSuccess(message) { this.showMessage('success', message, 3000); }
            showWarning(message) { this.showMessage('warning', message, 4000); }
            
            sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

            // === STORAGE MANAGEMENT ===
            saveToStorage() {
                try {
                    const data = {
                        uploadedFiles: this.uploadedFiles,
                        analysisResults: this.analysisResults,
                        vllmEndpoint: this.vllmEndpoint,
                        maxTokens: this.maxTokens,
                        timestamp: new Date().toISOString()
                    };
                    localStorage.setItem(this.storageKey, JSON.stringify(data));
                } catch (error) {
                    console.warn('Failed to save to storage:', error);
                }
            }

            loadStoredData() {
                try {
                    const stored = localStorage.getItem(this.storageKey);
                    if (stored) {
                        const data = JSON.parse(stored);
                        this.uploadedFiles = data.uploadedFiles || [];
                        this.analysisResults = data.analysisResults || {};
                        
                        if (data.vllmEndpoint) {
                            document.getElementById('vllmEndpoint').value = data.vllmEndpoint;
                            this.vllmEndpoint = data.vllmEndpoint;
                        }
                        
                        if (data.maxTokens) {
                            document.getElementById('maxTokens').value = data.maxTokens;
                            this.maxTokens = data.maxTokens;
                        }
                        
                        this.displayUploadedFiles();
                        this.updateComponentSuggestions();
                        this.validateForm();
                        
                        console.log('üìÅ Stored data loaded successfully');
                    }
                } catch (error) {
                    console.warn('Failed to load stored data:', error);
                }
            }

            clearAllData() {
                if (confirm('Are you sure you want to clear all data? This cannot be undone.')) {
                    this.uploadedFiles = [];
                    this.analysisResults = {};
                    this.componentSuggestions = [];
                    this.currentAnalyzedComponent = null;
                    
                    localStorage.removeItem(this.storageKey);
                    
                    this.displayUploadedFiles();
                    this.validateForm();
                    
                    document.getElementById('lifecycleContent').innerHTML = `
                        <h3>üéØ Component Analysis Results</h3>
                        <p style="margin-bottom: 20px;">Upload files and analyze components to get started.</p>
                    `;
                    
                    this.showSuccess('üóëÔ∏è All data cleared successfully');
                }
            }
        }

        // Initialize the analyzer
        const analyzer = new EnhancedMainframeAnalyzer();
        
        console.log('üöÄ Enhanced Mainframe Analyzer - Part 1 Ready!');
        console.log('‚úÖ Features active: File upload, API connection, component suggestions, token management');
        console.log('‚è≥ Coming in Part 2: Analysis engine, chat functionality, field matrix, dependencies');

        // Part 2: Analysis Engine and Chat Functionality
// This extends the analyzer from Part 1

// === ANALYSIS ENGINE ===
EnhancedMainframeAnalyzer.prototype.analyzeComponent = async function() {
    const componentName = document.getElementById('componentName').value.trim();
    if (!componentName) return;

    this.showLoading();
    this.updateProgress(0);

    try {
        const results = await this.runFocusedAnalysis(componentName);
        
        this.analysisResults[componentName] = results;
        this.currentAnalyzedComponent = componentName;
        
        this.displayAnalysisResults(componentName, results);
        this.enableChat();
        this.saveToStorage();
        
        this.hideLoading();
        this.showSuccess(`‚úÖ Analysis complete for ${componentName}!`);
        
    } catch (error) {
        this.hideLoading();
        this.showError(`Analysis failed: ${error.message}`);
        console.error('Analysis error:', error);
    }
};

EnhancedMainframeAnalyzer.prototype.runFocusedAnalysis = async function(componentName) {
    console.log(`Starting focused analysis for: ${componentName}`);
    
    // Stage 1: Find relevant files
    this.updateLoadingStatus('üîç Stage 1: Finding relevant files...');
    this.updateProgress(20);
    
    const relevantFiles = this.findRelevantFiles(componentName);
    if (relevantFiles.length === 0) {
        throw new Error(`Component "${componentName}" not found in uploaded files`);
    }

    // Stage 2: Optimize content for tokens
    this.updateLoadingStatus('üß† Stage 2: Optimizing content...');
    this.updateProgress(40);
    
    const optimizedContent = this.optimizeContentForTokens(relevantFiles);
    this.updateTokenDisplay(optimizedContent.totalTokens);

    // Stage 3: Perform analysis
    this.updateLoadingStatus('‚ö° Stage 3: Analyzing component...');
    this.updateProgress(70);
    
    const analysisPrompt = this.buildFocusedPrompt(componentName, optimizedContent.files);
    const analysisResult = await this.callvLLMAPI(analysisPrompt);
    
    this.updateProgress(100);
    
    return {
        componentName: componentName,
        timestamp: new Date().toISOString(),
        filesAnalyzed: relevantFiles.map(f => f.name),
        analysis: analysisResult,
        componentType: this.detectComponentType(componentName, relevantFiles),
        qualityScore: this.calculateQualityScore(analysisResult),
        completeness: this.assessCompleteness(analysisResult)
    };
};

EnhancedMainframeAnalyzer.prototype.findRelevantFiles = function(componentName) {
    const upperComponentName = componentName.toUpperCase();
    
    return this.uploadedFiles.filter(file => {
        const content = file.content.toUpperCase();
        const fileName = file.name.toUpperCase();
        
        return content.includes(upperComponentName) || 
               fileName.includes(upperComponentName) ||
               this.hasRelatedContent(content, upperComponentName);
    });
};

EnhancedMainframeAnalyzer.prototype.hasRelatedContent = function(content, componentName) {
    const patterns = [
        `COPY\\s+${componentName}`,
        `CALL\\s+['"]?${componentName}['"]?`,
        `\\b${componentName}\\b`,
        componentName.replace(/-/g, '[\\-_]')
    ];
    
    return patterns.some(pattern => new RegExp(pattern, 'i').test(content));
};

EnhancedMainframeAnalyzer.prototype.optimizeContentForTokens = function(files) {
    const targetTokens = Math.floor(this.maxTokens * this.tokenSafetyMargin);
    const optimized = [];
    let currentTokens = 0;

    for (const file of files) {
        const fileTokens = this.estimateTokenCount(file.content);
        
        if (currentTokens + fileTokens <= targetTokens) {
            optimized.push({
                ...file,
                content: file.content,
                truncated: false
            });
            currentTokens += fileTokens;
        } else {
            // Intelligent truncation
            const remainingTokens = targetTokens - currentTokens;
            if (remainingTokens > 100) { // Only include if meaningful space left
                const truncatedContent = this.intelligentTruncate(file.content, remainingTokens);
                optimized.push({
                    ...file,
                    content: truncatedContent,
                    truncated: true
                });
                currentTokens += this.estimateTokenCount(truncatedContent);
            }
            break; // Stop adding files once we're near limit
        }
    }

    return { files: optimized, totalTokens: currentTokens };
};

EnhancedMainframeAnalyzer.prototype.intelligentTruncate = function(content, targetTokens) {
    const targetChars = targetTokens * this.averageCharsPerToken;
    const lines = content.split('\n');
    
    // Prioritize important lines
    const prioritizedLines = {
        critical: [],
        important: [],
        regular: []
    };

    lines.forEach(line => {
        const upperLine = line.toUpperCase().trim();
        
        if (upperLine.includes('COPY ') || 
            upperLine.includes('CALL ') || 
            upperLine.includes('EXEC ') ||
            upperLine.match(/^\s*\d{2}\s+[A-Z]/) || 
            upperLine.includes('PROCEDURE DIVISION') ||
            upperLine.includes('DATA DIVISION')) {
            prioritizedLines.critical.push(line);
        }
        else if (upperLine.includes('WORKING-STORAGE') ||
                 upperLine.includes('LINKAGE') ||
                 upperLine.includes('//') || 
                 upperLine.includes('IF ') ||
                 upperLine.includes('PERFORM ')) {
            prioritizedLines.important.push(line);
        }
        else {
            prioritizedLines.regular.push(line);
        }
    });

    // Build optimized content
    let result = prioritizedLines.critical.join('\n');
    let remainingChars = targetChars - result.length;

    // Add important lines if space allows
    for (const line of prioritizedLines.important) {
        if (result.length + line.length + 1 < remainingChars * 0.8) {
            result += '\n' + line;
        } else break;
    }

    // Fill remaining space with regular content
    remainingChars = targetChars - result.length;
    for (const line of prioritizedLines.regular) {
        if (result.length + line.length + 1 < remainingChars) {
            result += '\n' + line;
        } else break;
    }

    return result;
};

EnhancedMainframeAnalyzer.prototype.detectComponentType = function(componentName, files) {
    const mainFile = files.find(f => 
        f.name.toUpperCase().includes(componentName.toUpperCase())
    );
    
    if (mainFile) {
        return mainFile.type;
    }
    
    // Check if it's a field in a copybook
    const copybookFile = files.find(f => f.type === 'Copybook');
    if (copybookFile) {
        const fieldPattern = new RegExp(`^\\s*\\d{2}\\s+${componentName}`, 'im');
        if (fieldPattern.test(copybookFile.content)) {
            return 'Field';
        }
    }
    
    return 'Component';
};

// OPTIMIZED PROMPT - FOCUSED AND CONCISE
EnhancedMainframeAnalyzer.prototype.buildFocusedPrompt = function(componentName, files) {
    return `ANALYZE COMPONENT: ${componentName}

FILES:
${files.map(f => `=== ${f.name} (${f.type}) ===\n${f.content}`).join('\n')}

REQUIRED ANALYSIS:

**1. FIELD FLOW TRACKING**
For each field found:
- INPUT: How field gets data (file/screen/calculation)
- PROCESSING: How field is transformed/used
- OUTPUT: Where field data goes
- UNUSED: Fields defined but never used

**2. BUSINESS RULES**  
- Validation logic (IF statements, conditions)
- Calculation rules (COMPUTE, ADD, etc.)
- Decision points (EVALUATE, WHEN)

**3. FIELD CATEGORIES**
List fields under each category:
- INPUT_FIELDS: [field1, field2, ...]
- DERIVED_FIELDS: [field1, field2, ...]  
- OUTPUT_FIELDS: [field1, field2, ...]
- UNUSED_FIELDS: [field1, field2, ...]

**4. PROGRAM FLOW** (if program)
- Main processing steps
- Called programs/modules
- File operations

FORMAT: Use ** headers, be specific, include field names and line references where possible.`;
};

// === API COMMUNICATION ===
EnhancedMainframeAnalyzer.prototype.callvLLMAPI = async function(prompt) {
    const response = await fetch(`${this.vllmEndpoint}/generate`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            prompt: prompt,
            max_tokens: Math.floor(this.maxTokens * 0.6),
            temperature: 0.3,
            top_p: 0.95,
            stop: ["Human:", "Assistant:"],
            stream: false
        }),
        signal: AbortSignal.timeout(60000)
    });

    if (!response.ok) {
        throw new Error(`API request failed: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();
    
    if (data.text) {
        return data.text.trim();
    } else if (data.choices && data.choices[0]) {
        return data.choices[0].text.trim();
    } else {
        throw new Error('Invalid API response format');
    }
};

EnhancedMainframeAnalyzer.prototype.calculateQualityScore = function(analysisText) {
    let score = 0;
    
    // Structure score
    const hasHeaders = analysisText.includes('**');
    score += hasHeaders ? 30 : 0;
    
    // Content depth score
    const analysisLength = analysisText.length;
    score += Math.min(analysisLength / 1000, 1) * 40;
    
    // Field categories score
    const hasFieldCategories = analysisText.includes('INPUT_FIELDS:') || 
                              analysisText.includes('DERIVED_FIELDS:');
    score += hasFieldCategories ? 30 : 0;
    
    return Math.min(Math.round(score / 10), 10);
};

EnhancedMainframeAnalyzer.prototype.assessCompleteness = function(analysisText) {
    const checkpoints = {
        'Field Flow': analysisText.includes('FIELD FLOW') || analysisText.includes('INPUT:'),
        'Business Rules': analysisText.includes('BUSINESS RULES') || analysisText.includes('VALIDATION'),
        'Field Categories': analysisText.includes('INPUT_FIELDS:') || analysisText.includes('DERIVED_FIELDS:'),
        'Program Flow': analysisText.includes('PROGRAM FLOW') || analysisText.includes('PROCESSING'),
        'Detailed Analysis': analysisText.length > 500
    };
    
    const completed = Object.values(checkpoints).filter(Boolean).length;
    const total = Object.keys(checkpoints).length;
    
    return {
        score: Math.round((completed / total) * 100),
        checkpoints: checkpoints,
        completed: completed,
        total: total
    };
};

// === DISPLAY METHODS ===
EnhancedMainframeAnalyzer.prototype.displayAnalysisResults = function(componentName, results) {
    // Update main analysis tab
    this.displayMainAnalysis(componentName, results);
    
    // Update field matrix tab
    this.displayFieldMatrix(componentName, results);
    
    // Update usage patterns tab
    this.displayUsagePatterns(componentName, results);
    
    // Switch to analysis tab
    this.switchTab({ target: { dataset: { tab: 'lifecycle' } } });
};

EnhancedMainframeAnalyzer.prototype.displayMainAnalysis = function(componentName, results) {
    const container = document.getElementById('lifecycleContent');
    
    const html = `
        <h3>üîÑ Analysis Results: ${componentName}</h3>
        <p style="margin-bottom: 20px;">
            Component type: <strong>${results.componentType}</strong> ‚Ä¢ 
            Files analyzed: <strong>${results.filesAnalyzed.length}</strong> ‚Ä¢ 
            Completed: <strong>${new Date(results.timestamp).toLocaleString()}</strong>
        </p>
        
        <!-- Quality Metrics -->
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 15px; margin-bottom: 25px;">
            <div style="background: rgba(76, 175, 80, 0.1); padding: 15px; border-radius: 8px; text-align: center; border-left: 4px solid #4CAF50;">
                <div style="font-size: 1.5rem; font-weight: bold; color: #FFD700;">${results.qualityScore}/10</div>
                <div style="font-size: 11px;">Quality Score</div>
            </div>
            <div style="background: rgba(33, 150, 243, 0.1); padding: 15px; border-radius: 8px; text-align: center; border-left: 4px solid #2196F3;">
                <div style="font-size: 1.5rem; font-weight: bold; color: #FFD700;">${results.completeness.score}%</div>
                <div style="font-size: 11px;">Completeness</div>
            </div>
            <div style="background: rgba(255, 152, 0, 0.1); padding: 15px; border-radius: 8px; text-align: center; border-left: 4px solid #FF9800;">
                <div style="font-size: 1.5rem; font-weight: bold; color: #FFD700;">${results.filesAnalyzed.length}</div>
                <div style="font-size: 11px;">Files Analyzed</div>
            </div>
        </div>

        <!-- Analysis Results -->
        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px; border-left: 4px solid #FFD700;">
            <h4 style="color: #FFD700; margin-bottom: 15px;">üîç Analysis Results</h4>
            <div style="background: rgba(0, 0, 0, 0.2); padding: 20px; border-radius: 8px; font-family: monospace; font-size: 13px; line-height: 1.6; max-height: 600px; overflow-y: auto;">
                ${this.formatAnalysisText(results.analysis)}
            </div>
        </div>
    `;
    
    container.innerHTML = html;
};

EnhancedMainframeAnalyzer.prototype.displayFieldMatrix = function(componentName, results) {
    const container = document.getElementById('fieldMatrixContent');
    const fieldInfo = this.extractFieldInformation(results.analysis);
    
    let html = `
        <h3>üìã Field Matrix: ${componentName}</h3>
        <p style="margin-bottom: 20px;">Field-level flow tracking and categorization.</p>
    `;
    
    if (fieldInfo.categories && Object.keys(fieldInfo.categories).some(cat => fieldInfo.categories[cat].length > 0)) {
        html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">';
        
        Object.keys(fieldInfo.categories).forEach(category => {
            const fields = fieldInfo.categories[category];
            if (fields.length > 0) {
                const color = this.getCategoryColor(category);
                html += `
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 15px; border-radius: 8px; border-left: 4px solid ${color};">
                        <h4 style="color: ${color}; margin-bottom: 10px;">${this.formatCategoryName(category)}</h4>
                        <div style="font-family: monospace; font-size: 12px;">
                            ${fields.map(field => `<div style="margin: 5px 0; padding: 5px; background: rgba(0,0,0,0.2); border-radius: 3px;">‚Ä¢ ${field}</div>`).join('')}
                        </div>
                    </div>
                `;
            }
        });
        
        html += '</div>';
    } else {
        html += `
            <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px;">
                <p style="text-align: center; opacity: 0.8;">No structured field information found. Check the main analysis tab for details.</p>
            </div>
        `;
    }
    
    container.innerHTML = html;
};

EnhancedMainframeAnalyzer.prototype.displayUsagePatterns = function(componentName, results) {
    const container = document.getElementById('usageContent');
    const usageStats = this.extractUsageStatistics(results.analysis, results.componentType);
    
    let html = `
        <h3>üìà Usage Patterns: ${componentName}</h3>
        <p style="margin-bottom: 20px;">Usage pattern analysis for ${results.componentType}.</p>
    `;
    
    if (usageStats.length > 0) {
        html += `
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 25px;">
                ${usageStats.map(stat => `
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 15px; border-radius: 8px; border-left: 4px solid ${stat.color};">
                        <div style="font-size: 1.2rem; font-weight: bold; color: #FFD700; margin-bottom: 5px;">
                            ${stat.value}
                        </div>
                        <div style="font-size: 12px; opacity: 0.8;">
                            ${stat.label}
                        </div>
                        <div style="font-size: 10px; margin-top: 5px; opacity: 0.6;">
                            ${stat.description}
                        </div>
                    </div>
                `).join('')}
            </div>
        `;
    }

    html += `
        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px;">
            <h4 style="color: #FFD700; margin-bottom: 15px;">üìä Usage Patterns</h4>
            <div style="background: rgba(0, 0, 0, 0.2); padding: 20px; border-radius: 8px;">
                ${this.generateUsagePatternDisplay(results.analysis, results.componentType)}
            </div>
        </div>
    `;

    container.innerHTML = html;
};

// === UTILITY HELPER METHODS ===
EnhancedMainframeAnalyzer.prototype.formatAnalysisText = function(text) {
    return text
        .replace(/\*\*([^*]+)\*\*/g, '<strong style="color: #FFD700;">$1</strong>')
        .replace(/\n/g, '<br>')
        .replace(/^- /gm, '‚Ä¢ ');
};

EnhancedMainframeAnalyzer.prototype.extractFieldInformation = function(analysisText) {
    const fieldInfo = { categories: {} };
    
    // Look for field categories in the analysis
    const categoryPatterns = {
        'INPUT_FIELDS': /INPUT_FIELDS:\s*\[(.*?)\]/s,
        'DERIVED_FIELDS': /DERIVED_FIELDS:\s*\[(.*?)\]/s,
        'OUTPUT_FIELDS': /OUTPUT_FIELDS:\s*\[(.*?)\]/s,
        'UNUSED_FIELDS': /UNUSED_FIELDS:\s*\[(.*?)\]/s
    };

    Object.keys(categoryPatterns).forEach(category => {
        const match = analysisText.match(categoryPatterns[category]);
        if (match) {
            const fieldsStr = match[1];
            const fields = fieldsStr.split(',')
                .map(f => f.trim().replace(/['"]/g, ''))
                .filter(f => f && f !== '...' && f !== 'none');
            fieldInfo.categories[category] = fields;
        } else {
            fieldInfo.categories[category] = [];
        }
    });

    return fieldInfo;
};

EnhancedMainframeAnalyzer.prototype.getCategoryColor = function(category) {
    const colors = {
        'INPUT_FIELDS': '#4CAF50',
        'DERIVED_FIELDS': '#2196F3',
        'OUTPUT_FIELDS': '#FF9800',
        'UNUSED_FIELDS': '#f44336'
    };
    return colors[category] || '#FFD700';
};

EnhancedMainframeAnalyzer.prototype.formatCategoryName = function(category) {
    return category.replace(/_/g, ' ').toLowerCase()
        .replace(/\b\w/g, l => l.toUpperCase());
};

EnhancedMainframeAnalyzer.prototype.extractUsageStatistics = function(analysisText, componentType) {
    const stats = [];
    
    switch (componentType) {
        case 'Copybook':
            stats.push(
                { label: 'Fields Defined', value: this.countMatches(analysisText, /\d{2}\s+[A-Z]/g), color: '#4CAF50', description: 'Total field definitions' },
                { label: 'Programs Using', value: this.countMatches(analysisText, /PROGRAM|COPY/gi), color: '#2196F3', description: 'Programs referencing' },
                { label: 'Usage Frequency', value: 'Active', color: '#FF9800', description: 'Access pattern analysis' }
            );
            break;
        case 'COBOL Program':
            stats.push(
                { label: 'Call Operations', value: this.countMatches(analysisText, /CALL/gi), color: '#4CAF50', description: 'External program calls' },
                { label: 'File Operations', value: this.countMatches(analysisText, /READ|WRITE|OPEN|CLOSE/gi), color: '#2196F3', description: 'File I/O operations' },
                { label: 'Business Rules', value: this.countMatches(analysisText, /IF|WHEN|EVALUATE/gi), color: '#FF9800', description: 'Decision points' }
            );
            break;
        case 'Field':
            stats.push(
                { label: 'Read Operations', value: this.countMatches(analysisText, /READ|MOVE.*TO/gi), color: '#4CAF50', description: 'Field access count' },
                { label: 'Write Operations', value: this.countMatches(analysisText, /MOVE.*TO|COMPUTE/gi), color: '#2196F3', description: 'Field modification count' },
                { label: 'Validation Rules', value: this.countMatches(analysisText, /VALIDATE|CHECK|IF/gi), color: '#FF9800', description: 'Data validation points' }
            );
            break;
    }
    
    return stats;
};

EnhancedMainframeAnalyzer.prototype.countMatches = function(text, regex) {
    const matches = text.match(regex);
    return matches ? matches.length : 0;
};

EnhancedMainframeAnalyzer.prototype.generateUsagePatternDisplay = function(analysisText, componentType) {
    const patterns = this.extractUsagePatterns(analysisText, componentType);
    
    if (patterns.length === 0) {
        return '<p style="text-align: center; opacity: 0.7;">Usage patterns extracted from analysis</p>';
    }
    
    return patterns.map(pattern => `
        <div style="margin-bottom: 15px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 5px; border-left: 3px solid ${pattern.color};">
            <strong style="color: ${pattern.color};">${pattern.type}:</strong> ${pattern.description}
            <div style="font-size: 11px; opacity: 0.8; margin-top: 5px;">${pattern.details}</div>
        </div>
    `).join('');
};

EnhancedMainframeAnalyzer.prototype.extractUsagePatterns = function(text, componentType) {
    const patterns = [];
    
    if (text.toLowerCase().includes('read') || text.includes('INPUT')) {
        patterns.push({
            type: 'Read Pattern',
            color: '#4CAF50',
            description: 'Data access and retrieval operations',
            details: 'Input operations detected in analysis'
        });
    }
    
    if (text.toLowerCase().includes('write') || text.includes('MOVE') || text.includes('OUTPUT')) {
        patterns.push({
            type: 'Write Pattern',
            color: '#2196F3',
            description: 'Data modification and update operations',
            details: 'Output operations detected in analysis'
        });
    }
    
    if (text.includes('CALL') || text.toLowerCase().includes('program')) {
        patterns.push({
            type: 'Integration Pattern',
            color: '#FF9800',
            description: 'External program and system integration',
            details: 'Cross-component integration detected'
        });
    }
    
    if (text.includes('UNUSED') || text.includes('unused')) {
        patterns.push({
            type: 'Unused Elements',
            color: '#f44336',
            description: 'Unused fields or components identified',
            details: 'Cleanup opportunities detected'
        });
    }
    
    return patterns;
};

// === BULK ANALYSIS ===
EnhancedMainframeAnalyzer.prototype.bulkAnalyze = async function() {
    if (this.uploadedFiles.length === 0) {
        this.showError('No files uploaded for bulk analysis');
        return;
    }

    this.showLoading();
    this.updateLoadingStatus('üîÑ Starting bulk analysis...');

    const components = this.componentSuggestions.slice(0, 5); // Limit to 5 components
    let completed = 0;

    try {
        for (const component of components) {
            this.updateLoadingStatus(`Analyzing ${component.name} (${completed + 1}/${components.length})...`);
            this.updateProgress((completed / components.length) * 100);
            
            try {
                const results = await this.runFocusedAnalysis(component.name);
                this.analysisResults[component.name] = results;
                completed++;
                
                await this.sleep(2000); // Brief pause between analyses
            } catch (error) {
                console.warn(`Failed to analyze ${component.name}:`, error);
            }
        }

        this.hideLoading();
        this.saveToStorage();
        this.showSuccess(`‚ú® Bulk analysis complete! ${completed}/${components.length} components analyzed`);

    } catch (error) {
        this.hideLoading();
        this.showError(`Bulk analysis failed: ${error.message}`);
    }
};

// === EXPORT FUNCTIONALITY ===
EnhancedMainframeAnalyzer.prototype.exportResults = function() {
    if (Object.keys(this.analysisResults).length === 0) {
        this.showError('No analysis results to export');
        return;
    }

    try {
        const exportData = {
            timestamp: new Date().toISOString(),
            totalComponents: Object.keys(this.analysisResults).length,
            totalFiles: this.uploadedFiles.length,
            analysisResults: this.analysisResults,
            fileInfo: this.uploadedFiles.map(f => ({
                name: f.name,
                type: f.type,
                size: f.size,
                uploadDate: f.uploadDate
            })),
            systemInfo: {
                vllmEndpoint: this.vllmEndpoint,
                maxTokens: this.maxTokens,
                version: '2.0.0-focused'
            }
        };

        const dataStr = JSON.stringify(exportData, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        
        const link = document.createElement('a');
        link.href = URL.createObjectURL(dataBlob);
        link.download = `mainframe-analysis-${new Date().toISOString().split('T')[0]}.json`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        this.showSuccess('üì§ Analysis results exported successfully!');
        
    } catch (error) {
        this.showError(`Export failed: ${error.message}`);
    }
};

// === ENHANCED CHAT FUNCTIONALITY ===
EnhancedMainframeAnalyzer.prototype.initializeChat = function() {
    // Update chat panel HTML
    const chatPanel = document.querySelector('.chat-panel');
    chatPanel.innerHTML = `
        <div style="background: rgba(76, 175, 80, 0.2); border-radius: 10px; padding: 15px; margin-bottom: 15px; border-left: 4px solid #4CAF50;">
            <h3 style="margin-bottom: 8px; color: #FFD700;">üí¨ Analysis Chat</h3>
            <p style="font-size: 12px; opacity: 0.8;">Ask detailed questions about your analysis</p>
        </div>

        <div style="margin-bottom: 15px;">
            <div style="font-size: 11px; margin-bottom: 8px; opacity: 0.7;">Quick questions:</div>
            <button class="chat-suggestion-btn" data-question="What fields are unused in this component?">Unused fields?</button>
            <button class="chat-suggestion-btn" data-question="Show me the complete field flow">Field flow?</button>
            <button class="chat-suggestion-btn" data-question="What business rules are implemented?">Business rules?</button>
            <button class="chat-suggestion-btn" data-question="Which fields come from input files?">Input fields?</button>
        </div>

        <div id="chatMessages" style="flex: 1; overflow-y: auto; margin-bottom: 15px; max-height: 400px; padding-right: 10px;">
            <div style="margin-bottom: 15px; padding: 12px; border-radius: 10px; max-width: 85%; background: rgba(76, 175, 80, 0.3); border-left: 4px solid #4CAF50;">
                <div style="font-weight: bold; font-size: 12px; opacity: 0.8; margin-bottom: 5px;">Analysis Assistant</div>
                <div style="font-size: 14px; line-height: 1.5;">
                    üëã Welcome! I can help analyze your mainframe components.
                    <br><br>
                    Once you analyze a component, I can answer questions about:
                    <br>‚Ä¢ Field flows and transformations
                    <br>‚Ä¢ Business rules and validations
                    <br>‚Ä¢ Unused or static fields
                    <br>‚Ä¢ Input/output patterns
                    <br><br>
                    Upload files and analyze a component to get started!
                </div>
            </div>
        </div>

        <div style="display: flex; gap: 10px; align-items: flex-start;">
            <textarea 
                id="chatInput" 
                style="flex: 1; padding: 12px; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 8px; background: rgba(255, 255, 255, 0.1); color: white; font-size: 14px; resize: vertical; min-height: 40px; max-height: 100px; font-family: inherit;"
                placeholder="Ask about field flows, business rules, unused fields..."
                disabled
                rows="2"
            ></textarea>
            <button id="chatSendBtn" style="background: linear-gradient(45deg, #4CAF50, #45a049); color: white; border: none; padding: 12px 16px; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 600; transition: all 0.3s ease; white-space: nowrap; min-width: 80px;" disabled>
                Send
            </button>
        </div>

        <div style="font-size: 10px; opacity: 0.6; margin-top: 8px; text-align: center;">
            Chat enabled after component analysis
        </div>
    `;

    // Add chat styles
    const chatStyles = document.createElement('style');
    chatStyles.textContent = `
        .chat-suggestion-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 6px 10px;
            border-radius: 15px;
            font-size: 11px;
            cursor: pointer;
            margin: 3px;
            transition: all 0.3s ease;
            display: inline-block;
        }

        .chat-suggestion-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        #chatMessages::-webkit-scrollbar {
            width: 6px;
        }

        #chatMessages::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        #chatMessages::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }

        #chatInput:focus {
            outline: none;
            border-color: #FFD700;
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.3);
        }

        #chatInput::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        #chatSendBtn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
        }

        #chatSendBtn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
    `;
    document.head.appendChild(chatStyles);

    // Initialize chat event listeners
    this.initializeChatEventListeners();
};

EnhancedMainframeAnalyzer.prototype.initializeChatEventListeners = function() {
    const chatSendBtn = document.getElementById('chatSendBtn');
    const chatInput = document.getElementById('chatInput');
    
    if (chatSendBtn && chatInput) {
        chatSendBtn.addEventListener('click', () => {
            console.log('Chat send button clicked');
            this.sendChatMessage();
        });
        
        chatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                console.log('Enter pressed in chat');
                this.sendChatMessage();
            }
        });
    }

    // Chat suggestions
    document.querySelectorAll('.chat-suggestion-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const question = e.target.dataset.question;
            console.log('Suggestion clicked:', question);
            if (chatInput) {
                chatInput.value = question;
                this.sendChatMessage();
            }
        });
    });
};

EnhancedMainframeAnalyzer.prototype.sendChatMessage = async function() {
    const input = document.getElementById('chatInput');
    const sendBtn = document.getElementById('chatSendBtn');
    const message = input.value.trim();
    
    console.log('Send chat message called:', message);
    
    if (!message) {
        this.showError('Please enter a message');
        return;
    }
    
    if (!this.currentAnalyzedComponent) {
        this.showError('Please analyze a component first');
        return;
    }
    
    input.disabled = true;
    sendBtn.disabled = true;
    sendBtn.textContent = 'Processing...';
    
    this.addChatMessage('user', message);
    input.value = '';
    
    this.showChatTyping();
    
    try {
        console.log('Processing chat query...');
        const response = await this.processChatQuery(message);
        console.log('Got response:', response);
        
        this.hideChatTyping();
        this.addChatMessage('assistant', response);
        
    } catch (error) {
        console.error('Chat error:', error);
        this.hideChatTyping();
        this.addChatMessage('assistant', `I apologize, but I encountered an error: ${error.message}. Please try rephrasing your question.`);
    } finally {
        input.disabled = false;
        sendBtn.disabled = false;
        sendBtn.textContent = 'Send';
        input.focus();
    }
};

EnhancedMainframeAnalyzer.prototype.processChatQuery = async function(question) {
    const analysisData = this.analysisResults[this.currentAnalyzedComponent];
    
    // OPTIMIZED CHAT PROMPT
    const chatPrompt = `ANALYSIS CHAT: ${this.currentAnalyzedComponent}

QUESTION: "${question}"

ANALYSIS RESULTS:
${analysisData.analysis}

INSTRUCTIONS:
Answer the user's question based on the analysis results above. Be specific and reference exact field names, programs, or line numbers when available. If the information isn't in the analysis, say so clearly.

Focus on:
- Field flows and transformations
- Business rules and validations
- Unused or static fields  
- Input/output patterns

Keep responses practical and use examples from the actual analysis.`;

    return await this.callvLLMAPI(chatPrompt);
};

EnhancedMainframeAnalyzer.prototype.addChatMessage = function(sender, content) {
    const messagesContainer = document.getElementById('chatMessages');
    if (!messagesContainer) {
        console.error('Chat messages container not found');
        return;
    }
    
    const messageDiv = document.createElement('div');
    messageDiv.style.cssText = `
        margin-bottom: 15px; 
        padding: 12px; 
        border-radius: 10px; 
        max-width: 85%; 
        word-wrap: break-word; 
        line-height: 1.5;
        animation: fadeInUp 0.3s ease;
        ${sender === 'user' ? 
            'background: rgba(33, 150, 243, 0.3); border-left: 4px solid #2196F3; margin-left: auto; text-align: right;' : 
            'background: rgba(76, 175, 80, 0.3); border-left: 4px solid #4CAF50;'
        }
    `;
    
    messageDiv.innerHTML = `
        <div style="font-weight: bold; font-size: 12px; opacity: 0.8; margin-bottom: 5px;">
            ${sender === 'user' ? 'You' : 'Analysis Assistant'}
        </div>
        <div style="font-size: 14px; line-height: 1.5;">
            ${this.formatChatMessage(content)}
        </div>
    `;
    
    messagesContainer.appendChild(messageDiv);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
};

EnhancedMainframeAnalyzer.prototype.formatChatMessage = function(content) {
    return content
        .replace(/\n/g, '<br>')
        .replace(/\*\*([^*]+)\*\*/g, '<strong style="color: #FFD700;">$1</strong>')
        .replace(/`([^`]+)`/g, '<code style="background: rgba(0,0,0,0.3); padding: 2px 4px; border-radius: 3px; color: #4CAF50;">$1</code>')
        .replace(/^- /gm, '‚Ä¢ ');
};

EnhancedMainframeAnalyzer.prototype.showChatTyping = function() {
    const messagesContainer = document.getElementById('chatMessages');
    if (!messagesContainer) return;
    
    this.hideChatTyping();
    
    const typingDiv = document.createElement('div');
    typingDiv.id = 'typingIndicator';
    typingDiv.style.cssText = `
        margin-bottom: 15px; 
        padding: 12px; 
        border-radius: 10px; 
        max-width: 85%; 
        background: rgba(76, 175, 80, 0.3); 
        border-left: 4px solid #4CAF50;
    `;
    
    typingDiv.innerHTML = `
        <div style="font-weight: bold; font-size: 12px; opacity: 0.8; margin-bottom: 5px;">Analysis Assistant</div>
        <div style="font-size: 14px; line-height: 1.5;">
            <span style="opacity: 0.7;">Analyzing your question...</span>
            <span style="animation: blink 1s infinite; margin-left: 5px;">‚óè‚óè‚óè</span>
        </div>
    `;
    
    messagesContainer.appendChild(typingDiv);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
};

EnhancedMainframeAnalyzer.prototype.hideChatTyping = function() {
    const typingIndicator = document.getElementById('typingIndicator');
    if (typingIndicator && typingIndicator.parentNode) {
        typingIndicator.parentNode.removeChild(typingIndicator);
    }
};

EnhancedMainframeAnalyzer.prototype.enableChat = function() {
    const chatInput = document.getElementById('chatInput');
    const chatSendBtn = document.getElementById('chatSendBtn');
    
    if (chatInput && chatSendBtn) {
        chatInput.disabled = false;
        chatSendBtn.disabled = false;
        
        this.addChatMessage('assistant', 
            `üéØ **Analysis complete for ${this.currentAnalyzedComponent}!**
            
I can now answer detailed questions about:
‚Ä¢ Field flows and transformations
‚Ä¢ Business rules and validation logic  
‚Ä¢ Unused or static fields
‚Ä¢ Input/output patterns
‚Ä¢ Program logic and structure

**Try asking:**
‚Ä¢ "What fields are unused?"
‚Ä¢ "Show me the field flow"
‚Ä¢ "What business rules are implemented?"
‚Ä¢ "Which fields come from input files?"`
        );
    }
};

// Initialize chat when document is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function() {
        if (typeof analyzer !== 'undefined') {
            analyzer.initializeChat();
        }
    });
} else {
    // Document already loaded
    if (typeof analyzer !== 'undefined') {
        analyzer.initializeChat();
    }
}

// Add CSS animation for chat messages
const chatAnimationStyle = document.createElement('style');
chatAnimationStyle.textContent = `
    @keyframes fadeInUp {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
    }
    
    @keyframes blink {
        0%, 50% { opacity: 1; }
        51%, 100% { opacity: 0; }
    }
`;
document.head.appendChild(chatAnimationStyle);

console.log('üöÄ Enhanced Mainframe Analyzer - Part 2 Ready!');
console.log('‚úÖ Features active: Analysis engine, chat functionality, field matrix, usage patterns');
console.log('‚è≥ Coming in Part 3: Enhanced dependency mapping with chunking');

// Part 3: Enhanced Dependency Mapping with Chunking
// This extends the analyzer from Parts 1 & 2

// === ENHANCED DEPENDENCY ANALYSIS ===
EnhancedMainframeAnalyzer.prototype.initializeDependencyAnalysis = function() {
    // Update dependencies tab content
    const dependenciesContent = document.getElementById('dependenciesContent');
    dependenciesContent.innerHTML = `
        <h3>üîó Enhanced Dependency Analysis</h3>
        <p style="margin-bottom: 20px;">Complete dependency mapping with intelligent chunking and availability checking.</p>
        
        <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px; text-align: center;">
            <button class="action-btn secondary-btn" id="checkDependenciesBtn" style="width: auto; padding: 12px 24px; margin: 0 auto; display: block;">
                üîç Analyze Dependencies with Chunking
            </button>
            <p style="font-size: 12px; margin-top: 15px; opacity: 0.8;">
                Uses intelligent chunking to scan all uploaded files for comprehensive dependency mapping
            </p>
        </div>
    `;
    
    // Add event listener for dependency analysis
    const checkBtn = document.getElementById('checkDependenciesBtn');
    if (checkBtn) {
        checkBtn.addEventListener('click', async () => {
            if (!this.currentAnalyzedComponent) {
                this.showError('Please analyze a component first');
                return;
            }
            
            try {
                checkBtn.disabled = true;
                checkBtn.textContent = '‚è≥ Analyzing Dependencies...';
                
                const dependencyReport = await this.performEnhancedDependencyAnalysis(this.currentAnalyzedComponent);
                
                // Store the results
                if (!this.analysisResults[this.currentAnalyzedComponent]) {
                    this.analysisResults[this.currentAnalyzedComponent] = {};
                }
                this.analysisResults[this.currentAnalyzedComponent].dependencyReport = dependencyReport;
                
                this.displayDependencyResults(dependenciesContent, this.currentAnalyzedComponent, dependencyReport);
                this.saveToStorage();
                
            } catch (error) {
                console.error('Dependency analysis failed:', error);
                checkBtn.disabled = false;
                checkBtn.textContent = 'üîç Analyze Dependencies with Chunking';
                this.showError(`Dependency analysis failed: ${error.message}`);
            }
        });
    }
};

EnhancedMainframeAnalyzer.prototype.performEnhancedDependencyAnalysis = async function(componentName) {
    this.showLoading();
    this.updateLoadingStatus('üîç Starting enhanced dependency analysis with chunking...');
    
    try {
        // Stage 1: Create dependency-optimized chunks
        this.updateLoadingStatus('üìä Stage 1: Creating dependency-aware chunks...');
        this.updateProgress(20);
        
        const dependencyChunks = this.createDependencyScanChunks();
        
        // Stage 2: Scan all chunks for dependencies
        this.updateLoadingStatus('üîÑ Stage 2: Scanning chunks for dependencies...');
        this.updateProgress(40);
        
        const allDependencies = await this.scanAllDependenciesWithChunking(dependencyChunks);
        
        // Stage 3: Analyze component-specific dependencies
        this.updateLoadingStatus('üéØ Stage 3: Analyzing component-specific dependencies...');
        this.updateProgress(70);
        
        const componentDeps = await this.analyzeComponentSpecificDependencies(componentName, allDependencies);
        
        // Stage 4: Generate comprehensive report
        this.updateLoadingStatus('üìã Stage 4: Generating dependency report...');
        this.updateProgress(90);
        
        const dependencyReport = this.generateEnhancedDependencyReport(componentName, componentDeps);
        
        this.updateProgress(100);
        this.hideLoading();
        this.showSuccess(`‚úÖ Enhanced dependency analysis complete for ${componentName}!`);
        
        return dependencyReport;
        
    } catch (error) {
        this.hideLoading();
        this.showError(`Enhanced dependency analysis failed: ${error.message}`);
        throw error;
    }
};

EnhancedMainframeAnalyzer.prototype.createDependencyScanChunks = function() {
    const chunks = [];
    const targetTokensPerChunk = Math.floor(this.maxTokens * 0.4); // Conservative for dependency scanning
    
    console.log(`Creating dependency chunks with target ${targetTokensPerChunk} tokens each`);
    
    // Prioritize files by type for dependency scanning
    const cobolPrograms = this.uploadedFiles.filter(f => f.type === 'COBOL Program');
    const copybooks = this.uploadedFiles.filter(f => f.type === 'Copybook');
    const jclFiles = this.uploadedFiles.filter(f => f.type.includes('JCL'));
    const otherFiles = this.uploadedFiles.filter(f => 
        !cobolPrograms.includes(f) && !copybooks.includes(f) && !jclFiles.includes(f));
    
    // Process files in priority order
    this.createDependencyAwareChunks([...cobolPrograms, ...copybooks, ...jclFiles, ...otherFiles], 
        targetTokensPerChunk, chunks);
    
    console.log(`Created ${chunks.length} dependency-aware chunks`);
    return chunks;
};

EnhancedMainframeAnalyzer.prototype.createDependencyAwareChunks = function(files, targetTokens, chunks) {
    let currentChunk = [];
    let currentTokens = 0;
    let overlapContent = '';
    
    files.forEach(file => {
        const fileTokens = this.estimateTokenCount(file.content);
        
        if (currentTokens + fileTokens > targetTokens && currentChunk.length > 0) {
            chunks.push({
                files: [...currentChunk],
                totalTokens: currentTokens,
                overlapContext: overlapContent,
                chunkIndex: chunks.length,
                scanType: 'dependency'
            });
            
            overlapContent = this.createDependencyOverlap(currentChunk);
            currentChunk = [];
            currentTokens = this.estimateTokenCount(overlapContent);
        }
        
        currentChunk.push(file);
        currentTokens += fileTokens;
    });
    
    if (currentChunk.length > 0) {
        chunks.push({
            files: currentChunk,
            totalTokens: currentTokens,
            overlapContext: overlapContent,
            chunkIndex: chunks.length,
            scanType: 'dependency'
        });
    }
};

EnhancedMainframeAnalyzer.prototype.createDependencyOverlap = function(files) {
    let overlapContent = '';
    
    files.forEach(file => {
        const lines = file.content.split('\n');
        
        // Extract dependency-relevant lines for overlap
        const dependencyLines = lines.filter(line => {
            const upper = line.toUpperCase().trim();
            return upper.includes('COPY ') ||
                   upper.includes('CALL ') ||
                   upper.includes('EXEC ') ||
                   upper.includes('//') ||
                   upper.includes('DSN=') ||
                   upper.includes('DD ') ||
                   upper.includes('EXEC SQL') ||
                   upper.includes('TABLE ') ||
                   upper.includes('FROM ') ||
                   upper.includes('INTO ') ||
                   upper.includes('SELECT ') ||
                   upper.includes('FD ') ||
                   upper.includes('ASSIGN');
        });
        
        if (dependencyLines.length > 0) {
            overlapContent += `\n=== DEPENDENCY CONTEXT from ${file.name} ===\n`;
            overlapContent += dependencyLines.slice(0, 20).join('\n');
        }
    });
    
    return overlapContent;
};

EnhancedMainframeAnalyzer.prototype.scanAllDependenciesWithChunking = async function(dependencyChunks) {
    let allDependencies = {
        copybooks: new Set(),
        calledPrograms: new Set(),
        callingPrograms: new Set(),
        jclDatasets: new Set(),
        dbTables: new Set(),
        fileReferences: new Set()
    };
    
    for (let i = 0; i < dependencyChunks.length; i++) {
        this.updateLoadingStatus(`Processing dependency chunk ${i + 1}/${dependencyChunks.length}...`);
        
        const chunkDeps = await this.extractDependenciesFromChunk(dependencyChunks[i]);
        
        // Merge dependencies from this chunk
        Object.keys(chunkDeps).forEach(depType => {
            if (chunkDeps[depType] && Array.isArray(chunkDeps[depType])) {
                chunkDeps[depType].forEach(dep => allDependencies[depType].add(dep));
            }
        });
        
        if (i < dependencyChunks.length - 1) {
            await this.sleep(800); // Brief pause between chunks
        }
    }
    
    // Convert Sets back to Arrays
    Object.keys(allDependencies).forEach(key => {
        allDependencies[key] = Array.from(allDependencies[key]);
    });
    
    console.log('Dependencies found:', allDependencies);
    return allDependencies;
};

EnhancedMainframeAnalyzer.prototype.extractDependenciesFromChunk = async function(chunk) {
    // OPTIMIZED DEPENDENCY EXTRACTION PROMPT - FOCUSED AND CONCISE
    const prompt = `DEPENDENCY EXTRACTION - Chunk ${chunk.chunkIndex + 1}

FILES FOR ANALYSIS:
${chunk.files.map(f => `=== ${f.name} (${f.type}) ===\n${f.content}`).join('\n')}

${chunk.overlapContext ? `DEPENDENCY CONTEXT:\n${chunk.overlapContext}\n` : ''}

EXTRACT ALL DEPENDENCIES:

**COPYBOOK DEPENDENCIES**
- COPY statements: COPY COPYBOOK-NAME
- Include statements and copybook references

**PROGRAM CALL DEPENDENCIES**  
- CALL statements: CALL 'PROGRAM-NAME'
- Dynamic calls and JCL EXEC PGM= statements

**JCL DATASET DEPENDENCIES**
- DD statements: DSN=DATASET.NAME
- Input and output file references

**DATABASE TABLE DEPENDENCIES**
- EXEC SQL statements with table names
- SELECT, INSERT, UPDATE, DELETE operations

**FILE REFERENCE DEPENDENCIES**
- FD entries and SELECT statements
- File assignments and OPEN/CLOSE operations

RESPONSE FORMAT (exact format required):
COPYBOOKS: name1, name2, name3
CALLED_PROGRAMS: prog1, prog2, prog3  
CALLING_PROGRAMS: caller1, caller2, caller3
JCL_DATASETS: dataset1, dataset2, dataset3
DB_TABLES: table1, table2, table3
FILE_REFERENCES: file1, file2, file3

Only include actual names found, no descriptions or explanations.`;

    const response = await this.callvLLMAPI(prompt);
    return this.parseDependencyResponse(response);
};

EnhancedMainframeAnalyzer.prototype.parseDependencyResponse = function(response) {
    const dependencies = {
        copybooks: [],
        calledPrograms: [],
        callingPrograms: [],
        jclDatasets: [],
        dbTables: [],
        fileReferences: []
    };

    const lines = response.split('\n');
    lines.forEach(line => {
        const trimmed = line.trim();
        
        if (trimmed.startsWith('COPYBOOKS:')) {
            dependencies.copybooks = this.parseCommaSeparatedList(trimmed.split(':')[1]);
        } else if (trimmed.startsWith('CALLED_PROGRAMS:')) {
            dependencies.calledPrograms = this.parseCommaSeparatedList(trimmed.split(':')[1]);
        } else if (trimmed.startsWith('CALLING_PROGRAMS:')) {
            dependencies.callingPrograms = this.parseCommaSeparatedList(trimmed.split(':')[1]);
        } else if (trimmed.startsWith('JCL_DATASETS:')) {
            dependencies.jclDatasets = this.parseCommaSeparatedList(trimmed.split(':')[1]);
        } else if (trimmed.startsWith('DB_TABLES:')) {
            dependencies.dbTables = this.parseCommaSeparatedList(trimmed.split(':')[1]);
        } else if (trimmed.startsWith('FILE_REFERENCES:')) {
            dependencies.fileReferences = this.parseCommaSeparatedList(trimmed.split(':')[1]);
        }
    });

    return dependencies;
};

EnhancedMainframeAnalyzer.prototype.parseCommaSeparatedList = function(str) {
    if (!str) return [];
    return str.split(',')
        .map(item => item.trim())
        .filter(item => item && item.length > 0 && !item.toLowerCase().includes('none') && !item.toLowerCase().includes('n/a'))
        .map(item => item.replace(/['"`]/g, ''))
        .slice(0, 20); // Limit to reasonable number
};

EnhancedMainframeAnalyzer.prototype.analyzeComponentSpecificDependencies = async function(componentName, allDependencies) {
    this.updateLoadingStatus('üîç Analyzing specific dependencies for ' + componentName + '...');
    
    // OPTIMIZED COMPONENT-SPECIFIC DEPENDENCY PROMPT
    const prompt = `COMPONENT DEPENDENCY ANALYSIS: ${componentName}

ALL DISCOVERED DEPENDENCIES:
Copybooks: ${allDependencies.copybooks.slice(0, 15).join(', ')}
Called Programs: ${allDependencies.calledPrograms.slice(0, 15).join(', ')}
Calling Programs: ${allDependencies.callingPrograms.slice(0, 15).join(', ')}
JCL Datasets: ${allDependencies.jclDatasets.slice(0, 15).join(', ')}
DB Tables: ${allDependencies.dbTables.slice(0, 15).join(', ')}
File References: ${allDependencies.fileReferences.slice(0, 15).join(', ')}

UPLOADED FILES:
${this.uploadedFiles.map(f => f.name + ' (' + f.type + ')').join(', ')}

ANALYZE:
1. Which dependencies are directly related to ${componentName}?
2. Which dependencies are present vs missing in uploaded files?
3. What is the risk level for each missing dependency?

Provide focused analysis for ${componentName} dependencies.`;

    const response = await this.callvLLMAPI(prompt);
    return this.parseComponentDependencyResponse(response, allDependencies);
};

EnhancedMainframeAnalyzer.prototype.parseComponentDependencyResponse = function(response, allDependencies) {
    // Enhanced parsing with actual dependency data and availability checking
    const presentDependencies = Object.values(allDependencies).flat().filter(dep => 
        this.uploadedFiles.some(f => 
            f.content.toUpperCase().includes(dep.toUpperCase()) || 
            f.name.toUpperCase().includes(dep.toUpperCase())
        )
    );
    
    return {
        directDependencies: {
            copybooks: allDependencies.copybooks.slice(0, 10),
            programs: allDependencies.calledPrograms.slice(0, 10),
            files: allDependencies.fileReferences.slice(0, 10),
            tables: allDependencies.dbTables.slice(0, 10)
        },
        reverseDependencies: {
            calledByPrograms: allDependencies.callingPrograms.slice(0, 10),
            usedInJCL: allDependencies.jclDatasets.slice(0, 10)
        },
        availabilityAnalysis: {
            present: presentDependencies,
            missing: Object.values(allDependencies).flat().filter(dep => !presentDependencies.includes(dep))
        },
        summary: {
            totalDependencies: Object.values(allDependencies).flat().length,
            presentDependencies: presentDependencies.length,
            missingDependencies: Object.values(allDependencies).flat().length - presentDependencies.length,
            completenessPercentage: Math.round((presentDependencies.length / Math.max(Object.values(allDependencies).flat().length, 1)) * 100)
        }
    };
};

EnhancedMainframeAnalyzer.prototype.generateEnhancedDependencyReport = function(componentName, componentDeps) {
    return {
        componentName: componentName,
        timestamp: new Date().toISOString(),
        analysisMethod: 'Enhanced Chunking',
        dependencies: {
            copybooks: componentDeps.directDependencies.copybooks,
            calledPrograms: componentDeps.directDependencies.programs,
            callingPrograms: componentDeps.reverseDependencies.calledByPrograms,
            jclDatasets: componentDeps.reverseDependencies.usedInJCL,
            fileReferences: componentDeps.directDependencies.files,
            dbTables: componentDeps.directDependencies.tables
        },
        summary: componentDeps.summary,
        availabilityAnalysis: componentDeps.availabilityAnalysis,
        recommendations: this.generateDependencyRecommendations(componentDeps)
    };
};

EnhancedMainframeAnalyzer.prototype.generateDependencyRecommendations = function(componentDeps) {
    const recommendations = [];
    
    if (componentDeps.summary.missingDependencies > 0) {
        recommendations.push({
            priority: 'HIGH',
            category: 'Missing Dependencies',
            description: `${componentDeps.summary.missingDependencies} dependencies not found in uploaded files`,
            action: 'Upload missing copybooks, programs, or JCL files for complete analysis'
        });
    }
    
    if (componentDeps.summary.completenessPercentage < 70) {
        recommendations.push({
            priority: 'MEDIUM',
            category: 'Incomplete Analysis',
            description: `Only ${componentDeps.summary.completenessPercentage}% of dependencies are available`,
            action: 'Consider uploading additional related files'
        });
    }
    
    if (componentDeps.directDependencies.copybooks.length > 10) {
        recommendations.push({
            priority: 'LOW',
            category: 'High Coupling',
            description: 'Component has many copybook dependencies',
            action: 'Review for potential refactoring opportunities'
        });
    }
    
    return recommendations;
};

EnhancedMainframeAnalyzer.prototype.displayDependencyResults = function(container, componentName, depReport) {
    const deps = depReport.dependencies;
    
    let html = `
        <h3>üîó Enhanced Dependency Analysis: ${componentName}</h3>
        <p style="margin-bottom: 20px;">
            Complete dependency mapping using intelligent chunking ‚Ä¢ Completed: ${new Date(depReport.timestamp).toLocaleString()}
        </p>
        
        <!-- Dependency Summary -->
        <div style="background: rgba(76, 175, 80, 0.1); padding: 20px; border-radius: 10px; margin-bottom: 20px; border-left: 4px solid #4CAF50;">
            <h4 style="color: #FFD700; margin-bottom: 15px;">üìä Dependency Summary</h4>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 15px;">
                <div style="text-align: center;">
                    <div style="font-size: 1.5rem; font-weight: bold; color: #FFD700;">${depReport.summary.totalDependencies}</div>
                    <div style="font-size: 11px;">Total Dependencies</div>
                </div>
                <div style="text-align: center;">
                    <div style="font-size: 1.5rem; font-weight: bold; color: #4CAF50;">${depReport.summary.presentDependencies}</div>
                    <div style="font-size: 11px;">Present</div>
                </div>
                <div style="text-align: center;">
                    <div style="font-size: 1.5rem; font-weight: bold; color: #f44336;">${depReport.summary.missingDependencies}</div>
                    <div style="font-size: 11px;">Missing</div>
                </div>
                <div style="text-align: center;">
                    <div style="font-size: 1.5rem; font-weight: bold; color: #FF9800;">${depReport.summary.completenessPercentage}%</div>
                    <div style="font-size: 11px;">Completeness</div>
                </div>
            </div>
        </div>
    `;

    // Display each dependency type
    let hasAnyDependencies = false;
    
    Object.keys(deps).forEach(depType => {
        if (deps[depType] && deps[depType].length > 0) {
            hasAnyDependencies = true;
            const title = this.getDependencyTypeTitle(depType);
            const icon = this.getDependencyTypeIcon(depType);
            
            html += `
                <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px; margin-bottom: 15px;">
                    <h4 style="color: #FFD700; margin-bottom: 10px;">${icon} ${title}</h4>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 10px;">
                        ${deps[depType].map(dep => {
                            const isPresent = this.uploadedFiles.some(f => 
                                f.content.toUpperCase().includes(dep.toUpperCase()) || 
                                f.name.toUpperCase().includes(dep.toUpperCase())
                            );
                            const statusColor = isPresent ? '#4CAF50' : '#f44336';
                            const statusIcon = isPresent ? '‚úÖ' : '‚ùå';
                            
                            return `
                                <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; background: rgba(255,255,255,0.05); border-radius: 5px; border-left: 3px solid ${statusColor};">
                                    <span style="font-family: monospace; color: white; font-size: 13px;">${dep}</span>
                                    <span style="color: ${statusColor}; font-size: 11px; font-weight: bold;">
                                        ${statusIcon} ${isPresent ? 'PRESENT' : 'MISSING'}
                                    </span>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
            `;
        }
    });
    
    // Add recommendations if available
    if (depReport.recommendations && depReport.recommendations.length > 0) {
        html += `
            <div style="background: rgba(255, 193, 7, 0.1); padding: 20px; border-radius: 10px; border-left: 4px solid #FFC107;">
                <h4 style="color: #FFC107; margin-bottom: 15px;">üí° Recommendations</h4>
                ${depReport.recommendations.map(rec => `
                    <div style="margin-bottom: 10px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 5px; border-left: 3px solid ${this.getPriorityColor(rec.priority)};">
                        <div style="font-weight: bold; color: ${this.getPriorityColor(rec.priority)}; margin-bottom: 5px;">
                            ${this.getPriorityIcon(rec.priority)} ${rec.category} (${rec.priority})
                        </div>
                        <div style="font-size: 12px; margin-bottom: 5px;">${rec.description}</div>
                        <div style="font-size: 11px; opacity: 0.8;"><strong>Action:</strong> ${rec.action}</div>
                    </div>
                `).join('')}
            </div>
        `;
    }
    
    if (!hasAnyDependencies || depReport.summary.totalDependencies === 0) {
        html += `
            <div style="background: rgba(255, 193, 7, 0.1); padding: 20px; border-radius: 10px; text-align: center; border-left: 4px solid #FFC107;">
                <h4 style="color: #FFC107; margin-bottom: 10px;">‚ÑπÔ∏è No Dependencies Found</h4>
                <p>No dependencies were detected for <strong>${componentName}</strong></p>
                <p style="font-size: 12px; opacity: 0.8; margin-top: 10px;">
                    This could indicate a standalone component or dependencies not captured in the uploaded files.
                </p>
            </div>
        `;
    }
    
    container.innerHTML = html;
    console.log('Enhanced dependency results displayed successfully');
};

EnhancedMainframeAnalyzer.prototype.getDependencyTypeTitle = function(depType) {
    const titles = {
        copybooks: 'Copybook Dependencies',
        calledPrograms: 'Called Programs',
        callingPrograms: 'Calling Programs', 
        jclDatasets: 'JCL Datasets',
        dbTables: 'Database Tables',
        fileReferences: 'File References'
    };
    return titles[depType] || depType;
};

EnhancedMainframeAnalyzer.prototype.getDependencyTypeIcon = function(depType) {
    const icons = {
        copybooks: 'üìö',
        calledPrograms: 'üìû',
        callingPrograms: 'üì≤',
        jclDatasets: 'üíæ',
        dbTables: 'üóÑÔ∏è',
        fileReferences: 'üìÅ'
    };
    return icons[depType] || 'üîó';
};

EnhancedMainframeAnalyzer.prototype.getPriorityColor = function(priority) {
    const colors = {
        'HIGH': '#f44336',
        'MEDIUM': '#FF9800',
        'LOW': '#4CAF50'
    };
    return colors[priority] || '#FFD700';
};

EnhancedMainframeAnalyzer.prototype.getPriorityIcon = function(priority) {
    const icons = {
        'HIGH': 'üö®',
        'MEDIUM': '‚ö†Ô∏è',
        'LOW': 'üí°'
    };
    return icons[priority] || 'üìå';
};

// Initialize dependency analysis when document is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function() {
        if (typeof analyzer !== 'undefined') {
            analyzer.initializeDependencyAnalysis();
        }
    });
} else {
    // Document already loaded
    if (typeof analyzer !== 'undefined') {
        analyzer.initializeDependencyAnalysis();
    }
}

console.log('üöÄ Enhanced Mainframe Analyzer - Part 3 Ready!');
console.log('‚úÖ Features active: Enhanced dependency mapping with intelligent chunking');
console.log('üéØ Complete system now includes:');
console.log('   ‚Ä¢ File upload and management');
console.log('   ‚Ä¢ Component suggestions and validation');
console.log('   ‚Ä¢ Token-aware analysis with optimization');
console.log('   ‚Ä¢ Focused field flow and business rule analysis');
console.log('   ‚Ä¢ Interactive chat functionality');
console.log('   ‚Ä¢ Field matrix and usage patterns');
console.log('   ‚Ä¢ Enhanced dependency mapping with chunking');
console.log('   ‚Ä¢ Export and storage capabilities');
console.log('   ‚Ä¢ Bulk analysis support');
    </script>
</body>
</html>